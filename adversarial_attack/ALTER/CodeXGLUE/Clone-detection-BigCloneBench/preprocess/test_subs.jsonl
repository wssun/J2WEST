{"id1": "17522011", "id2": "8754809", "code1": "    public static String read(ClassLoader classLoader, String name, boolean all) throws IOException {\n        if (all) {\n            StringMaker sm = new StringMaker();\n            Enumeration enu = classLoader.getResources(name);\n            while (enu.hasMoreElements()) {\n                URL url = (URL) enu.nextElement();\n                InputStream is = url.openStream();\n                String s = read(is);\n                if (s != null) {\n                    sm.append(s);\n                    sm.append(StringPool.NEW_LINE);\n                }\n                is.close();\n            }\n            return sm.toString().trim();\n        } else {\n            InputStream is = classLoader.getResourceAsStream(name);\n            String s = read(is);\n            is.close();\n            return s;\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 0, "substitutes": {"classLoader": [" classLoad", "fileDir", " classloader", "classPath", "filePath", "Classloader", "resourceReader", "classLoad", "resourceLoading", "classloader", "fileloader", "ClassLoad", "fileLoader", "classDir", " classPath", " classDir", "resourceLoader", "ClassPath", "ClassReader", " classLoading", "fileLoad", " classReader", "ClassLoading", "classReader", "resourceloader", "ClassDir", "classLoading", "ClassLoader"], "name": ["named", "address", "filename", "prefix", "x", "child", "data", "time", "string", "home", "no", "resource", "alias", "path", "str", "class", "search", "parent", "value", "base", "large", "root", "file", "part", "type", "connection", "NAME", "comment", "image", "Name", "code", "old", "ame", "size", "pass", "n", "key", "null", "word", "default", "active", "names", "none", "id"], "all": ["named", "any", "f", "sync", "allow", "left", "alpha", "app", "ALL", "and", "with", "apply", "each", "list", "total", "this", "alls", "am", "array", "al", "only", "full", "part", "one", "sort", "call", "partial", "process", "batch", "not", "l", "pass", "at", "ann", "auto", "local", "All", "attribute", "active", "both", "global", "none"], "sm": ["gm", "cm", "nm", "asm", "serv", "ama", "hm", "vm", "service", "sb", "source", "sf", "em", "sk", "sr", "sh", "sy", "im", "mo", "zip", "sl", "ym", "sa", "mm", "km", "bm", "sam", "sp", "m", "ms", "smith", "rm", "wm", "su", "sw", "om", "tm", "ss", "sum", "sv", "si", "sym", "imm", "spe", "api", "so", "Sm", "fm", "SM", "sim", "sn"], "enu": ["venou", " ennu", "munU", " enus", "ENou", "anu", "munus", "munun", "enun", "ENc", "enus", "Enus", "Ennu", "Enun", "anU", "ENus", "encu", "Enu", "venus", "enncu", "venu", "Enc", "venc", "EnU", "ennus", "Enou", "ENu", "anus", "enou", "Encu", "enU", "anun", "ennu", "ennnu", " encu", "enc", "munu"], "url": ["loader", "plug", "address", "f", "rel", "uri", "ssl", "string", "source", "i", "resource", "web", "path", "layer", "str", "server", "http", "ur", "sl", "zip", "URL", "base", "file", "in", "page", "impl", "ls", "connection", "image", "job", "browser", "l", "ll", "download", "Url", "loc", "li", "key", "r", "pull", "id"], "is": ["ir", "esi", "lis", "ris", "it", "serv", "ori", "iss", "uri", "ie", "isl", "abs", "iris", "i", "es", "ais", "app", "ic", "has", "ignore", "web", "ois", "im", "http", "us", "its", "init", "isa", "p", "os", "iso", "in", "vs", "ins", "ls", "act", "ar", "io", "inner", "ip", "ii", "image", "cms", "bis", "IS", "mis", "ios", "ops", "ri", "as", "was", "or", "close", "Is", "isc", "are", "js", "isi", "si", "api", "info", "il", "id"], "s": ["session", "ans", "S", "comments", "f", "cs", "d", "ments", "ses", "g", "lines", "ssl", "string", "sb", "abs", "es", "sf", "i", "ds", "ies", "sl", "ings", "its", "p", "sg", "os", "rows", "ns", "se", "sc", "gs", "ins", "ls", "w", "u", "als", "m", "ms", "spec", "les", "sets", "results", "storage", "services", "ches", "ws", "ions", "o", "details", "su", "c", "ips", "outs", "rs", "ss", "l", "ps", "ts", "n", "js", "sv", "si", "strings", "r", "ows", "h", "e", "ks"]}}
{"id1": "13644375", "id2": "6371589", "code1": "    public String get(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toString(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["address", "data", "uri", "service", "request", "string", "source", "i", "resource", "xml", "path", "feed", "host", "str", "http", "server", "sl", "URL", "json", "base", "file", "method", "type", "location", "connection", "href", "name", "route", "email", "l", "download", "Url", "api", "object", "id"], "get": ["delete", "patch", "pull", "find", "uri", "service", "request", "parse", "i", "put", "resource", "send", "remote", "gi", "end", "Get", "read", "http", "with", "GET", "e", "cli", "invoke", "json", "base", "query", "load", "transfer", "select", "handle", "method", "call", "open", "update", "client", "set", "print", "exec", "build", "download", "start", "post", "api", "use", "status", "create", "show"], "response": ["application", "serv", "data", "content", "tree", "received", "request", "wave", "resource", "document", "xml", "success", "output", "status", "feed", "http", "server", "model", "Resp", "onse", "Response", "json", "respond", "reply", "error", "respons", "page", "full", "method", "res", "connection", "result", "resp", "body", "api", "report", "out", "object", "message"], "entity": ["data", "content", " entities", "ity", "source", "resource", "xml", "document", "output", "ent", "person", "http", "model", "server", "pe", "el", "ce", "json", "query", "event", "error", "file", "page", "translation", "ale", "environment", "connection", "action", "image", "element", "collection", "info", "result", "instance", "Entity", "item", "body", "api", "node", "object", "null", "e"]}}
{"id1": "20306677", "id2": "471804", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"o": ["f", "i", "oid", "ol", "t", "ow", "Obj", "ao", "p", "ou", "os", "od", "office", "vo", "O", "one", "bot", "ingo", "s", "oo", "oro", " object", "OO", " O", "obj", "b", "ilo", "oe", "po", " bo", "or", "bo", "article", "oa", "n", "out", "object", "mo", "e"], "update": ["latest", "updated", "core", "apply", "insert", "value", "full", "future", "unit", "change", "build", "current", "view", "inc", "run", "index", "address", "next", "version", "sync", "data", "other", "two", "where", "ite", "connection", "draw", "write", "width", "append", "use", "ul", "grade", "id", "delete", "save", "patch", "find", "check", "more", "put", "resource", "diff", "plus", "response", "database", "load", "add", "Update", "get", "offset", "up", "property", "object", "status", "create", "date", "bug", "row", "end", "feed", "replace", "UPDATE", "json", "lock", "query", "event", "fill", "edit", "range", "result", "size"], "bill": ["number", "bar", "account", "bird", "f", "bl", "bug", "bel", "user", "service", "company", "flow", "db", " contract", "project", "note", "ban", "BILL", "book", "base", "roll", "conn", "foo", "fee", "unit", "contract", "ee", "nn", "batch", "b", "order", "charge", "mill", "log", "pool", "report", "Bill", "fl", "object", "business", "bean"], "pst": ["jpsts", "Psth", "nct", "psth", "psp", " pct", "lpsts", "prest", "nst", "Psts", "ppsp", "Psp", " psth", "prect", " psts", "ppsc", "ppct", "lpsp", "presp", "psc", "Psc", "lpct", "pct", "jpct", "nsp", "lpst", "jpsth", "psts", "ppst", "jpst", "presc", "Pst", "nsts", "Pct"]}}
{"id1": "13783898", "id2": "149935", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"infile": ["inputfp", "Infiles", "inputfilename", "infilename", " infilename", " infiles", "outfp", "inputfile", "inputfiles", "inFile", "infp", "Infile", "Infilename", "infiles", " infp", "InFile", "inputFile", "outFile", "outfilename", "outfiles"], "outfile": ["Outfile", "outputfilename", " outfolder", "infilename", " outfp", "outputfile", "OutFile", "outfp", "infolder", "newFile", " outFile", "infp", " outfilename", "outfolder", "newfolder", " outname", "outputfp", "Outname", "Outfolder", "outputfolder", "outFile", "outname", "outfilename", "newfile", "newname"], "in": ["gin", "vin", "a", "re", "data", "isin", "socket", "inn", "source", "i", "thin", "ic", "con", "sin", "is", "input", "init", "inas", "base", "min", "din", "conn", "reader", "rin", "ins", "bin", "m", "into", "err", "inner", "s", "image", "b", "inside", "as", "win", "In", "pass", "cin", "inc", "ac", "IN", "nin", "ini", "r", "login", "again", "pin", "id"], "out": ["session", "sync", "OUT", "socket", "point", "home", "no", "source", "output", "exit", "on", "off", "line", "lib", "writer", "parent", "Out", "base", "ou", "error", "file", "conn", "co", "timeout", "bin", "one", "err", "net", "io", "to", "inner", "image", "name", "up", "client", "job", "o", "obj", "outs", "exec", "write", "or", "outer", "In", "work", "cache", "inc", "post", "ex", "copy", "again"], "buffer": ["queue", "border", "address", "length", "uffer", "data", "flush", "reference", "bb", "source", "wave", "feed", "slice", "layer", "server", "limit", "iter", "buff", "buf", "fb", "input", "binary", "len", "value", "base", "raw", "transfer", "url", "reader", "type", "offset", "seed", "Buffer", "batch", "bytes", "b", "write", "result", "size", "cache", "split", "count", "padding", "null"], "read": ["lex", " write", "f", "length", "x", "sync", "allow", "next", " copy", "find", "ad", "check", "parse", "i", "Read", "connect", "send", "end", "feed", "tell", "slice", "ind", "limit", "iter", "input", "wait", "len", " Read", "reading", "load", "add", "raw", "sleep", "reader", "select", "play", "se", "fill", "seek", "io", "get", "ride", "READ", "ip", "_", " count", "write", "exec", "close", "size", "reads", "start", "work", "n", "pass", "run", "inc", "current", "count", "copy", "use", " skip", "id"], "success": ["primary", "growth", "construct", "better", "data", "content", "follow", "fast", "flash", " succ", "successful", "status", "cess", "path", "rolling", "response", "valid", "model", "rolled", "initial", "fail", " successful", "value", "modified", "failed", "ccess", "roll", "func", "respons", "winner", "error", "first", "true", "method", "danger", "comment", " succeed", "results", "warning", "open", "done", "right", " Success", "ceed", "result", "successfully", "good", "Success", "pass", "xx", "complete", "continue", "default", "again", "null", "message"]}}
{"id1": "62362", "id2": "3024992", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 1, "substitutes": {"src": ["inst", "ctx", "filename", "st", "rb", "feat", "ref", "uri", "gb", "ssl", "sb", "source", "string", "resource", "upload", "prot", "Dest", "path", "sin", "RC", "slice", "tmp", "buf", "sth", "input", "sl", "supp", "dist", "username", "secure", "load", "req", "fp", "url", "file", "sc", "reader", "impl", "img", "cb", "gz", "spec", "href", "s", "cpp", "storage", "gn", "vr", "name", "code", "obj", "sit", "sel", "rc", "proc", "download", "stream", "component", "cmp", "dep", "Source", "loc", "fn", "rl", "SourceFile", "ource", "config", "sec", "back", "sn"], "dest": ["target", "orig", "home", "source", "wb", "Dest", "dc", "path", "di", "tmp", "lib", " destination", "class", "dist", "cont", "txt", "temp", "img", "bin", "std", "dir", "obj", "disk", "fn", " dst", "null", "dat"], "in": ["inf", "f", "d", "a", "data", "isin", "inn", "source", "i", "t", "is", "input", "inas", "din", "file", "reader", "ins", "bin", "err", "io", "up", "as", "doc", "win", "ps", "In", "stream", "n", "pass", "inc", "IN", "ini", "r", "ex", "val", "login", "pin"], "p": ["pa", "pb", "pd", "f", "d", "pg", "g", "lp", "pm", "i", "per", "pc", "pe", "t", "h", "pp", "pr", "cp", "pi", "op", "fp", "v", "wp", "bp", "part", "sp", "cop", "m", "s", "py", "o", "pre", "c", "np", "b", "po", "j", "l", "ps", "jp", "parser", "tp", "P", "e"], "ds": ["docs", "d", "uds", "dt", "lp", " db", "ays", "hs", "ads", " DS", "ded", "scripts", "des", "ils", "icks", "ants", "qs", "dm", "vals", "dates", "ld", "sys", "dat", "posts", "ks", "styles", "ans", "pd", "cs", "sync", "data", "words", "points", "dp", "bs", "dd", "gs", "cdn", "Ds", "ups", "rs", "ps", "js", " dd", "sts", "cons", "tools", "els", "lines", "db", "DS", "di", "dist", "amps", "os", "tests", "vs", "dos", "ins", "ls", " sd", "s", "ws", "xs", "ts", "plugins", " props", " ps", "eps", "obs", "gd", "da", "dc", "parts", "dds", "ys", "utils", "nas", "ns", "ss", "df", "models", "dl"], "format": ["filter", "f", "filename", "prefix", "template", "feat", "data", "Format", "plugin", "version", "string", "source", "form", "xml", "path", "handler", "host", "t", "layout", "atter", "class", "tag", "scale", "function", "sche", "fp", "file", "url", "fd", "part", "type", "act", "spec", "style", "letter", "unit", "table", "language", "name", "struct", "ant", "pattern", "nat", "at", "frame", "parser", "fn", "api", "config", "magic", "record", "object", "model", "match"], "hasPixelData": ["hasPictureData", "hasPicOps", "haspixelStyle", " hasPixeldata", "hasBytedata", "hasPicStyle", "hasPixelDATA", "hasPictureDATA", "haspixelData", " hasPixelOps", "hasPixeldata", "hasPixelStyle", "haspixelOps", "hasPicData", "hasByteData", " hasPixelSize", "haspixelSize", "hasPicturedata", "hasPixelSize", "haspixelDATA", "haspixeldata", "hasPixelOps", " hasPixelStyle", " hasPixelDATA", "hasByteSize"], "inflate": [" inflATE", "infloocate", "uninflocate", "infloase", "uninfloute", "uninfloate", "information", "informATE", "incollate", "infloATE", "inflation", "infolute", " information", "infolame", "incollame", "inFlase", "incollocate", "inFlate", "informate", "infloate", "influte", "inflase", "incollute", "uninfloame", "inFlation", "uninflute", "infolate", "informase", "inflame", "infolocate", "infloation", " informase", "uninfloocate", " informate", "infloame", "infloute", "inflocate", "uninflame", " inflation", "inFlATE", " inflase", "inflATE", " informATE", "uninflate"], "pxlen": ["nplin", "pyln", "pxlf", "fxlen", "pngden", "xyfin", "pyden", "pxden", "fxden", "rxfin", "xplength", "xplen", "fxval", "pglf", "xylen", "pyl", "xpval", "cpden", "fxlf", "pxlin", "pxLen", "rxlen", "pylen", "pngln", "pplen", "fxl", "cpln", "pngLen", "rxlin", "nplen", "npden", "xyden", "fxlength", "ppden", "pxval", "pxfin", "pxl", "ppln", "npfin", "rxden", "xyLen", "xylin", "fxln", "pxlength", "xplf", "pxln", "pglen", "cplen", "pnglen", "cpl", "xyln", "ppLen", "pglength", "pgval"], "out": ["session", "dump", "prefix", "OUT", "re", "user", "point", "output", "line", "server", "cli", "lib", "list", "group", "parent", "store", "lock", "Out", "base", "v", "conn", "error", "page", "gen", "err", "inter", "io", "code", "up", "obj", "step", "print", "outs", "work", "cache", "log", "post", "copy", "sys", "again"]}}
{"id1": "3266833", "id2": "693636", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "label": 0, "substitutes": {"is": ["ir", "lis", "ris", "iss", "iris", "abs", "i", "es", "ais", "has", "ib", "us", "isu", "iv", "its", "init", "bs", "isa", "os", "iso", "fits", "in", "ins", "get", "ip", "image", "bis", "cms", "IS", "mis", "ws", "ios", "info", "as", "was", "or", "close", "Is", "isc", "im", "id"], "name": ["named", "address", "filename", "prefix", "version", "data", "format", "string", "no", "domain", "alias", "word", "source", "path", "label", "vision", "this", "search", "nice", "parent", "value", "base", "large", "database", "min", "file", "office", "url", "part", "directory", "type", "one", "connection", "NAME", "image", "module", "title", "Name", "code", "space", "ame", "term", "description", "size", "memory", "pass", "n", "key", "default", "null", "names", "id"], "contentType": ["mediaType", "messageName", "mediaPath", "messagetype", "Contenttype", "ContentTypes", "outputTypes", "ContentType", "contentInfo", "contentPoint", "documentInfo", "sourceInfo", "documenttype", "messageInfo", "sourceType", " contenttype", "ContentPath", "messageType", "ContentInfo", "contentPath", "mediaTypes", "contenttype", " contentInfo", "outputType", "contentTypes", "documentType", "outputPath", " contentPoint", "sourcetype", "sourcePoint", "contentName", "ContentName", "outputName", "documentPoint", " contentName", "mediaName"], "index": ["number", "expression", "address", "length", "x", "fix", "prefix", "data", "content", "alpha", "string", "i", "weight", "end", "none", "slice", "id", "input", "list", "search", "value", "error", "shape", "page", "in", "timeout", "type", "level", "offset", "image", "open", "update", "multi", "write", "width", "size", "axis", "include", "inc", "position", "Index", "key", "body", "height", "append", "default", "pointer", "pull", "depth"], "extension": ["configance", "variensions", "variension", "Extension", "configensions", "variuration", "Extance", "extance", "extensions", "Extensions", "configuration", "variance", "Exturation", "exturation", "configension"], "isImage": ["areImage", "areFile", "isimage", "ISFile", "IsVideo", "ISImage", "asImage", "IsPicture", " isInstance", "areMedia", "IsFile", " isPicture", "areImages", "isPicture", " isVideo", "isaImage", "ISPicture", "isImages", "ISVideo", "asInstance", " isFile", " isMedia", "isaImages", "IsImage", "areimage", "isaMedia", "isInstance", "isFile", "isVideo", "asimage", "isaFile", "areInstance", "asFile", " isimage", "isMedia", " isImages"], "isAux": ["isUux", "isAsx", "isOAUX", " isHax", "asAExcept", "isAsux", "isAAru", " isArrayUX", "isAxt", "isAAux", "isAcru", "isArrayxt", "isAlux", "isHaUX", "isHax", "isAslux", "isAnux", " isArrayux", "asAux", "isWalux", "isOAExcept", "asAlux", "isAcux", "isUExcept", "isAExcept", " isAxt", "asAsex", "isAcUX", " isHaUX", "isAex", " isAUX", " isArrayxt", " isHalux", "isAnex", "isHalux", "isAAUX", "isWaux", "asAUX", "isOAlux", "isOAux", "isAnUX", "isAsExcept", "isUex", "isAx", "isWaUX", "isWax", "asAsUX", "isAsex", "isHaux", "isArrayru", "isAUX", " isArrayru", "isAAxt", "isArrayux", "isAru", "isUUX", "isUlux", "asAslux", "isAsUX", " isHaux", "isAcxt", "asAsux", "isArrayUX", "asAsExcept", " isAlux", " isAru", " isAx", "asAex", "isAnlux"], "out": ["ext", "extra", "next", "sync", "OUT", "version", "a", "data", "prefix", "user", "socket", "source", "word", "output", "off", "project", "input", "this", "again", "parent", "Out", "base", "array", "error", "file", "page", "in", "conn", "part", "plain", "temp", "exp", "io", "inner", "table", "image", " in", "buffer", "up", "client", "obj", "o", "outs", "exec", "result", "size", "outer", "over", "cache", "auto", "post", "pool", "at", "work", "ex", "copy", "object", "null"], "bufferedImage": ["BufferedImage", "buffledimage", "bufferedimage", "Bufferedimage", "buffledImage", "bufferingImage", "BufferingImage", "buffendedImage", "Bufferingimage", "buffendedimage", "bufferingimage"], "inputStream": ["Inputstream", "InputSteam", " inputSteam", "outputSteam", "outputstream", "inputstream", "inputSteam", " inputstream", " inputBuffer", "outputBuffer", "InputBuffer", "inputBuffer", "InputStream", "outputStream"]}}
{"id1": "2518655", "id2": "12380475", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fnOut": ["lsOut", " fnOUT", "fnOUT", "fpEx", "fnEx", "FNOutput", "fnOutput", " fnIn", "fpOUT", "FNEx", " fnEx", "fpOut", "FNIn", "fpOutput", "fnIn", "lsFile", "fpIn", " fnOutput", "lsOutput", "fnFile", "fpFile", "FNOut", " fnFile", "lsOUT"], "writer": ["loader", "walker", "a", "usher", "socket", "builder", "ler", "per", "nw", "output", "wa", "handler", "wire", "server", "riter", "editor", "entry", "layer", "war", "file", "winner", "fd", "reader", "wr", "Writer", "w", "temp", "er", "worker", "writers", "widget", "inner", "buffer", "director", "ws", "write", "outer", "work", "parser", "driver", "key", "r", "writ", "word", "out", "writing"], "i": ["hi", "phi", "f", "x", "ori", "ui", "ti", "uri", "ie", "bi", "ci", "gi", "qi", "strength", "di", "h", "z", "abi", "pi", "chi", "p", "v", "ai", "ix", "part", "u", "type", "k", "m", "iu", "io", "s", "ip", "ii", "o", "b", "c", "I", "ri", "fi", "multi", "j", "n", "si", "key", "li", "ini", "oi", "mi", "ji", "index", "xi", "eni", "e", "id"], "fInput": ["fileinput", "sfInput", " fOutput", "fileOutput", "sfinput", "finput", "sfSource", "sfFormat", "fFormat", "fOutput", "fileFormat", "sfOutput", " fFormat", "fSource", " fSource", "fileInput", " finput", "fileSource"], "in": ["vin", "f", "version", "gin", "data", "isin", "socket", "inn", "ln", "sin", "line", "input", "init", "inas", "reading", "kin", "scan", "min", "din", "conn", "lin", "reader", "rin", "ins", "bin", "connection", "inner", "s", "c", "b", "inside", "win", "In", "n", "cin", "inc", "IN", "nin", "ini", "ner", "login", "out", "again", "pin", "id"]}}
{"id1": "23118425", "id2": "932225", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 1, "substitutes": {"plaintext": ["flatText", " plainstring", " plainsource", "flatsource", "protecteddata", " plainstruct", " plainText", "broadText", "plainText", "flatstring", " plaindata", "flattext", "protectedtext", "plainstruct", "protectedstruct", "flatstruct", "broadtext", "protectedText", "flatdata", "broadsource", "plainstring", "broadstring", "plaindata", "plainsource"], "md": ["material", "nm", "pd", "d", "dh", "data", "wd", "pg", "hm", "pm", "ad", "amd", "mad", "dc", "db", "sha", "kg", "mu", "meta", "pkg", "mm", "am", "Cmd", "od", "MD", "dd", "mand", "ma", "mt", "m", "ms", " MD", "bd", "dig", "mb", "mg", "vd", "dm", "cd", "code", "cmd", "mod", "ph", "hd", "mac", "mag", "mp", "mc", "metadata", "mem", "ld", "mo", "message"], "raw": ["custom", "unsigned", "RAW", "rew", "row", "content", "wrap", "hex", "empty", "ack", "feed", "dec", "response", "initial", "buf", "input", "unknown", "binary", "ng", "load", "block", "array", "full", "shared", "Raw", "image", "serial", "buffer", "partial", "original", "channel", " hex", " RAW", "pack", "instance", "stream", "local", "def", "clean", "enc", "null", "message"], "hash": ["version", "Hash", "data", "row", "string", "hex", "empty", "id", "response", "sha", "password", "text", "value", "html", "base", "block", "array", "url", "full", "secret", "header", "image", "buffer", "code", "her", "build", "ash", "sum", "kh", "cache", "mac", "log", "key", "crypt", "h", "auth", "rh", "message"]}}
{"id1": "20568568", "id2": "1586662", "code1": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "code2": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"requestPage": ["returnPages", "resourcepage", "responsepage", "resourcePages", "resourceResult", " requestType", "resourcePage", "requestType", "returnPage", "requestResult", "responsePages", "returnpage", " requestResult", "RequestResult", " requestpage", "requestpage", "responseType", "requestPages", " requestPages", "returnType", "RequestPage", "RequestPages", "responsePage", "Requestpage"], "result": ["join", "mark", "data", "content", "format", "detail", "color", "string", "document", "success", "output", "replace", "response", "valid", "cup", "answer", "search", "value", "html", "menu", "root", "event", "array", "error", "page", "res", "comment", "results", "header", "Result", "up", "info", "description", "sum", "feature", "cache", "example", "test", "ret", "report", "our", "summary", "complete", "status", "date", "match", "message"], "url": ["loader", "plug", "f", "bel", "data", "src", "uri", "service", "ssl", "string", "source", "resource", "web", "path", "feed", "hub", "http", "server", "org", "sl", "URL", "class", "blog", "base", "file", "page", "in", "ls", "gl", "connection", "io", "image", "buffer", "up", "channel", "b", "l", "ll", "link", "download", "Url", "api", "r", "fl"], "ins": ["pins", "ans", "ains", "gin", "ris", "lines", "src", "inn", "abs", "limits", "ds", "is", "out", "its", "inas", "alls", "bs", "ints", "kin", "rows", "din", "lin", "in", "reader", "rss", "ils", "ls", "ens", "vs", "als", "inner", "s", "bis", "ats", "ws", "ios", "ips", "as", "outs", "ps", "Ins", "ts", "plugins", "inc", "fe", "r", "login", "INS", "fs", "ks"], "bufferedReader": ["buffledWriter", "buffenedWriter", "bufferedIn", "bufferingReader", " bufferedIn", "buffererWriter", " bufferedWriter", " bufferedStream", "bufferedStream", "bufferedWriter", "BufferedWriter", "buffenedBuffer", " buffedReader", "BufferedBuffer", "buffenedReader", "buffererBuffer", "BufferedStream", "BuffererStream", " buffedWriter", "BuffererWriter", "buffedWriter", "BufferedReader", "bufferingWriter", "buffererStream", "buffererReader", "bufferedBuffer", "buffenedStream", "buffedStream", "buffledReader", "buffedReader", "BuffererBuffer", "buffledStream", "bufferingBuffer", "buffenedIn", "BuffererReader", "buffedIn", " buffedIn", " buffedStream", "buffledIn", "bufferingStream"], "cssLine": ["ssLine", "ssChar", "cssChar", "cssUrl", "csFile", "cssPage", "htmlline", "csLine", "cnLine", "styleChar", "cssFile", "cssRow", "cssBlock", "cnRow", "ssUrl", "CSSBlock", "ssline", "cnBlock", "htmlPage", "CSSLine", "ssBlock", "cnUrl", "styleBlock", "csChar", "styleFile", "ssRow", "ssPage", "ssFile", "htmlLine", "csBlock", "cssline", "htmlBlock", "csUrl", "styleLine", "csRow", "CSSPage", "CSSline"], "queryZoom": ["QueryZom", "queryClom", "queryzooming", "searchZoom", "QueryLom", "searchZip", "queryLom", "queryClip", "queryzip", "QueryZoom", "searchLoom", "queryZom", "QueryLoom", "queryZooming", "searchLip", "QueryLooming", "queryCloom", "queryzom", "queryzoom", "QueryZooming", "searchLom", "queryLooming", "queryLoom", "searchZooming", "queryClooming", "queryLip", "queryZip", "searchLooming", "searchZom"], "appendToHome": [" appendFromHome", "appendFromRoot", " appendOnPage", " append2Root", " appendFromRoot", " append2Home", "appendFromHome", " append2Back", " appendToBack", "appendToPage", " appendFromPage", "appendToRoot", " appendOnRoot", " appendOnBack", " appendFromBack", "appendToBack", "appendFromBack", " append2Page", "appendFromPage", " appendOnHome", " appendToPage", " appendToRoot"], "sql": ["install", "csv", "serv", "data", "msg", "cfg", "ssl", "string", "db", "str", "zip", "sl", "sol", "search", " SQL", "base", "html", "query", "expr", "QL", "params", "fp", "shell", "select", "SQL", "statement", "res", "spec", "comment", "table", "s", "job", "details", "printf", "setup", "sq", "ql", "sv", "log", "view", "general", "body", "sys", "dl", "eps", "id"], "pstmt": ["Pctmt", "pstm", "pstct", " pssm", "pstrkt", "pstrmd", "pcrlt", "pstrmt", "pstmd", "pstlt", "pstrlt", "pssm", "pctkt", "pspct", "pstrct", " pssst", "pstrm", "pstrst", "Pctkt", "Pctlt", "pctct", " pssmt", "pssMT", "pstkt", "Pstmd", " pstMT", "Pstkt", "pcrmt", "pspMT", "pcrMT", "pctlt", "pspmt", " pssMT", "pstMT", "pctMT", "Pstlt", "pssmt", "PctMT", "pssst", "pctmd", "PstMT", "pspkt", "pctst", "pctm", "pctmt", "Pstct", "Pctct", " pstm", "pstst", "Pstmt", "pcrmd", "pstrMT", " pstst", "Pctmd"], "rs": ["ctx", " Rs", "Res", "row", "Rs", " res", "rd", "RC", " repl", "Resp", " obj", "RS", "p", "rows", "params", "ls", "res", " r", "results", " src", "xs", " rc", "rc", "ret", "rl", "r", "mr", " RS"]}}
{"id1": "7757297", "id2": "3945236", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"uri": ["address", "filename", "plugin", "data", "format", "ui", " ur", "string", "source", "i", "resource", "path", "response", "http", "server", "message", "duration", "cli", "URI", "URL", "text", "username", "base", "database", "file", " URI", "directory", "location", "absolute", "href", "io", "name", "route", "email", "ri", "description", "iri", "Url", "report", "api", "id"], "encodedrdf": ["encodedrdfe", "encodedwdfe", "encodedddef", "encodedudef", "encodingrdbf", "encodingrsrf", "encodedrdF", "encodingwdF", "encodingwdf", "encodedudfe", "encodedrsfe", "encodingwdef", "encodedwdef", "encodedudF", "encodedrtbf", "encodedddbf", "encodedrtrf", "encodedrdrf", "encodedrdef", "encodingrsf", "encodedddrf", "encodingrdF", "encodingwdfe", "encodedudf", "encodingrdef", "encodedrtf", "encodingrsfe", "encodedddF", "encodedrsrf", "encodedrdbf", "encodedrsbf", "encodingrdf", "encodingrdrf", "encodingrdfe", "encodedwdF", "encodedddf", "encodedddfe", "encodingrsbf", "encodedwdf", "encodedrtfe", "encodedrsf"], "url": ["session", "Connection", "address", "user", "socket", "service", "ssl", "string", "connect", "web", "resource", "contact", "server", "http", "URL", "text", "base", "database", "conn", "file", "page", "location", "image", "open", "name", "client", "job", "channel", "relation", "l", "link", "Url", "position", "loc", "config", "use", "proxy"], "connection": ["application", "session", "Connection", "number", "ctx", "version", "condition", "socket", "service", "string", "source", "connect", "section", "document", "con", "contact", " Connection", "handler", "response", "http", "server", "password", "character", "writer", "URL", "text", "context", "communication", "function", "database", "conn", "in", "directory", "io", "unit", "open", "connected", "client", "channel", "relation", "c", "b", "or", "l", "n", "position", "loc", "driver", "config", "use", "proxy"], "lastUser": ["LastOwner", " lastWord", " lastOwner", "LastUser", "lastOwner", "finalOwner", "lastWord", "LastWord", " lastId", "LastId", "finalWord", "finalId", "finalUser", "lastId"], "out": ["prefix", "flush", "server", "full", "w", "outs", "external", "at", "view", "pool", "sync", "data", "socket", "conn", "file", "in", "plain", "exp", "io", "write", "exec", "log", "key", "report", "word", "again", "dump", "OUT", "check", "no", "output", "and", "line", "writer", "init", "Out", "part", "temp", "bin", "comment", "up", "client", "doc", "outer", "cache", "copy", "object", "user", "flow", "off", "password", "editor", "cli", "commit", "window", "lock", "error", "page", "one", "err", "inner", "name", "obj", "cmd", "o", "result", "login", "extra", "global"]}}
{"id1": "23402240", "id2": "16590954", "code1": "    public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) {\n        int intResult = 0;\n        String sql = \"UPDATE torneo\" + \" SET  numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"idTorneo": ["idTordepo", "idForneor", "idTnee", "idTorneor", "idTneo", "idTourgee", "idTecte", "idTornpo", "idTorno", "idFordeor", "idTneology", "idFornee", "idTordeor", "idTordee", "idTorneology", "idFordeographic", "idTectographic", "idTorneographic", "idTourgeo", "idTornology", "idForneographic", "idTordeology", "idTourgeor", "idTornee", "idForneology", "idFordepo", "idFordee", "idFornepo", "idTector", "idFordeo", "idFordeology", "idTecto", "idTordeo", "idTourgeographic", "idTornepo", "idTnepo", "idTordeographic", "idForneo", "idTorne"], "nDivisiones": ["nDivitione", "nDecisionions", "nDivitions", "nDivdivisionions", "nDivdivisions", "nDIVisionsese", "nDivisionsese", "nDivitiones", "nDivensione", "nDIVisione", "nDivisione", "nDivensionese", "nDivitionese", "nDecitione", "nDivisionse", "nDivensiones", "nDivitionions", "nDivisionss", "nDIVisionese", "nDivisionses", "nDIVisionsions", "nDivisionsions", "nDecitiones", "nDivensionions", "nDIVisiones", "nDivisionions", "nDIVisionses", "nDivisionese", "nDecisions", "nDecisione", "nDecisiones", "nDivdivisione", "nDIVisionions", "nDecitionions", "nDIVisionse", "nDecitions", "nDivisions", "nDivdivisiones"], "intResult": ["interResult", "interTr", " intRest", "indResult", "ntPoint", "intResults", "intPoint", "interRes", "indRes", "intReturn", "intRest", "INTResults", "IntReturn", "INTResult", "ntResult", "IntResult", "intsReturn", "ntTr", "intsResult", "INTRest", " intResults", "intsResponse", "indTr", "intTr", "INTResponse", "intsResults", "indPoint", "INTReturn", "intRes", "ntRes", " intReturn", "IntRest", "intResponse", "interPoint", " intResponse"], "sql": ["install", "sync", "pg", "socket", "ssl", "string", "section", "sf", "db", "str", "zip", "sl", "repl", "q", "base", " SQL", "query", "database", "QL", "url", "conn", "params", "shell", "select", "SQL", "ls", "comment", "s", "seed", "up", "cmd", "printf", "setup", "sq", "ql", "l", "pass", "log", "general", "fn", "dl"], "connection": ["application", "session", "Connection", "ctx", "condition", "port", "socket", "union", "pg", "BC", "section", "connect", "lc", "document", "con", "ongo", "db", "bc", "server", "writer", "context", "cp", "communication", "function", "p", "database", "query", "event", "conn", "select", "environment", "tc", "engine", "table", "unit", "connected", "collection", "client", "relation", "c", "po", "ion", "log", "position", "loc", "mc", "config", "index", "proxy"], "ps": ["pa", "cs", "pd", "pg", "pers", "PS", "ds", "pe", "pc", "pp", "pps", "pr", "cp", "pi", "bs", "p", "relations", "os", "processor", "params", "pointer", "gs", "sp", "Ps", "ms", "qs", "pse", "process", "pid", "ips", "syn", "pos", "settings", "po", "rs", "ss", "jp", "proc", "pt", "ppa", "proxy", "eps", "ks"]}}
{"id1": "12428013", "id2": "414258", "code1": "    public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) {\n        if (monitor != null && monitor.isCanceled()) {\n            return;\n        }\n        try {\n            ftpClient = new FTPClient();\n            ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST)));\n            ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT));\n            ftpClient.connect();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD)));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (from != null) {\n                FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false);\n                synchedSet.add(ftpHolder);\n            }\n            JobHandler.aquireFTPLock();\n            for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) {\n                if (monitor != null && monitor.isCanceled()) {\n                    JobHandler.releaseFTPLock();\n                    ftpClient.quit();\n                    return;\n                }\n                Thread.yield();\n                FTPHolder element = (FTPHolder) iter.next();\n                ftpClient.setType(FTPTransferType.ASCII);\n                ftpClient.put(element.from, element.to);\n                if (element.renameTo != null) {\n                    try {\n                        ftpClient.delete(element.renameTo);\n                    } catch (Exception e) {\n                    }\n                    ftpClient.rename(element.to, element.renameTo);\n                    log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo);\n                }\n            }\n            JobHandler.releaseFTPLock();\n            ftpClient.quit();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (FTPException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        synchedSet.clear();\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"monitor": ["number", "loader", "umi", "cm", "annot", "sm", "core", "cher", "runner", "condition", "port", "pm", "counter", "watch", "Monitor", "container", "progress", "handler", "reason", "meter", "duration", "member", "username", "mor", "function", "period", "processor", "conn", "method", "timeout", "directory", "manager", "don", "m", "widget", "thread", "state", "stat", "unit", "image", "module", "dm", "update", "clock", "client", "callback", "mon", "timer", "or", "program", "component", "control", "log", "oper", "controller", "consumer", "report", "mc", "driver", "body", "config", "object", "status", "master", "match", "message"], "from": ["address", "prefix", "who", "left", "user", "uri", "string", "source", "form", "remote", "resource", "origin", "path", "contact", "host", "server", "with", "small", "org", "by", "ce", "actor", "username", "since", "base", "front", "add", "ou", "url", "part", "type", "connection", "owner", "From", "action", "range", "name", "code", "vol", "about", "channel", "route", "email", "or", "component", "size", "start", "at", "loc", "false", "attribute", "back", "id"], "to": ["target", "To", "address", "prefix", "version", "ref", "left", "user", "uri", "site", "source", "remote", "go", "resource", "eto", "token", "server", "with", "two", "top", "by", "repl", "dest", "value", "base", "database", "reply", "url", "file", "full", "type", "location", "into", "connection", "io", "range", "table", "name", "info", "about", "o", "pos", "until", "su", "po", "toc", "size", "key", "so", "out", "TO"], "renameTo": ["renributeTarget", "reameToken", "renewTo", "renameto", "rennameTarget", "renageToken", "renributeTo", " RenAMETo", "reageTo", " RenseFor", "renseOf", "renAMEToken", "rennameFrom", "renAMETarget", "renokeTO", " RenAMEFor", "renributeFor", " RenameTo", "renamFor", "renameFor", " renAMEFrom", " renAMETarget", "reageto", " renameTarget", "relameTo", "renenameTarget", " renameFrom", "renseFor", "renamelOf", "renenameto", " RenameOf", "renokeFor", "relalFrom", "renseTO", "renameTO", "renalTO", "renageTO", "relalTo", "relalTarget", "renamTarget", " RenseTo", "renamelTo", "renamTo", "renameToken", "renameWill", " RenameFor", "renalToken", "renokeTo", "renenameTo", "relenameTo", "renalto", "renewTarget", "renributeWill", "relameTarget", "renamelTO", "renenameUrl", "relenameto", "renAMEUrl", " renAMETo", " RenameWill", "renAMEto", "renAMETo", "renameTarget", "renalFrom", "renamelFor", "renameOf", " RenAMETarget", "rennameto", "renokeFrom", "renamWill", "renalTo", "reameTo", "renoketo", "renseTo", " RenameTO", "renageto", "renAMEFor", "renalTarget", "reageTO", " RenseOf", "reameto", " RenAMEWill", "relenameUrl", " RenameTarget", "relameto", "renageTo", "renAMETO", "reameTO", "relalto", "relameUrl", "rennameTo", "renokeUrl", " RenseTO", "renAMEWill", "renewFrom", "renokeOf", "relameFrom", "renameUrl", "renenameFrom", "renameFrom", "reageToken", "renAMEFrom", "relenameFrom"], "ftpClient": ["ftfpCloud", " ftpControl", "ftapiServer", "aftpClient", "ftpiServer", "ftcpCloud", " ftpiHost", " ftlClient", " ftpCan", "ftmServer", " ftlCommunity", " ftoServer", "ftfCloud", " ftnServer", "fttpClient", " fttpClass", "ftiClient", " ftiGuest", " ftlCenter", "ftiGuest", " ftnClient", "fttpHost", "ftmClient", " ftoHost", "ctcpClient", " ftapiClient", " ftlConnection", " ftpHost", "ftfpChannel", "ftfpCenter", " ftpHelper", "ftfpServer", "ftoServer", "afttStream", "ftpControl", " ftapiServer", "ftbHost", "ftoCan", "ftiServer", "afttClient", "fttpStream", " ftpoClient", " ftpoCenter", "ftfpResource", "ftpoCloud", " ftpChannel", "fttpCan", "ftnHost", " ftiServer", "ftcpHost", "fttpServer", "ftcpGuest", " ftapiCloud", "ftpCenter", " ftpServer", " fticlient", "ftbCan", "ftapiCloud", "aftpStream", "ctpResource", "ctpClient", "ftpStream", "ftpcServer", "fttpClass", "ftpclient", "ftpsClient", "ftbServer", " ftpCloud", "ftpiHost", "ftlClient", "ftcGuest", "ftpcClass", "ftlCenter", "ftfClient", "ftcServer", "ftpcCenter", "ftbrClient", "ftpoCenter", "ctcpResource", "ftpHost", "ftmResource", "ftcClient", "ftcpCommunity", "ctpServer", " ftpGuest", "ftpcConnection", "ftcclient", "ctcpChannel", " fttpControl", "ftpoClient", "ftcpConnection", " ftpiChannel", "ftnClient", " ftpiServer", "ftbClient", "ftapiClient", "ftpsContainer", " ftpCommunity", " ftapiHelper", "ftpcHelper", " ftpContainer", "fttStream", "fticlient", "ftfpClient", " ftiClient", " ftnHost", "ftcpChannel", "ftpcControl", " fttpClient", "ftpsClass", " ftpConnection", "ftpcCommunity", "ftpiClient", "ftcpHelper", "ftfCenter", "ftpContainer", "ftpiChannel", "ctpChannel", " fttpContainer", "ftoHost", "fttpChannel", "ftpServer", "ftpcClient", " ftoClient", "ftlCommunity", "ftoClient", "ftpCommunity", "ftapiHelper", "ftpChannel", "ftpResource", "ftpcCloud", "ftpCloud", "ftpClass", "ftpCan", "ftcpResource", "fttpControl", "ftbrStream", "ftnServer", " ftpclient", "ftpConnection", "ctcpServer", " ftpClass", "ftcpServer", "ftlConnection", "ftpHelper", "ftcpCenter", "ftcpclient", "ftmChannel", " ftpiClient", "ftcpClient", "ftpcContainer", " ftpoCloud", " ftoCan", "fttpContainer", "ftpGuest", "fttClient", "ftpsControl", " ftpCenter"], "ftpHolder": ["fttpChard", "ftpWolder", "fttpHook", "ftphold", "ftpShook", "fttpChander", "ftphather", "ftphander", "ftpHold", "ftpcWold", "ftpChook", "ftpCholder", "ftpWholder", "ftpcHholder", "ftpHook", "fttpChook", "ftphook", "ftpShander", "ftpHander", "ftpWather", "ftphard", "ftpShard", "ftpcWolder", "ftpChard", "fttpHolder", "ftpcHolder", "fttpHard", "ftpHather", "ftpWold", "ftpholder", "fttpHander", "ftpWorkolder", "ftpSholder", "ftpChander", "ftpHholder", "fttpCholder", "ftpWorkholder", "ftpcHold", "ftpcHather", "ftpcWather", "ftpWorkather", "ftpHard", "ftpcWholder", "ftphholder", "ftpWorkold"], "iter": ["walker", "ir", "itter", "next", "f", "it", "ener", "cher", "gener", "i", "former", "end", "http", "entry", "limit", "iterator", "ator", "list", "its", "ite", "iv", "init", "collect", "file", "chain", "in", "reader", "keep", "ipper", "er", "ter", "inter", "err", "izer", "finder", "inner", "ip", "Iterator", "set", "skip", "result", "Iter", "or", "outer", "size", "over", "ver", "inc", "enter", "oper", "loc", "ner", "ser", "index", "coll", "info", "e", "id"], "element": ["number", "et", "per", "token", "server", "entry", "input", "value", "atom", "variable", "er", "type", "header", "e", "cell", "next", "plugin", "data", "Element", "service", "air", "folder", "reader", "connection", "owner", "action", "ee", "optional", "instance", "component", "item", "key", "article", "content", "empty", "resource", "document", "output", "layer", "line", "option", "el", "this", "text", "entity", "part", "comment", "letter", "module", "or", "ele", "node", "activity", "coll", "object", "match", "expression", "child", "section", "container", "editor", "member", "parent", "event", "page", "environment", "style", "inner", "email", "result", "definition", "attribute"]}}
{"id1": "20011285", "id2": "19687456", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 1, "substitutes": {"sourceFile": ["ourceBase", "searchFile", "ourceDirectory", "inputFiles", "targetFactory", "searchSourceFile", "targetDirectory", " sourcePlace", "sourcefile", "sourceFilename", "sortSourceFile", "searchfile", "SourceSourceFile", " sourcefile", "ourceFiles", " sourceFolder", "SourceFiles", "inputFolder", " sourceFiles", "targetfile", "SourcePlace", "sourceDir", "sourceFILE", "targetFiles", "sortFilename", "SOURCEFilename", "SourceFactory", "inputFile", "searchFiles", "ourceFactory", "ourcefile", " sourceDir", "sourceDirectory", "SOURCEFILE", " sourceBook", "sourcePlace", "srcFiles", "SOURCESourceFile", "sourceFiles", "sourceSourceFile", "SOURCEFile", " sourceFILE", "ourceSourceFile", "sourceBase", "searchFILE", "targetFILE", "searchFilename", "Sourcefile", "SourceDir", "srcFile", "sourceBook", "SourceDirectory", "sortFILE", "sourceFactory", "ourcePlace", "sortFile", " sourceSourceFile", "sourceFolder", " sourceBase", "ourceBook", "srcBase", "targetFile", "targetDir", "ourceFile", " sourceDirectory", "srcBook", "SourceFile", "ourceFolder"], "destinationFile": ["destacementFile", "thisinationfile", "destinateFile", "dominatorPath", "thisinatedName", "dominatorfile", "DestationFile", "distructionFolder", "DestinatingDirectory", "destinaryFile", "destationFile", "destinatePath", "destagingFile", "destationDirectory", "destinatingFiles", "Destationfile", "distinationDirectory", "Destinationfile", " destinatingFile", " destinatingLine", "destinatingDirectory", "destinatorLine", "thisinatedFolder", "destinationFiles", "thisinationName", "destinatingFile", "DestinatingFile", "destinationfile", "destationFolder", "DestationDirectory", " destinatingfile", "destinationDirectory", "destructionFile", "destinatorFile", "distinationFILE", "destinatefile", " destinationFiles", "DestinatingFiles", "destinatedPath", "destinedFile", "distructionDirectory", "destacementFiles", "destationFiles", "destationfile", "destinatorfile", "destinatingLine", "destinationPath", "distinationFile", "destinedfile", "destificationFolder", "DestinationFiles", "destificationFile", "destinatorFolder", "destinatorFiles", "destinateFiles", "dominatorFiles", "dominationPath", "destinaryFolder", "destinationLine", "dominationFile", "distructionFILE", "destinatedfile", "destinedLine", " destinatingFiles", "destinationName", "destinatorPath", "thisinationFile", "distinationFolder", "destinatorFILE", "destinationFolder", "destagingDirectory", "destructionFolder", "destinaryDirectory", " destinationfile", "dominationFiles", "thisinationFolder", "destructionFILE", "destificationName", "thisinatedFile", "distructionFile", "destinatingfile", "destinatedName", "destificationfile", "destagingFiles", "destinaryFILE", "thisinatedfile", " destinationLine", "destinatorDirectory", "destacementDirectory", "dominatorFile", "destinedFiles", "destinationFILE", "dominationfile", "destinatingPath", "destinatedFile", "destructionDirectory", "DestinationFile", "destinatedFolder", "DestinationDirectory", "DestationFiles", "destationName", "destacementfile", "destinatedFiles"], "tmp": ["st", "csv", "rb", "data", "nb", "bb", "vm", "pty", "upload", "diff", "handler", "slice", "db", "stuff", "zip", "pp", "t", "list", "buf", "fb", "dest", "folder", "meta", "mm", "p", "txt", "array", "v", "sup", "page", "params", "part", "temp", "sp", "img", "files", "apps", "m", "rm", "ip", "mb", "storage", "media", "xs", "obj", "dir", "pos", "np", "po", "amp", "tab", "cache", "flat", "current", "cmp", "mp", "tp", "ppa", "api", "split", "area", "copy", "mo", "dat", "e"], "f": ["inf", "d", "x", "g", "cf", "handler", "fx", "fr", "xf", "conf", "t", "fb", "h", "fc", "lf", "this", "F", "fa", "ff", "tf", "p", "bf", "v", "file", "fp", "fd", "full", "u", "m", "io", "fo", "rf", "o", "c", "b", "fi", "j", "l", "uf", "df", "af", "fn", "fe", "r", "fl", "info", "fs", "e"], "i": ["hi", "x", "d", "ui", "ti", "uri", "ie", "bi", "ij", "ci", "gi", "qi", "lc", "di", "pi", "p", "v", "in", "ai", "ix", "u", "m", "iu", "io", "s", "ip", "ii", "y", "name", "info", "o", "c", "b", "I", "ri", "fi", "multi", "j", "l", "index", "start", "n", "si", "vi", "key", "li", "oi", "ji", "h", "xi", "e", "id"], "source": ["target", "core", "src", "uri", "from", "ssl", "site", "resource", "ie", "service", "proxy", "diff", "SOURCE", "slice", "plus", "server", "sl", "input", "ce", "this", "parent", "secure", "base", "sc", "reader", "scope", "ge", "connection", "slave", "io", "get", "image", "force", "storage", "client", "result", "component", "size", "stream", "start", "current", "view", "si", "Source", "ource", "copy", "use", "back", "null", "grade", "e"], "destination": ["destension", "optioninator", "Destinator", " destribution", "destruction", " destroying", "Destension", "transinator", "Destribution", "destroying", "ordination", "ordinator", "destinated", "Destination", "optionination", "descination", "Destroying", "descruction", "Destruction", "Destinated", "transination", "transruction", "destribution", "descinator", "transension", "ordroying", "destinator", " destinator", "optioninated", " destinated", "ordinated", "descension", "optionribution"]}}
{"id1": "23246123", "id2": "9687813", "code1": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "code2": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"parent": ["wrapper", "ctx", "cl", "child", "parents", "port", "g", "section", "form", "resource", "document", "container", "builder", "host", "command", "panel", "this", "class", "context", "menu", "p", "root", "event", "Parent", " scene", "page", "connection", " sup", "self", "comp", "image", "client", "c", "instance", "component", "parser", "object", "null", "clip", "message"], "composite": ["complexitable", "comppite", "complites", "comppiton", "compositionited", "comppositioniton", "COMpliton", "comPOSite", "composited", "comppositionitable", "comPOSitable", "COMplite", "complitor", "compposite", "complite", "COMpositable", "compositor", "compositon", "comosites", "compliton", "comppositionite", "compositionites", "composites", "comositable", "comppositionited", "COMplitable", "comosited", "comppositionitor", "compositionite", "comPOSited", "compposited", "COMposite", "compositable", "comppositor", "comppositionites", "comppositon", "complexiton", "comppites", "COMposites", "compositionitable", "complexite", "comosite", "compositionitor", "comppitor", "compositioniton", "COMpositon", "COMplites", "complexites", "comppositable", "comPOSites", "compposites", "complitable"], "content": ["application", "loader", "scroll", "cm", "address", "version", "child", "plugin", "format", "section", "xml", "document", "container", "app", "output", "resource", "feed", "host", "layer", "server", "model", "cell", "context", "folder", "html", "cont", "json", "load", "conn", "page", "file", "connection", "comment", "header", "image", "media", "cms", "title", "code", "client", "create", "component", "current", "control", "report", "activity", "complete", "config", "copy", "Content", "object", "ez", "message"], "ncol": ["Ncol", " ncolumn", "ncolumn", "nbcol", "nrow", "pcolumn", "numCol", " nrow", "pCol", "nCol", "numrow", "pblock", "nbcolumn", "numcolumn", "Nblock", "Ncolumn", "pcol", " nCol", "nblock", "numcol", "NCol", " nblock", "nbrow", "nbCol"], "layout": ["join", "scroll", "address", "data", "ui", "follow", "nav", "left", " layouts", "alpha", "lc", "section", "flow", "container", "Layout", "feed", "xml", "layer", "nl", "grid", "model", "holder", "entry", "font", "where", "list", "board", "lay", "scale", "base", "lock", "block", "shape", "inline", "mount", "translation", "closure", "shadow", "location", "widget", "draw", "edit", " Layout", "offset", "image", "design", "l", "flat", "control", "view", "position", "split", "padding", "config", "figure"], "numColumns": ["numControles", "NumControles", "numcolumnCount", "NumColumnCount", "numcolumns", "numColumnows", "NumControlCount", "numColows", "numColes", "numcolumnows", "numControlCount", "numColumnes", "NumControlows", "numCols", "NumControls", "numControls", "numControlows", "NumColumns", "NumColumnows", "numColumnCount", "NumColumnes", "numColCount", "numcolumnes"], "browser": ["session", "loader", "platform", "plugin", "port", "runner", "user", "jar", "uri", "mobile", "ssl", "nav", "fox", "proxy", "flash", "cart", "chrome", "graph", "feed", "remote", "web", "host", "Browser", "server", "editor", "http", "facebook", "lib", "roller", "binary", "cv", "book", "vert", "window", "html", "root", "front", "webkit", "page", "img", "manager", "shadow", "css", "bot", "finder", "comment", "agent", "box", "image", "ab", "br", "io", "river", "client", "google", "design", "term", "download", "feature", "ger", "js", "test", "driver", "cookie", "report", "config", "theme", "coll", "fire", "ver"], "text": ["ext", "TEXT", "it", "plugin", "data", "format", "port", "user", "service", " Text", "string", "source", "form", "feed", "path", "output", "off", "str", "editor", "entry", "label", "font", "input", "atter", "binary", "writer", "desc", "vert", "ut", "context", "txt", "select", "connection", "comment", "letter", "unit", "image", "inner", "element", "title", "default", "name", "struct", "client", "pattern", "term", "Text", "test", "driver", "report", "config", "button", "ort", "object", "info", "message"], "url": ["address", "f", "re", "bel", "pull", "ref", "rel", "user", "uri", "service", "ssl", "string", "source", "resource", "web", "path", "feed", "host", "server", "http", "ur", "zip", "sl", "URL", "base", "file", "page", "www", "gl", "connection", "io", "image", "open", "lr", "l", "download", "Url", "api", "config", "e", "id"], "in": ["gin", "f", "re", "d", "dr", "data", "it", "serv", "x", "a", "rb", "inn", "ssl", "i", "resource", "ic", "on", "sr", "str", "fr", "is", "el", "input", "arin", "init", "rec", "p", "min", "din", "reader", "rin", "w", "ins", "er", "bin", "err", "ar", "inner", "s", "image", "o", "b", "ri", "c", "or", "l", "rc", "In", "stream", "inc", "IN", "nin", "ini", "out", "again", "pin", "e"], "r": ["ir", "f", "kr", "re", "gr", "R", "rb", "rr", "rw", "ro", "ru", "dr", "hr", "rel", "i", "sr", "rh", "cr", "fr", "ur", "pr", "rob", "p", "reader", "rss", "res", "er", "m", "rg", "err", "ar", "rar", "vr", "br", "rt", "right", "d", "rf", "o", "b", "ri", "c", "lr", "or", "rs", "l", "rc", "nr", "rx", "rl", "ner", "h", "out", "mr", "e"], "sb": ["abb", "pb", "xb", "bh", "rb", "bb", "gb", "lp", "ruby", "ssl", "src", "sf", "eb", "wb", "sr", "bc", "db", "ib", "nl", "BB", "bj", "erb", "usb", "buf", "fb", "sth", "binary", "sa", "rob", "bs", "lb", "bf", "bsp", "sg", "obb", "bm", "bp", "sp", "library", "SB", "cb", "s", "buffer", "mb", "storage", "b", "lr", " SB", "kb", "sv", "si", "lab", "sn"], "line": ["cl", "f", "data", "row", "lines", "string", "source", "i", "end", "LINE", "str", "nl", "id", "message", "character", "entry", "pe", "sl", "el", "lf", "base", "block", "page", "lin", "part", "inline", "se", "stroke", "ge", "char", "comment", "letter", "header", "Line", "code", "name", "obj", "cle", "b", "le", "l", "ne", "pass", "n", "key", "split", "li", "record", "object", "col", "e", "cell"]}}
{"id1": "9872346", "id2": "18374478", "code1": "    public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException {\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\");\n        Document document = null;\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            factory.setCoalescing(true);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDefaultUseCaches(false);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"User-Agent\", \"eXchaNGeR/\" + System.getProperty(\"xngr.version\") + \" (http://xngr.org/)\");\n            connection.connect();\n            InputStream stream = connection.getInputStream();\n            document = factory.newDocumentBuilder().parse(stream);\n            stream.close();\n            connection.disconnect();\n        } catch (SAXException e) {\n            if (e instanceof SAXParseException) {\n                throw (SAXParseException) e;\n            }\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \") [\" + document + \"]\");\n        return document;\n    }\n", "code2": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "label": 0, "substitutes": {"url": ["loader", "address", "f", "filename", " URL", "uri", "user", "ssl", "string", "source", "proxy", "xml", "remote", "resource", "path", "feed", "host", "layer", "server", "http", "entry", "ur", "org", "sl", "URL", "store", "base", "load", "file", "page", "mount", "www", "location", "image", "name", "client", "email", "l", "ll", "download", "Url", "link", "position", "loc", "rl", "config", "dl", "coll"], "validate": [" invalidATE", " validated", " invalidated", "Valate", " invalidation", " validation", " validATE", "validated", "validation", "validATE", "Valation", " invalidate", "ValATE", "Valated"], "document": ["application", "material", "session", "number", "video", "expression", "f", "version", "data", "content", "service", "port", " documentation", "ocument", "Document", "source", "request", "xml", "container", "resource", "output", "response", "valid", "project", "text", "value", "parent", "function", "root", "database", "degree", "office", "page", "location", "image", "media", "language", "collection", "result", "instance", "doc", "index", "dict", "df", "node", "metadata", "null", "complete", "record", "word", "object", "model", "message"], "factory": ["dlier", " flict", "cactory", "facictionary", " fade", "folver", "flict", "defade", "defactory", "inflict", "locol", "defiller", "sfocol", "facistry", "cictionary", "lault", "infactory", "filler", " filler", "Factory", "FFactory", "fFactory", "puture", "sfolver", "infocol", "infFactory", "sfault", "piller", "facactory", "dictionary", "fault", "future", "Flict", "flier", " fancy", "pactory", "lolver", "sfactory", "lactory", "pade", "faclier", "infancy", "fistry", "defuture", "clier", "fade", "infolver", "cistry", "fictionary", " future", "Fancy", "dactory", " fFactory", "focol", "fancy", "infault", "distry"], "connection": ["application", "session", "Connection", "system", "version", "condition", "union", "socket", "uri", "cf", "service", "user", "section", "connect", "resource", "builder", "con", "container", "handler", "response", "http", "server", "character", "writer", "context", "communication", "function", "database", "error", "conn", "translation", "reader", "environment", "io", "image", "default", "open", "connected", "client", "channel", "relation", "c", "link", "index", "cache", "current", "position", "driver", "loc", "config", "use", "out", "proxy", "info"], "stream": ["loader", "system", "wrapper", "ream", "video", "f", "version", "data", "row", "string", "source", "form", "resource", "xml", "per", "output", "path", "feed", "handler", "upload", "response", "server", "model", "input", "writer", "context", "cont", "load", "raw", "v", "file", "sc", "reader", "Stream", "stack", "io", "inner", "image", "coll", "client", "channel", "sw", "result", "trans", "view", "body", "transform", "out", "object", "null"]}}
{"id1": "7757297", "id2": "692738", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"uri": ["address", "filename", "plugin", "data", "format", "ui", " ur", "string", "source", "i", "resource", "path", "response", "http", "server", "message", "duration", "cli", "URI", "URL", "text", "username", "base", "database", "file", " URI", "directory", "location", "absolute", "href", "io", "name", "route", "email", "ri", "description", "iri", "Url", "report", "api", "id"], "encodedrdf": ["encodedrdfe", "encodedwdfe", "encodedddef", "encodedudef", "encodingrdbf", "encodingrsrf", "encodedrdF", "encodingwdF", "encodingwdf", "encodedudfe", "encodedrsfe", "encodingwdef", "encodedwdef", "encodedudF", "encodedrtbf", "encodedddbf", "encodedrtrf", "encodedrdrf", "encodedrdef", "encodingrsf", "encodedddrf", "encodingrdF", "encodingwdfe", "encodedudf", "encodingrdef", "encodedrtf", "encodingrsfe", "encodedddF", "encodedrsrf", "encodedrdbf", "encodedrsbf", "encodingrdf", "encodingrdrf", "encodingrdfe", "encodedwdF", "encodedddf", "encodedddfe", "encodingrsbf", "encodedwdf", "encodedrtfe", "encodedrsf"], "url": ["session", "Connection", "address", "user", "socket", "service", "ssl", "string", "connect", "web", "resource", "contact", "server", "http", "URL", "text", "base", "database", "conn", "file", "page", "location", "image", "open", "name", "client", "job", "channel", "relation", "l", "link", "Url", "position", "loc", "config", "use", "proxy"], "connection": ["application", "session", "Connection", "number", "ctx", "version", "condition", "socket", "service", "string", "source", "connect", "section", "document", "con", "contact", " Connection", "handler", "response", "http", "server", "password", "character", "writer", "URL", "text", "context", "communication", "function", "database", "conn", "in", "directory", "io", "unit", "open", "connected", "client", "channel", "relation", "c", "b", "or", "l", "n", "position", "loc", "driver", "config", "use", "proxy"], "lastUser": ["LastOwner", " lastWord", " lastOwner", "LastUser", "lastOwner", "finalOwner", "lastWord", "LastWord", " lastId", "LastId", "finalWord", "finalId", "finalUser", "lastId"], "out": ["prefix", "flush", "server", "full", "w", "outs", "external", "at", "view", "pool", "sync", "data", "socket", "conn", "file", "in", "plain", "exp", "io", "write", "exec", "log", "key", "report", "word", "again", "dump", "OUT", "check", "no", "output", "and", "line", "writer", "init", "Out", "part", "temp", "bin", "comment", "up", "client", "doc", "outer", "cache", "copy", "object", "user", "flow", "off", "password", "editor", "cli", "commit", "window", "lock", "error", "page", "one", "err", "inner", "name", "obj", "cmd", "o", "result", "login", "extra", "global"]}}
{"id1": "17161805", "id2": "4852691", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"plaintext": [" plainstring", "longText", "battext", " plainText", "plaincontent", " plainform", "batstring", "plainform", "plainText", "longtext", "foreTEXT", "bodytext", "batTEXT", "foreText", " plainTEXT", "batText", "longcontent", "bodyText", "plainstring", " plaincontent", "longform", "bodyform", "plainTEXT", "foretext", "forestring", "bodycontent"], "md": ["um", "f", "pd", "d", "dh", "sm", "wd", "ad", "pm", "gd", "amd", "mad", "rpm", "ind", "sha", "di", "grad", "meta", "mm", "od", "MD", "dd", "mand", "ma", "m", "ms", " MD", "rm", "bd", "mb", "dm", "code", "cd", "cmd", "mod", "po", "hd", "df", "me", "mac", "mag", "mp", "mc", "metadata"], "raw": ["custom", "unsigned", "RAW", "internal", "rew", "row", "alpha", "orig", "hex", "ack", "pure", "remote", "micro", "feed", "blocks", "dec", "initial", "input", "unknown", "binary", "load", "block", "array", "missing", "shared", "Raw", "buffer", "ghost", "serial", "original", " Raw", " hex", "pack", "instance", "all", "stream", "local", "clean", "enc", "out", "ode"]}}
{"id1": "9210168", "id2": "614099", "code1": "            @Override\n            public void run() {\n                try {\n                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n                    InputStream fis = url.openStream();\n                    InputStreamReader r = new InputStreamReader(fis, \"UTF-8\");\n                    BufferedReader br = new BufferedReader(r);\n                    String line;\n                    StringBuilder sb = new StringBuilder();\n                    while (null != (line = br.readLine())) {\n                        sb.append(line);\n                        sb.append(\"\\r\\n\");\n                    }\n                    br.close();\n                    r.close();\n                    fis.close();\n                    final String text = sb.toString();\n                    SwingUtilities.invokeLater(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            MainPanel.this.source.setText(text);\n                            MainPanel.this.source.setCaretPosition(0);\n                        }\n                    });\n                } catch (Exception ex) {\n                }\n            }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"url": ["loader", "address", "f", "re", "user", "uri", "service", "ssl", "string", "source", "resource", "remote", "web", "path", "str", "server", "http", "fr", "ur", "sl", "URL", "base", "file", "reader", "er", "gl", "err", "image", "b", "lr", "l", "Url", "loc", "rl", "api", "id"], "fis": [" fIs", "Fos", "sfis", " fIS", " fisc", "fisc", "bIs", "fIs", "sfIs", "Fis", "FIS", " fiss", "afis", "flIs", "afIS", "sfiss", "fliss", "afiss", "cfis", "afos", "flis", "fos", "bIS", "biss", "cfiss", "bis", "fiss", "FIs", "sfisc", "cfos", "flisc", "Fiss", "cfIS", "fIS"], "r": ["ir", "f", "kr", "d", "gr", "R", "rr", "rb", "re", "ru", "hr", "BR", "i", "resource", "ler", "sr", "cr", "http", "fr", "tr", "ur", "e", "is", "pr", "p", "reader", "wr", "w", "res", "er", "err", "ar", "s", "vr", "rt", "rf", "b", "c", "ri", "rs", "rc", "l", "rx", "rl", "mr", "Reader"], "br": ["bar", "bl", "bh", "rb", "dr", "gr", "bb", "BR", "hr", "bro", "HR", "sr", "str", "cr", "tr", "fr", "fb", "buf", "pr", "bf", "wr", "reader", "res", "yr", "err", "bd", "Br", "brush", "arr", "rt", "B", "b", "result", "lr", "browser", "bridge", "rx", "ch", "ob", "mr", "be"], "line": ["number", "cl", "f", "bl", "column", "data", "row", "lines", "string", "lc", "i", "end", "LINE", "str", "nl", "id", "cr", "entry", "character", "sl", "el", "liner", "lf", "base", "lin", "page", "inline", "se", "part", "ge", "char", "letter", "comment", "buffer", "header", "style", "name", "Line", "code", "cle", "b", "pos", "le", "sel", "l", "link", "pass", "key", "li", "rl", "split", "word", "e", "cell"], "sb": ["abb", "pb", "xb", "bl", "bh", "rb", "nb", "bb", "src", "gb", "eb", "sf", "wb", "bc", "db", "ib", "zb", "BB", "bj", "erb", "fb", "usb", "buff", "buf", "sth", "binary", "rob", "sa", "bs", "lb", "orb", "bf", "bsp", "sg", "obb", "bm", "bp", "ls", "SB", "cb", "ab", "s", "mb", "bt", "storage", "bis", "b", "sv", "si", "ob", "sn"], "text": ["ext", "TEXT", "data", "content", "format", "string", "source", "output", "path", "str", "entry", "font", "value", "html", "txt", "translation", "connection", "comment", "letter", "buffer", "title", "code", "name", "obj", "struct", "result", "Text", "test", "config", "word", "object", "info", "message"]}}
{"id1": "16572931", "id2": "13657103", "code1": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"jarPath": ["garEntry", "JarUrl", "parsePath", " jarpath", "jarFile", "jarLog", " jarLog", "browserEntry", "javaName", "erbPo", "relEntry", "jarUrl", "javaPo", " jarPo", "JarPath", "javaFile", "relFile", "tarEntry", "javaEntry", "relKey", "garpath", "JarEntry", "browserName", "javaUrl", "browserpath", "garLog", "tarKey", "javapath", "browserPath", "jarPo", "garPath", "jarName", "parseEntry", "Jarpath", "JarLog", " jarFile", "erbPath", "javaPath", "jarKey", "tarFile", "parsepath", "erbEntry", "tarPath", " jarUrl", "JarFile", "parseFile", "erbName", "JarKey", "jarpath", " jarName"], "jarEntry": ["javaPart", "aliasInfo", "aliasentry", "jarFile", "Jarentry", "javaentry", "javaEnt", " jarDir", "urlEnt", "urlPath", "archiveEntry", "jarUrl", "cookieEnt", "javaFile", "JarPath", "cookieEntry", "urlUrl", "urlEntry", "tarEntry", "javaEntry", "cookieDir", "tarUrl", "JarEntry", "JarPart", "aliasPath", "javaUrl", "archiveentry", "archivePath", "jarDir", "archiveInfo", "aliasEntry", "jarPart", "jarentry", " jarInfo", "javaInfo", " jarPart", "jarEnt", " jarEnt", "jarInfo", " jarFile", " jarentry", "javaPath", "tarPath", "JarFile", "javaDir", "tarEnt", "JarInfo", "cookiePath"], "path": ["prefix", "uri", "request", "alias", "host", "entry", "then", "cross", "zone", "root", "url", "full", "th", "Path", "type", "right", "code", "build", "not", "config", "continue", "model", "instead", "next", "here", "data", "left", "home", "source", "context", "folder", "base", "file", "conn", "walk", "method", "boot", "archive", "mode", "ph", "pass", "log", "test", "key", "info", "ath", "PATH", "patch", "content", "wd", "string", "resource", "str", "zip", "this", "text", "ith", "prop", "temp", "mount", "directory", "dir", "c", "pattern", "work", "cache", "clean", "cel", "default", "object", "it", "graph", "parent", "p", "location", "image", "name", "route", "step", "loc"], "relPath": ["relId", "basepath", "RelPath", " relId", "relEntry", "RelFile", " relName", "basePath", "relFile", " relFile", "baseFile", "relatedEntry", "relName", " relpath", "RelId", " relEntry", "relpath", "relatedPath", "baseId", "RelName", "relatedpath", "Relpath", "RelEntry", "relatedName"], "jar": ["bar", "rb", "tar", "ie", "ja", "xml", "ler", "gi", "cr", "war", "entry", "gar", "zip", "sl", "z", "binary", "zone", "folder", "pkg", "zy", "base", "gap", "jo", "file", "url", "com", "java", "ar", "cook", "rar", "module", "open", "archive", "py", "job", "her", "le", "pack", "j", "browser", "tab", "car", "cur", "Jar", "jam", "ser", "bag", "fire", "ball"], "ze": ["zee", "lde", "je", "isin", "ie", "te", "ffe", "za", "zz", "zed", "zie", "entry", "pe", "zip", "ine", "z", "ce", "zer", "zy", "zi", "aze", "se", "zo", "zzy", "kee", "ke", "ge", " je", "kel", "oe", "le", "ZE", "ele", "ne", "ipe", "fe", "zes", "be", "e"], "bin": ["bar", "bas", "plugin", "bb", "bi", "bian", "gi", "web", "sin", "db", "zip", "lib", "bed", "binary", "init", "abi", "ban", "brain", "lyn", "lock", "base", "root", "min", "kin", "abin", "boot", "bot", "bn", "bon", "inner", "bis", "obin", "pack", "win", "cin", "ini", "spin", "login", "proxy", "pin", "bank", "bit"]}}
{"id1": "19849797", "id2": "13333160", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 1, "substitutes": {"sourceFile": ["srcFolder", " sourcefile", "destDirectory", "SourceDirectory", " sourceFolder", "sourceFolder", "ourceDirectory", "srcfile", "ourceUrl", "SourceUrl", "destUrl", "sourceDir", "srcDir", "sourceUrl", "SourceFolder", "ourceFile", "destfile", "Sourcefile", "SourceDir", "ourcefile", "sourcefile", "srcFile", " sourceDir", "SourceFile", "sourceDirectory"], "destFile": ["destDirectory", "DestPath", "DestDir", "DestDirectory", "resultLine", " destDir", "destPath", "destFiles", "srcLine", "srcFiles", "srcDirectory", "srcfile", "resultFile", "destLine", "targetfile", "resultfile", "targetPath", "foreignPath", "DestFile", "sourceFiles", "sourceDir", "srcDir", "resultDir", "destPoint", "foreignfile", "targetFile", "targetFiles", "DestFiles", "foreignFile", " destDirectory", "DestPoint", "foreignFiles", "targetDir", " destPoint", "destfile", "sourcePoint", " destfile", "Destfile", "destDir", "srcFile", "targetLine", " destFiles"], "source": ["session", "target", "wrapper", "core", "reference", "src", "uri", "service", "from", "ie", "site", "resource", "remote", "status", "output", "sin", "SOURCE", "slice", "server", "iter", "input", "ce", "this", "context", "dest", "parent", "secure", "root", "file", "url", "reader", "scope", "object", "manager", "connection", "slave", "get", "inner", "unit", "image", "table", "seed", "storage", "client", "channel", "route", "result", "component", "size", "stream", "index", "current", "start", "cache", "si", "Source", "view", "api", "ource", "scene", "use", "config", "proxy", "null", "id"], "destination": ["constination", "constribution", "destion", "domation", "dominator", "participinate", "Destinator", " destinated", "distination", " destribution", "generination", "destruction", "Destinate", "Destribution", "dominated", "Destion", "destinated", "Destination", "distion", "participinator", "participination", "generinated", "domination", " destruction", "Destruction", "Destinated", "destation", "construction", " destation", "constinator", "identinator", "destribution", "identination", "destinate", "distinator", "distinated", "distruction", "generruction", "destinator", "Destation", "participinated", " destinator", "identinate", "generinator", " destion", "identinated"]}}
{"id1": "9261777", "id2": "23273706", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 1, "substitutes": {"source": ["session", "target", "address", "prefix", "strip", "data", "content", "src", "uri", "service", "ie", "string", "site", "resource", "sample", "parse", "empty", "token", "rule", "sin", "SOURCE", "slice", "path", "zip", "sl", "project", "input", "text", "dest", "secure", "parent", "base", "query", "url", "file", "in", "se", "missing", "single", "scope", "sort", "shared", "connection", "spec", "table", "style", "unit", "seed", "image", "comment", "inner", "name", "original", "result", "size", "start", "flat", "index", "stream", "view", "Source", "null", "ource", "copy", "use", "config", "proxy", "info", "id"], "destination": ["destension", "endinations", "destion", "projectension", "Destinator", "distination", "coordization", "destinating", "datination", "transinator", "datinating", " destinations", "Destion", "destinations", "distinations", "Destination", "destinated", "homeinations", " destification", "coordination", "endinator", "homeination", "Destinated", "homeinated", "coordension", "homeinator", "endination", "destization", "projectination", "transination", "projectinations", "coordinations", " destinating", "destification", "datinator", "transion", "destinator", "distization", "transification", "Destinating", "datinated", " destion", " destinator", "endinated", "Destification", " destinated", "distension", "projectization"], "is": ["oss", "ir", "nis", "lis", "ris", "serv", "ori", "ui", "ie", "iss", "iris", "isl", "abs", "src", "i", "es", "ci", "ais", "ic", "has", "sin", "ois", "ib", "cos", "us", "init", "bs", "isa", "ics", "in", "ai", "vs", "iso", "ens", "ils", "ins", "act", "ar", "io", "s", "ip", "ii", "bis", "IS", "mis", "ws", "ios", "ops", "as", "was", "or", "close", "Is", "ps", "are", "isc", "isi", "si", "api", "osi", "ob", "out", "info", "be", "eni", "fs", "sis"], "os": ["oss", "obs", "ends", "OS", "ori", "bos", "socket", "aos", "i", "es", "ais", "ose", "ol", "cos", "ot", "nos", "ds", "los", "us", "ies", "mos", "ow", "bs", "ou", "des", "vs", "ens", "dos", "ls", "io", "s", "Os", "ios", "ops", "o", "oses", "pos", "as", "or", "ss", "ros", "acs", "js", "oa", "osi", "so", "ob", "sys", "out", "oS", "oes", "fs", "ks"], "buffer": ["queue", "border", "address", "delay", "uffer", "data", "row", "flush", "reference", "bb", "string", "wave", "feed", "layer", "slice", "read", "limit", "character", "iter", "buff", "buf", "writer", "binary", "base", "block", "url", "page", "shape", "transfer", "reader", "image", "header", "seed", "Buffer", "batch", "bytes", "result", "memory", "cache", "position", "padding", "default", "null", "sequence"], "length": ["number", "join", "address", "child", "data", "row", "left", "point", "last", "strip", "string", "section", "weight", "end", "division", "Length", "feed", "slice", "distance", "line", "id", "limit", "character", "duration", "total", "len", "power", "value", "lock", "block", "volume", "load", "url", "ring", "full", "part", "type", "of", "level", "style", "offset", "partial", "range", "code", "width", "quote", "l", "size", "lower", "start", "position", "key", "split", "count", "ob", "index", "object", "match", "depth"]}}
{"id1": "2217889", "id2": "23666867", "code1": "    public static InputStream getResourceAsStreamIfAny(String resPath) {\n        URL url = findResource(resPath);\n        try {\n            return url == null ? null : url.openStream();\n        } catch (IOException e) {\n            ZMLog.warn(e, \" URL open Connection got an exception!\");\n            return null;\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 0, "substitutes": {"resPath": ["resUrl", "respath", "resourceRoot", "resRoot", " respath", "resourceUrl", " resUrl", "ResUrl", "ResPath", "ResDir", "resDir", "ResRoot", " resDir", " resRoot", "Respath", "resourcePath", "resourcepath", "resourceDir"], "url": ["loader", "address", "f", "data", "ref", "rel", "uri", "bb", "service", "ssl", "string", "source", "src", "xml", "resource", "path", "feed", "host", "server", "http", "entry", "sl", "URL", "blog", "base", "event", "file", "page", "impl", "location", "err", "connection", "image", "element", "open", "job", "lr", "instance", "browser", "l", "ll", "stream", "Url", "log", "loc", "api", "rl", "ob", "config", "object"]}}
{"id1": "22135199", "id2": "823074", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"baos": ["baops", "paOS", "baoS", " baOS", " baops", "caos", "waos", "yaoS", "kaols", "paos", "aaaao", " baoS", "yaol", " baol", "baOs", "pao", "caOs", "kao", "baols", "kaos", "paols", " bao", "waOS", "waOs", "bao", "aaaaOs", "aaaaOS", "paol", "aaaaos", "paoS", " baols", "caOS", "yaops", "wao", "paops", "baol", "yaos", "baOS", "kaOS", "cao"], "channel": ["system", "queue", "video", "data", "socket", "service", "source", "flow", "container", "feed", "handler", "server", "console", "context", "window", "parent", "can", "conn", "url", "sc", "reader", "annels", "connection", "io", "cam", "chan", "self", "Channel", "client", "c", "camera", "cho", "en", "stream", "log", "pool", "ch", "config", "out", "sea", "bean"], "params": ["ctx", " parameters", "Parameters", "stats", "http", "param", "conf", " param", "par", "mm", "processor", "conn", "ams", "css", "tx", "cms", "ops", "settings", "proc", "size", "Param", "parser", "api", "config", "Par", "null", "options", "cpu"], "outbuf": ["outputrb", "Outbuffer", "outbuffer", " outcb", "outqueue", "outputbuff", "Outbuf", " outbuff", "Outcb", "iobuf", " outrb", "outputcb", "outputbuf", "outputqueue", " outbuffer", "outputbuffer", " outqueue", "outbuff", "Outbuff", "ioqueue", "iobuffer", "outcb", "outrb", "iorb"], "metrics": ["Metrates", "metrix", "matrics", "milstats", "matrates", "metstats", "matric", "matrix", "Metstats", "Metrics", "milric", " metstats", "metric", "milrics", "milrix", "Metric", "Metrix", " metrates", " metrix", "metrates", " metric"], "encoder": ["ecoded", "ecoder", "ecressor", "encressor", " encressor", "encler", "ecode", "eccode", "ecler", "Encipher", "encipher", "encode", "encoded", " encoded", "ecoser", "Encoding", "enoder", "enccode", "ecoding", "enressor", " encler", "Encoded", "enoser", " encode", " encoding", " encipher", "enoded", "Encler", " enccode", "encoser", "Encoder", "enode", "encoding", "ecipher", " encoser", "Encoser", "Encode"], "tmpFile": [" tmpfile", "zipFilename", "txtBase", "tmpFiles", "tempFile", "TempPage", "mpBase", "tmpFolder", "poFolder", " temporaryFiles", " tmpFiles", " tmpFilename", "tmpfile", " tmpFolder", " temporaryfile", " temporaryFile", " tmpTable", "txtfile", "tmpPath", "tempFiles", "txtFile", "mpFiles", "zipfile", "mpPage", "mpFile", "tmpTable", "tmpFilename", "mpPath", "poFile", "zipFolder", "pofile", "tempPath", "TempFile", "tmpBase", " temporaryTable", "zipFile", "txtPage", "poFilename", "tempfile", "tmpPage", "TempBase", "Tempfile", " tmpPath", "tempTable", "mpfile"], "fout": ["Fin", "sfout", "sfin", "filein", "Fout", "fdagain", "sfbase", "flsync", "fdsync", "fileout", "fileagain", "fbase", "Fbase", "wflush", "wsync", "fagain", "sfagain", "flout", "wagain", "fin", "Fagain", "fflush", "flflush", "fsync", "wout", "fdflush", "flagain", "filebase", "fdout"], "wrtout": ["wadrout", " wrcout", " wrcin", "Wrtio", "wadrin", " wrtagain", " wrcagain", "wrbwriter", "WRTouter", "wRTagain", "wrtwriter", "wntagain", "wRTouter", "wrcouter", "Wrtin", "wrtouter", "wrtOut", "wntouter", "WRTwriter", "wrxout", "wntin", "wrxin", "wrio", "wrtio", "WRTOut", " wrtouter", "wrout", "wrcin", "wrin", "WRTout", "wRTOut", "wadrOut", "WrtOut", "Wrtouter", "wrtagain", "wRTwriter", "wrbin", "Wrtwriter", "wrOut", " wrtin", " wrcouter", "wrcagain", "Wrtout", "wrcout", "wntout", "wrxouter", "wrbout", "wrbouter", "wRTout", "WRTin", "WRTio", "wrxwriter", "wadrio", "wrtin", "wRTin", "wRTio"], "fchannel": ["fqueue", "hqueue", "pqueue", "hchannel", "fchan", "lchannel", "cstream", "lstream", "cqueue", "pstream", "lcontainer", "pchannel", "cchan", "lqueue", "dchannel", "fstream", "hcontainer", "pchan", "hstream", "fcontainer", "cchannel", "dqueue", "dstream", "dchan", "dcontainer"], "s": ["states", "S", "f", "d", "g", "ses", "string", "abs", "i", "es", "sb", "t", "ings", "groups", "p", "os", "v", "ns", "gs", "u", "ls", "ins", "m", "ms", "qs", "services", "o", "b", "c", "su", "settings", "ss", "ps", "l", "ts", "n", "js", "strings", "r"]}}
{"id1": "16511008", "id2": "20886320", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"configID": ["configIDE", "ConfigId", "ConfigID", "contractIP", "configUID", "configIP", "configRI", "ConfigUID", "configId", "projectId", "ConfigIP", "projectIP", " configRI", "projectIDE", "projectID", "contractID", " configUID", "contractIDE", "projectRI", "contractUID", "projectUID", " configId", "ConfigRI", "ConfigIDE"], "programMessageSymbolID": ["programMessageSyncmbID", "programMessageSymbid", "programMessageSyborI", "programMessageSymbIT", "programMessageSyncmbolID", "programMessageSymbolIDE", "programMessageSyplementationId", "programMessageEntaxid", "programMessageSyMBID", "programMessageSyncmbolIL", "programMessageSyplementationIDE", "programMessageSyMBIDE", "programMessageSymbolid", "programMessageSyntaxI", "programMessageSyncmbIT", "programMessageSyletterId", "programMessageSyletterIP", "programMessageEntaxID", "programMessageSyntaxid", "programMessageSymbI", "programMessageSyMBId", "programMessageSyletterID", "programMessageSyletterIT", "programMessageEmbolI", "programMessageSyntaxId", "programMessageSyborID", "programMessageSymbIL", "programMessageSyncmbIP", "programMessageSymbIV", "programMessageSymbID", "programMessageSyncmbIL", "programMessageSyncmbId", "programMessageSymbolIP", "programMessageSyntaxID", "programMessageSyectorId", "programMessageSyntaxIV", "programMessageSyborId", "programMessageSyncmbolIT", "programMessageSyncmbIDE", "programMessageSymbIP", "programMessageSymbolIL", "programMessageEmbolid", "programMessageSyncmbolIDE", "programMessageEntaxI", "programMessageSymbolI", "programMessageSyectorID", "programMessageEmbolId", "programMessageSymbolIT", "programMessageSyMBIL", "programMessageSymbolIV", "programMessageEmbolID", "programMessageSymbId", "programMessageSyncmbolId", "programMessageSyncmbolIP", "programMessageSyplementationIL", "programMessageSyborid", "programMessageSymbolId", "programMessageSyplementationID", "programMessageEntaxId", "programMessageSyncmbIV", "programMessageSyectorIV", "programMessageSymbIDE", "programMessageSyncmbolIV"], "profilingMessageSymbol": ["profilingMessageSynPart", "profilingApplicationSymbol", "profilingMessageYletter", "profilingApplicationSyletter", "profilingFileSymSy", "profilingMessageSymb", "profilingMessageSymmbol", "profilingMessageCyletter", "profilingMessageCymbol", "profilingMessagePolymbol", "profilingFileSymbol", "profilingUserYletter", "profilingFileSySy", "profilingApplicationSymmb", "profilingMessageSySy", "profilingMessageSymPart", "profilingUserYmbol", "profilingMessageSymletter", "profilingFileSymPart", "profilingMessageSynmbol", "profilingMessagePolyPart", "profilingUserSymb", "profilingUserYmb", "profilingApplicationSymmbol", "profilingUserSyletter", "profilingUserSymbol", "profilingMessageYmb", "profilingMessagePolySy", "profilingMessageYmbol", "profilingMessageSynSy", "profilingMessageSyPart", "profilingFileSyPart", "profilingMessageSyletter", "profilingApplicationSymb", "profilingMessageCymb", "profilingApplicationSymletter", "profilingMessageSymmb", "profilingFileSymmbol", "profilingMessageSymSy"], "connection": ["application", "session", "Connection", "ctx", "version", "condition", "port", "user", "socket", "section", "connect", "document", "container", "con", " Connection", "ongo", "db", "bc", "response", "password", "server", "context", "communication", "function", "database", "volume", "error", "conn", "directory", "environment", "manager", "state", "engine", "table", "management", "unit", "image", "sql", "connected", "collection", "client", "channel", "relation", "c", "machine", "result", "ion", "cache", "log", "pool", "position", "driver", "config", "index", "use"], "statement": ["joined", "session", "Connection", "expression", "next", "Statement", "Session", "condition", "parse", "string", "section", "connect", "study", "document", "Query", "rule", "db", "str", "response", "di", "command", "commit", "writer", "function", "lock", "database", "jo", "error", "conn", "volume", "se", "part", "library", "timeout", "mt", "directory", "state", "stat", "comment", "usage", "unit", "management", "sql", "table", "storage", "collection", "execute", "relation", "result", "instance", "journal", "ment", "ss", "pass", "si", "parser", "general", "report", "use", "out", "message"], "resultSet": ["ResultTime", "errorSource", "responseGroup", " resultChan", "resultLine", " resultList", "resultSource", "responseTime", "featureChan", "resultList", "ResultGen", "resultTime", "resultHit", "ResultList", "resourceSet", "featureSet", " resultS", "responseSource", "resourceS", "responseList", "resultGroup", "rowGroup", "rowSet", "errorHit", "responseGen", "ResultSet", "ResultHit", "resourceSource", " resultTime", " resultSource", "resultChan", "ResultLine", "featureList", " resultGen", "responseSet", "ResultS", " resultLine", "resultGen", "featureLine", "ResultChan", " resultHit", "rowList", "ResultSource", "resultS", "errorSet", "ResultGroup"], "query": ["join", "expression", "script", "condition", "uri", "request", "string", "parse", "resource", "qu", "Query", "go", "send", "rule", "reason", "str", "id", "command", "search", "question", "value", "q", "qq", "lock", "database", "scan", "error", "root", "function", " Query", "select", "timeout", "type", "call", "comment", "table", "sql", "module", "name", "update", "code", "o", "result", "sq", "ql", "description", "work", "cache", "general", "report", "eries", "record", "index", "info", "message"], "msg": ["gm", "fg", "cm", "nm", "tool", "gr", "dr", "cfg", "format", "rr", "g", "phrase", "gor", "mr", "reason", "str", "id", "model", "ug", "mu", "e", "game", "og", "text", "desc", "tag", "pkg", "html", "agg", "mn", "sg", "req", "op", "error", "ma", "gs", "var", "mt", "type", "m", "Msg", "err", "gen", "ge", "rg", "char", "ag", "exc", "module", "title", "mg", "name", "info", "cmd", "md", "printf", "set", "doc", "bg", "log", "def", "cap", "bag", "status", "map", "sim", "message"]}}
{"id1": "88047", "id2": "19096138", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"inFile": ["InPlace", "inPlace", "infile", "outFilename", " infile", "outPath", "outFiles", "oldfile", " inPath", "oldFiles", "outPlace", "oldFilename", "inputfile", "incFile", "oldFile", "inputFiles", "InPath", "incPlace", "outfile", "Infile", "incfile", "incFiles", "inFiles", "inFilename", "InFile", "inputFile", "inputFilename", " inFiles", "inPath", "InFiles"], "outFile": ["zipFilename", "Outfile", "outFilename", "outputFile", " outTable", "outputFolder", " outFolder", "OutFile", "outPlace", " outPlace", "OutDir", "OutPlace", "outputTable", " outString", "newFile", "inputFolder", "inputTable", "newDir", " outDir", "inputPlace", "outFolder", "zipString", "outfile", "outputString", "zipFILE", "outputFilename", "outDir", "zipFile", " outFilename", "inputFile", " outfile", "outputFILE", "outputPlace", "outFILE", "newPlace", "outString", " outFILE", "newfile", "outTable"], "iis": ["ioIs", "iniIs", "iIs", "iniais", "iisc", "iniisc", " iIS", "ciid", "iniiss", "iiIS", "Iiss", "iils", " iid", "iais", "iid", "ioisc", "iIS", "iniils", "Iis", "iniIS", "iniis", "ioiss", "ciis", " iais", "IIs", "ciiss", " iIs", "iiss", "ciais", "iniid", "iiIs", " iiss", "Iisc", "iois", "iiils", "iiis", " iils"], "dcmParser": ["dmcPar", " dcmLoader", "dcpReader", "DcmJar", "pdymReader", "pdymJar", "dmmarser", "dcrJar", "dcmStreamer", "DcmParser", "ddcParser", "dtermStreamer", " dpmPar", "dymReader", "dcrWriter", "dcpParser", "dmmReader", "dcmPar", "dcyJar", " dpmBuilder", "ddcLoader", "dcmarser", " dcmPlugin", "dpmparser", " dcmBuilder", "ddcPlugin", " dpmarser", "dmoduleParser", "dsemStreamer", "dpmStreamer", "dymParser", "dtermPlugin", "pdymParser", " dcmarser", "dtermParser", "ddcReader", "Dcmarser", "dymJar", " dcmPar", "dcrparser", "dsemParser", "Dcmparser", "dcmWriter", "dmmParser", " dpmJar", "dcmBuilder", " dpmStreamer", "dsemReader", " dpmPlugin", " dcmStreamer", "dcmparser", "dcmLoader", "dcmPlugin", "dmoduleReader", "dmcJar", "dcpJar", " dpmReader", "dpmLoader", "dcyParser", "dcyarser", "dcyReader", "dcrReader", "dpmJar", "pdcmReader", "dcrParser", "dpmBuilder", "dpmPar", "dymparser", "pdymparser", " dpmLoader", "DcmReader", " dpmParser", "pdcmParser", "dcpparser", " dcmReader", "dtermReader", "dmcParser", "dcmReader", "dcmJar", "dpmarser", "pdcmparser", "dcrarser", " dcmJar", "DcmWriter", "dmmWriter", "dpmParser", "dpmReader", "dcrPar", "dmodulePlugin", "pdcmJar", "dmoduleBuilder", "dsemPlugin", "dmcarser", "dpmPlugin"], "ds": ["session", "cs", "pd", "d", "docs", "uds", "data", "dt", "dr", "sync", "src", "iss", "gd", "Ts", "tes", "asi", "da", "dc", "ays", "db", "ipes", "DS", "parts", "di", "ads", "points", "is", "dds", "bs", "amps", "nas", "utils", "ys", "os", "des", "dd", "vs", "ns", "ils", "fd", "gs", "ins", "ls", "conn", "cdn", "Ds", "s", "Os", "tx", "services", "ws", "xs", "client", "details", "rs", "ss", "ps", "ros", "Db", "df", "js", "ts", "drivers", "plugins", "ld", "sys", "eps", "dat", "ks"], "pdReader": ["pidReader", "dsReader", "pidScan", "pidLoader", "xdreader", "hdRead", "pdParser", "dsLoader", "hdWriter", "pbLoader", "pdRead", "pcRead", "wdLoader", "xdReader", "pidParser", "xdRead", "pdLoader", "pcLoader", "pbParser", "pdreader", "pbReader", "wdWriter", "dsRead", "dsWriter", "hdreader", "wdRead", "pcScan", "wdReader", "hdReader", "pbScan", "pcParser", "pdScan", "dsreader", "pcWriter", "pcReader", "xdWriter"], "out": ["d", "flush", "ssl", "class", "store", "url", "full", "w", "code", "outs", "as", "external", "at", "inc", "pool", "auto", "sys", "model", "oder", "ext", "sync", "data", "with", "lib", "group", "base", "conn", "file", "in", "down", "img", "exp", "connection", "net", "io", "device", "write", "exec", "pass", "log", "key", "word", "again", "dot", "OUT", "builder", "output", "line", "db", "list", "writer", "Out", "array", "temp", "manager", "to", "s", "later", "up", "client", "order", "doc", "outer", "sum", "cache", "ex", "copy", "default", "object", "session", "child", "point", "user", "flow", "password", "cli", "parent", "lock", "page", "co", "gen", "err", "now", "call", "inner", "image", "name", "obj", "o", "result", "term", "over", "login", "null"], "dcmEncParam": ["dcmElParameter", "dcmAccSm", "dcmEngVar", "dpmDecParam", "dcmDecSm", "dcmElType", "dcmDecPar", "dcmEncSm", "dcmencParameter", "dcmEncVar", "dcmEncType", "dcmEncPar", "dcmEncParameter", "dcmencSm", "dcmAccParam", "dpmEncSm", "dcmEnVar", "dcmEngParam", "dcmElParam", "dcmEngType", "dcmEngParameter", "dcmElVar", "dcmEnType", "dpmDecParameter", "dcmEnParam", "dpmEncParam", "dpmDecSm", "dcmEnParameter", "dcmDecParameter", "dcmDecParam", "dcmencParam", "dcmAccParameter", "dcmEnPar", "dpmEncParameter"], "pdWriter": ["ddWrite", "dsWrite", "ddWriter", "tdOutput", "hdOutput", "hdWR", "hdWriter", "tdContent", "pdWR", "PDContent", "tdReader", "dsWR", "dsOutput", "ddOutput", "pxOutput", "ddWR", "PDOutput", "hdWrite", "pdContent", "PDReader", "dsWriter", "tdWriter", "pdOutput", "pxContent", "PDWriter", "pdWrite", "pxReader", "pxWriter"]}}
{"id1": "8000624", "id2": "4599372", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"dest": ["delete", "target", "rest", " Dest", "filename", "data", "content", "src", "them", "orig", "source", "wb", "Dest", "path", "output", "exit", "tmp", "comb", " destination", "class", "dist", "folder", "desc", "cont", "txt", "sup", "file", "die", "destroy", "temp", "w", "img", "bin", "opt", "table", "done", "name", "later", "obj", "write", "flat", "test", "transform", "object"], "in": ["issue", "gin", "f", "vin", "re", "x", "isin", "inn", "source", "i", "thin", "wave", "ln", "con", "sin", "plus", "ax", "input", "lib", "init", "fa", "kin", "din", "conn", "lin", "reader", "rin", "ins", "bin", "m", "connection", "inner", "s", "image", "up", "b", "as", "inside", "l", "win", "In", "pass", "n", "cin", "inc", "IN", "ac", "nin", "ini", "r", "login", "h", "again", "pin", "pull", "id"], "out": ["ext", "target", "sync", "OUT", "x", "data", "socket", "user", "other", "no", "i", "app", "output", "off", "plus", "lib", "writer", "this", "vert", "Out", "ou", "conn", "file", "url", "part", "w", "temp", "timeout", "bin", "object", "one", "err", "call", "net", "io", "inner", "image", "name", "up", "client", "o", "b", "outside", "outs", "exec", "not", "or", "outer", "external", "n", "cache", "inc", "nin", "our", "ex", "copy", "again", "pin"], "c": ["ca", "cm", "cl", "f", "cu", "x", "d", "content", "cf", "lc", "i", "ci", "ic", "C", "dc", "cr", "bc", "pc", "t", "ce", "fc", "p", "cy", "v", "esc", "sc", "u", "ct", "cb", "m", "arc", "comment", "char", "exc", "buffer", "code", "ec", "abc", "o", "cc", "rc", "l", "n", "ac", "oc", "ch", "xc", "r", "uc", "enc", "config", "pointer", "col", "e"]}}
{"id1": "5620792", "id2": "17729554", "code1": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 0, "substitutes": {"text": ["ext", "address", "TEXT", "length", "template", "prefix", "data", "content", "format", "string", "hex", "source", "path", "token", "str", "id", "password", "font", "input", "class", "binary", "context", "value", "txt", "url", "transfer", "in", "secret", "connection", "letter", "buffer", "image", "contract", "name", "code", "struct", "bytes", "pattern", "Text", "key", "config", "word", "out", "object", "message"], "HASH_VALUE_SIZE": ["HASH_VALUE_LOAD", "HASH_VALUE_size", "HASH_VALUE2SIZE", "HASH_SIZE_LOAD", "HASH_VALUEFsize", "HASH_SIZE_SIZE", "HASH_Value_VALUE", "HASH_Value_size", "HASH_VALUEFVALUE", "HASH_VALUE2LOAD", "HASH_Value_SIZE", "HASH_VALUEFLOAD", "HASH_Value_Size", "HASH_VALUE2size", "HASH_SIZE_size", "HASH_VALUEFSIZE", "HASH_VALUE2VALUE", "HASH_SIZE_VALUE", "HASH_VALUE_Size", "HASH_VALUE_VALUE"], "md": ["um", "nm", "f", "pd", "d", "data", "sm", "wd", "hm", "pm", "amd", "em", "mad", "ind", "valid", "sha", "editor", "mu", "meta", "ng", "pkg", "mm", "am", "bf", "MD", "dd", "od", "ma", "mand", "method", "mt", "m", "ms", "gen", " MD", "rm", "dig", "bd", "hash", "mb", "mg", "code", "dm", "cmd", "mod", "sum", "me", "mac", "mag", "mp", "body", "mc", "metadata", "ld", "mo", "message"], "sha1hash": ["sha256hex", "sha0hex", "sha2dot", "ha2sum", "ha1sum", "SHA1h", "sha1sum", "SHA2hex", "SHA1dot", "ha2Hash", "SHA2hash", "sha1Hash", "sha2dig", "sha64Hash", "ha2str", "ha1hash", "sha256hash", "ha1Hash", "sha9str", "sha2h", "sha0dot", "sha2hash", "ha1dig", "ha1str", "sha0hash", "SHA1hash", "SHA1hex", "sha9Hash", "ha2dig", "sha1dig", "sha2hex", "sha0h", "sha2str", "sha64sum", "sha64dig", "sha256dot", "sha1h", "sha2sum", "sha64str", "sha1str", "SHA2h", "sha256h", "sha1dot", "sha9hash", "sha9dig", "ha2hash", "SHA2dot", "sha1hex", "sha2Hash", "sha64hash"]}}
{"id1": "12349563", "id2": "12678045", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"location": ["target", "operation", "address", "Location", "filename", "length", "data", "content", "reference", "point", "uri", "string", "source", "home", "resource", "remote", "path", "provided", "layer", "response", "host", "server", "layout", "folder", "base", "file", "shape", "pointer", "directory", "type", "connection", "href", "image", "language", "collection", "name", "LOC", "route", "region", "description", "position", "loc", "local", "node", "area", "localhost", "object", "info", "message"], "url": ["address", "f", "user", "uri", "ssl", "string", "source", "i", "resource", "web", "path", "host", "server", "http", "sl", "zip", "lib", "URL", "blog", "base", "file", "page", "impl", "www", "connection", "io", "image", "open", "obj", "c", "b", "build", "l", "ll", "Url", "loc", "api", "r", "config", "fl"], "cxn": ["cexn", "crexp", "cxp", "cexne", "cuxp", "cxns", "cdsn", " crexg", " crexcon", " crexp", "cxxp", "cxxn", "cdsp", "crexg", "crexn", " crexn", "Cxns", " cxcon", "Cxn", "Cuxne", "Cuxn", "cxne", "cexp", "cuxne", "cuxn", "cuxns", "cexcon", "cdscon", " cxg", "cxcon", "cexns", "Cuxns", "cxxne", "crexcon", "cdsg", "cxxns", " cxp", "Cxne", "cexg", "cxg", "Cxp", "Cuxp"], "is": ["oss", "ir", "nis", "lis", "next", "ris", "x", "it", "ori", "ui", "iss", "src", "uri", "isl", "abs", "iris", "i", "es", "ais", "app", "web", "does", "has", "ois", "im", "http", "cos", "us", "its", "init", "internet", "isa", "bs", "os", "in", "iso", "ens", "ai", "ms", "ar", "get", "s", "ip", "bis", "cms", "IS", "ios", "as", "was", "or", "close", "Is", "isc", "stream", "js", "isi", "api", "ob", "out", "info", "fs", "id"], "byteBuffer": ["bitBuff", "byteBB", "ByteBuff", "bitLength", " byteArray", " byteBB", "ByteLength", "ByteBB", "bitArray", " byteLength", "byteBuff", "ByteBuffer", " byteBuff", "ByteArray", "byteArray", "bitBuffer", "byteLength", "bitBB"]}}
{"id1": "6963063", "id2": "22879400", "code1": "    public static void main(String args[]) {\n        int[] mas = { 3, 5, 6, 9, 1, -3, -4, -88 };\n        int sort = 0;\n        for (int j = 0; j < (mas.length); j++) {\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    sort = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = sort;\n                }\n            }\n        }\n        for (int i = 0; i < mas.length; i++) {\n            System.out.print(\" \" + mas[i]);\n        }\n    }\n", "code2": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "label": 0, "substitutes": {"mas": ["ga", "pa", "phi", "MA", "bas", "asm", "cs", "a", "data", "asia", "ama", "features", "asa", "las", "alpha", "ages", "months", "Las", "mad", "sha", "ima", "parts", "afi", "mos", "inas", "ra", "sa", "fa", "meta", "cas", "mm", "amps", "nas", "mes", "os", " ma", "params", "amas", "ma", "phas", "mat", "ras", "faces", "ams", "lambda", "ins", "ls", "ms", "missing", "astics", "spec", "ta", "marks", "ias", "ums", "mis", "forms", "xs", "mast", "space", "pos", "as", "lam", "cats", "central", "mag", "images", "mc", "ia", "names", "la", "rules"], "sort": ["filter", "g", "parse", "alpha", "alias", "diff", "Sort", "slice", "ind", "sign", "replace", "label", "lib", "list", "init", "seq", "search", "par", "hide", "parent", "vert", "scale", "min", "num", "part", "type", "ist", "place", "err", "style", "edit", "alt", "offset", "ii", "s", "default", "update", "orient", "pre", "order", "pos", "o", "l", "index", "lower", "axis", "start", "cmp", "size", "position", "loc", "split", "ji", "adjust", "use", "ort", "master", "ul", "id"], "j": ["f", "d", "x", "it", "ui", "a", "ie", "bi", "ij", "ci", "ind", "is", "z", "pi", "J", "jc", "p", "q", "v", "num", "u", "m", "k", "ii", "y", "o", "b", "I", "l", "jp", "n", "js", "si", "li", "ji", "oi", "h", "xi"], "i": ["hi", "phi", "f", "x", "ori", "it", "ui", "a", "data", "ti", "ie", "uri", "ni", "bi", "ij", "ci", "qi", "gi", "lc", "slice", "mu", "di", "h", "cli", "z", "init", "abi", "pi", "ik", "v", "in", "ai", "ix", "temp", "u", "m", "k", "iu", "yi", "io", "inner", "ip", "ii", "info", "o", "b", "ri", "I", "c", "fi", "multi", "jp", "si", "uli", "li", "ini", "oi", "ji", "mi", "api", "index", "xi", "e", "id"]}}
{"id1": "6501291", "id2": "13783549", "code1": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"input": ["target", "inf", "address", "data", "content", "format", "string", "source", "i", "xml", "zip", "binary", "init", "text", "parent", "load", "raw", "file", "url", "Input", "down", "img", "bin", "single", "connection", "inner", "io", "image", "buffer", "element", "media", "name", "archive", "stream", "frame", "view", "audio", "config", "pull"], "output": ["application", "target", "operation", "address", "next", "version", "format", "four", "reference", "string", "source", "web", "remote", "xml", "document", "response", "Output", "generation", "file", "office", "page", "url", "temp", "directory", "secret", "connection", "style", "letter", "unit", "generated", "job", "written", "write", "settings", "result", "outer", "external", "current", "example", "complete", "config", "model"], "reader": ["loader", "author", "f", "rb", "rr", "parse", "source", "i", "ler", "per", "feed", "plus", "server", "read", "editor", "iter", "zip", "writer", "reading", "file", "rer", "se", "er", "worker", "err", "der", "io", "inner", "rake", "buffer", "rar", "b", "ri", "her", "as", "l", "stream", "rc", "ink", "cur", "parser", "IN", "rx", "inc", "ini", "r", "ner", "h", "Reader", "oder"], "in": ["loader", "gin", "f", "re", "data", "socket", "user", "inn", "source", "i", "read", "is", "writer", "init", "din", "file", "url", "ins", "bin", "er", "err", "inner", "io", "s", "image", "as", "or", "l", "win", "doc", "In", "stream", "n", "inc", "ac", "IN", "ini", "r", "h", "id"], "out": ["ext", "OUT", "data", "user", "socket", "source", "off", "line", "server", "editor", "writer", "parent", "Out", "raw", "conn", "file", "temp", "w", "bin", "exp", "gen", "err", "connection", "net", "io", "inner", "image", "buffer", "self", "up", "client", "obj", "o", "exec", "outs", "write", "instance", "outer", "over", "cache", "inc", "log", "post", "pool", "ex", "copy", "again"], "buf": ["queue", "plug", "ctx", "length", "bl", "bh", "rb", "data", "bb", "lc", "pad", "bc", "off", "tmp", "buff", "fb", "bu", "cv", "seq", "cas", "ff", "bf", "raw", "v", "vec", "fd", "bp", "lim", "bin", "cb", "box", "bd", "ab", "buffer", "br", "batch", "bytes", "b", "c", "rc", "uf", "cur", "loc", "cap", "val", "uc", "bag", "la"], "len": ["f", "length", "data", "no", "i", "lc", "end", "ln", "lt", "line", "ind", "iter", "sl", "el", "z", "lf", "base", "nt", "min", "url", "lin", "part", "rev", "lim", "bin", "err", "pos", "c", "pre", "le", "all", "en", "l", "size", "Len", "fin", "n", "li", "val", "count", "r", "cap", "fl", "dl", "id"]}}
{"id1": "21488868", "id2": "8182932", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"infile": ["inputfp", "Infiles", "inputfilename", "infilename", " infilename", " infiles", "outfp", "inputfile", "inputfiles", "inFile", "infp", "Infile", "Infilename", "infiles", " infp", "InFile", "inputFile", "outFile", "outfilename", "outfiles"], "outfile": ["Outfile", "outputfilename", " outfolder", "infilename", " outfp", "outputfile", "OutFile", "outfp", "infolder", "newFile", " outFile", "infp", " outfilename", "outfolder", "newfolder", " outname", "outputfp", "Outname", "Outfolder", "outputfolder", "outFile", "outname", "outfilename", "newfile", "newname"], "in": ["gin", "vin", "a", "re", "data", "isin", "socket", "inn", "source", "i", "thin", "ic", "con", "sin", "is", "input", "init", "inas", "base", "min", "din", "conn", "reader", "rin", "ins", "bin", "m", "into", "err", "inner", "s", "image", "b", "inside", "as", "win", "In", "pass", "cin", "inc", "ac", "IN", "nin", "ini", "r", "login", "again", "pin", "id"], "out": ["session", "sync", "OUT", "socket", "point", "home", "no", "source", "output", "exit", "on", "off", "line", "lib", "writer", "parent", "Out", "base", "ou", "error", "file", "conn", "co", "timeout", "bin", "one", "err", "net", "io", "to", "inner", "image", "name", "up", "client", "job", "o", "obj", "outs", "exec", "write", "or", "outer", "In", "work", "cache", "inc", "post", "ex", "copy", "again"], "buffer": ["queue", "border", "address", "length", "uffer", "data", "flush", "reference", "bb", "source", "wave", "feed", "slice", "layer", "server", "limit", "iter", "buff", "buf", "fb", "input", "binary", "len", "value", "base", "raw", "transfer", "url", "reader", "type", "offset", "seed", "Buffer", "batch", "bytes", "b", "write", "result", "size", "cache", "split", "count", "padding", "null"], "read": ["lex", " write", "f", "length", "x", "sync", "allow", "next", " copy", "find", "ad", "check", "parse", "i", "Read", "connect", "send", "end", "feed", "tell", "slice", "ind", "limit", "iter", "input", "wait", "len", " Read", "reading", "load", "add", "raw", "sleep", "reader", "select", "play", "se", "fill", "seek", "io", "get", "ride", "READ", "ip", "_", " count", "write", "exec", "close", "size", "reads", "start", "work", "n", "pass", "run", "inc", "current", "count", "copy", "use", " skip", "id"], "success": ["primary", "growth", "construct", "better", "data", "content", "follow", "fast", "flash", " succ", "successful", "status", "cess", "path", "rolling", "response", "valid", "model", "rolled", "initial", "fail", " successful", "value", "modified", "failed", "ccess", "roll", "func", "respons", "winner", "error", "first", "true", "method", "danger", "comment", " succeed", "results", "warning", "open", "done", "right", " Success", "ceed", "result", "successfully", "good", "Success", "pass", "xx", "complete", "continue", "default", "again", "null", "message"]}}
{"id1": "7872659", "id2": "1473212", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    @Test\n    public void test_validate_geo_getEvents() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=geo.getevents&location=madrid&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"completePath": ["completeRoot", "completeHome", "CompleteDir", "successpath", "successMusic", " CompletePath", "completeCh", "flatCorp", "iteMusic", "correctPoint", "execpath", " CompleteFile", "successPath", "completeCorp", "execVol", " completeMusic", " CompleteDir", " completeDir", "completeVol", "CompleteFile", "successCh", " completePoint", " completepath", "correctRoot", "flatPoint", "correctPath", "CompleteHome", "progressPath", "execPath", "itepath", "execLoader", "completeDir", "completePoint", "flatRoot", "progresspath", " CompleteHome", "itePath", "CompletePath", "doneVol", "completeFile", "completepath", "donePath", "doneLoader", "completeMusic", "iteCh", "correctCorp", "donepath", " completeRoot", "flatPath", "completeLoader", " completeCorp", "progressVol", " completeFile", " completeHome", "progressLoader", " completeCh"], "masterFile": ["MasterFilename", " masterFilename", "configName", "MasterFiles", "masterFiles", "masterName", "cacheFiles", "masterFILE", "cacheFILE", "mastersPath", "configFile", "MasterPath", "configFilename", "cachePath", "cacheFile", "masterPath", "mastersFile", "mastersFiles", "MasterFile", "mastersFILE", " masterPath", "MasterName", "configPath", "masterFilename", " masterName", "MasterFILE"], "CustRatingFileName": ["CustRatingClassVersion", "CustRateFileDesc", "CustRateFileName", "CustRateFilenameDesc", "CustIndexFilesPath", "CustRatingFilesPath", "CustRatingFilenameSize", "CustIndexFilePath", "CustRatingFullSize", "CustRatingFileType", "CustRateFileSize", "CustRateFilenamePath", "CustRatingFilesSize", "CustRatingFilenamePath", "CustIndexFileName", "CustRatingFilesDesc", "CustRatingLineType", "CustRatingLineName", "CustRatingFilesType", "CustIndexFileVersion", "CustIndexFilesType", "CustRatingFileDesc", "CustRatingFilenameDesc", "CustRateFilenameSize", "CustRateFilePath", "CustRatingFilePath", "CustRateFilenameName", "CustRatingFullPath", "CustIndexFilesName", "CustRatingFileVersion", "CustRatingFullDesc", "CustRatingFilesVersion", "CustRatingFilesName", "CustRatingFileSize", "CustIndexFileType", "CustRatingLinePath", "CustRatingClassName", "CustIndexFilesVersion", "CustRatingFilenameName", "CustRatingFullName", "CustRatingLineVersion", "CustRatingClassType", "CustRatingClassPath"], "MovieIndexFileName": ["MovieConfigFolderFile", "MovieIndexClassName", "MovieEditFSize", "MovieConfigFolderVersion", "MovieIndexClassSize", "MovieIndexFileUrl", "MovieEditFileName", "MovieIndexFILEHandle", "MovieIndexFSize", "MovieConfigFileName", "MovieIndexFileHandle", "MovieIndexFilesUrl", "MovieIndexFILEFile", "MovieIndexFolderHandle", "MovieIndexFname", "MovieIndexPlaceHandle", "MovieConfigFolderHandle", "MovieIndexFILEName", "MovieIndexPlaceVersion", "MovieConfigFileFile", "MovieConfigFileHandle", "MovieIndexFName", "MovieConfigFolderName", "MovieIndexFILEVersion", "MovieIndexFileVersion", "MovieEditFileUrl", "MovieIndexFilesSize", "MovieIndexFUrl", "MovieEditFileSize", "MovieIndexFileSize", "MovieIndexPlaceName", "MovieEditFilename", "MovieIndexFilename", "MovieIndexFileFile", "MovieEditFUrl", "MovieIndexFilesname", "MovieIndexPlaceFile", "MovieIndexFolderName", "MovieEditFName", "MovieIndexFolderFile", "MovieIndexFolderVersion", "MovieIndexClassname", "MovieEditFname", "MovieIndexFilesName", "MovieIndexClassUrl", "MovieConfigFileVersion"], "inFile": ["infile", " infile", "incC", "inputSourceFile", "InSourceFile", "inputfile", "incFile", "inputF", " inF", "InF", "outC", "outfile", "incSourceFile", "Infile", "incfile", "inSourceFile", "InFile", "inputFile", "outSourceFile", "inF", "outFile", " inSourceFile"], "inC": ["outF", "inputC", "InCL", "innerCC", "InCC", "inputCC", "inCC", "inB", "InCI", "outCC", " inCC", "inputF", "outB", " inF", "InF", "outC", "innerFile", " inB", "inCL", "inCI", "InB", "InFile", "inputFile", "outCL", "InC", "inF", "outFile", " inCL", "outCI", "innerCI", "innerC"], "outFile1": ["outFiles2", "outPath3", "againC1", "outfileName", "outFiles3", "outputFileId", "outFilesFirst", "outFileName", "outPlaceId", "againFile1", "outfile1", "againC3", "outFId", "outPlaceName", "outPathFirst", "outputfileName", "outputFile2", "outPlace2", "againFileFirst", "outfileId", "outPath2", "outPath1", "againC2", "againCFirst", "outFile3", "outFileFirst", "outFName", "outCFirst", "outputFileName", "outFileId", "outF1", "outC3", "againFile3", "outFiles1", "outputfile1", "outputFile1", "outputfile2", "outF2", "againFile2", "outputfileId", "outfile2", "outPlace1"], "outC1": ["newcOne", "outB8", "newC1", "newCOne", "againB1", "againC8", "outc1", "outD8", "againC1", "newCFirst", "outC81", "outF8", "outcOne", "outc81", "outCOne", "newC81", "outCFOne", "outB1", "newcFirst", "outCF81", "outBOne", "againB2", "outD1", "outDFirst", "outB2", "outcFirst", "againC2", "outD2", "outCFirst", "outCFFirst", "outDOne", "againBOne", "outF1", "newc81", "outFOne", "againB8", "outF2", "againCOne", "outC8", "outCF1", "outD81", "newc1"], "outFile2": ["outFiles2", "outputfile5", "outputFile4", "outChannel1", "outfileTwo", "outFiles6", "outChannel6", "againFile1", "againLine2", "outFile4", "outputfile4", "outFiles4", "outFile6", "outLine1", "outDirectory4", "outDirectory5", "outfile4", "againLineTwo", "outLine6", "outFileTwo", "outLine2", "outputFile2", "outChannel2", "outputFileTwo", "outFilesTwo", "outLineTwo", "againFile6", "outFiles5", "outputFile5", "outFiles1", "outputfileTwo", "outputfile2", "againFile2", "againLine6", "outfile2", "outChannelTwo", "outDirectoryTwo", "againLine1", "outFile5", "outfile5", "againFileTwo", "outDirectory2"], "outC2": ["outCache1", "outB4", "outFTwo", "againB1", "againC1", "outCache4", "OutC1", "outFileII", "OutF2", "OutC2", "OutCII", "outFile4", "outF4", "OutFII", "outB1", "OutF4", "outCache2", "againBTwo", "outFileTwo", "outC4", "againB2", "outCacheII", "outB2", "againCTwo", "outFII", "againB4", "againC2", "outBTwo", "outF1", "OutC4", "OutF1", "againC4", "outF2", "outCII", "outCTwo"], "fileSize": [" fileSIZE", "bufferSize", "FileLength", "resourceSize", "fileAddress", "resourceAddress", "imageLength", "FileAddress", "fileSIZE", "imageSize", " fileMode", "FileSize", "resourceSIZE", "imageSIZE", "fileLength", "bufferMode", " fileLength", "fileMode", "FileMode", "FileSIZE", " fileAddress", "bufferLength"], "totalNoDataRows": ["totalNoDataChues", "totalNoPageRues", "totalNoPageRrows", "totalNoDataCOWS", "totalNoDataLOWS", "totalNoDataRues", "totalNoDataROWS", "totalNoPageROWS", "totalNoPageLows", "totalNoDataCues", "totalNoPageRows", "totalNoDataRrows", "totalNoDataCows", "totalNoDataChOWS", "totalNoDataChows", "totalNoDataLues", "totalNoPageLues", "totalNoPageLrows", "totalNoDataLows", "totalNoDataCrows", "totalNoDataLrows", "totalNoPageLOWS", "totalNoDataChrows"], "mappedBuffer": ["machedURL", "mashedBuffer", "MappedFile", "mashedFile", "mappedbuffer", "MappingBuff", "mippedURL", "MachedURL", "machedBuff", "MachedBuff", "mippedStream", "mppedStream", "mashedChannel", "Machedbuffer", "mapedFile", "machedFile", "mashedBuff", "mapedStream", "mippedBuffer", "mactedBuffer", "mappingChannel", "mactedBuff", "MappedStream", "MappingBuffer", "machedbuffer", "MappedBuffer", "mappedBuff", "mactedStream", "mppedBuffer", "mappedFile", "MachedBuffer", "machedBuffer", "mapedBuffer", "MachedStream", "mppedChannel", "MappedURL", "mippedBuff", "mapedURL", "MappedBuff", "MappingFile", "mppedBuff", "mappingFile", "MappingChannel", "machedStream", "mappingbuffer", "mappedStream", "mappingBuff", "Mappedbuffer", "mapedBuff", "mappingBuffer", "mappingStream", "mactedbuffer", "mappedURL", "mappedChannel", "MappedChannel", "machedChannel", "MachedFile", "MachedChannel"], "startIndex": ["startRow", " startSection", "startingIndex", " startCode", "startPoint", "stopindex", "endInfo", "startSection", "useIndex", "useindex", "stopCode", "initInfo", "startCode", "initOffset", "stopIndex", "endSection", "startingSection", " startPosition", "initindex", "endRow", "startindex", " startOffset", " startindex", "StartInfo", "endIndex", " startInfo", "startPosition", "StartIndex", "usePosition", "endCode", " startPoint", "StartPosition", " startRow", "endPosition", "stopRow", "startOffset", "useInfo", "initIndex", "endPoint", "startInfo", "StartOffset", "startingPoint", "startingPosition", "endindex", "Startindex"], "count": ["number", "length", "allow", "found", "child", "depth", "follow", "find", "counter", "time", "more", "other", "i", "weight", "ind", "limit", "list", "total", "len", "group", "add", "first", "part", "keep", "type", "call", "thread", "self", "force", "Count", "code", "name", "c", "order", "old", "all", "close", "size", "sum", "start", "max", "current", "loop", "cache", "pool", "key", "test", "index", "coll", "col", "id"], "currentMovie": ["thisMovie", "currentlyMovie", "CurrentTheme", "parentFilm", "parentmovie", "reportedImage", "currentlyPicture", "currentFilm", "CurrentFilm", "reportedMusic", "reportedMovie", "defaultImage", "reportedmovie", " currentFilm", "currentlyMusic", "currentTheme", "defaultFilm", "defaultMovie", "CurrentMovie", "Currentmovie", " currentMusic", "parentPicture", "currentMusic", "validTheme", "thisFilm", "parentMovie", "currentmovie", " currentImage", "validFilm", " currentPicture", "reportedPicture", "validmovie", "currentPicture", "thisPicture", "reportedTheme", "currentImage", "defaultMusic", "reportedFilm", "validMovie", "thismovie", " currentmovie"], "movieName": ["camname", "moviename", "MovieFamily", "filmNumber", "MovieNumber", "movieId", "MovieId", "voicename", "movieFamily", "moneyFamily", "camFamily", "filmname", "movieInfo", "voiceId", "moneyName", "moneyNumber", "camName", "MovieName", "MovieInfo", "filmName", "voiceInfo", " movieFamily", " moviename", "filmFamily", "movieNumber", "voiceName", " movieId", "Moviename", " movieInfo"], "customer": ["Customeri", "Customers", "ustomer", "Customer", " customers", " customER", " customeri", "mixER", "customor", "customER", "mixers", "mixer", "customers", "mixor", "ustomers", "Customor", "ustomER", "CustomER", "customeri", "ustomor", "ustomeri"], "rating": ["number", "rr", "data", "rated", "ruby", "alpha", "string", "resource", "RC", "rolling", "http", "including", "writer", "value", "reading", "rates", "rate", "rage", "url", "error", "ring", "score", "reader", "missing", "type", "comment", "ing", "range", "radius", "packing", "rc", "feature", "rank", "Rating", "setting", "r", "rice", "padding", "attribute", "ranking", "info", "writing", "id"], "outBuf1": ["outKbuffOne", "outKuf3", "outDuffn", "outCufOne", "outDuff1", "outBbuffOne", "outDuff11", "outBafOne", "outFaf1", "outFafOne", "outBaf3", "outFufCloud", "outBbuf11", "outBbuf1", "outBaft1", "outBufOne", "outBummerCloud", "outBalth2", "outBbuff8", "outCuf1", "outBbuf3", "outBuf8", "outBalth1", "outDuf1", "outKuf8", "outBufn", "outBummerOne", "outBbuff3", "outBaft11", "outFbuf91", "outKuf1", "outCuff0", "outBumOne", "outFuf91", "outKbuf3", "outBaf1", "outBaftn", "outBum01", "outBbuff0", "outBuf01", "outDuf3", "outBuffOne", "outBaf8", "outKbuff8", "outDuff3", "outBiff1", "outBaft3", "outBuff11", "outKuf2", "outBuf3", "outKbuff1", "outBuff1", "outBafCloud", "outBuff8", "outBiff01", "outBuf11", "outBuff3", "outKbuf1", "outCuff1", "outBbufn", "outBummer1", "outCuffOne", "outFbuf01", "outKufOne", "outBiff91", "outBbuf2", "outDufn", "outBbuf91", "outBum91", "outKbuf2", "outFbuf1", "outBum1", "outKbuff3", "outFafCloud", "outBuff2", "outBuffn", "outFufOne", "outBaf0", "outDuf11", "outBalth3", "outFuf1", "outBbuf01", "outBuf0", "outCuf0", "outBuf91", "outBuffCloud", "outBufCloud", "outFuf01", "outFbufOne", "outBbuff1", "outBuff0", "outBiffOne", "outBbufOne"], "outBuf2": ["outBuber20", "outBbuf1", "outBbuff200", "outFbuff2", "outBbufTwo", "outFuf8", "outBuf20", "outBbuff8", "outBuf8", "outWBufTwo", "outFuf82", "outWBuff2", "outFbuff4", "outWBbuff200", "outFufTwo", "outBoff200", "outBuf82", "outBbuffer12", "outWBbuff2", "outBbuffer4", "outFuf4", "outBum2", "outFbuf2", "outWBuff0", "outFuf12", "outBait4", "outBbuff0", "outFbuff1", "outBuffTwo", "outFbufB", "outWBuf8", "outBuff1", "outWBbuff8", "outBuff8", "outFuf2", "outBuff4", "outBbuffTwo", "outBuff12", "outWBuff4", "outBuffB", "outWBuff8", "outFbuff82", "outBbuff4", "outFbuf4", "outBuber82", "outFbuffTwo", "outFuf20", "outBum82", "outBbuf2", "outBoffTwo", "outBbuff20", "outWBuf2", "outFufB", "outBbuff2", "outBbuf12", "outBait200", "outBbuffer2", "outBum20", "outBuff2", "outBbufB", "outWBbuffTwo", "outBait2", "outFbuff8", "outBbufferB", "outBait8", "outBoff2", "outBufB", "outBaitTwo", "outFuf1", "outBuf0", "outFbuff20", "outBbuff82", "outBuber8", "outBufTwo", "outBuf200", "outWBuf0", "outWBuf200", "outBuf12", "outBbuf4", "outBuber2", "outFbuf12", "outBuf4", "outBbuff1", "outWBuf4", "outBum8", "outBoff8", "outBait0", "outBuff0"], "endOfIndexFile": ["endOfindexTime", "endOfIndexfile", "endofindexFolder", "endOfDatafile", "endOfindexfile", "endofLinkDir", "endofLinkFiles", "endOfLinkFiles", "endOfIndexFiles", "endOfDataFile", "endofIndexFolder", "endofLinkFile", "endOfClientTime", "endOfDataTime", "endOfImageFolder", "endOfImageFiles", "endfile", "endOfLinkfile", "ended\n", "endOfClientDir", "Endfile", " end\n", "endOfLinkFile", "endofIndexDir", "endOfIndexFolder", "endOfLinkDir", "endOfClientFile", "endOfindexDir", "endofindexFiles", "endOfClientFiles", "endOfImageFile", "endOfImageTime", " endfile", "endofindexTime", "endOfLinkTime", "endOfindexFiles", "endOfIndexTime", "endOfDataDir", "endOfIndexDir", "End\n", "endofIndexFiles", "end\n", "endofLinkTime", "endofIndexFile", "endofIndexTime", "endofindexFile", "endedfile", "endOfindexFolder", "endOfindexFile"]}}
{"id1": "9449064", "id2": "20019847", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"readExp": ["readEXP", " readEXP", "readexp", " readExpl", "readExpress", "ReadExp", " readExpress", "ReadExt", "ReadExpl", "ReadEXP", "READExt", "ReadEx", "readEx", "loadExp", "READExpress", "writeComp", "readExt", " readComp", "READExp", "READEx", "writeExpress", " readexp", " readEx", "loadExt", "writeExt", " readExt", "readComp", "writeExpl", "readExpl", "Readexp", "ReadComp", "loadEXP", "writeEx", "loadexp"], "writeExp": [" writeExpl", "changeEx", "outputExp", "readexp", "changeExp", "readStr", "changeexp", "Writeexp", "writeStr", "changexp", "updateExp", "readEx", " writeEx", " writeExt", "writeEx", "readExt", "readxp", "outputStr", "outputExt", "WriteEx", "writeExt", "outputEx", "WriteExp", "writeExpl", "writexp", "updateExpl", " writeStr", "writeexp", "updateEx", " writexp", "updateexp", " writeexp", "WriteExpl"], "expFile": [" expTable", "expressFilename", "xpFile", "exampleFILE", "expressFile", "xpFiles", "xpFilename", "expressFILE", "exPath", "expressPlace", "expressFolder", " expFilename", "ExpTable", "expStream", "EXPFolder", "xpDir", " expDir", "pressTable", "scriptFilename", "scriptfile", "pressFile", "ExpFILE", "EXPDir", "expFilename", "scriptFile", "expTable", "ExpStream", "expPlace", "exFilename", "scriptFILE", "expPath", "EXPPlace", " expFiles", "expFiles", " expPath", "expFolder", "indexDir", "indexFilename", "exampleFile", "expressfile", "xpFolder", "exampleFilename", "expDir", "EXPFile", "exFile", "exFiles", "pressDir", "pressStream", "indexFile", "examplefile", "xpPlace", "xpPath", "ExpDir", "ExpFile", "expressDir", "indexFILE", "expFILE", " expStream", "ExpFilename", "expfile"], "exp": ["ext", "inst", " expanded", "expression", "inf", "f", "x", "push", "feat", "data", "nz", " expand", "asm", "complex", "script", "i", "expl", "form", "app", "div", "xml", "progress", "plus", "str", "zip", "express", "project", "input", "dem", "p", "query", "expr", "prov", "vec", "sc", "Exp", "imp", "pl", "act", "scope", "temp", " exam", "rep", "comp", "ip", "module", "obj", "np", "acc", "dj", "doc", "EXP", "jp", "isp", "example", "ef", "test", "iz", "exper", "fe", " expansion", "model", "xp", " experiment"], "fi": ["ifi", "cf", "ni", "bi", "i", "sf", "ci", "ffe", "qi", "FI", "ani", "afi", "fb", "fc", "abi", "flo", "pi", "fa", "zi", "ifa", "fp", "ilia", "Fi", "yi", "wi", "ii", "sci", "py", "lli", "isi", "si", "li", "ini", "fy", "fe", "osi", "xi", "eni"], "oi": ["avi", "ahi", "ori", "ui", "ti", "odi", "ni", "bi", "i", "asi", "ci", "qi", "ofi", "oid", "uci", "ois", "ani", "eye", "di", "oni", "ku", "eu", "ki", "ogi", "abi", "flo", "edi", "obb", "shi", "ai", "oxy", "io", "agi", "ii", "ilo", "omi", "lli", "oa", "isi", "si", "li", "ini", "ji", "osi", "obi", "eni", "ski"], "jf": ["chfx", "Jfp", "vfx", "jptf", "jenb", "jfs", "vf", "ujf", "pb", "jpF", "je", "Jb", " jv", " jtf", "jb", "jtf", "uje", "Jcf", "JF", " jc", "jpfx", "che", "jpf", " jb", "jetfs", "vtf", "pp", "jpcf", "jetf", "ujfs", "Jf", "chF", "jpb", "ujF", "jc", " jF", " jp", "Jp", "jF", "jencf", " jcf", "jenc", "jfp", "jcf", "jenf", "Jv", "jetF", "jv", "pf", " je", " jfs", "Jc", "Jfx", "jfx", "jenv", "jete", "jp", "pcf", "vb", "jenfp", "Je", "chf", " jfp", " jfx"], "sp": ["inst", "ctx", "st", "serv", "sm", "gp", "lp", "service", "sb", "source", "sf", "app", "per", "sh", "pe", "osp", "sl", "pp", "pr", "cp", "html", "p", "sg", "bsp", "op", "fp", "esp", "page", "wp", "sc", "bp", "se", "Sp", "imp", "pl", "scope", "spec", "style", "sci", "sup", "soc", "vp", "py", "px", "space", "sw", "np", "sq", "j", "ps", "jp", "amp", "isp", "sv", "js", "frame", "si", "inc", "tp", "cmp", "spe", "fe", "so", "SP", "mp"], "e": ["ctx", "x", "ev", "ception", "es", "pe", "t", "el", "ce", " Event", "E", "event", "v", "in", "se", "w", "de", "vent", "ea", "exc", "ee", "ec", " enc", "fe", "ep", "ae"], "fo": ["wo", "osa", "obo", "ato", "ro", "go", "oso", " lo", "fa", "flo", "ico", "ao", "jo", "yo", "vo", "co", "zo", "foo", "io", "ho", "ko", "obj", "o", "FO", "po", "oooo", "bo", "ph", "ooo", "tto", "lo", "so", "olo", "mo", "la"], "oo": ["ollo", "osa", "obo", "wo", "oto", "loo", "obe", "que", "ro", "argo", "da", "oid", "goo", "obi", "aco", "elo", "flo", "ico", "ao", "ou", "os", "co", "foo", "io", "oh", "ko", "OO", "LO", "o", "ilo", "FO", "oe", "po", "cro", "oooo", "bo", "ooo", "ox", "oa", "qa", "oda", "va", "lo", "so", "oos", "olo", "mo", "la"], "ex": ["lex", "ext", "rex", "cl", "x", "re", "ru", "nex", " Ex", "EX", "sex", "ception", "expl", "ic", "exit", "ignore", "ax", "fail", "class", "Exc", "error", "in", "tex", "res", "de", "pex", "com", "act", "err", "pl", "exc", "obj", "su", "except", "example", "rx", "cap", "out", "again", "null", "Ex"]}}
{"id1": "19849797", "id2": "2807585", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"sourceFile": ["srcFolder", " sourcefile", "destDirectory", "SourceDirectory", " sourceFolder", "sourceFolder", "ourceDirectory", "srcfile", "ourceUrl", "SourceUrl", "destUrl", "sourceDir", "srcDir", "sourceUrl", "SourceFolder", "ourceFile", "destfile", "Sourcefile", "SourceDir", "ourcefile", "sourcefile", "srcFile", " sourceDir", "SourceFile", "sourceDirectory"], "destFile": ["destDirectory", "DestPath", "DestDir", "DestDirectory", "resultLine", " destDir", "destPath", "destFiles", "srcLine", "srcFiles", "srcDirectory", "srcfile", "resultFile", "destLine", "targetfile", "resultfile", "targetPath", "foreignPath", "DestFile", "sourceFiles", "sourceDir", "srcDir", "resultDir", "destPoint", "foreignfile", "targetFile", "targetFiles", "DestFiles", "foreignFile", " destDirectory", "DestPoint", "foreignFiles", "targetDir", " destPoint", "destfile", "sourcePoint", " destfile", "Destfile", "destDir", "srcFile", "targetLine", " destFiles"], "source": ["session", "target", "wrapper", "core", "reference", "src", "uri", "service", "from", "ie", "site", "resource", "remote", "status", "output", "sin", "SOURCE", "slice", "server", "iter", "input", "ce", "this", "context", "dest", "parent", "secure", "root", "file", "url", "reader", "scope", "object", "manager", "connection", "slave", "get", "inner", "unit", "image", "table", "seed", "storage", "client", "channel", "route", "result", "component", "size", "stream", "index", "current", "start", "cache", "si", "Source", "view", "api", "ource", "scene", "use", "config", "proxy", "null", "id"], "destination": ["constination", "constribution", "destion", "domation", "dominator", "participinate", "Destinator", " destinated", "distination", " destribution", "generination", "destruction", "Destinate", "Destribution", "dominated", "Destion", "destinated", "Destination", "distion", "participinator", "participination", "generinated", "domination", " destruction", "Destruction", "Destinated", "destation", "construction", " destation", "constinator", "identinator", "destribution", "identination", "destinate", "distinator", "distinated", "distruction", "generruction", "destinator", "Destation", "participinated", " destinator", "identinate", "generinator", " destion", "identinated"]}}
{"id1": "7143591", "id2": "9267602", "code1": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"strUrl": ["objurl", "stableURL", "StrPage", "intUrl", "frURL", "nameUr", "frUr", "StrFile", " strPage", "arrUrl", "namePage", "StrURL", "intUr", "strUr", "stUr", "stURL", "stableUrl", "StrUrl", "nameUrl", " strURL", "strurl", "inturl", "stUrl", "objUr", "arrurl", "frUrl", "STRUrl", "Strurl", "strURL", "stFile", "STRURL", "frFile", "objUrl", "StrUr", "stableUr", "stableurl", "strFile", "strPage", "sturl", "intURL", "nameURL", " strurl", "STRFile", "arrUr", " strFile", "objURL", "arrURL", " strUr", "STRUr"], "charset": ["chaspace", "ChARSetting", "chactersetting", "chaset", "charsetting", "Charsetting", "Charspace", "chARSet", "ChARSpace", "charspace", "charsets", "chARSpace", "ChARSets", "Charsets", "chactersets", "Charset", "ChARSet", "chacterspace", "chARSetting", "chasetting", "chacterset", "chasets", "chARSets"], "fileIndex": [" fileId", "urlIndex", "fileCounter", "FilePath", "urlPath", "FileCounter", "FileName", "fileindex", "pageName", "pageId", "urlCounter", " fileCounter", "fileName", " fileName", "fileId", "pageIndex", "pageindex", "Fileindex", "urlindex", " fileindex", "FileId", "FileIndex"], "url": ["loader", "address", "f", "serv", "uri", "service", "ssl", "string", "source", "web", "resource", "con", "path", "host", "str", "server", "http", "ur", "zip", "sl", "org", "URL", "blog", "base", "file", "page", "ls", "www", "connection", "image", "open", "client", "b", "l", "ll", "link", "download", "Url", "log", "api", "config", "fl"], "conn": ["Connection", "ctx", "f", "sync", "serv", "socket", "ssl", "connect", "ci", "con", "cn", "server", "http", "fr", "conf", "cli", "nc", "cp", "p", "ai", "w", "connection", "open", "client", "conv", "c", "b", "exec", "util", "l", "Conn", "Url", "n", "loc", "ch", "api", "r", "enc", "config", "sn"], "is": ["oss", "ir", "nis", "lis", "ris", "x", "it", "serv", "ui", "jar", "uri", "iss", "isl", "inn", "ie", "src", "i", "es", "ais", "bi", "abs", "has", "ssl", "im", "ib", "http", "us", "its", "init", "internet", "isa", "os", "in", "ai", "iso", "ins", "err", "ar", "io", "ab", "s", "ip", "bis", "IS", "ws", "ios", "b", "ri", "as", "was", "browser", "Is", "ps", "isc", "isi", "si", "ob", "sys", "out", "info", "il"], "filePath": ["Filepath", " fileInfo", "fInfo", "FilePath", "fPath", "fileInfo", "fileLocation", "FileName", "fHalf", "fileHalf", "pageName", "fileName", " fileName", " fileHalf", "FileInfo", "FileLocation", "FileHalf", "fLocation", "pagepath", "filepath", "pagePath", "fName", "pageLocation", "fpath"], "pw": ["pW", "ppw", "pew", "ipW", "Pew", "pb", "Pwa", " pew", "spW", " pwe", "spw", "ipw", "pws", "pwe", "ipwa", "Pwe", "pow", "Pb", " pow", "opw", "lpW", " pW", "ppow", "ipwe", "Pw", "ppws", "lpow", "lpw", "Pow", "opwa", "spwa", "opws", "ppb", " pws", "pwa", " pwa", "lpew", "Pws", "ppwa", "opW", "PW", "ppW", "spb"], "fos": ["Fos", "Foos", "afo", "fOS", "phOS", "sfis", "sfos", "afOS", " fo", "foos", "phos", "sfoos", "afos", "fis", "fo", " foos", "phoos", "Fo", " fis", "sfOS", " fOS", "FOS", "phis", "afoos"], "writer": ["walker", "rew", "angler", "wrap", "rw", "wave", "xml", "wb", "output", "wa", "handler", "director", "wire", "riter", "war", "editor", "store", "file", "fd", "reader", "wr", "w", "Writer", "temp", "er", "worker", "writers", "connection", "io", "buffer", "ws", "player", "write", "we", "wer", "work", "wt", "driver", "r", "writ", "out", "null", "writing"], "bReader": [" bRead", " bWriter", " bFile", "rReader", "bWriter", "rbFile", "bRead", "bFile", "bbReader", "rbReader", "rbTr", "rbRead", "bbFile", "bbWriter", "rRead", "rbWriter", "rWriter", "bTr", " bTr", "bbRead", "rTr"], "sb": ["abb", "pb", "xb", "nb", "rb", "sm", "gb", "bb", "src", "vm", "ssl", "sf", "wb", "db", "WS", "zb", "erb", "tmp", "usb", "fb", "sth", "rob", "sa", "lb", "bf", "sg", "obb", "bm", "bp", "sp", "SB", "cb", "bps", "ab", "mb", "stab", "b", "sq", "kb", "sv", "si", "lab", "bg"], "rLine": ["rLo", "rLin", " rWr", "rbLine", "prLo", "crCo", " rLo", " rBlock", "prCo", "crLin", "rPage", "rEl", "lrLine", "rbEl", " rEl", " rPage", "prBlock", "srCo", "rtLine", "rBl", "rbBlock", "prBl", "crLine", "rtBlock", "rCo", "prLine", "lrBlock", "srLin", "prLin", "rWr", "crBl", "rtWr", "rtLo", "rBlock", "srLine", "lrPage", "prWr", "lrEl", "srBl", "rbPage"], "tmp_rLine": ["tmp_rRow", "tmp_rbLine", "tmp_RLine", "tmp_Rline", "tmp_erFile", "tmp_rnLook", "tmp_rtLook", "tmp_mrWord", "tmp_brUrl", "tmp_rbUrl", "tmp_RL", "tmp_rfWord", "tmp_rCo", "tmp_brLine", "tmp_lrLink", "tmp_rnWord", "tmp_lrBlock", "tmp_mrline", "tmp_rtWord", "tmp_rMe", "tmp_rfChar", "tmp_RRow", "tmp_nrLine", "tmp_bRow", "tmp_mrLine", "tmp_brFile", "tmp_rfString", "tmp_bUrl", "tmp_lrRow", "tmp_erLine", "tmp_brMe", "tmp_rBlock", "tmp_lrChar", "tmp_erL", "tmp_rfLook", "tmp_rLink", "tmp_rbBlock", "tmp_rL", "tmp_rnString", "tmp_rfLine", "tmp_rLook", "tmp_rWord", "tmp_mrFile", "tmp_rfRow", "tmp_rtLine", "tmp_rbFile", "tmp_brL", "tmp_rLin", "tmp_RChar", "tmp_brBlock", "tmp_lrLine", "tmp_nrline", "tmp_rbRow", "tmp_lrCo", "tmp_RLin", "tmp_bLine", "tmp_RWord", "tmp_erLin", "tmp_rtString", "tmp_rChar", "tmp_rfCo", "tmp_RFile", "tmp_bFile", "tmp_rUrl", "tmp_rnLine", "tmp_brLin", "tmp_RUrl", "tmp_rFile", "tmp_rbMe", "tmp_nrFile", "tmp_rline", "tmp_nrWord", "tmp_RLink", "tmp_RBlock", "tmp_RCo", "tmp_rString"], "str_len": ["str6length", "str__length", "int_en", "str__Len", "str6lon", "str__lon", "str_Len", "int_len", "str__len", "str6Len", "int_lim", "str64lim", "str_en", " str_Len", " str_lon", "str_lon", "str_length", "str_lim", "str6len", " str_length", "str64en", "str64len"]}}
{"id1": "18489832", "id2": "17974661", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "label": 0, "substitutes": {"url": ["loader", "f", "bug", "uri", "ssl", "source", "i", "web", "resource", "server", "http", "ur", "zip", "sl", "lib", "URL", "store", "base", "event", "file", "page", "connection", "image", "open", "update", "client", "route", "c", "b", "lr", "or", "l", "ll", "download", "link", "Url", "log", "r", "config", "proxy", "pull"], "destDir": ["tempFolder", "tempFile", " destDIR", "destDirectory", "DestDir", "outputFile", "outputFolder", "destFile", "DestFolder", "tmpDIR", "tmpDir", "outputdir", "outputDirectory", "DestFile", "tempDir", "tmpDirectory", "destFolder", " destDirectory", " destFile", "outputDIR", "outputDir", " destFolder", "destdir", "destDIR", "tempDIR", " destdir", "tmpdir", "DestDIR"], "urlConnection": ["downloadConnection", "urlconnection", "httpNetwork", "URLConnection", " urlChannel", "webChannel", "downloadNetwork", "urlFactory", "URLConnect", "httpFactory", "webConnection", "downloadConn", " urlconnection", "webConnect", "urlConn", "fileFactory", "fileConnection", "URLconnection", "httpConn", "urlConnect", "webconnection", "fileConn", "fileNetwork", " urlConnect", "httpConnection", "urlChannel", "urlNetwork", "URLChannel", "downloadFactory"], "tmpFile": [" tmpfile", "tmpFiles", "tempFile", "partFile", "tmpFolder", " tmpFiles", "tmpfile", " tmpFolder", "partfile", " tmpEntry", "partDir", "partFolder", "TempPath", "destFile", "destPath", "tmpPath", " tmpWorld", "tempFiles", "tmpWorld", "mpFiles", "mpFolder", "zipfile", "mpFile", "tmpDir", "tmpLine", "tempEntry", "tmpEntry", "mpPath", "TempWorld", "tempDir", "zipLine", "tempPath", "destFolder", "TempFile", "zipFile", " tmpDir", "tempLine", "tempfile", "destWorld", "zipFiles", "destfile", "Tempfile", " tmpLine", " tmpPath", "mpDir", "mpfile", "destEntry"], "in": ["gin", "f", "sync", "a", "data", "socket", "inn", "source", "i", "con", "token", "ax", "is", "input", "arin", "init", "Out", "kin", "min", "din", "lin", "conn", "reader", "rin", "file", "ins", "bin", "err", "connection", "inner", "up", "c", "as", "en", "l", "win", "In", "work", "n", "cin", "inc", "IN", "ac", "nin", "ini", "r", "ex", "copy", "login", "again", "info", "pin", "pull", "id"], "out": ["ext", "sync", "OUT", "point", "socket", "check", "no", "i", "source", "output", "off", "line", "server", "writer", "init", "this", "Out", "min", "op", "file", "conn", "co", "bin", "one", "err", "connection", "call", "io", "inner", "name", "up", "client", "obj", "o", "cmd", "outs", "exec", "download", "outer", "In", "n", "at", "inc", "IN", "nin", "ex", "copy", "index", "again", "null", "login"], "localURL": [" localUrl", "LocalCL", "baseUrl", "localURI", "remoteURI", "externalURL", "remoteUrl", "localUrl", "localAPI", "remoteFile", " localCL", "externalAPI", "localFile", "baseFile", "baseURI", "LocalURL", "LocalUrl", "remoteURL", "LocalAPI", "externalUrl", "externalCL", " localURI", "baseURL", " localFile", " localAPI", "localCL"]}}
{"id1": "4481712", "id2": "14464131", "code1": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://hostname:80\");\n            URLConnection conn = url.openConnection();\n            for (int i = 0; ; i++) {\n                String headerName = conn.getHeaderFieldKey(i);\n                String headerValue = conn.getHeaderField(i);\n                if (headerName == null && headerValue == null) {\n                    break;\n                }\n                if (headerName == null) {\n                }\n            }\n        } catch (Exception e) {\n        }\n    }\n", "label": 0, "substitutes": {"id": ["ids", "delete", "ID", "f", "it", "data", "uri", "string", "source", "i", "resource", "path", "oid", "parent", "lock", "root", "database", "query", "error", "url", "Id", "in", "ident", "rid", "type", "uid", "ip", "sql", "name", "info", "pid", "sid", "key", "api", "object", "model", "create"], "conn": ["Connection", "comm", "ca", "ctx", "cm", "sync", "cat", "serv", "core", "pg", "cond", "cf", "ssl", "lc", "connect", "ci", "con", "cn", "dc", "nw", "host", "db", "cr", "server", "pc", "conf", "org", "cli", "nc", "cp", "parent", "lock", "nt", "ou", "error", "co", "ai", "act", "ct", "cb", "connection", "err", "sql", "cms", "rt", "ec", "client", "cmd", "c", "cc", "po", "exec", "orp", "rc", "Conn", "n", "ann", "ac", "pool", "cur", "loc", "ch", "cmp", "mc", "log", "enc", "config", "h", "cache", "coll", "col", "auth"], "stmt": ["tmt", " stmi", "istmt", "strmm", "stmi", "Stmb", "Stmit", "dmb", "strmt", " sttx", " stmn", "stmb", "strmr", "ptmn", "stmn", "Stmr", "stql", "Stm", "Stmt", "strm", "tmn", " stmd", " stmit", "strmb", " stql", "strql", " stm", "stm", "Stmm", "Stmn", "ptmt", "Stmi", "Stma", "Stmd", "stmm", "strmp", "stmr", " stma", "pttx", "dma", "dm", "stmd", "sttx", "strmd", "strtx", "tm", "ptql", " stmr", "strmi", "stmit", "strmn", "stmp", "tmm", "istmit", "dmt", " stmp", "stma", " stmm", "Stmp", "istmr", "istm", " stmb"], "dbConn": ["bbConnect", " dbconn", "cbCon", "dbconn", "dbConnect", " dbCon", "bbConn", "cbConn", "bdCon", "databaseConnection", "bdConn", "bdConnection", "bbConnection", "dbCon", "databaseConn", "bdConnect", "databaseconn", "cbConnection", "dbConnection", "bbconn", "cbConnect", "databaseConnect", " dbConnection", " dbConnect"], "selfConnection": ["SelfReference", "selfReference", "passconnection", "parentconnection", "parentConnection", "thisconnection", "selfConnect", "thisConnect", "selfconnection", "parentConnect", " selfConnect", " selfconnection", "thisConnection", "SelfConnection", " selfConn", "thisConn", "passConnect", "Selfconnection", "passReference", "SelfConnect", "thisReference", "selfConn", "passConnection", "parentConn", "SelfConn", "passConn", " selfReference"]}}
{"id1": "17202158", "id2": "5759961", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "label": 0, "substitutes": {"zoneFileName": ["zoneFullname", "zonefilename", "ZonefileName", "Zonefilename", "zoneClassName", " zoneFileUrl", "ZoneFilePath", "zoneFileUrl", "zonefilePath", "zoneClassname", "zoneClassUrl", "zoneFilesname", "zoneFilePath", "zonefileName", "zoneFilesUrl", "ZoneFileName", "zoneFullUrl", "ZonefilePath", " zoneFilePath", " zoneDirUrl", "zoneDirUrl", "zoneFilesPath", " zoneDirName", "zoneFilename", "zoneClassPath", "zonefileUrl", "zoneFilesName", "zoneDirPath", "zoneDirName", "ZoneFileUrl", "zoneLineUrl", "zoneLineName", "ZoneFilename", "zoneFullPath", "zoneFullName", " zoneDirPath", "zoneLinePath", "ZonefileUrl"], "zoneids": ["zonefiles", "zoneid", "sizeid", "Zoneids", "poIDs", "typeints", "zoneIDs", "poids", " zonelines", "zipids", " zoneips", "ziplines", "Zoneid", "sizeids", "zoneints", "typeids", "zoneips", "typeid", " zonefiles", "zonelines", "polines", "ZoneIDs", "zipIDs", "sizeints", "zipid", "pofiles", " zoneid", " zoneIDs", "poid", "Zonefiles", "typeips", "sizeips", " zoneints"], "url": ["loader", "address", "f", "re", "bel", "data", "user", "uri", "service", "ssl", "string", "source", "resource", "path", "feed", "server", "http", "hub", "ur", "sl", "URL", "class", "this", "base", "file", "page", "reader", "location", "connection", "io", "buffer", "name", "job", "client", "channel", "b", "l", "stream", "Url", "api", "r", "ball"], "lnr": ["linw", "rlb", "lenp", "nlp", "slrb", "lenr", "slr", "lnrb", "rln", "nlr", "sln", "lnw", "lenb", "nlw", "lnn", "rlr", "lenw", "nlb", "linr", "lnb", "linn", "lnp", "rlrb", "slb", "linrb", "linp", "linb"], "line": ["number", "cl", "column", "data", "row", "lines", "parse", "string", "no", "lc", "rule", "LINE", "str", "response", "nl", "entry", "message", "sl", "el", "cell", "lf", "base", "block", "jo", "file", "page", "lin", "part", "inline", "ge", "char", "letter", "comment", "header", "unit", "name", "Line", "code", "look", "c", "le", "sel", "l", "link", "ne", "log", "key", "word", "col", "id"]}}
{"id1": "10728243", "id2": "481364", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "label": 0, "substitutes": {"password": ["number", "account", "sword", "address", "prefix", "filename", "dh", "words", "wd", "user", "string", "token", "pad", "path", "project", "input", "username", "phrase", "security", "secret", "wallet", "hash", "name", "channel", "email", "Password", "sum", "pass", "mac", "PASS", "key", "crypt", "padding", "attribute", "word", "config", "auth", "sudo"], "seed": ["address", "length", "finger", "prefix", "template", "string", "source", "alias", "token", "pad", "slice", "zip", "Salt", "text", "username", "random", "volume", "shadow", "phrase", "secret", "state", "offset", "hash", "pair", "name", "device", "machine", "pattern", "sum", "size", "mode", "pass", "prime", "key", "driver", "crypt", "padding", "eed", "sudo", "id"], "md": ["cm", "nm", "pd", "d", "dh", "sm", "wd", "ad", "hm", "pm", "gd", "amd", "mad", "dc", "diff", "mid", "ind", "sha", "kg", "ds", "di", " Md", "mn", "meta", "grad", "pkg", "mm", "am", "Cmd", "km", "MD", "dd", "od", "bm", "mand", "ma", "part", "mt", "m", "ms", " MD", "bd", "rm", "dig", "mb", "mg", "vd", "dm", "cd", "cmd", "om", "po", "ht", "doc", "nd", "hd", "mode", "df", "addr", "mac", "mag", "mp", "mc", "mi", "mem", "ld", "mo", "metadata"], "passwordHashStage1": ["passwordHashPhaseOne", "passwordSumStage1", "passwordHashStage0", "passwordSumStage0", "passwordHashstage2", "passwordSumPhase4", "passwordHashstage1", "passwordHashPhase1", "passwordHashStep1", "passwordHashStep2", "passwordSumPhaseOne", "passwordSumStageOne", "passwordSumStage2", "passwordHashStageOne", "passwordSumPhase1", "passwordSumPhase2", "passwordSumPhase0", "passwordHashStage3", "passwordHashstage3", "passwordHashStep3", "passwordHashPhase3", "passwordHashstage4", "passwordHashStage4", "passwordSumStage4", "passwordHashstage0", "passwordHashstageOne", "passwordHashPhase2", "passwordHashPhase4", "passwordSumStage3", "passwordSumPhase3", "passwordHashPhase0"], "passwordHashStage2": ["passwordSumStage1", "passwordSumPhaseTwo", "passwordHashStep4", "passwordBlockstage4", "passwordHashStage02", "passwordHashstage2", "passwordBlockStage4", "passwordHashStage8", "passwordSumStageTwo", "passwordHashstage1", "passwordBlockStage2", "passwordHashstage02", "passwordHashPhase1", "passwordHashStep1", "passwordSumStage02", "passwordHashPhaseTwo", "passwordHashstage8", "passwordHashstageTwo", "passwordSumPhase1", "passwordSumPhase2", "passwordBlockStage8", "passwordHashPhase8", "passwordSumPhase02", "passwordBlockstage8", "passwordHashStageTwo", "passwordBlockstage2", "passwordHashstage4", "passwordHashStage4", "passwordBlockStage1", "passwordHashPhase02", "passwordHashPhase2", "passwordBlockstage1", "passwordHashPhase4", "passwordHashStep8", "passwordHashStep2", "passwordSumStage2"], "toBeXord": ["toBeCrossor", "toBeWorkords", "toBeWorkors", "toBEYords", "toBeCrossords", "tobeXords", "tobeXord", "tobeYord", "toBeYords", "tobeYors", "tobeCrossord", "toBeZord", "tobeCrossors", "toBEXORD", "toBeZords", "tobeCrossor", "toBeXORD", "toBeCrossord", "toBeXor", "toBEYor", "toBeZORD", "toBeZors", "toBeWorkORD", "toBeXords", "toBEXord", "toBeCrossors", "toBeWorkord", "tobeCrossords", "tobeYorder", "toBeCrossORD", "toBeXorder", "tobeYor", "toBeYORD", "tobeXorder", "toBEYORD", "toBeYord", "toBeYor", "toBeWorkor", "toBeXors", "toBEXor", "toBeZor", "tobeXor", "toBeZorder", "toBeYors", "toBEYord", "toBEXords", "toBeYorder", "toBeWorkorder", "tobeXors"], "numToXor": ["numToWorkOR", "numtoXorer", "num2Xorer", "numtoxors", "numToAnyorer", "numtoXor", "numToCrossors", "numToAbsOr", "numtoxOR", "numToxor", "numToCrossorer", "numToAnyOr", "numToXors", "numToCrossOR", "numtoXors", "num2XOR", "num2AbsOr", "num2AbsOR", "numToAbsorer", "numtoxorer", "numToXorer", "num2Absor", "num2XOr", "numToWorkors", "numToWorkorer", "numToAbsOR", "numToxorer", "num2Xor", "numToXOr", "numtoXOR", "numToCrossor", "numToCrossOr", "numToAnyor", "numToxors", "numToAbsor", "numtoxor", "num2Absorer", "numToXOR", "numToAnyOR", "numToWorkor", "numToxOR"], "i": ["hi", "f", "x", "d", "a", "ui", "it", "ti", "uri", "bi", "ci", "qi", "gi", "off", "slice", "di", "t", "h", "z", "abi", "pi", "chi", "p", "v", "in", "ai", "part", "ix", "u", "m", "k", "io", "ip", "ii", "y", "info", "o", "b", "ri", "I", "c", "multi", "j", "l", "n", "si", "key", "li", "oi", "r", "index", "xi", "e", "id"]}}
{"id1": "12389873", "id2": "19378010", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public static Multimap<String, String> getProteins(final Set<String> queries, final int taxon) throws ParserConfigurationException, XPathExpressionException {\n        final DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        final XPathExpression xpe = XPathFactory.newInstance().newXPath().compile(__xpath);\n        final Multimap<String, String> proteins = HashMultimap.create();\n        for (final String query : queries) {\n            HttpURLConnection connection = null;\n            try {\n                final String encoded = URLEncoder.encode(query.trim(), \"UTF-8\");\n                final URL url = new URL(String.format(__urlTempl2, encoded, taxon));\n                connection = (HttpURLConnection) url.openConnection();\n                connection.setConnectTimeout(__connTimeout);\n                connection.setReadTimeout(__readTimeout);\n                connection.setRequestProperty(\"Connection\", \"close\");\n                connection.connect();\n                final InputStream stream = connection.getInputStream();\n                final Document doc = parser.parse(stream);\n                final NodeList nodes = (NodeList) xpe.evaluate(doc, XPathConstants.NODESET);\n                if (nodes != null) {\n                    final int n = nodes.getLength();\n                    for (int i = 0; i < n; i++) {\n                        final Node node = nodes.item(i);\n                        proteins.put(node.getTextContent().trim(), query.trim());\n                    }\n                }\n            } catch (final Exception ex) {\n                continue;\n            } finally {\n                if (connection != null) connection.disconnect();\n            }\n        }\n        return proteins;\n    }\n", "label": 0, "substitutes": {"conn": ["session", "Connection", "ca", "ctx", "cat", "dh", "oci", "pg", "sb", "connect", "ci", "Exec", "con", "dc", "cn", "db", "cr", "pc", "conf", "nc", "pr", "cp", "p", "nt", "ns", "co", "ls", "act", "ct", "connection", "state", "pub", "sql", "rt", "ec", "client", "c", "reg", "cc", "exec", "util", "Conn", "n", "cache", "ann", "dn", "pt", "loc", "ch", "mc", "enc", "config", "h", "coll", "col"], "stmt": [" stmi", "slpl", "flmt", "estert", "STms", "STpl", "stct", " stmn", "stmb", "estmp", "stmn", "steth", "stql", "stst", "slmn", "thegr", "syor", "stpl", "stms", " stert", "eltor", " stt", "stert", "putts", "dmd", "estct", "elts", "plb", "stgt", "putur", "themt", "estgt", "stts", "tsp", "playmd", "Stdb", "stmd", " stts", "flgt", "putmt", "plpl", "flmp", " stdb", "estmi", "putml", " stgt", "stml", "Sttor", "sybf", "stmc", "Steth", " stct", " stmc", "Stpl", "dMT", "tmt", " stpl", " stwd", "flct", "estmt", "STql", "slmp", "Stmt", "Stts", "Stwd", "plmb", "putmb", "Stql", " stapter", "Stmn", "Stbl", "Stml", " stmb", "ttr", "stbf", "slbl", "STts", "STeth", "playct", "STapter", "Sttr", "putnt", " stmp", "stwd", "putmd", " sttor", " stur", "estst", "playeth", "estapter", "elpl", "stgr", "Stmb", "stur", "stMT", "Stms", " stor", "Stur", "plmt", "playnt", " stql", "statwd", "stnt", "thepl", "Stb", " steth", "slgr", "statb", "STbl", "Stgr", " stMT", "sttor", "stbl", "playml", "stmp", "Stbf", "sytr", "Stnt", "stsp", "Stor", "esteth", "plmn", " stb", "stmi", " stms", "puttr", "slmt", "statmt", "sltr", "estms", " stsp", "tmb", "stdb", " stbf", "playmc", " stbl", " stmd", "estql", "putsp", " stst", "stb", "Stmc", "symt", "STdb", "Stmi", "Stmd", "STst", "STmt", "Stt", "STct", "StMT", "plur", "stapter", "puteth", "estts", "Stct", "playmt", "dpl", "stt", "plt", "putct", " sttr", "dmt", "sttr", "Stmp", "estur", "elmt", "putert", "stor", "themn", "statmn"]}}
{"id1": "13233761", "id2": "17773263", "code1": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 1, "substitutes": {"queries": ["questires", "quires", "compests", "commires", "questands", "quips", "comperies", "commips", "quands", "bleries", "questeries", "commands", "squands", "quests", "compips", "blests", "squires", "squests", "commeries", "blips", "squips", "squeries", "compands", "blands", "questips"], "autoCommit": ["autoCompit", "autoCompits", "autoCompmit", "autoDebrit", "autoCommrit", "AutoCommit", "autoommit", "autoommits", "AutoDebmit", "AutoCommmit", "autoDebit", " autoCommmit", "AutoDebits", "autoCompitted", "autoComits", " autoCommitted", "autoCommitted", "autocommit", "autoComrit", "autoommmit", "autoCommits", "autoDebits", " autoComits", "AutoCommits", "autocommmit", "AutoDebit", "autoCommmit", "AutoDebrit", "autoommitted", "AutoCommrit", "autoComitted", " autoComit", " autoCommits", "autocommits", "autoDebmit", "autoComit", "autocommrit", " autoComitted"], "iterator": ["inst", "loader", "walker", "adder", "filter", "next", "data", "gener", "runner", "cher", "ie", "string", "section", "i", "former", "end", "division", "handler", "interstitial", "slice", "entry", "iter", "consider", "ator", "list", "init", "context", "internet", "creator", "database", "population", "vector", "reader", "ter", "inter", "finder", "connection", "inner", "runners", "done", "collection", "Iterator", "ski", "later", "set", "step", "encer", "instance", "size", "started", "start", "stream", "outer", "loop", "parser", "series", "index", "pointer", "info", "starter", "sequence", "metadata"], "query": ["join", "expression", "filter", "next", "data", "row", "script", "condition", "uri", "string", "qu", "Query", "rule", "press", "str", "entry", "command", "commit", "question", "search", "value", "q", "select", "connection", "call", "action", "comment", "table", "style", "sql", "name", "update", "result", "sq", "ql", "key", "record", "sequence", "message"], "statement": ["inst", "session", "join", "expression", "next", "Statement", "data", "script", "flush", "condition", "string", "section", "document", "response", "command", "commit", "function", "database", "conn", "mt", "connection", "stat", "state", "comment", "table", "s", "unit", "sql", "usage", "storage", "style", "element", "action", "execute", "result", "ment", "start", "si", "parser", "use", "sequence"]}}
{"id1": "21642215", "id2": "9267602", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"row": ["column", "bug", "user", "builder", "container", "per", "feed", "server", "tr", "entry", "Row", "list", "ow", "group", "scan", "query", "head", "raw", "rows", "array", "block", "reader", "k", "table", "buffer", "up", "info", "result", "tab", "item", "view", "post", "key", "report", "r", "record", "index", "copy", "col", "cell"], "name": ["number", "filter", "named", "filename", "prefix", "time", "string", "source", "resource", "alias", "path", "str", "search", "username", "query", "database", "file", "type", "connection", "NAME", "image", "title", "Name", "ame", "description", "size", "start", "key", "word", "info"], "in": ["loader", "session", "f", "version", "re", "serv", "it", "socket", "user", "inn", "ssl", "source", "i", "resource", "string", "ln", "con", "path", "token", "with", "iter", "is", "input", "init", "rec", "lock", "query", "min", "din", "conn", "file", "reader", "ins", "bin", "err", "inner", "get", "s", "buffer", "image", "update", "b", "as", "l", "doc", "win", "In", "stream", "cin", "inc", "index", "IN", "nin", "ini", "r", "ex", "record", "login", "out", "again", "pin"], "urlName": ["urName", "methodPath", "URLPath", "UrlName", "urlPath", "UrlUrl", "urname", "urlUrl", " urlPath", "resourcename", "URLUrl", "URLType", "urlType", "urlNAME", "URLname", " urlname", " urlAlias", "URLNAME", "URLAlias", "methodName", " urlNAME", "UrlType", "resourceName", "methodname", "UrlPath", "urNAME", " urlUrl", " urlType", "urlAlias", "urlname", "resourceType", "methodType", "Urlname", "resourcePath", "URLName", "urAlias"], "url": ["f", "bel", "socket", "uri", "user", "service", "ssl", "source", "resource", "web", "feed", "path", "server", "http", "hub", "sl", "input", "URL", "base", "file", "page", "reader", "gl", "location", "connection", "io", "open", "client", "channel", "b", "l", "link", "stream", "Url", "fl"], "inputLine": ["selectLINE", "dataPage", "elementStream", "upByte", "installLINE", "resourceLink", " inputByte", "pullEntry", "imageLine", " inputString", "currentLine", "outputLine", "resourceL", "currentEntry", "uploadByte", "keepLINE", "installLine", "pullLin", "dataline", "inputEntry", "outputStream", "pullLine", "inputLINE", "inStream", "elementBlock", "selectLine", "submitStream", "InputName", "sourceL", "execLin", "inputLin", "sourceline", "selectStream", "uploadLine", "elementLine", "execL", "elementline", "InputLINE", "InputLine", "InputUrl", "inputUrl", "installEntry", "InputLink", "inputStream", "reviewLine", " inputLink", "resourceLin", "execBlock", "inputSite", "configLine", "reviewL", "submitL", " inputStream", "submitCell", " inputEntry", "execUrl", "resourceLine", "Inputline", "dataString", " inputUrl", "currentline", "readStream", "requestLine", "keepStream", "inputString", "InputL", "readLine", "upLine", "reviewStream", "upEntry", "requestEntry", "dataLine", "inputline", "configLINE", "uploadEntry", " inputL", "sourceStream", "inputCell", "currentLink", " inputCell", "InputLin", " inputBlock", "inputPage", "uploadLINE", "currentPage", "inputL", "imageLin", "inputByte", "InputStream", "InputSite", "submitLine", "submitLin", "imageEntry", "upLINE", "keepLine", " inputName", "readline", "submitEntry", "configline", "keepline", "inputLink", "reviewCell", "submitLINE", "inLine", "outputBlock", "dataSite", " inputLINE", " inputPage", "inputName", "inL", "pullline", "currentLin", "installline", "outputline", "inline", "selectline", "InputBlock", "imageLINE", "InputString", "configL", "inputBlock", "requestLINE", "sourceLine", "readBlock", "requestline", "execName", " inputLin", "dataLink", " inputSite", "execLine", " inputline"], "score": ["length", "live", "core", "time", "weight", "strength", "success", "path", "cost", "speed", "average", "scale", "value", "mor", "rate", "winner", "error", "sc", "fit", "price", "draw", "level", "confidence", "code", "scoring", "Score", "result", "width", "loss", "size", "feature", "rank", " Score", "test", "key", "count", "rice", "ner", "status", "grade", "match", "message"], "dataScore": ["DataResult", " dataWeight", " dataSource", "errorSource", "singleScore", "singleSum", "DataSize", "imageScore", " dataUse", " dataSize", " dataResult", "dataLine", "inputGrade", "imageWeight", "DataMatch", "imageResult", "DataWeight", "dataMatch", "DataLength", "dataWeight", "singleGrade", "DataSource", " dataMatch", "dataSize", "indexUse", "singleLength", " dataLine", "dataGrade", " dataSum", "videoLength", "dataLength", "DataScore", "imageSize", "videoMatch", "inputLength", "dataSum", "indexScore", "videoSize", "videoScore", "DataSum", "DataUse", " dataGrade", "indexGrade", "dataResult", "dataSource", "DataGrade", "dataUse", "inputSum", " dataLength", "indexMatch", "errorScore", "errorSize", "inputScore", "DataLine", "errorLength"], "metaboliteID": ["metabolitableID", "metabolriteSecret", "metabolriteIP", "metovalriteID", "metronitionId", "metabolitationID", "metabolitesName", "metovalriteString", "metabolitionName", "metabolitationKey", "metaboluteid", "metaboliticSecret", "metovalriteKey", "metabolitationName", "metaboliteString", "metronitionName", "metabolitableId", "metaboliticID", "metaboliteId", "metabolriteName", "metovaliteid", "metronitionIP", "metabolteId", "metabolteName", "metabolitationId", "metaboluteKey", "metaboluteId", "metovalriteId", "metovalriteid", "metabolteID", "metabolitesID", "metaboliteid", "metabolteKey", "metabolitableString", "metaboluteID", "metabolriteid", "metabolitesIP", "metronitionID", "metabolriteID", "metovaliteSecret", "metaboliticString", "metaboliteSecret", "metaboliteKey", "metroniteId", "metabolitionIP", "metroniteID", "metovaliteKey", "metroniteIP", "metabolitionId", "metroniteName", "metabolitableSecret", "metaboliticId", "metovaliteId", "metabolideKey", "metabolitesId", "metovaliteString", "metaboliteName", "metabolideId", "metovaliteName", "metabolideid", "metabolriteString", "metaboliteIP", "metabolriteKey", "metovaliteID", "metovalriteName", "metabolitionID", "metabolideID", "metabolriteId", "metovalriteSecret"], "data": ["video", "content", "ui", "uri", "alpha", "string", "source", "sample", "resource", "empty", "div", "pad", "response", "zip", "input", "text", "json", "value", "array", "error", "raw", "missing", "style", "results", "image", "buffer", "media", "done", "code", "batch", "ata", "size", "cache", "DATA", "picture", "body", "split", "area", "info", "map", "dat", "message"], "molecularWeight": ["molesculeWeight", "moleuralFlow", "molesularWeight", "molecheRank", "moleculeRank", "moleularWeight", "moleularFlow", "molescularWeight", "molecularFlow", "molecularRank", "molecheWeight", "molescularRank", "molesculeRank", "moleuralWeight", "molescularFlow", "moleularRank", "moleculeWeight", "moleculeFlow", "molesularFlow"]}}
{"id1": "16825994", "id2": "19096138", "code1": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"out": ["ext", "cl", "sync", "OUT", "prefix", "cfg", "string", "con", "output", "diff", "password", "cli", "list", "writer", "parent", "Out", "base", "p", "array", "error", "conn", "file", "plain", "url", "part", "w", "temp", "bin", "err", "gz", "io", "comment", "up", "obj", "client", "cmd", "c", "exec", "outs", "result", "In", "cache", "log", "inc", "ch", "ex", "config", "again", "info"], "srcDir": ["srcFolder", "srcdir", "sourcePath", "sourceFolder", "rcDirectory", "srcDirectory", "rcdir", " srcFolder", "sourceDir", " srcdir", "rcPath", " srcPath", "srcPath", "rcDir", "rcFolder", " srcDirectory", "sourceDirectory", "sourcedir"], "conf": ["ca", "ctx", "cm", "Config", "cl", "cert", "f", "cfg", "ref", "cf", "ssl", "lc", "Conf", "con", "cn", "host", "bc", "cli", "init", "binary", "cp", "base", "file", "conn", "sc", "com", "cb", "err", "client", "conv", "obj", "c", "cc", "fi", "af", "cache", "log", "pool", "ch", "def", "ini", "config", "info", "global", "fs"], "srcFS": ["sourceTS", "rcfs", " srcTS", " srcDF", "sourceFS", "rcDF", "srcFs", " srcfs", "srcfs", "sourcefs", "rcFs", "srcDF", "sourceDF", "sourceFs", "srcTS", "rcTS", "rcFS", " srcFs"], "contents": ["intries", "indls", "CONTitions", "extents", "Contens", "Contances", "intls", "condences", "extons", "extances", "continent", "content", "extensions", "Contries", "contensions", "contacts", "contls", "contENTS", "intencies", "contances", "CONTants", "extacts", "Contitions", "CONTlements", "intacts", "continENTS", "intensions", "intons", "extries", "Contencies", "intlements", "extencies", "contries", "indents", "contlements", "Contons", "contencies", "continents", "continitions", "contens", "contants", "compents", "CONTENTS", "Contensions", "ContENTS", "condents", "indants", "contitions", "CONTens", "Contacts", "intants", "condens", "compens", "contences", "compences", "intents", "contons", "condent", "CONTls", "indlements", "Contents", "intances", "continences", "compent", "continens", "CONTents"], "i": ["hi", "phi", "f", "length", "x", "d", "it", "ui", "ti", "uri", "ie", "bi", "lc", "ci", "gi", "qi", "slice", "di", "h", "iv", "abi", "pi", "xi", "p", "v", "sup", "ai", "part", "ix", "u", "m", "k", "iu", "yi", "io", "inner", "ip", "ii", "y", "o", "b", "ri", "I", "c", "multi", "fi", "j", "l", "start", "n", "si", "vi", "key", "li", "ini", "oi", "ji", "index", "info", "e", "id"], "in": ["gin", "anc", "d", "serv", "data", "isin", "g", "socket", "inn", "source", "con", "input", "inas", "kin", "min", "din", "conn", "lin", "reader", "part", "rin", "ins", "impl", "bin", "inner", "image", "c", "exec", "as", "l", "In", "stream", "cin", "inc", "ac", "IN", "nin", "ini", "r", "ex", "login", "again", "id"]}}
{"id1": "12236729", "id2": "2668634", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"inputFile": ["outputFiles", "outputfile", "sourcePath", "inputfile", "currentDir", "currentFile", "inputFiles", " inputDir", "sourceFiles", "currentFiles", "inputDir", " inputfile", " inputPath", "outputPath", "inputPath", " inputFiles", "outputDir", "sourceFile", "sourcefile", "currentfile"], "outputFile": ["tempFile", "OutputFile", "referenceFilename", "outputfile", " outputFilename", "Outputfile", "OutputDirectory", "inputfile", "OutputDir", "referenceDir", " outputfile", "tempDirectory", "outputDirectory", " outputDir", "tempDir", "referencefile", "inputDir", "outputFilename", "tempfile", "outputDir", "inputFilename", "referenceFile", " outputDirectory"], "in": ["gin", "f", "a", "pull", "socket", "inn", "source", "i", "ln", "con", "sin", "read", "is", "input", "init", "kin", "lock", "min", "din", "conn", "lin", "file", "reader", "ins", "bin", "into", "err", "connection", "inner", "get", "s", "image", "up", "inside", "as", "l", "win", "In", "n", "cin", "inc", "IN", "nin", "ini", "r", "login", "again", "pin", "e", "id"], "out": ["sync", "OUT", "socket", "i", "output", "off", "plus", "line", "writer", "parent", "Out", "v", "file", "conn", "error", "plain", "w", "temp", "bin", "one", "err", "net", "io", "up", "obj", "o", "b", "outside", "outs", "write", "exec", "outer", "over", "n", "cache", "inc", "post", "at", "log", "ex", "copy", "extra", "again", "null"], "c": ["cm", "cl", "f", "d", "cu", "a", "x", "cf", "lc", "i", "ci", "C", "line", "cr", "pc", "character", "ce", "fc", "p", "cy", "v", "esc", "sc", "u", "ct", "m", "k", "char", "code", "ec", "cd", "o", "b", "cc", "l", "rc", "n", "ch", "xc", "count", "uc", "r", "pointer", "col", "e", "id"]}}
{"id1": "23672408", "id2": "23452437", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"clazz": ["sloss", "clod", "closs", "elaz", "loser", " clobe", "classe", "chou", "Clott", "slod", " clclass", "Clone", "CLod", "elazz", "laone", "Clclass", "lasse", "sllass", " claz", "ploser", "Cllass", "CLazz", "flance", "chaz", "Claz", "Classe", "plazz", "Closs", "slaz", "CLobe", "chazz", "slazz", "closer", "lazz", "sloser", "plclass", "CLaz", "laoss", "Clou", "chott", "laz", "clobe", "CLosing", "CLlass", "closing", "llass", "slone", "clott", "clou", "klaz", "klod", "klazz", "fllass", "elott", "Clazz", "CLoser", "lance", " cllass", "laazz", "slosing", "Closer", "clance", "flazz", "floser", "cllass", " closer", "klosing", "claz", "clclass", "laclass", "pllass", "clone", " clance", "Clance", " classe", "slobe", "slclass", "elou"], "i16": ["ini33", "id2016", "ii14", "idi1600", "i14", "ini14", "si1600", "ii20", "ii1600", "idi64", "isi14", "i33", "id15", "si33", "si16", "id16", "si15", "ii160", "i160", "ini16", "i15", "si14", "isi16", "ii16", "I15", "ii33", "isi1600", "ini2016", "i2016", "si160", "i20", "i1600", "I1600", "si20", "i64", "si2016", "ini160", "I16", "ii15", "idi16", "ini15", "I14", "ini20", "idi15", "si64", "isi15", "ii64", "id14"], "fileType": [" fileTyp", "featureTyp", "eventTy", "ileType", "playTyp", "imageTime", "fileTyp", "messageTy", "lineType", "fileTy", "fileTypes", "iconType", "channeltype", "eventTyp", "eventSize", "functionSpread", "iconSize", "pathType", "functionType", "filetype", " fileTime", "fileLike", "FILEBlock", "filePatch", "messagetype", "imageName", "lineTyp", "featureType", "fileRel", " filetype", "filePath", "iletype", "FILESize", "FILEType", "fileForce", " fileTy", "imageType", "fileClass", "pathtype", "featureBlock", "channelForce", "fileTime", "channelType", "playPath", "FileBlock", "eventPatch", "fileSpread", "ileTypes", " fileClass", "iconPatch", "channelClass", "pathName", "alLike", "lineSize", "messageType", "featureSize", " fileName", "featureRel", " filePath", " fileSpread", "linePath", "channelTyp", "channelTy", " fileBlock", "FileRel", "FILEPatch", "channelSpread", "eventType", "featureTy", "functionForce", " fileInfo", "fileSize", "featureInfo", "functionTyp", "imageLike", "ileLike", "fileInfo", " fileForce", "imageTypes", "eventBlock", " fileRel", "fileBlock", "altype", "messageClass", "fileName", "alTypes", "alType", "pathTime", "playSize", "playType", "imagetype", "iconBlock", " fileSize", "FileType", "FileInfo"], "desti16": ["deleteI16", "deleteI160", "deletei1600", "deletei116", "destu66", "desci16", "destii15", "destidi160", "destabi16", "destidi1600", "destii66", "destii16", "destabi160", "descu16", "descu166", "deste166", "desci15", "desti15", "destii166", "destu15", "desti1600", "deste16", "desti116", "destI16", "descu66", "destidi16", "deleteI116", "destI1600", "destu166", "deleteI1600", "deletei16", "deletei160", "destI116", "desci166", "desti66", "destabi116", "desti160", "deste15", "destu16", "descu15", "destI160", "destidi116", "desti166", "deste66", "destabi1600", "desci66"], "src": ["uri", "ssl", "sb", "usr", "http", "sl", "input", "url", "sc", "rss", "bot", "sel", "download", "crop", "uv", "view", "config", "sys", "kk", "target", "rest", "inf", "sync", "data", "source", "upload", "tmp", "iv", "lib", "console", "rob", "dest", "desc", "thumbnails", "img", "cdn", "gz", "archive", "stream", "ctr", "r", "pull", "video", "ctx", "st", "rb", "content", "gb", "resource", "output", "buf", "dist", "secure", "load", "front", "req", "func", "gl", "cb", "sq", "proc", "start", "ource", "scene", "default", "coll", "back", "inst", "filename", "remote", "sr", "impl", "image", "acl", "obj", "b", "rc", "cmp", "scenes", "cur", "loc", "rl", "https", "null"], "dst": ["dsts", "sdput", "dind", "sdbl", "dtd", "dibl", "hdst", "edost", " dbl", "DST", "edst", "edST", "Dsts", "madST", "dost", "madstore", "dedput", "fsp", " dtd", "edstore", "madost", " dput", "dedsc", "dsc", "dedst", "dnt", "fbl", "pput", "sddest", " dsc", "Dost", "idbl", "dest", "sdst", "sdsc", "hdnt", "Dst", "hdest", " dnt", "dist", "idsp", "Dbl", "pst", "dST", "Dstore", "sdnt", "idst", "ditd", "dnd", "dedbl", "hddest", "Dnd", " dost", "dstore", " dest", "idost", "dput", "fst", " dnd", "dbl", "Dput", "Dsp", "Dtd", " ddest", "psts", "ddest", "post", "madst", "dsp", "sdest", " dsts", "fost"], "i32": ["in34", "l34", "iu32", "in32", "pi34", "i36", "e33", "ui34", "l32", "e52", "pi33", "ui31", "in31", "i33", "u32", "l33", "u31", "i35", "ui32", "iu34", "e40", "int35", "i31", "int40", "pi52", "e32", "i52", " i35", "iu31", "in16", " i31", " i36", "int36", "e34", "ui16", "l52", " i34", "int32", "e35", " i40", "pi32", "e36", "pi31", "i34", "u33", "iu33", "i40", "u34"], "desti32": ["destii29", "sourcei15", "sourcei30", " Destin34", "destin34", " Destin32", "destidi34", "destidi30", "destin32", " Desti29", "sourceiu32", "deste34", "desti31", " Destin31", "desti15", "desti34", "deste32", "destii32", "destiu34", "deste30", "destiu32", "sourceiu34", " Desti34", "destii31", "desti30", "destidi15", "deste15", "destiu30", " Desti31", "destin29", " Destin29", "sourcei32", "destin31", "sourcei34", "sourceiu15", "destidi32", "destiu31", "destiu29", "desti29", "sourceiu30", " Desti32", "destiu15", "destii34"]}}
{"id1": "14188043", "id2": "3375718", "code1": "    public static byte[] openHttpResult(String urlPath, boolean retry) throws IOException {\n        AQUtility.debug(\"net\", urlPath);\n        URL url = new URL(urlPath);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setUseCaches(false);\n        connection.setInstanceFollowRedirects(true);\n        connection.setConnectTimeout(NET_TIMEOUT);\n        int code = connection.getResponseCode();\n        if (code == 307 && retry) {\n            String redirect = connection.getHeaderField(\"Location\");\n            return openHttpResult(redirect, false);\n        }\n        if (code == -1 && retry) {\n            return openHttpResult(urlPath, false);\n        }\n        AQUtility.debug(\"response\", code);\n        if (code == -1 || code < 200 || code >= 300) {\n            throw new IOException();\n        }\n        byte[] result = AQUtility.toBytes(connection.getInputStream());\n        return result;\n    }\n", "code2": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "label": 0, "substitutes": {"urlPath": ["UrlCase", " urlInfo", "httpPath", "urlFile", "uripath", "httpHome", "uriPath", "URLPath", "filePath", "UrlHome", " urlpath", "urlCase", " urlText", "lPath", "uriFile", "Urlpath", "runpath", "fileName", "httpCase", "urlHome", "URLpath", "httppath", "resourceFile", "fileFile", "uriName", " urlPoint", "resourceName", "urlText", " urlHome", "UrlPoint", "lInfo", "UrlText", "UrlPath", "urlName", " urlCase", "URLText", "filepath", "urlPoint", "runInfo", "urlInfo", "runPath", "resourcePath", "resourcepath", "URLPoint", "lpath", "urlpath"], "retry": ["rery", "refrying", "retri", "detried", "refri", "pretri", "rtried", "rtri", "reone", "refry", " retried", "relone", " retrow", "relrying", "retrow", "pretried", "detri", " retri", "detrying", "retone", "reltry", "retrying", " retone", "rtrow", "refried", "Retrying", "rettry", "Retried", "retried", "relry", "Retri", "pretrow", "detry", "rerying", " rettry", " retrying", "Retry", "pretry", "rtry"], "url": ["f", "user", "uri", "service", "ssl", "string", "lc", "connect", "web", "resource", "source", "con", "path", "server", "http", "entry", "org", "sl", "URL", "base", "conn", "file", "page", "www", "image", "client", "channel", "relation", "c", "util", "l", "link", "Url", "log", "loc", "li", "config", "proxy"], "connection": ["application", "session", "Connection", "wrapper", "number", "f", "union", "condition", "socket", "uri", "user", "lc", "connect", "resource", "section", "con", " Connection", "handler", "response", "http", "server", "character", "cli", "nc", "text", "context", "communication", "function", "creator", "database", "event", "error", "conn", "co", "object", "io", "image", "nn", "connected", "client", "channel", "relation", "c", "b", "close", "l", "link", "ion", "component", "cache", "index", "loc", "driver", "body", "config", "use", "proxy", "info"], "code": ["cm", "version", "x", "bug", "content", "cod", "check", "ie", "last", "orig", "cycle", "ception", "go", "success", "sec", "line", "reason", "response", "id", "dec", "see", "zip", "ce", "cause", "zone", "nc", "desc", "score", "error", "Code", "expected", "co", "se", "sc", "type", "one", "call", "state", "level", "change", "force", "done", "stage", "charge", "order", "coord", "c", "codes", "pri", "close", "cc", "size", "mode", "rc", "age", "test", "xx", "coded", "key", "count", "fe", "complete", "index", "ode", "status", "create", "grade", "e", "message"], "redirect": ["redanch", "transirection", " redrict", "redition", "codedirection", " redirection", "transirect", "codedirect", "transition", "refanch", "refirection", "Redanch", "redrict", "refirect", "transef", "redirection", "redef", "refrict", "codedef", "codedition", " redef", " redition", "Redirect", " redanch", "Redirection", "Redrict"], "result": ["data", "content", "request", "string", "source", "resource", "success", "output", "diff", "str", "response", "message", "entry", "answer", "value", "load", "array", "error", "page", "err", "comment", "results", "image", "buffer", "Result", "up", "instance", "rc", "df", "work", "cache", "ret", "report", "r", "record", "continue", "default", "object", "status", "grade", "match", "dict"]}}
{"id1": "10131427", "id2": "14598566", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"in": ["a", "data", "inn", "source", "i", "resource", "diff", "input", "again", "base", "min", "file", "url", "reader", "ins", "bin", "m", "inner", "io", "image", "buffer", "name", "c", "b", "or", "In", "work", "at", "inc", "ac", "IN", "ini", "ex", "copy", "index", "config", "login", "id"], "out": ["target", "prefix", "OUT", "x", "data", "point", "string", "source", "output", "off", "writer", "dest", "Out", "base", "p", "v", "file", "conn", "part", "w", "temp", "connection", "io", "image", "buffer", "name", "client", "o", "c", "outs", "exec", "external", "n", "cache", "at", "ex", "copy", "object"], "sourceChannel": ["srcManager", "sourceChan", "ourceChannel", "sourceManager", "Sourcechannel", "srcConnection", "ourceChan", " sourceConnection", " sourceManager", "srcChannel", "SourceChannel", "sourceStream", "targetChannel", "SourceStream", "SourceConnection", "sourceQueue", "targetStream", " sourceStream", "SourceManager", "sourceConnection", "srcSocket", "SourceQueue", " sourceSocket", "SourceChan", "srcStream", "targetChan", "srcChan", "srcQueue", "SourceSocket", "sourcechannel", " sourcechannel", " sourceQueue", " sourceChan", "ourceStream", "targetchannel", "ourcechannel", "sourceSocket"], "destinationChannel": ["DestinatorChan", "destinatorCh", "DestinatorStream", "destinationchannel", "destinatorchannel", "destinationConnection", "DestinationConnection", "DestinatorConnection", "destinateStream", "destinationCh", "destinateChannel", "destinatorStream", "destinatedChannel", "DestinationChan", "destinateConnection", "destinationStream", "DestinatorCh", "destinatedCh", "destinatorConnection", "DestinationStream", "destationConnection", "destinatorChannel", "destinationsStream", "destinatedConnection", "destationchannel", "DestinatorChannel", "destinatechannel", "destationCh", "destinatedChan", "destationChannel", "destinatorChan", "destinationschannel", "destinationsConnection", "DestinationCh", "destationChan", "Destinationchannel", "Destinatorchannel", "destinationsChannel", "DestinationChannel", "destinationChan"]}}
{"id1": "10385815", "id2": "6421904", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fileFrom": ["FileTo", "ioTo", " fileStart", "fileAs", "mailFrom", "FileSource", "FileStart", "ioStart", "fileIn", "FileAs", " fileIn", "FileFrom", "ioSource", " fileAs", "mailAs", "mailIn", "FileIn", " fileSource", "mailTo", "fileStart", "fileSource", "ioFrom"], "fileTo": ["fpto", "FileTo", "FileTO", "fpTo", "fpFrom", "fpTO", "FileFrom", "fileTarget", "Fileto", "fileto", "fileTO", "resourceTarget", "resourceFile", "fileFile", "resourceFrom", " fileFile", "FileFile", "FileTarget", " fileTO", "resourceTo", " fileTarget", " fileto"], "inputStream": ["inputSync", "inputstream", "outputFile", " inputSync", "inputContext", "InputSync", "Inputstream", "outputSteam", "outputstream", "inputSteam", "InputFile", "InputContext", "InputStream", " inputstream", " inputFile", "outputSync", " inputSteam", "InputSteam", "inputFile", "outputContext", " inputContext", "InputChannel"], "outputStream": ["writeChannel", "OutputPath", "referenceSteam", "OutputChan", "writeSocket", "OutputStream", "outputSteam", "inputSteam", "OutputChannel", "referenceStream", " outputStreamer", "referenceSocket", "referenceChannel", "outputSocket", "OutputSteam", "OutputStreamer", "outputPath", "writeSteam", "outputStreamer", "inputPath", "inputChan", "fourStreamer", "fourChannel", " outputChan", "fourStream", "outputChan", "writeStream", " outputPath", " outputSteam", "fourSteam", "inputSocket"], "inputChannel": ["butChannel", "outputCam", "parentStream", "inputContext", "audioClient", "outputClient", "InputSocket", "InputContext", " inputPassword", "parentPassword", "inputCam", "InputStream", "butCommand", "audioCam", "inputClient", " inputSocket", "parentChan", "outputCommand", "outputSocket", " inputCommand", "inputPassword", "audioStream", "outputPassword", "inputChan", "audioChannel", " inputChan", "outputContext", " inputContext", "butChan", " inputClient", "outputChan", "InputChan", "parentChannel", " inputCam", "inputSocket", "InputChannel", "inputCommand", "butContext"], "outputChannel": [" outputQueue", "outStream", "outContext", "inputchannel", " outputchannel", " outputContext", "inputContext", "OutputChan", "OutputStream", "OutputContext", "outChan", "OutputChannel", "outChannel", "OutputQueue", "Outputchannel", "outputchannel", "inputChan", "outputQueue", "outputContext", " outputChan", "inputQueue", "outputChan"]}}
{"id1": "19584877", "id2": "5414088", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"infile": ["inputfp", "Infiles", "inputfilename", "infilename", " infilename", " infiles", "outfp", "inputfile", "inputfiles", "inFile", "infp", "Infile", "Infilename", "infiles", " infp", "InFile", "inputFile", "outFile", "outfilename", "outfiles"], "outfile": ["Outfile", "outputfilename", " outfolder", "infilename", " outfp", "outputfile", "OutFile", "outfp", "infolder", "newFile", " outFile", "infp", " outfilename", "outfolder", "newfolder", " outname", "outputfp", "Outname", "Outfolder", "outputfolder", "outFile", "outname", "outfilename", "newfile", "newname"], "in": ["gin", "vin", "a", "re", "data", "isin", "socket", "inn", "source", "i", "thin", "ic", "con", "sin", "is", "input", "init", "inas", "base", "min", "din", "conn", "reader", "rin", "ins", "bin", "m", "into", "err", "inner", "s", "image", "b", "inside", "as", "win", "In", "pass", "cin", "inc", "ac", "IN", "nin", "ini", "r", "login", "again", "pin", "id"], "out": ["session", "sync", "OUT", "socket", "point", "home", "no", "source", "output", "exit", "on", "off", "line", "lib", "writer", "parent", "Out", "base", "ou", "error", "file", "conn", "co", "timeout", "bin", "one", "err", "net", "io", "to", "inner", "image", "name", "up", "client", "job", "o", "obj", "outs", "exec", "write", "or", "outer", "In", "work", "cache", "inc", "post", "ex", "copy", "again"], "buffer": ["queue", "border", "address", "length", "uffer", "data", "flush", "reference", "bb", "source", "wave", "feed", "slice", "layer", "server", "limit", "iter", "buff", "buf", "fb", "input", "binary", "len", "value", "base", "raw", "transfer", "url", "reader", "type", "offset", "seed", "Buffer", "batch", "bytes", "b", "write", "result", "size", "cache", "split", "count", "padding", "null"], "read": ["lex", " write", "f", "length", "x", "sync", "allow", "next", " copy", "find", "ad", "check", "parse", "i", "Read", "connect", "send", "end", "feed", "tell", "slice", "ind", "limit", "iter", "input", "wait", "len", " Read", "reading", "load", "add", "raw", "sleep", "reader", "select", "play", "se", "fill", "seek", "io", "get", "ride", "READ", "ip", "_", " count", "write", "exec", "close", "size", "reads", "start", "work", "n", "pass", "run", "inc", "current", "count", "copy", "use", " skip", "id"], "success": ["primary", "growth", "construct", "better", "data", "content", "follow", "fast", "flash", " succ", "successful", "status", "cess", "path", "rolling", "response", "valid", "model", "rolled", "initial", "fail", " successful", "value", "modified", "failed", "ccess", "roll", "func", "respons", "winner", "error", "first", "true", "method", "danger", "comment", " succeed", "results", "warning", "open", "done", "right", " Success", "ceed", "result", "successfully", "good", "Success", "pass", "xx", "complete", "continue", "default", "again", "null", "message"]}}
{"id1": "22855019", "id2": "8801182", "code1": "    public static MessageService getMessageService(String fileId) {\n        MessageService ms = null;\n        if (serviceCache == null) init();\n        if (serviceCache.containsKey(fileId)) return serviceCache.get(fileId);\n        Properties p = new Properties();\n        try {\n            URL url = I18nPlugin.getFileURL(fileId);\n            p.load(url.openStream());\n            ms = new MessageService(p);\n        } catch (Exception e) {\n            ms = new MessageService();\n        }\n        serviceCache.put(fileId, ms);\n        return ms;\n    }\n", "code2": "    private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception {\n        Properties list = new Properties();\n        list.load(new FileInputStream(fileWithListOfImages));\n        long current = 0;\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir);\n        System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\");\n        System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\");\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\");\n        }\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            URL url = new URL(uriPrefix + urlString);\n            File file = new File(outputDir + \"/\" + imageNameToFileName(urlString));\n            current++;\n            if (!file.exists()) {\n                try {\n                    BufferedInputStream in = new BufferedInputStream(url.openStream(), 64000);\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file), 64000);\n                    int c;\n                    while ((c = in.read()) != -1) {\n                        out.write(c);\n                    }\n                    out.close();\n                    in.close();\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                    System.out.println(\"saved\");\n                } catch (Exception e) {\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", FAILED, error: \" + e.getMessage());\n                }\n            } else {\n                System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                System.out.println(\"already exists\");\n            }\n            if (current / 100 == current / 100.0) {\n                long delta = (System.currentTimeMillis() - startTime);\n                System.out.println(\"Total time \" + delta + \" ms, \" + (delta / current) + \" ms/file\");\n            }\n        }\n        long delta = (System.currentTimeMillis() - startTime);\n        System.out.println(\"Total time \" + delta + \" ms, \" + (delta / list.size()) + \" ms/file\");\n    }\n", "label": 0, "substitutes": {"fileId": ["FILEInit", "fileid", "messageDef", "messageid", "FILEPart", " fileEnd", "moduleDef", "connectionid", " fileDef", "logPart", "fileDef", "FileID", "logId", "Fileid", "FILEEnd", " fileKey", "connectionString", "messageId", "urlId", "fileInit", " fileType", "ilePart", "ileId", "urlInit", " fileid", " fileInit", "ileData", " fileData", "connectionID", "FILEKey", "urlType", "FILEId", "connectionId", "moduleid", "filePart", "FILEContext", "fileString", "FILEType", "FILEid", "fileData", "logid", "FILEData", "fileID", "urlKey", "FileString", "ileEnd", " fileString", " filePart", "fileContext", "logContext", "fileType", " fileContext", "moduleId", "fileKey", " fileID", "FileId", "fileEnd"], "ms": ["cm", "cs", "Ms", "MS", "g", "pm", "service", "PS", "es", "ems", "ds", "hs", "mos", "us", "is", "mm", "ys", "ics", "mes", "bs", "bm", "vs", "ns", "ils", "ma", "sp", "gs", "ls", "ams", "ims", "manager", "m", "qs", "s", "cms", "services", "ws", "xs", "md", "ips", "rs", "ss", "ps", "ts", "me", "models", "ports", "js", "mi", "mc", "mo", "fs", "e", "ks"], "p": ["pb", "f", "plugin", "data", "lp", "pm", "i", "per", "pe", "pc", "t", "pp", "pr", "cp", "pro", "pi", "op", "fp", "properties", "wp", "bp", "sp", "u", "m", "ip", "vp", "py", "pre", "c", "np", "po", "j", "l", "ps", "jp", "cache", "parser", "tp", "api", "r", "P", "ap", "info", "e"], "url": ["f", "bel", "plugin", "data", "user", "uri", "service", "ssl", "string", "source", "i", "resource", "web", "path", "feed", "server", "http", "entry", "ur", "org", "sl", "zip", "URL", "base", "file", "page", "u", "m", "connection", "image", "open", "channel", "c", "b", "browser", "l", "stream", "Url", "key", "api", "config", "fl", "e", "id"]}}
{"id1": "8046691", "id2": "23677142", "code1": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "code2": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "label": 0, "substitutes": {"url": ["loader", "address", "user", "uri", "src", "ssl", "string", "source", "resource", "document", "path", "feed", "host", "contact", "server", "http", "ur", "org", "sl", "URL", "html", "base", "file", "page", "www", "gl", "object", "location", "connection", "io", "buffer", "image", "channel", "email", "l", "download", "stream", "Url", "ll", "log", "loc", "config", "proxy", "pull"], "link": ["loader", "ref", "uri", "lc", "flash", "path", "http", "entry", "block", "type", "tail", "self", "open", "code", "machine", "build", "download", "ink", "auto", "config", "index", "model", "address", "sync", "data", "service", "parse", "source", "slice", "base", "file", "connection", "ee", "set", "Link", "pack", "log", "local", "li", "key", "LI", "info", "pull", "check", "line", "layer", "db", "di", "list", "load", "add", "or", "cache", "proxy", "object", "match", "message", "bug", "user", "low", "links", "flow", "feed", "sign", "lock", "head", "error", "inline", "linked", "location", "call", "style", "image", "name", "route", "skip", "l", "light", "post", "loc"], "httpConn": ["httpsConnect", "perconn", " httpCan", "HttpConnection", "HttpConnector", "phpConnection", "httpConnect", "HttpExec", "workConnector", "httpCon", "buildCmd", "buildCt", " httpConnection", "httpCons", "perCt", "cacheConnect", " httpConnect", "urlCt", "fullconn", "phpCan", "httpCan", "buildConnect", "HttpConnect", "scheConfig", " httpCon", " httpConnector", "scheConnection", "cacheConfig", "workConnect", " httpConfig", "webConnection", "buildCod", "webCmd", "physconn", "workConn", "httpsConnection", "perConn", "perCon", "httpConnection", " httpCod", "perConfig", "buildConfig", "buildConnector", "serverConnect", "webCt", "workConnection", "httpCod", "phpConnect", "webConnect", "cacheConn", "urlCon", "httpCmd", "physCons", " httpconn", "fullConn", "physConnection", "serverConnection", "urlConnect", "httpExec", "httpsConn", " httpCt", "perConnection", " httpCons", "serverConn", "httpconn", " httpCmd", "buildConn", "webCons", "HttpConn", "HttpCan", "scheCod", "serverCon", "httpConnector", "buildConnection", "webExec", "buildconn", "webConn", "Httpconn", "perConnect", "urlConn", "phpConn", "urlConnection", "physConn", "httpCt", "scheConn", "webconn", "fullConnection", "httpsCt", "cacheConnection", " httpExec", "fullCon", "httpConfig"], "outs": ["pins", "OUT", "bits", "data", "lines", "INS", "output", "blocks", "limits", "cos", "boxes", "gets", "writer", "groups", "reports", "its", "opens", "Out", "utils", "errors", "flows", "bs", "conn", "in", "ns", "ils", "fits", "events", "ins", "timeout", "css", "steps", "qs", "io", "results", "sets", "services", "ws", "ios", "forms", "ops", "details", "runs", "ips", "works", "plugins", "cache", "ports", "strings", " out", "out", "again", "options", "posts", "locks"], "bins": ["fout", "palls", "pins", "wbouts", "rbout", "balls", "fains", "rbins", "rains", "fouts", "bout", "bINS", "pouts", "fins", "Bains", " balls", "bains", "rins", "Bins", " bains", " bINS", "pains", "rbouts", "rbains", "wbains", "rINS", "Bouts", "wbins", "BINS", "wbout", "Balls"], "bouts": [" bout", "bbaos", "bbouts", "Baos", "bops", "bbIns", "BIns", "bbops", "bout", "bbout", "bbins", "Bins", " baos", "Bout", "baos", " bIns", " bops", "bIns", "Bouts", "Bops"], "postData": [" postArray", "formdata", "Postdata", "rowData", "POSTContent", "postString", "formDATA", "rowArray", "postArray", " postBody", "POSTBody", "rowBody", "postBody", "POSTData", "PostString", "PostData", "postedDATA", "postedData", "postedBody", "readQuery", "postDATA", " postdata", " postQuery", "PostQuery", " postContent", "POSTArray", "readdata", "postQuery", "postdata", "postContent", " postString", "posteddata", "readString", "formData", "readData", "formBody", "PostBody", "PostDATA", "rowContent"], "mimePattern": ["mIMEModel", "mimesRule", "mIMEPattern", " mimeModel", "MimeParser", "mimeParser", " mIMEPattern", " mIMEpattern", "morphpattern", "mimeModel", "morphRule", "mimepattern", "MimePattern", "mimesParser", "mimParser", "morphPattern", "mimesPattern", "mimpattern", "mimespattern", "mimPattern", "MimesRule", "mangleModel", "MimesParser", "morphParser", " mIMEModel", "mimesModel", "MimesPattern", "mimRule", "Mimepattern", "manglePattern", "MimeRule", "mimeRule", "mIMEpattern", "manglepattern", " mimepattern", "Mimespattern"], "matcher": [" matches", " Matched", " matchy", "matchches", "regatch", "patatch", " matched", "Matchers", "matchers", "patchers", "patches", "mather", "matched", " mather", "patcher", " matchers", "Matcher", "Matchy", "matchher", " Matchers", "regchers", "regcher", "matchy", "matchchy", "matches", "regches", "Mather", " Matcher", "Matched", "Matatch", "Matches", "matchcher", "matatch", " Matches"], "byteBuffer": ["bitBuff", "ByteBuff", "bitLength", " byteArray", "bufferBuffer", "bufferPad", "byteBuilder", "layerBuilder", "layerBuffer", "ByteLength", "bitArray", " byteLength", "byteBuff", "ByteBuffer", " byteBuff", "ByteArray", "bufferBuff", "byteArray", " byteBuilder", "bitBuffer", "byteLength", "ByteBuilder", "layerArray", "BytePad", "layerBuff", " bytePad", "bytePad", "bufferLength"], "count": ["number", "f", "length", "a", "allow", "child", "found", "depth", "core", "cond", "low", "last", "counter", "string", "more", "weight", "i", "end", "ind", "label", "limit", "col", "list", "len", "group", "parent", "base", "file", "num", "part", "keep", "type", "now", "level", "offset", "Count", "code", "name", "c", "b", "skip", "match", "build", "all", "l", "size", "sum", "start", "max", "n", "current", "pool", "cache", "key", "ch", "val", "index", "default", "C", "e", "id"]}}
{"id1": "7872659", "id2": "11968328", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"completePath": ["completeRoot", "completeHome", "CompleteDir", "successpath", "successMusic", " CompletePath", "completeCh", "flatCorp", "iteMusic", "correctPoint", "execpath", " CompleteFile", "successPath", "completeCorp", "execVol", " completeMusic", " CompleteDir", " completeDir", "completeVol", "CompleteFile", "successCh", " completePoint", " completepath", "correctRoot", "flatPoint", "correctPath", "CompleteHome", "progressPath", "execPath", "itepath", "execLoader", "completeDir", "completePoint", "flatRoot", "progresspath", " CompleteHome", "itePath", "CompletePath", "doneVol", "completeFile", "completepath", "donePath", "doneLoader", "completeMusic", "iteCh", "correctCorp", "donepath", " completeRoot", "flatPath", "completeLoader", " completeCorp", "progressVol", " completeFile", " completeHome", "progressLoader", " completeCh"], "masterFile": ["MasterFilename", " masterFilename", "configName", "MasterFiles", "masterFiles", "masterName", "cacheFiles", "masterFILE", "cacheFILE", "mastersPath", "configFile", "MasterPath", "configFilename", "cachePath", "cacheFile", "masterPath", "mastersFile", "mastersFiles", "MasterFile", "mastersFILE", " masterPath", "MasterName", "configPath", "masterFilename", " masterName", "MasterFILE"], "CustRatingFileName": ["CustRatingClassVersion", "CustRateFileDesc", "CustRateFileName", "CustRateFilenameDesc", "CustIndexFilesPath", "CustRatingFilesPath", "CustRatingFilenameSize", "CustIndexFilePath", "CustRatingFullSize", "CustRatingFileType", "CustRateFileSize", "CustRateFilenamePath", "CustRatingFilesSize", "CustRatingFilenamePath", "CustIndexFileName", "CustRatingFilesDesc", "CustRatingLineType", "CustRatingLineName", "CustRatingFilesType", "CustIndexFileVersion", "CustIndexFilesType", "CustRatingFileDesc", "CustRatingFilenameDesc", "CustRateFilenameSize", "CustRateFilePath", "CustRatingFilePath", "CustRateFilenameName", "CustRatingFullPath", "CustIndexFilesName", "CustRatingFileVersion", "CustRatingFullDesc", "CustRatingFilesVersion", "CustRatingFilesName", "CustRatingFileSize", "CustIndexFileType", "CustRatingLinePath", "CustRatingClassName", "CustIndexFilesVersion", "CustRatingFilenameName", "CustRatingFullName", "CustRatingLineVersion", "CustRatingClassType", "CustRatingClassPath"], "MovieIndexFileName": ["MovieConfigFolderFile", "MovieIndexClassName", "MovieEditFSize", "MovieConfigFolderVersion", "MovieIndexClassSize", "MovieIndexFileUrl", "MovieEditFileName", "MovieIndexFILEHandle", "MovieIndexFSize", "MovieConfigFileName", "MovieIndexFileHandle", "MovieIndexFilesUrl", "MovieIndexFILEFile", "MovieIndexFolderHandle", "MovieIndexFname", "MovieIndexPlaceHandle", "MovieConfigFolderHandle", "MovieIndexFILEName", "MovieIndexPlaceVersion", "MovieConfigFileFile", "MovieConfigFileHandle", "MovieIndexFName", "MovieConfigFolderName", "MovieIndexFILEVersion", "MovieIndexFileVersion", "MovieEditFileUrl", "MovieIndexFilesSize", "MovieIndexFUrl", "MovieEditFileSize", "MovieIndexFileSize", "MovieIndexPlaceName", "MovieEditFilename", "MovieIndexFilename", "MovieIndexFileFile", "MovieEditFUrl", "MovieIndexFilesname", "MovieIndexPlaceFile", "MovieIndexFolderName", "MovieEditFName", "MovieIndexFolderFile", "MovieIndexFolderVersion", "MovieIndexClassname", "MovieEditFname", "MovieIndexFilesName", "MovieIndexClassUrl", "MovieConfigFileVersion"], "inFile": ["infile", " infile", "incC", "inputSourceFile", "InSourceFile", "inputfile", "incFile", "inputF", " inF", "InF", "outC", "outfile", "incSourceFile", "Infile", "incfile", "inSourceFile", "InFile", "inputFile", "outSourceFile", "inF", "outFile", " inSourceFile"], "inC": ["outF", "inputC", "InCL", "innerCC", "InCC", "inputCC", "inCC", "inB", "InCI", "outCC", " inCC", "inputF", "outB", " inF", "InF", "outC", "innerFile", " inB", "inCL", "inCI", "InB", "InFile", "inputFile", "outCL", "InC", "inF", "outFile", " inCL", "outCI", "innerCI", "innerC"], "outFile1": ["outFiles2", "outPath3", "againC1", "outfileName", "outFiles3", "outputFileId", "outFilesFirst", "outFileName", "outPlaceId", "againFile1", "outfile1", "againC3", "outFId", "outPlaceName", "outPathFirst", "outputfileName", "outputFile2", "outPlace2", "againFileFirst", "outfileId", "outPath2", "outPath1", "againC2", "againCFirst", "outFile3", "outFileFirst", "outFName", "outCFirst", "outputFileName", "outFileId", "outF1", "outC3", "againFile3", "outFiles1", "outputfile1", "outputFile1", "outputfile2", "outF2", "againFile2", "outputfileId", "outfile2", "outPlace1"], "outC1": ["newcOne", "outB8", "newC1", "newCOne", "againB1", "againC8", "outc1", "outD8", "againC1", "newCFirst", "outC81", "outF8", "outcOne", "outc81", "outCOne", "newC81", "outCFOne", "outB1", "newcFirst", "outCF81", "outBOne", "againB2", "outD1", "outDFirst", "outB2", "outcFirst", "againC2", "outD2", "outCFirst", "outCFFirst", "outDOne", "againBOne", "outF1", "newc81", "outFOne", "againB8", "outF2", "againCOne", "outC8", "outCF1", "outD81", "newc1"], "outFile2": ["outFiles2", "outputfile5", "outputFile4", "outChannel1", "outfileTwo", "outFiles6", "outChannel6", "againFile1", "againLine2", "outFile4", "outputfile4", "outFiles4", "outFile6", "outLine1", "outDirectory4", "outDirectory5", "outfile4", "againLineTwo", "outLine6", "outFileTwo", "outLine2", "outputFile2", "outChannel2", "outputFileTwo", "outFilesTwo", "outLineTwo", "againFile6", "outFiles5", "outputFile5", "outFiles1", "outputfileTwo", "outputfile2", "againFile2", "againLine6", "outfile2", "outChannelTwo", "outDirectoryTwo", "againLine1", "outFile5", "outfile5", "againFileTwo", "outDirectory2"], "outC2": ["outCache1", "outB4", "outFTwo", "againB1", "againC1", "outCache4", "OutC1", "outFileII", "OutF2", "OutC2", "OutCII", "outFile4", "outF4", "OutFII", "outB1", "OutF4", "outCache2", "againBTwo", "outFileTwo", "outC4", "againB2", "outCacheII", "outB2", "againCTwo", "outFII", "againB4", "againC2", "outBTwo", "outF1", "OutC4", "OutF1", "againC4", "outF2", "outCII", "outCTwo"], "fileSize": [" fileSIZE", "bufferSize", "FileLength", "resourceSize", "fileAddress", "resourceAddress", "imageLength", "FileAddress", "fileSIZE", "imageSize", " fileMode", "FileSize", "resourceSIZE", "imageSIZE", "fileLength", "bufferMode", " fileLength", "fileMode", "FileMode", "FileSIZE", " fileAddress", "bufferLength"], "totalNoDataRows": ["totalNoDataChues", "totalNoPageRues", "totalNoPageRrows", "totalNoDataCOWS", "totalNoDataLOWS", "totalNoDataRues", "totalNoDataROWS", "totalNoPageROWS", "totalNoPageLows", "totalNoDataCues", "totalNoPageRows", "totalNoDataRrows", "totalNoDataCows", "totalNoDataChOWS", "totalNoDataChows", "totalNoDataLues", "totalNoPageLues", "totalNoPageLrows", "totalNoDataLows", "totalNoDataCrows", "totalNoDataLrows", "totalNoPageLOWS", "totalNoDataChrows"], "mappedBuffer": ["machedURL", "mashedBuffer", "MappedFile", "mashedFile", "mappedbuffer", "MappingBuff", "mippedURL", "MachedURL", "machedBuff", "MachedBuff", "mippedStream", "mppedStream", "mashedChannel", "Machedbuffer", "mapedFile", "machedFile", "mashedBuff", "mapedStream", "mippedBuffer", "mactedBuffer", "mappingChannel", "mactedBuff", "MappedStream", "MappingBuffer", "machedbuffer", "MappedBuffer", "mappedBuff", "mactedStream", "mppedBuffer", "mappedFile", "MachedBuffer", "machedBuffer", "mapedBuffer", "MachedStream", "mppedChannel", "MappedURL", "mippedBuff", "mapedURL", "MappedBuff", "MappingFile", "mppedBuff", "mappingFile", "MappingChannel", "machedStream", "mappingbuffer", "mappedStream", "mappingBuff", "Mappedbuffer", "mapedBuff", "mappingBuffer", "mappingStream", "mactedbuffer", "mappedURL", "mappedChannel", "MappedChannel", "machedChannel", "MachedFile", "MachedChannel"], "startIndex": ["startRow", " startSection", "startingIndex", " startCode", "startPoint", "stopindex", "endInfo", "startSection", "useIndex", "useindex", "stopCode", "initInfo", "startCode", "initOffset", "stopIndex", "endSection", "startingSection", " startPosition", "initindex", "endRow", "startindex", " startOffset", " startindex", "StartInfo", "endIndex", " startInfo", "startPosition", "StartIndex", "usePosition", "endCode", " startPoint", "StartPosition", " startRow", "endPosition", "stopRow", "startOffset", "useInfo", "initIndex", "endPoint", "startInfo", "StartOffset", "startingPoint", "startingPosition", "endindex", "Startindex"], "count": ["number", "length", "allow", "found", "child", "depth", "follow", "find", "counter", "time", "more", "other", "i", "weight", "ind", "limit", "list", "total", "len", "group", "add", "first", "part", "keep", "type", "call", "thread", "self", "force", "Count", "code", "name", "c", "order", "old", "all", "close", "size", "sum", "start", "max", "current", "loop", "cache", "pool", "key", "test", "index", "coll", "col", "id"], "currentMovie": ["thisMovie", "currentlyMovie", "CurrentTheme", "parentFilm", "parentmovie", "reportedImage", "currentlyPicture", "currentFilm", "CurrentFilm", "reportedMusic", "reportedMovie", "defaultImage", "reportedmovie", " currentFilm", "currentlyMusic", "currentTheme", "defaultFilm", "defaultMovie", "CurrentMovie", "Currentmovie", " currentMusic", "parentPicture", "currentMusic", "validTheme", "thisFilm", "parentMovie", "currentmovie", " currentImage", "validFilm", " currentPicture", "reportedPicture", "validmovie", "currentPicture", "thisPicture", "reportedTheme", "currentImage", "defaultMusic", "reportedFilm", "validMovie", "thismovie", " currentmovie"], "movieName": ["camname", "moviename", "MovieFamily", "filmNumber", "MovieNumber", "movieId", "MovieId", "voicename", "movieFamily", "moneyFamily", "camFamily", "filmname", "movieInfo", "voiceId", "moneyName", "moneyNumber", "camName", "MovieName", "MovieInfo", "filmName", "voiceInfo", " movieFamily", " moviename", "filmFamily", "movieNumber", "voiceName", " movieId", "Moviename", " movieInfo"], "customer": ["Customeri", "Customers", "ustomer", "Customer", " customers", " customER", " customeri", "mixER", "customor", "customER", "mixers", "mixer", "customers", "mixor", "ustomers", "Customor", "ustomER", "CustomER", "customeri", "ustomor", "ustomeri"], "rating": ["number", "rr", "data", "rated", "ruby", "alpha", "string", "resource", "RC", "rolling", "http", "including", "writer", "value", "reading", "rates", "rate", "rage", "url", "error", "ring", "score", "reader", "missing", "type", "comment", "ing", "range", "radius", "packing", "rc", "feature", "rank", "Rating", "setting", "r", "rice", "padding", "attribute", "ranking", "info", "writing", "id"], "outBuf1": ["outKbuffOne", "outKuf3", "outDuffn", "outCufOne", "outDuff1", "outBbuffOne", "outDuff11", "outBafOne", "outFaf1", "outFafOne", "outBaf3", "outFufCloud", "outBbuf11", "outBbuf1", "outBaft1", "outBufOne", "outBummerCloud", "outBalth2", "outBbuff8", "outCuf1", "outBbuf3", "outBuf8", "outBalth1", "outDuf1", "outKuf8", "outBufn", "outBummerOne", "outBbuff3", "outBaft11", "outFbuf91", "outKuf1", "outCuff0", "outBumOne", "outFuf91", "outKbuf3", "outBaf1", "outBaftn", "outBum01", "outBbuff0", "outBuf01", "outDuf3", "outBuffOne", "outBaf8", "outKbuff8", "outDuff3", "outBiff1", "outBaft3", "outBuff11", "outKuf2", "outBuf3", "outKbuff1", "outBuff1", "outBafCloud", "outBuff8", "outBiff01", "outBuf11", "outBuff3", "outKbuf1", "outCuff1", "outBbufn", "outBummer1", "outCuffOne", "outFbuf01", "outKufOne", "outBiff91", "outBbuf2", "outDufn", "outBbuf91", "outBum91", "outKbuf2", "outFbuf1", "outBum1", "outKbuff3", "outFafCloud", "outBuff2", "outBuffn", "outFufOne", "outBaf0", "outDuf11", "outBalth3", "outFuf1", "outBbuf01", "outBuf0", "outCuf0", "outBuf91", "outBuffCloud", "outBufCloud", "outFuf01", "outFbufOne", "outBbuff1", "outBuff0", "outBiffOne", "outBbufOne"], "outBuf2": ["outBuber20", "outBbuf1", "outBbuff200", "outFbuff2", "outBbufTwo", "outFuf8", "outBuf20", "outBbuff8", "outBuf8", "outWBufTwo", "outFuf82", "outWBuff2", "outFbuff4", "outWBbuff200", "outFufTwo", "outBoff200", "outBuf82", "outBbuffer12", "outWBbuff2", "outBbuffer4", "outFuf4", "outBum2", "outFbuf2", "outWBuff0", "outFuf12", "outBait4", "outBbuff0", "outFbuff1", "outBuffTwo", "outFbufB", "outWBuf8", "outBuff1", "outWBbuff8", "outBuff8", "outFuf2", "outBuff4", "outBbuffTwo", "outBuff12", "outWBuff4", "outBuffB", "outWBuff8", "outFbuff82", "outBbuff4", "outFbuf4", "outBuber82", "outFbuffTwo", "outFuf20", "outBum82", "outBbuf2", "outBoffTwo", "outBbuff20", "outWBuf2", "outFufB", "outBbuff2", "outBbuf12", "outBait200", "outBbuffer2", "outBum20", "outBuff2", "outBbufB", "outWBbuffTwo", "outBait2", "outFbuff8", "outBbufferB", "outBait8", "outBoff2", "outBufB", "outBaitTwo", "outFuf1", "outBuf0", "outFbuff20", "outBbuff82", "outBuber8", "outBufTwo", "outBuf200", "outWBuf0", "outWBuf200", "outBuf12", "outBbuf4", "outBuber2", "outFbuf12", "outBuf4", "outBbuff1", "outWBuf4", "outBum8", "outBoff8", "outBait0", "outBuff0"], "endOfIndexFile": ["endOfindexTime", "endOfIndexfile", "endofindexFolder", "endOfDatafile", "endOfindexfile", "endofLinkDir", "endofLinkFiles", "endOfLinkFiles", "endOfIndexFiles", "endOfDataFile", "endofIndexFolder", "endofLinkFile", "endOfClientTime", "endOfDataTime", "endOfImageFolder", "endOfImageFiles", "endfile", "endOfLinkfile", "ended\n", "endOfClientDir", "Endfile", " end\n", "endOfLinkFile", "endofIndexDir", "endOfIndexFolder", "endOfLinkDir", "endOfClientFile", "endOfindexDir", "endofindexFiles", "endOfClientFiles", "endOfImageFile", "endOfImageTime", " endfile", "endofindexTime", "endOfLinkTime", "endOfindexFiles", "endOfIndexTime", "endOfDataDir", "endOfIndexDir", "End\n", "endofIndexFiles", "end\n", "endofLinkTime", "endofIndexFile", "endofIndexTime", "endofindexFile", "endedfile", "endOfindexFolder", "endOfindexFile"]}}
{"id1": "742465", "id2": "10212189", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 1, "substitutes": {"view": ["session", "gu", "f", "can", "template", "ui", "row", "port", "user", "check", "request", "section", "form", "container", "VIEW", "review", "im", "views", "server", "http", "see", "layout", "el", "input", "by", "this", "list", "group", "window", "html", "base", "lock", "block", "event", "query", "head", "page", "v", "full", "reader", "ou", "screen", "manager", "widget", "box", "style", "View", "buffer", "image", "display", "change", "self", "edit", "up", "update", "client", "vol", "sel", "link", "show", "index", "cache", "body", "config", "out", "object", "model", "use", "vis", "e", "cell"], "url": ["loader", "address", "f", "length", "data", "socket", "uri", "jar", "ssl", "string", "source", "resource", "web", "builder", "path", "host", "server", "http", "hub", "fb", "sl", "zip", "URL", "blog", "base", "file", "page", "www", "gl", "location", "connection", "buffer", "image", "open", "name", "client", "channel", "job", "b", "email", "browser", "download", "l", "link", "stream", "Url", "log", "position", "ob", "config", "ul", "id"], "in": ["data", "isin", "socket", "inn", "source", "resource", "con", "sin", "on", "is", "input", "arin", "init", "din", "file", "lin", "reader", "rin", "ins", "inner", "s", "buffer", "bis", "b", "as", "doc", "win", "In", "stream", "cin", "inc", "ac", "IN", "nin", "ini", "login", "out", "again", "pin"], "bin": ["loader", "an", "gin", "nb", "socket", "bb", "ruby", "inn", "bi", "source", "con", "sin", "is", "input", "lib", "binary", "init", "abi", "ban", "kin", "lock", "din", "file", "lin", "reader", "bot", "connection", "bn", "inner", "buffer", "b", "inside", "fin", "browser", "win", "cache", "cin", "run", "IN", "body", "ini", "record", "spin", "out", "login", "oin", "pin"], "line": ["cl", "column", "data", "row", "lines", "user", "service", "parse", "string", "lc", "section", "end", "LINE", "str", "id", "nl", "entry", "pe", "ine", "el", "lf", "text", "base", "block", "file", "page", "lin", "inline", "part", "type", "ge", "comment", "letter", "range", "unit", "ip", "name", "Line", "code", "job", "up", "look", "b", "le", "l", "link", "definition", "log", "key", "val", "word", "out", "status", "pin", "e", "cell"], "version": ["cover", "install", "video", "filename", "bug", "plugin", "patch", "format", "string", "section", "id", "server", "vision", "option", "project", "username", "vert", "value", "license", "v", "type", "product", "dev", "secret", "unit", "image", "beta", "Version", "name", "update", "info", "versions", "code", "VERSION", "release", "download", "description", "feature", "python", "position", "driver", "null", "model", "date", "pull", "ver"], "build": ["install", "help", "length", "bug", "Build", "hold", "patch", "follow", "rel", "push", "row", "home", "builder", "built", "valid", "make", "label", "where", "tag", "lock", "base", "load", "block", "add", "boot", "building", "style", "comment", "unit", "image", "name", "update", "info", "job", "print", "release", "how", "work", "run", "log", "test", "clean", "use", "uild", "show", "pull", "ver"]}}
{"id1": "3958807", "id2": "13886238", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"streamName": ["StreamPath", "filename", "fileNAME", "imageName", "streamname", "streamPath", " streamname", "filePath", "streamType", "resourcename", "StreamPart", "streamNAME", "imagename", " streamNAME", "fileName", " streamPart", "StreamName", "filePart", "imageType", "resourceName", " streamPath", "Streamname", "streamPart", "fileType", " streamType", "imageNAME", "resourcePath"], "streamToLoad": ["streamtoUpload", "streamWillload", "streamTOload", "streamtoLoad", "streamToUpload", "streamWillLoad", "resourceToUse", "streamTORead", "resourceToPlay", "streamToPlay", "streamToRead", "inputWillLoad", "streamtoRead", "objectToRead", "streamTOUpload", "objectToUse", "resourceToload", "stream2Use", "inputToload", "streamWillUpload", "streamToUse", "objectTOLoad", "objectTOUse", "resourceTOload", "streamtoUse", "streamtoPlay", "inputWillRead", "inputToLoad", "objectTOUpload", "inputToUse", "inputToRead", "stream2load", "inputWillload", "streamTOUse", "resourceTOUse", "streamTOLoad", "objectTORead", "streamWillRead", "resourceTOLoad", "streamtoload", "resourceTOPlay", "streamToload", "resourceToLoad", "streamWillUse", "stream2Load", "streamTOPlay", "stream2Read", "inputWillUse", "objectToLoad", "objectToUpload"], "sz": ["alsze", "szip", "alszip", " szi", " sze", "sesz", "psz", "sesza", "sza", "seszi", " sj", " szip", "sesze", "psze", "psza", "sj", " sza", "sze", "szi", "pszi", "alsj", "alsz"], "req": ["sem", "ctx", "f", "serv", "rr", "rw", "ref", "src", "request", "progress", "require", "response", "http", "fr", "Resp", "input", "rec", "respond", "q", "pkg", "wx", "conn", "qt", "rss", "res", "cb", "err", "requ", "inv", "obj", "client", "exec", "download", "proc", "rx", "ok", "report", "r", "def", "Request", "rh"], "resp": ["comm", "ctx", "re", "serv", "circ", "content", "ref", "rel", "bb", "eb", "request", "remote", "wb", "output", "wa", "rh", "response", "http", "server", "news", "zip", "Resp", "Response", "rec", "par", "respond", "rem", "html", "reply", "wx", "conn", "esp", "page", "wp", "fp", "rss", "sp", "rev", "res", "err", "cook", "rep", "obj", "client", "job", "exec", "prev", "download", "proc", "jp", "df", "cmp", "ret", "body", "report", "rup", "api", "e"], "out": ["OUT", "serv", "data", "aos", "i", "output", "tmp", "zip", "buf", "binary", "Out", "base", "p", "op", "os", "conn", "in", "co", "w", "res", "bin", "object", "boot", "gz", "oct", "io", "s", "buffer", "default", "cms", "ios", "ops", "o", "b", "outs", "exec", "cache", "auto", "log", "pool", "ch", "fn", "copy", "again", "null"], "bos": ["obo", "osa", "obs", "biz", "bas", "bh", "oops", "bb", "las", "aos", "bi", "bro", "bc", "zb", "los", "flo", "zos", "bs", "os", "obb", "fits", "zo", "ubis", "obos", "bin", "boot", "bps", "bot", "io", "bis", "ko", "bes", "mis", "ios", "lol", "cro", "bott", "ros", "bo", "lo", "osi", "ob", "oos"]}}
{"id1": "4982745", "id2": "6866575", "code1": "    protected JSONObject doJSONRequest(JSONObject jsonRequest) throws JSONRPCException {\n        HttpPost request = new HttpPost(serviceUri);\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, getConnectionTimeout());\n        HttpConnectionParams.setSoTimeout(params, getSoTimeout());\n        HttpProtocolParams.setVersion(params, PROTOCOL_VERSION);\n        request.setParams(params);\n        request.addHeader(\"Authorization\", \"Basic \" + Base64Coder.encodeString(serviceUser + \":\" + servicePass));\n        HttpEntity entity;\n        try {\n            entity = new JSONEntity(jsonRequest);\n        } catch (UnsupportedEncodingException e1) {\n            throw new JSONRPCException(\"Unsupported encoding\", e1);\n        }\n        request.setEntity(entity);\n        try {\n            long t = System.currentTimeMillis();\n            HttpResponse response = httpClient.execute(request);\n            t = System.currentTimeMillis() - t;\n            Log.d(\"json-rpc\", \"Request time :\" + t);\n            String responseString = EntityUtils.toString(response.getEntity());\n            responseString = responseString.trim();\n            JSONObject jsonResponse = new JSONObject(responseString);\n            if (jsonResponse.has(\"error\")) {\n                Object jsonError = jsonResponse.get(\"error\");\n                if (!jsonError.equals(null)) throw new JSONRPCException(jsonResponse.get(\"error\"));\n                return jsonResponse;\n            } else {\n                return jsonResponse;\n            }\n        } catch (ClientProtocolException e) {\n            throw new JSONRPCException(\"HTTP error\", e);\n        } catch (IOException e) {\n            throw new JSONRPCException(\"IO error\", e);\n        } catch (JSONException e) {\n            throw new JSONRPCException(\"Invalid JSON response\", e);\n        }\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 0, "substitutes": {"jsonRequest": [" jsonQuery", "serverQuery", "httpQuery", "sonQuery", "JSONMessage", "httprequest", "JSONResponse", "JSONRequest", "httpResponse", " jsonrequest", "httpRequest", "sonResponse", "jsonQuery", "serverRequest", "jsonMessage", "JSONQuery", "serverMessage", "jsonrequest", "sonMessage", "JSONrequest", "sonRequest", "serverResponse"], "request": ["application", "hello", "rest", "operation", "address", "re", "push", "child", "condition", "user", "uri", "service", "parse", "proxy", "resource", "xml", "builder", "upload", "form", "server", "http", "trip", "pe", "command", "input", "question", "json", "parent", "q", "base", "p", "query", "req", "head", "event", "url", "transfer", "claim", "php", "temp", "method", "er", "worker", "call", "connection", "get", "ip", "buffer", "QUEST", "client", "result", "post", "api", "r", "report", "complete", "object", "create", "Request", "e", "message"], "params": ["ctx", "address", "lp", "ssl", "Parameters", "stats", "handler", "resources", "http", "server", "param", "afi", "parts", "ds", "password", "tmp", "pps", "par", "json", "mm", "database", "array", "properties", "url", "phys", "ras", "ams", "ls", "manager", "gs", "phrase", "apter", "results", "ip", "sql", "acl", "default", "eters", "services", "info", "ops", "details", "lr", "settings", "rs", "ps", "arms", "cache", "plugins", "mac", "parser", "api", "copy", "headers", "config", "eps", "names", "options", "posts", "rules"], "entity": ["ga", "issue", "eme", "address", "data", "content", "string", "resource", "document", "xml", "ue", "em", "ent", "person", "server", "entry", "pe", "el", "json", "query", "event", "cy", "error", "url", "ale", "environment", "type", "security", "connection", "ge", "element", "image", "ee", "client", "result", "om", "oe", "instance", "Entity", "cache", "api", "attribute", "object", "model", "e"], "t": ["et", "tools", "f", "d", "st", "it", "dt", "utt", "ti", "the", "time", "i", "lt", "ent", "ot", "h", "duration", "len", "ut", "tf", "p", "tu", "v", "T", "tl", "u", "mt", "type", "m", "ta", "s", "y", "set", "c", "o", "setup", "tm", "tick", "j", "l", "started", "ts", "at", "n", "test", "wt", "tp", "tim", "tt", "r", "e"], "response": ["application", " responded", "data", " responding", "tree", "service", "string", "ception", "resource", "document", "wave", "success", "status", "output", "feed", "server", "http", "model", "entry", "Resp", " Response", "onse", "Response", "json", "respond", "value", "block", "reply", "error", "array", "page", "file", "full", "type", "location", "connection", "to", "results", "image", "code", "obj", "client", "relation", "result", "resp", "body", "api", "object", " responses", "message"], "responseString": ["replyStr", " responseStr", "respString", "respondData", "resultString", "respondString", "respText", " responseFile", "responseLine", "resultText", "ResponseFile", "responseStr", "ResponseBytes", " responseBytes", "ResponseData", "resultStr", "responseArray", "ResponseStr", "ResponseLine", "ResponseString", "resultBytes", "responseBytes", "respondStr", " responseData", "ResponseArray", "respStr", "responseFile", " responseArray", "replyString", "respondArray", " responseText", "respLine", "ResponseText", "replyData", "responseText", "responseData", "replyFile", " responseLine"], "jsonResponse": ["sonData", "JSONNode", " jsonElement", "journalError", "xmlView", "journalNode", " jsonData", "sonElement", "xmlAnswer", "jsonAnswer", "externalResponse", "sonResult", "jsonResp", "jsonElement", "activeResponse", "externalElement", "xmlError", "sonError", "JSONAnswer", "JSONResponse", "JSONRequest", "jsonServer", "jsonOutput", " jsonResp", "sonOutput", "JSONServer", "xmlResp", "JSONResp", "sonServer", "xmlResponse", "jsonNode", "jsonView", "xmlRequest", "sonResponse", "JSONResult", "externalError", "journalResp", "sonResp", " jsonResult", "journalOutput", "jsonData", "activeView", "sonNode", " jsonNode", "JSONView", "journalResponse", "activeAnswer", " jsonServer", "externalData", "xmlOutput", "activeRequest", "jsonResult", "sonRequest"], "jsonError": ["serverException", "journalError", "serverData", " jsonData", "journalData", "sonResult", "sonerror", " jsonerror", "xmlError", "sonError", "xmlResponse", "xmlResult", "journalException", "sonResponse", " jsonException", " jsonResult", "jsonException", "jsonData", "jsonerror", "journalResponse", "jsonResult", "xmlerror", "serverResponse", "serverError"]}}
{"id1": "4164833", "id2": "4750967", "code1": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"debFile": ["debianStream", "budgetFile", "debFolder", "DebFiles", "DebStream", "debStream", "DebFolder", "debfile", "ebFolder", "commitStream", "commitFiles", "commitfile", "ebfile", "Debfile", "commitFile", "DebFile", "budgetfile", "budgetFolder", "ebFile", "debFiles", "ebFiles", "budgetFiles", "debianFiles", "debianFile", "debianfile"], "controlFile": [" controlStream", " controlLog", "controlPath", " controlPage", "controlHandle", "controlStream", "dataPage", "monitorEntry", "controlledHandle", "controlledDir", "controlFiles", "controllerDir", "ctrlPath", "controlPage", "controlledPath", "ctrlLog", "Controlfile", "controlfile", "ctrlFile", "ctrlHandle", " controlFiles", "ctrlfile", "ctrlDir", "libfile", "controllerPath", "libDir", "controlLog", "ControlPath", "ControlFile", "datafile", "ControlDir", "dataLog", "controlledFile", "controllerFiles", "ctrlPage", "controllerFile", "libFile", "controlEntry", " controlfile", "controlDir", "controllerStream", "controllerEntry", "controllerHandle", " controlEntry", "monitorStream", "monitorFiles", "monitorFile", "libPath"], "dataFile": ["lockfile", " dataSource", "datFile", "inputLine", "datPage", " dataDir", "DataFiles", "dataLine", "datFilename", "dataPage", "DataSource", "dataDir", "addFILE", "dataFILE", " dataLine", "inputStream", "dataFolder", "addfile", "inputFolder", "patchFolder", "Datafile", " dataStream", "dataFilename", "lockFile", "lockPage", "inputFiles", "addDir", "addFile", "DataFilename", "mediaFile", "lockFilename", "patchStream", " dataFolder", "datafile", "DataPage", "mediafile", "datfile", " datafile", "mediaFILE", "patchFiles", "DataFile", "patchFile", "dataStream", "inputFile", "dataFiles", "dataSource", " dataFILE", "mediaDir", " dataFiles", "DataLine", "inputSource"], "now": ["next", "length", " NOW", "low", "time", "off", "and", "then", "small", "once", "wait", "ow", "this", "since", "day", "load", "first", "Now", "NOW", "self", "seed", "later", "name", "today", "set", "old", "not", "or", "size", "start", "max", "current", "cmp", "currently", "always", "after", "ok", "cur", "count", "post", "false", "created", "default", "info", "create", "date"], "deb": ["sem", "broad", "plug", "cm", "bug", "rb", "budget", "nb", "bh", "github", "bb", "dr", "debian", "eb", "aud", "web", "reb", "div", "Deb", "diff", "db", "ib", "fr", "make", "lab", "conf", "fb", "org", "bang", "daily", "dp", "ban", "cp", "hide", "pkg", "req", "obb", "error", "die", "img", "av", "cb", "rib", "dev", "ub", "cdn", "boot", "ab", "pub", "mb", "ee", "priv", "dm", "abc", "archive", "b", "exec", "fin", "aff", "download", "df", "tab", "af", "log", "compl", "ob", "dl", "bank", "raf"], "control": ["address", "internal", "length", "child", "controlled", "ack", "safe", "flow", "connect", "per", "output", "sub", "feed", "form", "ignore", "own", "initial", "input", "lib", "monitor", "group", "board", "block", "error", "url", "co", "reader", "select", "down", "manager", "io", "open", "media", "regular", "client", "channel", "exec", "Control", "rc", "close", "stream", "ctrl", "work", "controller", "ob", "config", "copy"], "buffer": ["number", "queue", "border", "address", "length", "uffer", "flush", "reference", "uri", "counter", "source", "wave", "resource", "document", "feed", "pad", "slice", "layer", "capacity", "entry", "limit", "character", "iter", "buff", "buf", "input", "writer", "binary", "value", "repeat", "base", "block", "error", "transfer", "url", "shape", "file", "reader", "variable", "page", "bin", "comment", "offset", "batch", "channel", "bytes", "write", "result", "size", "memory", "cache", "position", "count", "copy", "record", "null", "sequence", "message"], "read": ["number", "length", "readable", "pick", "flush", "request", "connect", "Read", "input", "wait", "scale", "value", "raw", "shape", "select", "open", "build", "n", "ink", "run", "view", "index", "show", "next", "sync", "parse", "send", "slice", "each", "rate", "reader", "seek", "draw", "set", "rol", "write", "exec", "en", "close", "pass", "key", "count", "r", "use", "pull", "id", "allow", "find", "check", "no", "i", "resource", "ize", "load", "add", "play", "level", "get", "READ", "ride", "start", "work", "copy", "create", "join", "child", "ack", "flow", "end", "feed", "ready", "iter", "reading", "fill", "ed", "ip", "skip", "reads", "loop"], "data": ["video", "address", "a", "ui", "ad", "ul", "own", "da", "feed", "pad", "db", "and", "valid", "di", "input", "writer", "base", "function", "block", "database", "file", "reader", "part", "down", "one", "image", "na", "media", "done", "update", "multi", "result", "ada", "download", "aa", "ata", "cache", "auto", "view", "audio", "body", "li", "api", "area", "complete", "extra", "object", "map", "dat", "message"]}}
{"id1": "11341711", "id2": "10795866", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"dir": ["ir", "d", "data", "wd", "source", "path", "director", "DIR", "diff", "db", "zip", "lib", "init", "group", "dist", "dest", "folder", "store", "desc", "base", "root", "pkg", "url", "file", "directory", "manager", "io", "module", "done", "name", "up", "Directory", "md", "Dir", "build", "download", "dep", "doc", "rc", "work", "cache", "log", "run", "config", "direction", "dict"], "sourcedir": ["sortedIR", "sourcesdir", "sourcedIR", "seedIR", "asortedIR", "ssourcediri", "sourcediri", "ssodedir", "sourcedirs", "asourcedirs", "seedir", "sourcedore", "asortedore", "asortedir", "sodedIR", "sortedir", "ssodedIR", "ssourceddir", "asourcedIR", "sourcesore", "ssodediri", "asourcedir", "seeddir", "ssodeddir", "sodediri", "sortedirs", "sourcesir", "sourcesIR", "sodedirs", "sourcesirs", "sodedore", "asortedirs", "sodeddir", "sourceddir", "seediri", "ssourcedIR", "sortedore", "sourcesiri", "ssourcedir", "asourcedore", "sodedir"], "destinationdir": ["destinateDir", "Destificationdirection", "Destinationfolder", "destinationsfile", "DestinationDir", "destinationDIR", "dominationDir", "desturationDir", "dominationdir", "desturationfolder", "desturationdir", "dominatorfile", "destinatordir", "dominatorDir", "destinationsDIR", "destinationfile", "destinatorDir", "destinatedirection", "destinateDIR", "dominationDIR", "desturationdirection", "destinatefolder", "destinatefile", "Destificationdir", "destinatedir", "destificationdirection", "destinationfolder", "dominationfile", "destinatorfile", "destificationdir", "dominatorDIR", "dominatordir", "destinatorDIR", "destinationdirection", "Destinationdirection", "destificationDir", "DestificationDir", "Destificationfolder", "destinationDir", "Destinationdir", "destinationsdir", "destificationfolder", "destinationsDir"], "destinationDirEnding": ["destinationDirectoryEndining", "destinationDirectorySignING", "destinationDirLeading", "destinationPathEndging", "destinationDirBeginining", "destinationPathBeginning", "destinationDirSignining", "destinationDirectorySigning", "destinationDirEndning", "destinationDirectorySignining", "destinationDirENDing", "destinationDirEndining", "destinationDirEndening", "destinationDirENDING", "destinationDirPassING", "destinationDirEndging", "destinationDirLeadening", "destinationDirENDning", "destinationDirSigning", "destinationDirBeginning", "destinationDirPassing", "destinationDirBeginging", "destinationPathEndING", "destinationDirBegining", "destinationDirENDging", "destinationDirSignING", "destinationDirectoryEndING", "destinationDirPassning", "destinationPathBeginging", "destinationDirectorySignening", "destinationDirLeadining", "destinationDirBeginening", "destinationDirEndING", "destinationPathBegining", "destinationDirSignening", "destinationPathBeginING", "destinationPathEndning", "destinationDirBeginING", "destinationPathEnding", "destinationDirectoryEndening", "destinationDirectoryEnding", "destinationDirPassging", "destinationDirLeadING"], "files": ["ids", "docs", "parents", "data", "features", "uploads", "words", "lines", "planes", "actions", "xml", "links", "output", "blocks", "resources", "sections", "balls", "boxes", "classes", " Files", "its", "groups", "reports", "iles", "thumbnails", "items", "flows", "errors", "rows", "file", "tests", "events", "books", "ls", "ins", "Files", "results", "children", "users", "services", "pages", "objects", "runs", "ips", "types", "l", "ps", "index", "keys", "modules", "models", "log", "images", "split", "strings", "fields", "projects", "bugs", "names", "fs", "rules", "locks"], "checkdir": ["checkd", "checkfile", " checklog", "workdirectory", "workFolder", "Checkfile", "ckdir", "lockdir", "ckd", "workdraft", "blockdraft", "checkDir", " checkd", "blockdirectory", "workDir", "checkFolder", "lockFolder", "ckdirectory", "workDIR", "workfolder", "calld", " checkDir", "ckfile", "workdir", "checklog", "checkfolder", "worklog", "callfolder", "CheckDir", "checkdirectory", "calldirectory", "CheckDIR", " checkfile", "searchdraft", "checkdraft", "calldir", " checkDIR", "searchdir", "searchdirectory", "checkDIR", " checkfolder", "locklog", " checkdirectory", "blockdir", "blockDir", " checkFolder", "ckDir", "workfile", "searchDir", "lockDir", "ckfolder", "Checkdir"], "date": [" Date", "d", "data", "dt", "user", "time", "mate", "contact", "sign", "mu", "late", "zone", "Date", "tag", "month", "day", "event", "rate", "ime", "ate", "file", "de", "m", "now", "ge", "state", "image", "change", "open", "name", "update", "md", "set", "doc", "start", "age", "at", "log", "config", "dat", "e"], "msec": ["disec", "csec", "mSec", "dseconds", "rsecond", "lss", "misec", "mseconds", "rseconds", "fmsec", "dsecond", "mnSec", "fmsecond", "mif", "dsec", "rsec", "csecond", "fmisec", "Mseconds", "mss", "msecond", "rss", "Misec", "css", "lseconds", "lsecond", " mif", "mnif", "fmseconds", "Msec", " minsec", " mSec", " minsc", "cseconds", " minif", "mnsc", "Msecond", " minSec", "lsec", " msc", "msc", "mnsec"], "checkFile": ["controlLine", "workFile", "CheckDirectory", "checkfile", "Checkfile", "checkDir", "CheckFile", " checkLine", "changeLine", "checkFiles", "workDir", "changefile", "checkDirectory", "ckDirectory", " checkDir", "ckfile", "workFiles", "controlfile", "checkFilename", "checkLine", "CheckDir", " checkfile", " checkFiles", " checkDirectory", "controlFile", " checkFilename", "ckFiles", "ckFile", "changeFilename", "workfile", "controlFilename", "CheckFiles", "changeFile"], "i": ["hi", "phi", "x", "ui", "ti", "ie", "uri", "bi", "ci", "gi", "qi", "slice", "im", "mu", "di", "is", "pi", "p", "v", "ix", "ai", "part", "u", "m", "iu", "io", "ip", "ii", "y", "info", "ri", "I", "multi", "fi", "b", "j", "n", "si", "vi", "key", "li", "ini", "oi", "ji", "field", "index", "xi", "eni", "e", "id"], "f": ["d", "fun", "cf", "sf", "feed", "fx", "fr", "t", "fb", "h", "fc", "F", "folder", "q", "p", "fp", "file", "v", "fd", "w", "u", "m", "o", "b", "fi", "j", "l", "df", "n", "fn", "fe", "r", "fl", "info", "fs", "e"], "g": ["ga", "gm", "gh", "G", "eg", "gin", "gu", "d", "msg", "pg", "gb", "gp", "gd", "gg", "gi", "go", "gar", "t", "h", "og", "group", "ng", "q", "p", "sg", "file", "gs", "u", "w", "m", "rg", "ge", "ig", "s", "mg", "gn", "reg", "b", "gc", "l", "ger", "n", "erg", "r", "tg", "vg", "bg", "global", "e"], "destinationFile": ["destiningFilename", "destificationDirectory", "destiningFile", "destacementDir", "destacementFile", "destinationsFile", "destacementfile", "DestinationDir", "DestationDir", "destiningfile", "DestificationFile", "destationFilename", "destinatorLocation", "DestationFile", "destiningDir", "destinationFilename", "destinationfile", "destinatorDir", "destinationsDirectory", "destinatorDirectory", "destinationDirectory", "destinatorFile", "destationFile", "destinationsLocation", "destacementFilename", "destationfile", "Destationfile", "DestinationFile", "DestificationLocation", "destificationDir", "DestificationDir", "DestinationDirectory", "destinationDir", "Destinationfile", "destinationLocation", "destationDir", "DestinationFilename", "DestificationDirectory", "destificationFile", "destinationsDir", "DestationFilename", "destificationLocation", "DestinationLocation"], "sourceFile": [" sourcefile", "ourceFiles", "ourceDirectory", "srcfile", " sourceFiles", "inputFiles", "sourceFiles", "srcModule", "sourceDir", "srcDir", " sourceModule", "inputDir", "ourceFile", "inputFile", " sourceDirectory", "Sourcefile", "SourceDir", "ourceDir", "sourcefile", "srcFile", " sourceDir", "SourceFile", "sourceModule", "sourceDirectory", "SourceModule", "inputDirectory"], "infile": ["difffile", "inf", "inputstream", "windir", "inputf", "winfile", " instream", "diffstream", "inputfile", "Instream", "inFile", "diffdir", "outdir", "Infile", " indata", "winFile", "outdata", "InFile", "instream", "inputFile", "Inf", "inputdata", "indata", "outstream", "outFile", "outf", "indir", "winstream", "diffFile", " inFile"], "outfile": [" outpage", "Outfile", "inputline", "Outline", "OutFile", "Outlive", "exfile", "inputfile", "againpage", " outline", "outfunction", "intfile", "intstream", " outFile", "outlive", "outline", " outstream", "intFile", "intlive", "inputfunction", "exstream", "Outstream", "exFile", "Outfunction", "inputFile", "outpage", "againstream", "expage", "outstream", "outFile", "againFile", " outlive", " outfunction", "againfile"], "c": ["cm", "cl", "d", "x", "a", "cu", "string", "lc", "ci", "end", "C", "cr", "dec", "pc", "character", "t", "z", "cont", "p", "cy", "v", "esc", "in", "w", "u", "ct", "m", "k", "char", "comment", "code", "ec", "abc", "channel", "o", "b", "ice", "rc", "index", "l", "n", "ac", "ch", "xc", "r", "uc", "enc", "h", "pointer", "col", "e", "id"]}}
{"id1": "17202158", "id2": "10445819", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"zoneFileName": ["zoneFullname", "zonefilename", "ZonefileName", "Zonefilename", "zoneClassName", " zoneFileUrl", "ZoneFilePath", "zoneFileUrl", "zonefilePath", "zoneClassname", "zoneClassUrl", "zoneFilesname", "zoneFilePath", "zonefileName", "zoneFilesUrl", "ZoneFileName", "zoneFullUrl", "ZonefilePath", " zoneFilePath", " zoneDirUrl", "zoneDirUrl", "zoneFilesPath", " zoneDirName", "zoneFilename", "zoneClassPath", "zonefileUrl", "zoneFilesName", "zoneDirPath", "zoneDirName", "ZoneFileUrl", "zoneLineUrl", "zoneLineName", "ZoneFilename", "zoneFullPath", "zoneFullName", " zoneDirPath", "zoneLinePath", "ZonefileUrl"], "zoneids": ["zonefiles", "zoneid", "sizeid", "Zoneids", "poIDs", "typeints", "zoneIDs", "poids", " zonelines", "zipids", " zoneips", "ziplines", "Zoneid", "sizeids", "zoneints", "typeids", "zoneips", "typeid", " zonefiles", "zonelines", "polines", "ZoneIDs", "zipIDs", "sizeints", "zipid", "pofiles", " zoneid", " zoneIDs", "poid", "Zonefiles", "typeips", "sizeips", " zoneints"], "url": ["loader", "address", "f", "re", "bel", "data", "user", "uri", "service", "ssl", "string", "source", "resource", "path", "feed", "server", "http", "hub", "ur", "sl", "URL", "class", "this", "base", "file", "page", "reader", "location", "connection", "io", "buffer", "name", "job", "client", "channel", "b", "l", "stream", "Url", "api", "r", "ball"], "lnr": ["linw", "rlb", "lenp", "nlp", "slrb", "lenr", "slr", "lnrb", "rln", "nlr", "sln", "lnw", "lenb", "nlw", "lnn", "rlr", "lenw", "nlb", "linr", "lnb", "linn", "lnp", "rlrb", "slb", "linrb", "linp", "linb"], "line": ["number", "cl", "column", "data", "row", "lines", "parse", "string", "no", "lc", "rule", "LINE", "str", "response", "nl", "entry", "message", "sl", "el", "cell", "lf", "base", "block", "jo", "file", "page", "lin", "part", "inline", "ge", "char", "letter", "comment", "header", "unit", "name", "Line", "code", "look", "c", "le", "sel", "l", "link", "ne", "log", "key", "word", "col", "id"]}}
{"id1": "3409084", "id2": "18358467", "code1": "    protected String getRequestContent(String urlText) throws Exception {\n        URL url = new URL(urlText);\n        HttpURLConnection urlcon = (HttpURLConnection) url.openConnection();\n        urlcon.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream()));\n        String line = reader.readLine();\n        reader.close();\n        urlcon.disconnect();\n        return line;\n    }\n", "code2": "    public DocumentSummary parseDocument(URL url) throws IOException, DocumentHandlerException {\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n            POIOLE2TextExtractor extractor = createExtractor(inputStream);\n            SummaryInformation info = extractor.getSummaryInformation();\n            DocumentSummary docSummary = new DocumentSummary();\n            docSummary.authors = DocSummaryPOIFSReaderListener.getAuthors(info);\n            docSummary.contentReader = new StringReader(extractor.getText());\n            docSummary.creationDate = info.getCreateDateTime();\n            docSummary.keywords = new ArrayList();\n            docSummary.keywords.add(info.getKeywords());\n            docSummary.modificationDate = new Date(info.getEditTime());\n            docSummary.title = info.getTitle();\n            return docSummary;\n        } catch (IOException e) {\n            if (e.getMessage().startsWith(\"Unable to read entire header\")) {\n                throw new DocumentHandlerException(\"Couldn't process document\", e);\n            } else {\n                throw e;\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"urlText": ["resourcetext", "urlContent", " urlString", "httpTEXT", "strTEXT", "strtext", "pageString", "resourceContent", "strContent", "urlString", "httpText", "resourceTEXT", "urlTEXT", "httpString", "strText", "pageTEXT", " urlTEXT", "urltext", "resourceText", " urlContent", " urltext", "pageText"], "url": ["f", "user", "uri", "ssl", "resource", "web", "feed", "path", "host", "bc", "str", "server", "http", "ur", "sl", "URL", "this", "blog", "base", "conn", "page", "full", "ls", "www", "connection", "image", "open", "client", "b", "c", "lr", "build", "or", "l", "ll", "Url", "log", "rl", "r", "api", "config", "fl", "object"], "urlcon": ["httpclient", "urlconnect", "urlann", "urlconn", "Urlfc", "UrlCon", "webCon", "webcon", "httpann", "urlconst", "urlenc", "urconn", "URLCon", " urlCon", "URLcon", "webann", "httpCon", "httpenc", "urlCon", "urlrun", " urlconst", "urlclient", "webconnect", "Urlcon", "httpfc", "webconn", "urcon", " urlconn", "Urlclient", " urlrun", " urlenc", "urlfc", "httpconst", "httpcon", "httprun", " urlann", "URLclient", "httpconn", " urlconnect", "webenc", "urrun", "urconst", "URLfc", "httpconnect"], "reader": ["loader", "bird", "rr", "data", "row", "cher", "i", "ler", "per", "director", "handler", "layer", "read", "editor", "iter", "input", "writer", "reading", "file", "in", "rer", "er", "worker", "finder", "io", "inner", "buffer", "rar", "keeper", "her", "ri", "result", "or", "stream", "car", "rx", "parser", "r", "ner", "ser", "ker", "Reader", "oder"], "line": ["data", "row", "content", "lines", "user", "string", "end", "feed", "LINE", "str", "response", "read", "message", "entry", "text", "value", "block", "page", "file", "lin", "inline", "char", "letter", "buffer", "element", "Line", "code", "name", "email", "link", "pass", "log", "body", "val", "cell"]}}
{"id1": "471804", "id2": "7425022", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 0, "substitutes": {"view": ["session", "gu", "f", "can", "template", "ui", "row", "port", "user", "check", "request", "section", "form", "container", "VIEW", "review", "im", "views", "server", "http", "see", "layout", "el", "input", "by", "this", "list", "group", "window", "html", "base", "lock", "block", "event", "query", "head", "page", "v", "full", "reader", "ou", "screen", "manager", "widget", "box", "style", "View", "buffer", "image", "display", "change", "self", "edit", "up", "update", "client", "vol", "sel", "link", "show", "index", "cache", "body", "config", "out", "object", "model", "use", "vis", "e", "cell"], "url": ["loader", "address", "f", "length", "data", "socket", "uri", "jar", "ssl", "string", "source", "resource", "web", "builder", "path", "host", "server", "http", "hub", "fb", "sl", "zip", "URL", "blog", "base", "file", "page", "www", "gl", "location", "connection", "buffer", "image", "open", "name", "client", "channel", "job", "b", "email", "browser", "download", "l", "link", "stream", "Url", "log", "position", "ob", "config", "ul", "id"], "in": ["data", "isin", "socket", "inn", "source", "resource", "con", "sin", "on", "is", "input", "arin", "init", "din", "file", "lin", "reader", "rin", "ins", "inner", "s", "buffer", "bis", "b", "as", "doc", "win", "In", "stream", "cin", "inc", "ac", "IN", "nin", "ini", "login", "out", "again", "pin"], "bin": ["loader", "an", "gin", "nb", "socket", "bb", "ruby", "inn", "bi", "source", "con", "sin", "is", "input", "lib", "binary", "init", "abi", "ban", "kin", "lock", "din", "file", "lin", "reader", "bot", "connection", "bn", "inner", "buffer", "b", "inside", "fin", "browser", "win", "cache", "cin", "run", "IN", "body", "ini", "record", "spin", "out", "login", "oin", "pin"], "line": ["cl", "column", "data", "row", "lines", "user", "service", "parse", "string", "lc", "section", "end", "LINE", "str", "id", "nl", "entry", "pe", "ine", "el", "lf", "text", "base", "block", "file", "page", "lin", "inline", "part", "type", "ge", "comment", "letter", "range", "unit", "ip", "name", "Line", "code", "job", "up", "look", "b", "le", "l", "link", "definition", "log", "key", "val", "word", "out", "status", "pin", "e", "cell"], "version": ["cover", "install", "video", "filename", "bug", "plugin", "patch", "format", "string", "section", "id", "server", "vision", "option", "project", "username", "vert", "value", "license", "v", "type", "product", "dev", "secret", "unit", "image", "beta", "Version", "name", "update", "info", "versions", "code", "VERSION", "release", "download", "description", "feature", "python", "position", "driver", "null", "model", "date", "pull", "ver"], "build": ["install", "help", "length", "bug", "Build", "hold", "patch", "follow", "rel", "push", "row", "home", "builder", "built", "valid", "make", "label", "where", "tag", "lock", "base", "load", "block", "add", "boot", "building", "style", "comment", "unit", "image", "name", "update", "info", "job", "print", "release", "how", "work", "run", "log", "test", "clean", "use", "uild", "show", "pull", "ver"]}}
{"id1": "19584877", "id2": "19849797", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"infile": ["inputfp", "Infiles", "inputfilename", "infilename", " infilename", " infiles", "outfp", "inputfile", "inputfiles", "inFile", "infp", "Infile", "Infilename", "infiles", " infp", "InFile", "inputFile", "outFile", "outfilename", "outfiles"], "outfile": ["Outfile", "outputfilename", " outfolder", "infilename", " outfp", "outputfile", "OutFile", "outfp", "infolder", "newFile", " outFile", "infp", " outfilename", "outfolder", "newfolder", " outname", "outputfp", "Outname", "Outfolder", "outputfolder", "outFile", "outname", "outfilename", "newfile", "newname"], "in": ["gin", "vin", "a", "re", "data", "isin", "socket", "inn", "source", "i", "thin", "ic", "con", "sin", "is", "input", "init", "inas", "base", "min", "din", "conn", "reader", "rin", "ins", "bin", "m", "into", "err", "inner", "s", "image", "b", "inside", "as", "win", "In", "pass", "cin", "inc", "ac", "IN", "nin", "ini", "r", "login", "again", "pin", "id"], "out": ["session", "sync", "OUT", "socket", "point", "home", "no", "source", "output", "exit", "on", "off", "line", "lib", "writer", "parent", "Out", "base", "ou", "error", "file", "conn", "co", "timeout", "bin", "one", "err", "net", "io", "to", "inner", "image", "name", "up", "client", "job", "o", "obj", "outs", "exec", "write", "or", "outer", "In", "work", "cache", "inc", "post", "ex", "copy", "again"], "buffer": ["queue", "border", "address", "length", "uffer", "data", "flush", "reference", "bb", "source", "wave", "feed", "slice", "layer", "server", "limit", "iter", "buff", "buf", "fb", "input", "binary", "len", "value", "base", "raw", "transfer", "url", "reader", "type", "offset", "seed", "Buffer", "batch", "bytes", "b", "write", "result", "size", "cache", "split", "count", "padding", "null"], "read": ["lex", " write", "f", "length", "x", "sync", "allow", "next", " copy", "find", "ad", "check", "parse", "i", "Read", "connect", "send", "end", "feed", "tell", "slice", "ind", "limit", "iter", "input", "wait", "len", " Read", "reading", "load", "add", "raw", "sleep", "reader", "select", "play", "se", "fill", "seek", "io", "get", "ride", "READ", "ip", "_", " count", "write", "exec", "close", "size", "reads", "start", "work", "n", "pass", "run", "inc", "current", "count", "copy", "use", " skip", "id"], "success": ["primary", "growth", "construct", "better", "data", "content", "follow", "fast", "flash", " succ", "successful", "status", "cess", "path", "rolling", "response", "valid", "model", "rolled", "initial", "fail", " successful", "value", "modified", "failed", "ccess", "roll", "func", "respons", "winner", "error", "first", "true", "method", "danger", "comment", " succeed", "results", "warning", "open", "done", "right", " Success", "ceed", "result", "successfully", "good", "Success", "pass", "xx", "complete", "continue", "default", "again", "null", "message"]}}
{"id1": "693636", "id2": "8801436", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"SHOPPING_ID": ["SHOPPING_IDS", "SHOPPING_Id", "SHOPPTINGIDId", "SHOPPINGOCKIDs", "SHOPPINGINGId", "SHOPPIP_Id", "SHOPPIP_id", "SHOPPYING_IDs", "SHOPPTING_IDS", "SHOPPIP_ID", "SHOPPIPINGId", "SHOPPYING_IDS", "SHOPPTING_NAME", "SHOPPTINGIDid", "SHOPPINGIDid", "SHOPPTING_ID", "SHOPPIPINGID", "SHOPPYING_ID", "SHOPPTINGIDIDS", "SHOPPINGINGID", "SHOPPIP_IDS", "SHOPPINGINGIDS", "SHOPPINGOCKID", "SHOPPINGINGNAME", "SHOPPINGIDIDs", "SHOPPING_NAME", "SHOPPING_id", "SHOPPINGIDId", "SHOPPINGIDID", "SHOPPTINGIDID", "SHOPPINGIDNAME", "SHOPPING_IDs", "SHOPPIPINGid", "SHOPPTING_id", "SHOPPINGOCKIDS", "SHOPPYING_Id", "SHOPPINGOCKId", "SHOPPIPINGIDS", "SHOPPTING_Id", "SHOPPINGINGid", "SHOPPINGIDIDS"], "con": ["wan", "session", "ca", "ctx", "cons", "un", "cm", "row", "cond", "cf", "Con", "connect", "cn", "pen", "bc", "db", "cr", "pc", "conf", "commit", "fc", "cas", "fa", "can", "query", "conn", "co", "ran", "act", "com", "ct", "connection", "CON", "fac", "ec", "client", "conv", "c", "exec", "cc", "en", "rc", "Conn", "win", "close", "ctrl", "ann", "cache", "ac", "log", "cur", "loc", "pool", "inc", "mc", "ex", "uc", "coll", "col"], "insert_cart": ["insert_table", "insertkcart", "insertingpack", "insertfulart", "initkcoll", " insert_pod", "insertingCart", "insertAdcycle", "insert_card", "insertpcycle", "pushingCart", "initkcart", "insertfulhard", "insertkcoll", "push_cart", " insert_table", "insertkcontainer", "initkcontainer", "init_cycle", " insert_art", " insert_front", "insertAdcontainer", " insert_card", "insertkcycle", "insert_front", "insert_pod", "insertpcoll", "insert_cycle", "insert_coll", "insert_hard", "insert_container", "insertfulcart", "insertAdcart", "insertpcontainer", "insertingcart", "init_container", "insertAdcoll", "insertfulcat", "insertpcart", "pushingpack", "insert_art", "pushingcart", "init_cart", "push_Cart", "insert_pack", " insert_cat", "insert_Cart", "push_pack", "init_coll", "insert_cat", "initkcycle", " insert_hard"]}}
{"id1": "1133123", "id2": "7149578", "code1": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 0, "substitutes": {"url": ["address", "f", "bel", "data", "uri", "service", "ssl", "source", "resource", "path", "host", "str", "server", "http", "limit", "iter", "sl", "el", "URL", "this", "base", "file", "object", "location", "connection", "buffer", "image", "name", "channel", "l", "link", "ll", "Url", "log", "loc", "config", "proxy", "null", "options", "id"]}}
{"id1": "11546108", "id2": "5744992", "code1": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "code2": "    public void dorequest(Map<String, String> ps, String method) throws IOException {\n        StringBuffer httpResponse = new StringBuffer();\n        URL ourl = new URL(url);\n        HttpURLConnection httpConnection = (HttpURLConnection) ourl.openConnection();\n        httpConnection.setRequestMethod(method);\n        httpConnection.setDoOutput(true);\n        this.setCookie(httpConnection);\n        OutputStream httpOutputStream = httpConnection.getOutputStream();\n        StringBuffer postParams = new StringBuffer(\"\");\n        for (Entry<String, String> entry : ps.entrySet()) {\n            postParams.append(entry.getKey());\n            postParams.append(\"=\");\n            postParams.append(entry.getValue());\n            postParams.append(\"&\");\n        }\n        httpOutputStream.write(postParams.toString().getBytes());\n        BufferedReader httpBufferedReader = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n        httpResponse.append(this.readBufferedContent(httpBufferedReader));\n        text = httpResponse.toString();\n        this.readCookie(httpConnection);\n    }\n", "label": 0, "substitutes": {"in": ["f", "a", "serv", "data", "isin", "socket", "inn", "ssl", "source", "xml", "con", "token", "fr", "t", "is", "input", "min", "din", "lin", "reader", "rin", "ins", "bin", "io", "inner", "s", "buffer", "fac", "b", "c", "fin", "l", "In", "stream", "inc", "pool", "IN", "nin", "ini", "r", "login", "h", "out", "again", "e"], "ligneEnCours": ["ligneenCourses", "ligneENCore", "ligneENCour", "ligneenAcore", "ligneEnAcore", "ligneENAcore", "ligneEnAcours", "ligneEnCore", "ligneOpenCOUR", "ligneEnSore", "ligneEnScOUR", "ligneEncour", "ligneEnColOUR", "ligneEncore", "ligneOpenAcour", "ligneENAcours", "ligneEnSourses", "ligneENcourses", "ligneEnColour", "ligneenScour", "ligneEnScore", "ligneenCOUR", "ligneENCourses", "ligneEnColourses", "ligneenCour", "ligneenAcours", "ligneenCours", "ligneEnAcour", "ligneEnCOUR", "ligneEnSours", "ligneEnScours", "ligneENCours", "ligneEnSour", "ligneOpenCourses", "ligneOpenAcOUR", "ligneEncourses", "ligneEnAcOUR", "ligneOpenCours", "ligneenScOUR", "ligneENcours", "ligneOpenAcours", "ligneENcour", "ligneEnAcourses", "ligneenScore", "ligneENCOUR", "ligneENcOUR", "ligneEncours", "ligneenCore", "ligneEnCour", "ligneEnScourses", "ligneEnSOUR", "ligneEnColours", "ligneENAcOUR", "ligneOpenAcourses", "ligneENAcour", "ligneenScours", "ligneOpenCour", "ligneEnCourses", "ligneEncOUR", "ligneEnScour", "ligneenAcour", "ligneenAcourses"], "i": ["esi", "phi", "f", "x", "ori", "ui", "ti", "uri", "bi", "ci", "qi", "gi", "slice", "di", "t", "col", "pi", "zi", "p", "v", "ix", "ai", "u", "type", "k", "m", "iu", "yi", "io", "ip", "ii", "ski", "info", "o", "multi", "c", "I", "b", "j", "l", "start", "n", "si", "position", "li", "ini", "oi", "count", "index", "xi", "eni", "e", "id"], "version": ["number", "install", "prefix", "uri", "source", "resource", "server", "option", "parent", "v", "page", "secret", "comment", "unit", "ip", "Version", "versions", "channel", "VERSION", "release", "download", "description", "feature", "position", "index", "model", "ver"], "url": ["address", "prefix", "uri", "ssl", "source", "resource", "xml", "path", "output", "server", "http", "sl", "URL", "text", "json", "base", "page", "location", "comment", "href", "image", "language", "channel", "route", "download", "position", "config"], "informations": ["instrumentates", "inspectations", "inadequations", " instrumentations", "inpectats", "information", "instrumentrations", "informATIONS", "inceptionations", "informments", "instrumentations", "inspectments", "inceptionats", "inspectation", "inpectations", "informedrations", "inspectats", "inpectments", "inposations", "inposats", "inposments", "inadequATIONS", "inadequrations", " informrations", " instrumentATIONS", " instrumentates", "inadequates", "inposation", "informedATIONS", "informrations", "inceptionation", "inpectation", "insformation", " informates", " instrumentrations", "inceptionments", "informedations", " informATIONS", "informedates", "informats", "insformments", "informates", "insformats", "instrumentATIONS", "insformations"], "texteErreur": ["texteArrourred", "texteErritour", "texteErreour", "texteErroau", "texteErriturs", "texteErresurs", "texteErrenaur", "texteErritUR", "texteErrorrenau", "texteErresur", "texteErrorrenUR", "texteErrorreau", "texteErrecur", "texteErrourred", "texteErreurs", "texteErreure", "texteErrours", "texteArreurs", "texteErrorrenaur", "texteErrenure", "texteArreorer", "texteErreorer", "texteErritau", "texteErrenUR", "texteErroorer", "texteErreUR", "texteErriture", "texteErleurs", "texteArrenurs", "texteArreure", "texteErrorrenur", "texteArreur", "texteErreurred", "texteErrecUR", "texteArrours", "texteErrenur", "texteErritaur", "texteErresorer", "texteArroorer", "texteArrenur", "texteErrenurs", "texteErresurred", "texteErrecour", "texteErrecau", "texteErleurred", "texteErroour", "texteArreurred", "texteErrorreaur", "texteErroure", "texteErrorreur", "texteErrorreUR", "texteErrenau", "texteErreaur", "texteArrour", "texteArreau", "texteErritur", "texteArrenure", "texteErleur", "texteErreau", "texteErrour", "texteErleorer", "texteErroUR", "texteArrenau", "texteErroaur"], "numErreur": ["numErrenur", "numErryur", "numErREure", "numSerreeur", "numErroour", "numErroneour", "numSerreur", "numErREeur", "numErreurs", "numerrour", "numErryural", "numErrourer", "numErrenure", "numSerreneur", "numErroneurer", "numerroour", "numErreurer", "numErreneur", "numErroneur", "numErryure", "numErreour", "numerrourer", "numSerrenure", "numSerrenural", "numerreour", "numErREur", "numErreeur", "numerreurs", "numErreural", "numErrenour", "numerreur", "numSerreural", "numErrenurs", "numErroneurs", "numErreure", "numErREural", "numErryeur", "numErrenurer", "numSerrenur", "numerrours", "numErrours", "numSerreure", "numErrour", "numerreurer", "numErrenural"], "al": ["AL", "f", "a", "bel", "alf", "tal", " Al", " ab", "alist", "pal", "bal", "sl", "el", "list", " all", " cal", "aler", " signal", "als", "pl", " rel", "ral", "sal", "ar", "att", "cal", " fal", "ala", " hal", "all", "l", " AL", "af", " ale", "alis", "oper", "ali", "local", " ul", "r", "val", "Al", "back", "il", "ul"]}}
{"id1": "20267500", "id2": "13657103", "code1": "    public static AudioInputStream getWavFromURL(String urlstr) {\n        URL url;\n        AudioInputStream ais = null;\n        try {\n            url = new URL(urlstr);\n            URLConnection c = url.openConnection();\n            c.connect();\n            InputStream stream = c.getInputStream();\n            ais = new AudioInputStream(stream, playFormat, AudioSystem.NOT_SPECIFIED);\n            LOG.debug(\"[getWavFromURL]Getting audio from URL: {0}\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return ais;\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 0, "substitutes": {"urlstr": ["llSTR", " urlStr", "lstr", "httpstring", " urlpath", "filestring", "llStr", "lSTR", " urlSTR", " urlstring", "urlstring", "httppath", "fileStr", "lStr", "lstring", "llstr", "filestr", "httpstr", "filepath", "urlStr", "llstring", "urlSTR", "httpStr", "urlpath"], "url": ["plug", "cl", "f", "uri", "ssl", "string", "lc", "source", "resource", "web", "feed", "path", "host", "str", "server", "http", "ur", "org", "sl", "URL", "file", "conn", "page", "u", "ls", "www", "connection", "image", "b", "lr", "build", "l", "ll", "Url", "log", "oc", "loc", "li", "api", "rl", "ch", "ob", "fl", "coll", "ul", "e"], "ais": ["cci", "avi", "ahi", " ta", "ami", " ain", "oci", "bb", "aos", "audi", "au", "aud", "asi", "xml", "ci", "Audio", "ays", "ois", "plays", "mos", "is", "sa", "ians", "os", "ai", "waves", "rss", "ras", "ait", "ls", "ava", " sax", " audi", "aaa", "ws", "ios", "as", "ay", "rs", "aa", "ss", "acs", " ba", "ac", "audio", " ado", " tapes", "oi", "ia", " audio", "aus", "ae"], "c": ["cm", "cl", "f", "cs", "cu", "a", "cf", "lc", "ci", "con", "cn", "dc", "bc", "cr", "http", "pc", "fc", "nc", "cp", "p", "conn", "co", "u", "ct", "m", "cb", "connection", "cd", "ec", "client", "channel", "b", "cc", "l", "ctrl", "cmp", "ac", "ch", "api", "mc", "uc", "enc", "coll", "C", "e"], "stream": ["video", "cm", "f", "d", "data", "content", "src", "string", "source", "form", "output", "feed", "path", "host", "server", "zip", "sl", "input", "fc", "context", "p", "in", "reader", "Stream", "u", "w", "uu", "m", "connection", "engine", "io", "s", "coll", "channel", "sw", "l", "cache", "audio", "uc", "h", "object", "e"]}}
{"id1": "62362", "id2": "2009072", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "label": 0, "substitutes": {"src": ["inst", "ctx", "filename", "st", "rb", "feat", "ref", "uri", "gb", "ssl", "sb", "source", "string", "resource", "upload", "prot", "Dest", "path", "sin", "RC", "slice", "tmp", "buf", "sth", "input", "sl", "supp", "dist", "username", "secure", "load", "req", "fp", "url", "file", "sc", "reader", "impl", "img", "cb", "gz", "spec", "href", "s", "cpp", "storage", "gn", "vr", "name", "code", "obj", "sit", "sel", "rc", "proc", "download", "stream", "component", "cmp", "dep", "Source", "loc", "fn", "rl", "SourceFile", "ource", "config", "sec", "back", "sn"], "dest": ["target", "orig", "home", "source", "wb", "Dest", "dc", "path", "di", "tmp", "lib", " destination", "class", "dist", "cont", "txt", "temp", "img", "bin", "std", "dir", "obj", "disk", "fn", " dst", "null", "dat"], "in": ["inf", "f", "d", "a", "data", "isin", "inn", "source", "i", "t", "is", "input", "inas", "din", "file", "reader", "ins", "bin", "err", "io", "up", "as", "doc", "win", "ps", "In", "stream", "n", "pass", "inc", "IN", "ini", "r", "ex", "val", "login", "pin"], "p": ["pa", "pb", "pd", "f", "d", "pg", "g", "lp", "pm", "i", "per", "pc", "pe", "t", "h", "pp", "pr", "cp", "pi", "op", "fp", "v", "wp", "bp", "part", "sp", "cop", "m", "s", "py", "o", "pre", "c", "np", "b", "po", "j", "l", "ps", "jp", "parser", "tp", "P", "e"], "ds": ["docs", "d", "uds", "dt", "lp", " db", "ays", "hs", "ads", " DS", "ded", "scripts", "des", "ils", "icks", "ants", "qs", "dm", "vals", "dates", "ld", "sys", "dat", "posts", "ks", "styles", "ans", "pd", "cs", "sync", "data", "words", "points", "dp", "bs", "dd", "gs", "cdn", "Ds", "ups", "rs", "ps", "js", " dd", "sts", "cons", "tools", "els", "lines", "db", "DS", "di", "dist", "amps", "os", "tests", "vs", "dos", "ins", "ls", " sd", "s", "ws", "xs", "ts", "plugins", " props", " ps", "eps", "obs", "gd", "da", "dc", "parts", "dds", "ys", "utils", "nas", "ns", "ss", "df", "models", "dl"], "format": ["filter", "f", "filename", "prefix", "template", "feat", "data", "Format", "plugin", "version", "string", "source", "form", "xml", "path", "handler", "host", "t", "layout", "atter", "class", "tag", "scale", "function", "sche", "fp", "file", "url", "fd", "part", "type", "act", "spec", "style", "letter", "unit", "table", "language", "name", "struct", "ant", "pattern", "nat", "at", "frame", "parser", "fn", "api", "config", "magic", "record", "object", "model", "match"], "hasPixelData": ["hasPictureData", "hasPicOps", "haspixelStyle", " hasPixeldata", "hasBytedata", "hasPicStyle", "hasPixelDATA", "hasPictureDATA", "haspixelData", " hasPixelOps", "hasPixeldata", "hasPixelStyle", "haspixelOps", "hasPicData", "hasByteData", " hasPixelSize", "haspixelSize", "hasPicturedata", "hasPixelSize", "haspixelDATA", "haspixeldata", "hasPixelOps", " hasPixelStyle", " hasPixelDATA", "hasByteSize"], "inflate": [" inflATE", "infloocate", "uninflocate", "infloase", "uninfloute", "uninfloate", "information", "informATE", "incollate", "infloATE", "inflation", "infolute", " information", "infolame", "incollame", "inFlase", "incollocate", "inFlate", "informate", "infloate", "influte", "inflase", "incollute", "uninfloame", "inFlation", "uninflute", "infolate", "informase", "inflame", "infolocate", "infloation", " informase", "uninfloocate", " informate", "infloame", "infloute", "inflocate", "uninflame", " inflation", "inFlATE", " inflase", "inflATE", " informATE", "uninflate"], "pxlen": ["nplin", "pyln", "pxlf", "fxlen", "pngden", "xyfin", "pyden", "pxden", "fxden", "rxfin", "xplength", "xplen", "fxval", "pglf", "xylen", "pyl", "xpval", "cpden", "fxlf", "pxlin", "pxLen", "rxlen", "pylen", "pngln", "pplen", "fxl", "cpln", "pngLen", "rxlin", "nplen", "npden", "xyden", "fxlength", "ppden", "pxval", "pxfin", "pxl", "ppln", "npfin", "rxden", "xyLen", "xylin", "fxln", "pxlength", "xplf", "pxln", "pglen", "cplen", "pnglen", "cpl", "xyln", "ppLen", "pglength", "pgval"], "out": ["session", "dump", "prefix", "OUT", "re", "user", "point", "output", "line", "server", "cli", "lib", "list", "group", "parent", "store", "lock", "Out", "base", "v", "conn", "error", "page", "gen", "err", "inter", "io", "code", "up", "obj", "step", "print", "outs", "work", "cache", "log", "post", "copy", "sys", "again"]}}
{"id1": "14450108", "id2": "22035737", "code1": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "code2": "    private static void loadMappings(Configuration cfg) {\n        try {\n            Enumeration en = LoadingUtils.getResources(MAPPINGS_FILE);\n            while (en.hasMoreElements()) {\n                URL url = (URL) en.nextElement();\n                logger.info(\"Found mapping module \" + url.toExternalForm());\n                InputStream inputStream = null;\n                try {\n                    inputStream = url.openStream();\n                    HibConfiguration hm = loadModuleMappings(inputStream);\n                    configureModuleMappings(cfg, hm.getSessionFactory());\n                } catch (IOException e) {\n                    logger.warn(\"Could not load mappings file \\\"\" + url.toExternalForm() + \"\\\"\", e);\n                } catch (JAXBException e) {\n                    logger.warn(\"Unable to instantiate JAXBContext \", e);\n                } finally {\n                    try {\n                        if (inputStream != null) inputStream.close();\n                    } catch (IOException e) {\n                        logger.debug(e);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            logger.warn(\"Could not find any mappings file hibernate.mappings.xml\", e);\n        }\n    }\n", "label": 0, "substitutes": {"ftpe": ["gtpy", "rtpy", "ctpe", "bbp", "aftps", "ctp", "aftpa", "ctpy", "bbpe", "etp", "gtpa", "ftpa", "ctper", " ftfe", " ftpa", "etpe", "ctps", "ftps", "utper", "rtp", "ftpy", " ftpy", "rtpe", "utpy", "gtp", "ftper", "utp", "ftfe", "rtfe", "bbper", "etpa", "bbpy", "gtfe", "aftp", "utpe", "ctpa", "aftpe", "etps", "gtpe"], "ftp": [" ftf", "ftnp", "rtps", "bbp", "pttp", "ftw", "ctp", " ftr", "ctper", "fdpatch", "hardps", "bbpi", "ftpart", "ptp", "oftping", "aftcp", "htper", "htpi", "ufpe", "fttp", "ottP", "hardpc", "fto", "wtp", "afn", "ottf", "fw", "aftb", "aftf", "fnp", "ufcp", "cto", "ptb", "webnp", "fundp", "afto", "ftr", "fundf", "ptper", "ftn", " ftcp", "bbpe", "ufapi", "wtpe", "htpe", "ctb", " ftb", "ctpn", "ottp", " ftP", "webpatch", "oftw", "hardp", " ftw", "ttp", "aftconn", "ftpi", " fttp", "ttcp", "aftw", "ctP", "oftp", "rtpc", "webp", "hardcp", "ftconn", "ctconn", "fping", "htp", " ftconn", "tttp", "ottpe", "fundpe", "ttpe", "ttapi", "ptport", "ottr", "fdp", "aftpatch", "ttpc", " ftper", "fdnp", "ftps", "ftP", "ttps", "afpc", "ftpc", "rtp", "ptP", "fp", "aftpe", "wtper", "aftnp", "ftper", "aftP", "uftp", "rtn", "bbper", "rtcp", "fpart", " ftping", "ftapi", "fdtp", "ufpn", "ftping", " ftpc", "afcp", "webtp", "cttp", "ctn", "ftcp", "ftpatch", "ftf", "ctcp", " ftpart", " ftport", "afb", "ptr", " ftn", " fto", " ftpn", "oftpart", "ottport", "fundP", "ftb", "ftpn", "afp", "wtpi", "aftp", "afttp", "ftport", " ftapi", " ftnp", "ufp", "ctf"], "currentDir": [" currentZip", "currentDIR", "currentZip", "CurrentFile", " currentPath", "activeZip", " currentFolder", "currentPath", "CurrentPath", "reportedZip", "CurrentDir", "CurrentDb", "activePath", "currentDirectory", " currentFile", "resultFile", "currentDb", "CurrentDIR", "currentFile", "activeFolder", "activeDb", "resultDir", "CurrentDirectory", " currentDIR", "reportedDir", "resultDirectory", "resultDIR", "activeDir", "reportedDIR", " currentDirectory", "activeDIR", " currentDb", "currentFolder", "reportedFolder"], "reply": ["address", "next", "prefix", "ry", "sync", "rr", "data", " replies", "service", "request", "status", "ignore", "ply", "ise", "line", "reason", "response", "server", "entry", "answer", " Reply", "command", "dy", "repl", "cause", "text", "respond", "lock", "base", "query", "error", "vote", "fee", "bot", "connection", "state", "comment", "change", "force", "code", "info", "job", "route", "result", "write", "link", "Reply", "article", "resp", "frame", "ret", "continue", "proxy", " response", "grade", "message"]}}
{"id1": "19549489", "id2": "9033641", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public void testHttpsConnection_Not_Found_Response() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            try {\n                doInteraction(connection, ss, NOT_FOUND_CODE);\n                fail(\"Expected exception was not thrown.\");\n            } catch (FileNotFoundException e) {\n                if (DO_LOG) {\n                    System.out.println(\"Expected exception was thrown: \" + e.getMessage());\n                }\n            }\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"sourceFile": [" sourcefile", "searchFile", "SourceDirectory", " sourceFilename", "siteFile", "serviceFiles", "siteFiles", "SourceFiles", "serviceFile", "siteDirectory", " sourceFiles", "sourceFiles", "SourceFILE", "sourceFILE", "resourceFile", "siteFILE", " sourceFILE", "resourceDirectory", " sourceDirectory", "searchFiles", "sourceDirectory", "Sourcefile", "searchFilename", "serviceFilename", "sourceFilename", "sourcefile", "resourceFiles", "SourceFile", "resourcefile", "searchfile", "servicefile"], "destinationFile": ["destinatedImage", "DestinationDir", "distinatedImage", "destinatedfile", "distinationFiles", "destinationFiles", "distinatedDirectory", "destinationfile", "destinatorDir", "destationImage", "destinatorDirectory", "destinationDirectory", "destinatorFile", "distinatedFile", "destinatedDir", "destinatedDirectory", "destationFile", "destationFiles", "destationfile", "destinatorfile", "destationDirectory", "destinatedFile", "DestinationFile", "distinationFile", "DestinatorFile", "distinationImage", "destinatorImage", "destinationDir", "distinationDirectory", "DestinationFiles", "Destinationfile", "distinatedFiles", "DestinatorFiles", "destinationImage", "Destinatorfile", "DestinatorDir", "destationDir", "destinatorFiles", "destinatedFiles"], "sourceFileChannel": ["ourceStreamStream", "targetLibrarySocket", " sourceFileConnection", "sourceStreamStream", "sourceFileSocket", "targetFileChannel", "sourceLineStream", "sourceDirStream", "sourceLinechannel", "sourceFileChan", "sourceFunctionChannel", "sourceStreamChannel", "sourceStreamChan", " sourceFilesContext", " sourceFileContext", "sourceLineClient", "ourceFilechannel", "sourceFunctionContext", "targetLibraryClient", "sourceFunctionService", "targetLibraryChannel", "sourceLineSocket", "sourceDirectoryChan", "sourceLibraryChannel", "ourceStreamChan", " sourceFileService", "sourceFilechannel", "ourceFileChannel", "sourceFilesChannel", "sourceStreamConnection", "ourceFileStream", "sourceDirchannel", " sourceFilesConnection", "sourceStreamContext", "sourceDirectoryClient", "targetFileClient", "sourceLibrarySocket", "sourceDirChan", "sourceLineChan", "sourceDirectorySocket", "sourceStreamService", " sourceFilesService", "targetLibraryChan", "sourceLineChannel", "targetFileSocket", "ourceStreamchannel", "sourceFileStream", "sourceFileService", "sourceFilesConnection", "sourceFileContext", "ourceStreamChannel", "sourceFunctionConnection", "sourceFilesService", "sourceDirectoryChannel", "targetFileChan", "sourceLibraryChan", "sourceStreamchannel", "sourceFileConnection", " sourceFilesChannel", "sourceDirChannel", "ourceFileChan", "sourceFileClient", "sourceLibraryClient", "sourceFilesContext"], "destinationFileChannel": ["destinationDirectoryHandler", "destinationDirectoryChannel", "destinationFilesCache", "destinationIOService", "destinatorFilesService", "destinationLineClient", "destinatorFilesChannel", "destinatorFilesConnection", "destinatorFileService", "destinationFilesConnection", "destinatorFilesClient", "destinationLineChannel", "destinationIOClient", "destinationIOChannel", "destinationDirectoryService", "destinatorFileClient", "destinationFileConnection", "destinatorFileConnection", "destinatorFilesChan", "destinationFilesService", "destinationFilesChannel", "destinationLineService", "destinationFileCache", "destinationLineHandler", "destinationLineChan", "destinationFileService", "destinationDirectoryCache", "destinationLineConnection", "destinatorFileChan", "destinationFilesHandler", "destinationFilesChan", "destinatorFileHandler", "destinationIOCache", "destinationDirectoryConnection", "destinationFilesClient", "destinatorFilesHandler", "destinatorFileCache", "destinationDirectoryClient", "destinationFileHandler", "destinatorFileChannel", "destinatorFilesCache", "destinationFileClient", "destinationDirectoryChan", "destinationFileChan"]}}
{"id1": "14168494", "id2": "23611770", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"dest": ["target", " Dest", "st", "d", "data", "orig", "source", "resource", "wb", "Dest", "path", "output", "tmp", "comb", " destination", "class", "this", "dist", "desc", "txt", "sup", "file", "transfer", "destroy", "temp", "true", "done", "name", "later", "obj", "dir", "loc", "out", "null"], "src": ["inst", "target", "filename", "st", "sync", "rb", "gb", "ssl", "sb", "source", "upload", "Dest", "sub", "sin", "slice", "ds", "tmp", "sl", "dist", "rob", "sup", "file", "url", "sc", "img", "bin", "cb", "s", "storage", "sit", "sq", "sel", "rc", "download", "stream", "loc", "split", "copy", "config", "master"], "srcChannel": ["inputConnection", "distChan", "sourceChan", "inputchannel", "srcConnection", "inputChannel", "rcCh", "rcSection", " srcchannel", " srcStream", "srcCh", "sourceChannel", "rcChannel", "rcStream", " srcChan", "rcConnection", " srcButton", "inputSection", " srcConnection", "distStream", "srcStream", "destchannel", "srcButton", "srcChan", "destChan", "srcSection", "destConnection", "sourcechannel", "sourceButton", " srcSection", "rcChan", " srcCh", "srcchannel", "destChannel", "rcchannel", "rcButton", "distChannel", "distCh"], "dstChannel": ["dstChan", "ddestChan", "dstsConnection", "dsrcchannel", "dstchannel", "dstVideo", "dstContext", " dstContext", "DdestChannel", " dstchannel", "ddestContext", "dstsStream", " dstConnection", "dstsChannel", " drdContext", " dstStream", "dsrcChannel", "drdChan", " drdchannel", " drdChan", "dstStream", "dstschannel", "ddestchannel", " dstsStream", "DstChannel", "ddestVideo", "dstConnection", "dDestChannel", "dDestConnection", "dDestchannel", "Ddestchannel", "DstVideo", "dDestStream", " dstsChannel", "ddestStream", "dsrcVideo", "ddestConnection", "drcChannel", "ddestChannel", "DdestVideo", " drdChannel", "drdContext", "drcVideo", "drdchannel", "drdChannel", "Dstchannel", " dstschannel", "drcchannel", " dstsConnection", "drcChan", " dstChan", "drcContext"]}}
{"id1": "884867", "id2": "6501291", "code1": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"zipname": ["zipdata", "clipfile", "clipout", "filename", "foldername", "folderName", " zipName", "foldern", " zipfile", "filesize", "zfile", "clipname", "zdata", "zipnames", "zout", "slicen", "zipfile", "clipdata", " zipsize", "zname", "slicename", " zipnamed", "sliceName", "foldernamed", "zipnamed", " zipnames", "filenames", "znames", " zipdata", "filefile", "zipName", "zipsize", " zipn", "zipn", "slicenamed", "zsize"], "zipout": [" zippath", "zippath", "clipout", "ipagain", "filename", "filein", " zipcontainer", "clippath", " zipagain", "ipname", "zipin", "zagain", "clipname", "zipagain", "zout", "patchname", "patchin", "patchout", "zname", "fileout", " zipcache", "zcontainer", "zin", "ipout", "patchcontainer", "ipin", "zipcache", "zcache", "clipin", "zpath", "filecache", "zipcontainer", " zipin"], "out": ["ext", "dump", "OUT", "flush", "point", "user", "flow", "output", "diff", "line", "plus", "server", "list", "writer", "class", "lib", "group", "window", "Out", "lock", "base", "query", "parent", "error", "conn", "page", "co", "file", "raw", "down", "bin", "exp", "gen", "err", "io", "comment", "image", "code", "up", "name", "client", "obj", "o", "b", "print", "outs", "exec", "write", "pre", "cmd", "doc", "outer", "n", "cache", "log", "post", "view", "inc", "pool", "key", "ex", "copy", "word", "again", "model"], "buffer": ["number", "queue", "border", "uffer", "data", "row", "reference", "bb", "source", "wave", "resource", "feed", "slice", "layer", "read", "limit", "iter", "buff", "buf", "input", "binary", "base", "event", "url", "shape", "file", "transfer", "reader", "offset", "image", "header", "Buffer", "batch", "channel", "bytes", "b", "result", "size", "cache", "position", "count", "padding", "null", "sequence"], "in": ["gin", "f", "cl", "re", "serv", "a", "inn", "i", "wave", "ic", "con", "token", "ax", "fr", "is", "input", "init", "rec", "din", "conn", "reader", "ins", "bin", "err", "connection", "inner", "image", "up", "c", "as", "or", "l", "win", "In", "pass", "inc", "ac", "IN", "nin", "ini", "r", "ex", "login", "h", "again", "pin"], "length": ["number", "join", "f", "L", "child", "pull", "row", "left", "point", "last", "string", "section", "i", "end", "Length", "feed", "line", "slice", "limit", "pe", "character", "zip", "duration", "class", "total", "len", "value", "lock", "load", "jo", "rows", "shape", "part", "type", "level", "tail", "range", "oh", "force", "partial", "style", "offset", "code", "old", "width", "build", "present", "l", "size", "ph", "position", "ok", "loc", "body", "key", "count", "ob", "index", "sequence", "e", "id"]}}
{"id1": "17475530", "id2": "3024992", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 1, "substitutes": {"in": ["gin", "f", "version", "serv", "ac", "data", "isin", "socket", "uri", "ssl", "inn", "source", "i", "resource", "xml", "con", "token", "path", "diff", "with", "ax", "is", "el", "input", "min", "din", "file", "conn", "url", "reader", "rin", "ins", "bin", "m", "exp", "err", "connection", "get", "image", "stream", "name", "as", "exec", "or", "doc", "win", "index", "In", "work", "n", "cin", "inc", "pass", "IN", "at", "ini", "r", "ex", "nin", "copy", "login", "out", "again", "val", "pin", "id"]}}
{"id1": "4468255", "id2": "18974466", "code1": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"from": ["d", "path", "http", "entry", "by", "ce", "html", "url", "missing", "er", "From", "self", "open", "code", "original", "old", "before", "link", "at", "auto", "so", "e", "un", "f", "data", "left", "source", "with", " form", "context", "base", "file", "normal", "of", "connection", "io", "stream", "log", "local", "id", "empty", "form", "resource", " file", "line", "without", "zip", "this", "os", "add", "ate", "part", "se", "temp", "client", "dir", "c", "or", "start", "back", "user", "feed", "parent", "one", "range", "name", "vol", "o"], "to": ["yet", "To", "son", "path", "token", "on", "http", "pe", "by", "root", "jo", "but", "sp", "de", "as", "not", "disk", "auto", "so", "target", "sync", "x", "template", "data", "socket", "source", "eto", "two", "top", "base", "file", "connection", "io", "comp", "storage", "process", "tom", "po", "me", "no", "resource", "output", "line", "plus", "db", "dis", "database", "front", "os", "load", "too", "office", "se", "temp", "stat", "dir", "client", "or", "cache", "copy", "TO", "system", "user", "site", "t", "termin", "flo", "parent", "p", "one", "location", "name", "about", "o", "toc", "all", "size", "tto", "null"], "result": ["ure", "real", "length", "allow", "found", "data", "follow", "mask", "ok", "source", "success", "diff", "replace", "plus", "valid", "sign", "accept", "fail", "member", "search", "function", "lock", "event", "error", "url", "die", "math", "card", "part", "effect", "true", "method", "res", "var", "ult", "mer", "err", "comment", "future", "results", "force", "br", "arr", "Result", "up", "info", "term", "cur", "rc", "sum", "compl", "current", "cache", "pass", "ret", "work", "test", "val", "r", "count", "report", "continue", "use", "default", "status", "date", "match", "ver"], "subFiles": ["smallContents", "ubContents", "ubDir", "smallfiles", "newsfiles", " subParents", "subDir", "SubWords", "partfiles", "SubParts", " subFs", "newsFiles", "smallFiles", "ubfiles", "ubFile", "subPages", "subFs", "partFs", "ubFiles", "partFiles", "newFile", " subDir", "subNotes", "subFile", " subfiles", "partParents", "ubNotes", "newPages", "singParents", "newParts", " subPages", " subNotes", "smallNotes", " subContents", "newfiles", "subWords", " subFile", " subWords", "subContents", "newFiles", "singfiles", " subParts", "SubFile", "SubPages", "singFiles", "subParents", "SubFiles", "Subfiles", "newsWords", "subParts", "newsParts", "singFs", "subfiles", "ubPages"], "i": ["hi", "phi", "f", "x", "d", "ori", "ui", "it", "a", "ti", "uri", "ie", "bi", "ci", "gi", "slice", "di", "is", "h", "iv", "z", "pi", "p", "v", "ai", "ix", "u", "k", "iu", "io", "inner", "s", "ip", "ii", "y", "name", "o", "b", "ri", "I", "multi", "c", "j", "l", "n", "si", "key", "li", "ini", "oi", "mi", "index", "xi", "e", "id"], "newDir": ["subConf", "subDir", "subDirectory", "nextDir", "nextFolder", "newD", "oldDir", " newFolder", "newFile", "subD", "oldFile", "subJar", "rawdir", "newConf", "NewFile", " newJar", "subFile", "rawJar", "newDirectory", "oldFolder", "newJar", "rawDir", "NewFolder", "subdir", "NewConf", " newdir", " newFile", "NewD", " newDirectory", " newConf", "newdir", "rawDirectory", "NewDir", "NewDirectory", "newFolder", "nextFile", "oldDirectory", "nextDirectory", " newD"], "in": ["gin", "f", "a", "serv", "it", "data", "pull", "isin", "socket", "ie", "inn", "source", "thin", "con", "diff", "on", "is", "input", "init", "this", "min", "din", "file", "lin", "conn", "reader", "url", "part", "ins", "bin", "m", "err", "inner", "io", "image", "up", "o", "b", "c", "l", "win", "In", "cin", "inc", "IN", "nin", "ini", "r", "ex", "login", "index", "again", "config", "pin", "e", "id"], "out": ["ext", "sync", "OUT", "serv", "cat", "socket", "con", "output", "on", "off", "line", "with", "lib", "writer", "Out", "base", "lock", "ou", "op", "cy", "conn", "file", "can", "co", "w", "img", "bin", "one", "exp", "err", "call", "net", "io", "inner", "name", "up", "client", "obj", "o", "c", "outs", "write", "exec", "all", "sum", "n", "at", "log", "post", "inc", "ex", "again"], "fileLength": ["pageSize", "fileSize", "baseLen", "baselength", "filelength", "FileLength", "baseLength", "fileLen", "Filelength", "pageName", "lineName", "pagelength", "fileName", " fileLen", "lineSize", " fileName", "FileSize", "FileLen", "linelength", "baseSize", "pageLength", " filelength", "lineLength", " fileSize"], "charBuff": ["pairMatrix", " charBuffer", "wordBuffer", "pairBuffer", "charBuffer", "pairBuff", "wordMatrix", " charMatrix", "charMatrix", "wordBuff"], "len": ["et", "lit", " split", "ni", "ln", "line", "iter", "lf", " lang", "nt", "part", "rev", "bin", " Len", "pos", "fin", "en", "l", "Len", "start", "cmp", " pos", "li", "val", "split", "fl", "id"], "oneChar": ["oneCor", "oneCh", "OneCh", "eightCharacter", "eightchar", " oneCor", "singleCor", "singleChar", "fourPixel", "eachChar", "singleCh", "eightPixel", "singleByte", "fourChar", "eachPixel", "eightChar", "fourCharacter", "OneByte", " oneCharacter", "eachCharacter", "oneByte", "OneChar", "eachchar", "oneCharacter", " onechar", "fourchar", "OneCor", "singlechar", "singleCharacter", " oneCh", "onePixel", "onechar", " oneByte"]}}
{"id1": "22993368", "id2": "13783549", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"infile": ["inputfp", "minfile", "inputfilename", "infilename", " infilename", " infiles", " inbase", "minFile", " instream", "outfp", "inputfile", "inputfiles", "Instream", "Inbase", "inFile", "infp", "inbase", "Infile", "infiles", " infp", "InFile", "instream", "minbase", "minstream", "outfilename", "outfiles", " inFile"], "outfile": ["outputfilename", "outputdatabase", " outfolder", "outputFile", "infilename", "outputfile", "inputpath", "inputfile", "infolder", " outpath", "inFile", "outpath", " outFile", " outfilename", "outfolder", "outputpath", "inputFile", "outdatabase", "outputfolder", " outdatabase", "outFile", "inputdatabase", "outfilename"], "in": ["gin", "a", "re", "data", "isin", "socket", "inn", "source", "i", "thin", "ic", "con", "sin", "is", "input", "init", "inas", "min", "din", "conn", "lin", "reader", "rin", "ins", "bin", "m", "into", "err", "inner", "s", "b", "inside", "as", "win", "In", "pass", "cin", "inc", "ac", "IN", "nin", "ini", "r", "login", "again", "pin", "id"], "out": ["session", "sync", "OUT", "socket", "point", "home", "no", "exit", "output", "off", "line", "lib", "writer", "parent", "Out", "base", "ou", "error", "file", "conn", "co", "timeout", "bin", "one", "err", "net", "io", "to", "inner", "image", "name", "up", "client", "job", "o", "obj", "channel", "outs", "exec", "write", "or", "outer", "In", "work", "cache", "log", "post", "inc", "pass", "ex", "copy", "again"], "buffer": ["queue", "border", "address", "length", "uffer", "data", "flush", "reference", "bb", "source", "wave", "feed", "slice", "layer", "server", "limit", "iter", "buff", "buf", "input", "binary", "value", "base", "raw", "transfer", "url", "reader", "bin", "type", "offset", "seed", "Buffer", "batch", "channel", "bytes", "b", "write", "result", "size", "cache", "split", "count", "padding", "null"], "read": ["lex", " write", "f", "length", "x", "sync", "allow", "next", " copy", "find", "ad", "check", "parse", "i", "Read", "connect", "send", "end", "feed", "tell", "slice", "ind", "limit", "iter", "wait", "len", "reading", " Read", "load", "add", "raw", "sleep", "reader", "select", "play", "se", "fill", "seek", "io", "get", "ride", "READ", "ip", "_", " count", "write", "exec", "size", "reads", "start", "work", "n", "pass", "run", "inc", "current", "count", "r", "copy", "use", " skip", "id"], "success": ["primary", "growth", "construct", "better", "data", "content", "follow", "fast", "flash", " succ", "successful", "status", "cess", "path", "rolling", "response", "valid", "model", "rolled", "initial", "fail", " successful", "value", "failed", "ccess", "roll", "func", "error", "winner", "first", "true", "method", "danger", "comment", " succeed", "results", "warning", "open", "done", "right", " Success", "ceed", "result", "successfully", "good", "Success", "pass", "xx", "positive", "complete", "continue", "default", "again", "null", "message"]}}
{"id1": "14473781", "id2": "10158738", "code1": "        @Override\n        protected String doInBackground(Void... params) {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpContext localContext = new BasicHttpContext();\n            HttpPost httpPost = new HttpPost(urlFormated);\n            try {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n                for (int index = 0; index < POSTparamList.size(); index++) {\n                    if (POSTparamList.get(index).getName().equalsIgnoreCase(\"image\")) {\n                        entity.addPart(POSTparamList.get(index).getName(), new FileBody(new File(POSTparamList.get(index).getValue())));\n                    } else {\n                        entity.addPart(POSTparamList.get(index).getName(), new StringBody(POSTparamList.get(index).getValue()));\n                    }\n                }\n                httpPost.setEntity(entity);\n                HttpResponse response = httpClient.execute(httpPost, localContext);\n                return processAnswer(response);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"params": ["data", "uri", "parse", "i", "Parameters", "handler", "resources", "param", "list", "par", "json", "pi", "query", "array", "properties", "page", "url", "ams", "type", "ip", "instance", "ps", "Param", "api", "config", "Par", "options"], "httpClient": ["HttpPost", "HttpClient", "httpsClient", "httpsCall", "httpCall", " httpCall", "HttpCase", "HttpCall", "ttpClient", "httpsCase", "ttpContext", "httpCase", " httpProxy", "ttpPost", " httpContext", "httpsPost", "HttpContext", "httpContext", "httpProxy", "HttpProxy", "ttpProxy", " httpCase"], "localContext": [" localConfig", " localcontext", "httpcontext", " localData", " localClient", "locConfig", "LocalClient", "localData", "localcontext", "localClient", "globalContext", "httpData", " localPort", "globalcontext", "locContext", "loccontext", "globalPort", "LocalContext", "globalClient", "httpContext", "Localcontext", "LocalPort", "localPort", "localConfig", "locData", "httpConfig"], "httpPost": ["HttpPost", "requestCopy", "phpPost", "phpPOST", "phppost", "HttpCreate", "requestPost", "phpCopy", "cachePost", "httpPatch", " httpPOST", "ttpCreate", "httpsPOST", "cachePatch", " httpCreate", "ttpCopy", "HttpCopy", "cachePOST", " httpCopy", " httpPatch", "httpCreate", "requestpost", "httpRequest", "ttppost", "ttpPost", "httpsRequest", "httpsPost", "httppost", "cacheRequest", " httppost", "httpCopy", "requestPOST", "httpPOST", "httpsPatch", "Httppost", " httpRequest"], "entity": ["issue", "eme", "address", "content", "service", "ity", "xml", "resource", "document", "per", "ent", "line", "person", "http", "model", "entry", "pe", "server", "el", "ce", "json", "base", "p", "event", "file", "page", "url", "part", "translation", "environment", "object", "connection", "image", "element", "media", "collection", "channel", "email", "om", "oe", "instance", "component", "Entity", "post", "body", "api", "node", "activity", "enc", "coll", "article", "create", "e"], "index": ["number", "column", "length", "prefix", "request", "weight", "second", "initial", "value", "type", "element", "old", "inc", "view", "pointer", "primary", "address", "f", "version", "x", "data", "left", "other", "success", "slice", "search", "in", "num", "connection", "action", "width", "position", "key", "word", "again", "id", "operation", "author", "string", "i", "diff", "ind", "list", "part", "level", "letter", "offset", "update", "argument", "pos", "pattern", "default", "object", "coll", "date", "expression", "condition", "alpha", "site", "section", "label", "page", "edit", "image", "name", "batch", "route", "step", "all", "size", "axis", "loop", "Index", "active"], "response": ["application", "data", "service", "request", "i", "resource", "output", "feed", "handler", "server", "http", "model", "answer", "onse", "Response", "json", "respond", "value", "reply", "v", "respons", "page", "array", "method", "connection", "offer", "image", "collection", "client", "related", "result", "resp", "post", "body", "api", "object", "status", "e", "message"]}}
{"id1": "17627195", "id2": "7468827", "code1": "    public Document getContentAsDocument() {\n        synchronized (this.url) {\n            URLConnection connection = this.url.openConnection();\n            if (doReload(connection)) {\n                InputSource inputSource = new InputSource(connection.getInputStream());\n                DocumentBuilderFactory factory = new DocumentBuilderFactoryImpl();\n                this.document = factory.newDocumentBuilder().parse(inputSource);\n            }\n            return this.document;\n        }\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"connection": ["application", "session", "Connection", "ctx", "condition", "which", "socket", "service", "source", "connect", "lc", "builder", "proxy", "con", "section", "handler", "db", "response", "server", "character", "this", "context", "communication", "function", "database", "conn", "url", "reader", "directory", "closed", "io", "image", "open", "connected", "collection", "client", "channel", "relation", "c", "result", "instance", "ion", "driver", "loc", "config", "pointer"], "inputSource": ["inputConnection", "dataPoint", "sourceSource", "imageConnection", "sourceStream", "inputStream", "InputReader", "inputProvider", " inputConnection", "dataProvider", "InputStream", "imageStream", "imageSource", "imageReader", " inputReader", "InputConnection", "inputReader", " inputPoint", " inputStream", "inputPoint", "sourceProvider", "InputSource", "sourcePoint", "dataStream", "dataSource", " inputProvider"], "factory": ["fii", "found", "confence", "confFactory", "Flesh", "confactory", "confii", "fence", "Factory", "cfence", "fFactory", "FFactory", "cfactory", "cfuture", " fii", "facactory", "facound", "flesh", "cfound", " flesh", "future", "confuture", "confound", "facuture", "Fii", " fFactory", "conflesh", "facence"], "document": ["application", "docs", "version", "content", "Document", "source", "xml", "graph", "director", "layer", "server", "response", "model", "project", "parent", "html", "entity", "root", "database", "url", "page", "library", "object", "image", "element", "media", "collection", "design", "result", "doc", "cache", "node", "record", "proxy", "layout", "master", "message"]}}
{"id1": "16851955", "id2": "18238468", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "label": 1, "substitutes": {"temp": ["tem", "session", "f", "template", "data", "wrap", "emp", "empty", "form", "container", "path", "output", "http", "model", "font", "tmp", "zip", "input", "writer", "this", "fake", "folder", "stable", "base", "lock", "txt", "parent", "v", "file", "full", "mount", "directory", "io", "buffer", "storage", "archive", "porary", "pipe", "flat", "cache", "current", "test", "local", "clean", "ex", "cel", "Temp", "copy", "out", "config", "null", "dat"], "layers": ["sloss", "lasses", " loss", "dlacks", "liusters", "blayers", "gows", " lodes", "liers", "liiers", "lows", " lows", "dlows", "bloss", "slayers", "languages", "liodes", "libraries", "lists", "gayers", "flanguages", "bllements", "dlenses", "dlusters", "dlores", "liores", "dliers", " lusters", "dlibraries", "Layers", "loss", " lays", " lacks", "lienses", "lays", " llements", "slists", " lists", " lasses", "dlayer", "layer", "dlayers", "lodes", " lients", "Lodes", "fllements", "lenses", " languages", "blists", "lores", "lacks", "slays", "Lients", "blays", "lusters", "flasses", " lores", "gayer", "liows", "lients", " liers", "liayers", "liients", " libraries", "liacks", " lenses", "llements", " layer", "gibraries", "flayers", "blasses", "blanguages"], "fann": [" fannon", "fcannot", "Fannon", "fain", "fanne", "sfannon", "sfann", "lann", "sfain", "sfAnn", "Fann", "fannot", "farn", " fannot", "fcann", "fannon", "lanne", "lannot", "Fain", "fcarn", "larn", "FAnn", "fAnn", " fAnn", "fcanne", " farn", " fain", " fanne"], "trainer": ["Triner", "Tracer", " tracker", "racer", "striner", "racker", "Trainer", "stracer", " trrain", "rainer", "trrain", "thacer", "triller", "traver", "prainer", "thainer", " triller", "riller", "strainer", "strayer", "trayer", "Trrain", "thacker", "tracker", " tracer", " trayer", " traver", "prayer", "thiller", "Trayer", "retayer", "praver", "retiner", "retainer", "prrain", "retacer", "tracer", "Traver", "triner"], "desiredError": ["resiredEvent", "deservedSize", "desizedEvent", "deservedGrade", "deservedCode", "desirederror", "desireError", "deservedException", "desirableGrade", "desizedException", "DesireException", "desirableCode", "despiredError", "Desireerror", "desizedGrade", "deservedEvent", "desiredCode", "despiredException", "descuedException", "desciredException", "desizedCode", "desedError", "desedFailure", "desiredEvent", "DesiredError", "resiredCode", "DesiredException", "Desirederror", "reservedEvent", "desiredException", "resiredGrade", "desciredError", "desireSize", "desireerror", "desedException", "desuedException", "DesireError", "descuedError", "DesireSize", "desiredFailure", "reservedCode", "desireException", "desiredSize", "deservedError", "desirableEvent", "despiredSize", "desiredGrade", "desuedError", "desciredFailure", "desizedFailure", "deservederror", "desirableError", "DesiredSize", "despirederror", "reservedError", "desuedFailure", "resiredError", "desizedError", "reservedGrade", "descuedFailure"], "mse": ["MSE", "amSE", " mbe", " mze", "mbe", "fce", "mge", "Mse", "rmse", " mSE", "mce", "amze", "Mbe", "rmbe", "Mce", " mge", "rmce", "mSE", "fge", "rmge", "amge", "Mge", " mce", "Mze", "amse", "fse", "fSE", "mze"]}}
{"id1": "2009072", "id2": "4389475", "code1": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "code2": "    @Override\n    public URLConnection openConnection(URL url) throws IOException {\n        if (!url.getProtocol().equals(\"file\")) {\n            String name = url.getFile();\n            File f = new File(cacheFolder, ((name.charAt(0) == '/') ? name.substring(1) : name).replace('/', File.separatorChar));\n            if (!f.exists()) {\n                File f2 = new File(f.getParentFile(), f.getName() + \"-not_found\");\n                if (!f2.exists()) {\n                    try {\n                        f.getParentFile().mkdirs();\n                        downloadFile(url, f);\n                    } catch (IOException e) {\n                        f.delete();\n                        throw e;\n                    }\n                }\n            }\n            return f.toURI().toURL().openConnection();\n        }\n        return super.openConnection(url);\n    }\n", "label": 0, "substitutes": {"path": ["ath", "filter", "PATH", "next", "prefix", "template", "data", "content", "tree", "uri", "request", "string", "form", "xml", "end", "plus", "str", "input", "list", "text", "context", "value", "parent", "base", "txt", "root", "file", "in", "pointer", "full", "part", "temp", "Path", "method", "type", "inner", "s", "self", "image", "name", "obj", "route", "c", "pattern", "or", "index", "stream", "log", "key", "transform", "node", "clean", "api", "enc", "body", "word", "object", "id"], "len": ["f", "length", "lc", "i", "end", "ln", "span", "line", "limit", "iter", "sl", "list", "lf", "base", "v", "lin", "part", "sp", "lim", "pos", "le", "fin", "en", "l", "size", "ll", "Len", "n", "split", "val", "count", "li", "fl"], "p": ["pa", "pb", "f", "point", "lp", "i", "press", "param", "pe", "pc", "t", "pp", "pr", "cp", "fp", "v", "sp", "u", "s", "ip", "vp", "py", "o", "c", "np", "po", "j", "l", "ps", "n", "tp", "api", "r", "ep", "P", "ap", "e"], "url": ["f", "user", "uri", "bb", "ssl", "string", "source", "resource", "web", "feed", "host", "server", "http", "sl", "URL", "blog", "base", "file", "page", "conn", "www", "location", "connection", "image", "open", "client", "channel", "b", "browser", "l", "link", "ll", "Url", "api", "ob", "fl", "object", "ball"], "result": ["data", "content", "uri", "ssl", "request", "source", "resource", "success", "output", "response", "http", "entry", "tmp", "this", "event", "array", "raw", "page", "reader", "res", "err", "results", "buffer", "open", "Result", "up", "obj", "instance", "stream", "work", "ret", "report", "val", "r", "api", "object", "match", "message"]}}
{"id1": "7006052", "id2": "23370621", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"src": ["inf", "filename", "sync", "rb", "data", "uri", "string", "source", "sb", "resource", "remote", "upload", "path", "sub", "sin", "slice", "sl", "txt", "sup", "url", "file", "sc", "img", "href", "s", "image", "archive", "code", "b", "old", "sel", "rs", "rc", "stream", "js", "loc", "fn", "config"], "dest": ["delete", "target", " Dest", "filename", "data", "orig", "home", "source", "wb", "Dest", "output", "sub", "const", "tmp", "comb", "project", " destination", "dist", "folder", "desc", "secure", "txt", "sup", "des", "die", "temp", "opt", "bin", "img", "default", "done", "later", "name", "dir", "route", "b", "result", "flat", "test", "loc"], "destFile": ["destF", "DestDir", " destinationFile", " destinationDir", " destDir", "destFiles", " destinationF", "targetfile", "DestF", " destinationFiles", "DestFile", " destF", "targetFile", "targetFiles", "DestFiles", "targetDir", "destfile", " destfile", "destDir", "Destfile", " destFiles"], "in": ["gin", "f", "data", "socket", "inn", "source", "i", "thin", "ln", "con", "diff", "is", "input", "init", "kin", "din", "url", "lin", "reader", "rin", "impl", "ins", "bin", "err", "inner", "s", "image", "up", "inside", "l", "win", "trans", "In", "pass", "n", "inc", "cin", "IN", "stream", "nin", "ini", "r", "login", "again", "pin", "id"], "out": ["ext", "sync", "OUT", "data", "user", "other", "output", "off", "cos", "writer", "this", "parent", "Out", "conn", "file", "plain", "part", "w", "bin", "one", "exp", "err", "net", "io", "inner", "image", "up", "obj", "client", "o", "exec", "outer", "work", "n", "inc", "log", "post", "cache", "pool", "ac", "ex", "copy", "extra", "again", "null"], "buf": ["queue", "ctx", "length", "bl", "bh", "rb", "data", "orig", "path", "pad", "blocks", "bc", "off", "tmp", "buff", "fb", "cv", "seq", "ff", "cas", "block", "bf", "raw", "v", "vec", "bin", "cb", "box", "bd", "buffer", "br", "Buffer", "batch", "b", "bytes", "c", "result", "rc", "uf", "cache", "pool", "loc", "cap", "uc", "bag", "map"], "len": ["f", "length", "data", "ie", "no", "lc", "end", "ln", "line", "off", "ind", "iter", "el", "lf", "base", "nt", "min", "url", "fd", "num", "part", "rev", "lim", "pos", "c", "pre", "bytes", "all", "en", "l", "size", "Len", "fin", "n", "split", "val", "count", "cap", "body", "li", "fl", "coll", "id"]}}
{"id1": "9275622", "id2": "255765", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"_file1": ["_zip1", "_fone", "_resource1", "_files01", "_fileOne", "_f1", "_mail2", "_zipOne", "_files0", "_mail0", "_fOne", "_File2", "_mail01", "_fileone", "_files1", "_resourceone", "_files2", "_file01", "_fileFirst", "_resourceFirst", "_file0", "_File01", "_File0", "_fFirst", "_File1", "_mail1", "_resourceOne", "_zipone", "_zipFirst"], "_file2": [" _files4", "_play2", "_Filesecond", "_playsecond", "_play3", "_model1", "_File5", "_filesTwo", " _file4", " _filesTwo", "_playTwo", " _fileTwo", "jmodelsecond", "jmodel2", "jmodel5", "_File2", "_play5", "jfile2", "_play1", " _files3", "jfile1", "_files2", "_file3", "_model5", "_filesecond", "_files4", "_play4", "_File1", "jfile5", "_modelsecond", "_file4", "jmodel1", "_fileTwo", "jfilesecond", "_files3", " _files2", "_file5", " _file3", "_model2"], "fis": ["Fos", "lfis", "fas", " fils", " fris", "lfais", " fas", "Fris", "fris", "cfas", " fais", "Fils", "cfris", "lfiss", "afis", "afi", "Fis", " fiss", "infils", " fi", "afiss", "cfis", "afais", "fais", "cfiss", "fiss", "infiss", "cfos", "fils", "Fas", "fi", "infos", "Fiss", "lfi", "infis"], "fos": ["Fos", "foes", "feoses", "Foos", "lis", "fOS", "lOS", "feis", "flOS", "infios", "gus", "faos", "poes", "floes", "fus", " fo", "infoos", "goses", "Fis", "los", "flos", "foos", "Fros", " fios", "fios", "infros", " fus", " faos", "Fus", "infaos", "flis", "Fios", "fo", " foos", " fros", "pos", "foses", "gos", "infos", "Fo", "Foses", "feos", "infus", "pis", "pOS", "fros", "Faos", "feus", "info", "loes", "gis"], "canalFuente": ["canalBuente", "canallBuente", "canallBuencia", "canalBuze", "canalsFuencia", "canalFUje", "canalsBuente", "canalCraento", "canaledBuje", "canalFUence", "canalBuento", "canaledFuje", "canalKuze", "canalsFuento", "canalsFuente", "canaledFuze", "canalBuestro", "canalFUze", "canalCraente", "canalBuencia", "canalSuze", "canalSuestro", "canalFUente", "canalsFuence", "canalCraencia", "canalBuje", "canalSuente", "canallFuence", "canalFuze", "canallFuze", "canalCraence", "canallBuence", "canalFUestro", "canalFuestro", "canalsBuento", "canaledBuze", "canalFuje", "canalKuence", "canallBuze", "canaledBuestro", "canalSuje", "canallFuente", "canalFuence", "canalKuente", "canalKuencia", "canalKuento", "canalFuento", "canalsBuencia", "canaledBuente", "canalFUencia", "canalsBuence", "canalBuence", "canallFuencia", "canaledFuente", "canalFuencia", "canaledFuestro"]}}
{"id1": "9857412", "id2": "13368520", "code1": "    @Override\n    public void writeData(byte[] data, byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        OutputStream os = urlc.getOutputStream();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        byte[] buffer = new byte[1024];\n        int br;\n        while ((br = bis.read(buffer)) > 0) {\n            os.write(buffer, 0, br);\n            if (!transferMetaData) {\n                transferredBytesNum += br;\n                elapsedTime = System.currentTimeMillis() - startTime;\n                fireOnProgressEvent(transferredBytesNum, elapsedTime);\n            }\n        }\n        bis.close();\n        os.close();\n    }\n", "code2": "    public void sendTextFile(String filename) throws IOException {\n        Checker.checkEmpty(filename, \"filename\");\n        URL url = _getFile(filename);\n        PrintWriter out = getWriter();\n        Streams.copy(new InputStreamReader(url.openStream()), out);\n        out.close();\n    }\n", "label": 0, "substitutes": {"data": ["queue", "video", "address", "content", "request", "source", "sample", "resource", "resources", "response", "input", "text", "json", "value", "database", "load", "array", "reader", "timeout", "connection", "image", "media", "batch", "bytes", "multi", "result", "memory", "cache", "DATA", "body", "config", "dat"], "options": ["address", "bits", "times", "resource", "Options", "resources", "parts", "option", "groups", "meta", "json", "properties", "params", "opt", "files", "scope", "table", "style", "results", "io", "ops", "obj", "details", "bytes", "vals", "settings", "values", "ts", "cache", "flags", "keys", "config", "headers", "object", "info"], "transferMetaData": ["transfermetaNew", "transfermetaData", "transferMediaDATA", "transferMetaNew", "writeMetaDATA", "writePersonalDATA", "removeETAPart", "transferNoData", "transfermetaPart", " transferMetData", "writePersonalArray", "writePersonalPart", "writePersonalData", "writeMetaData", "transfermetaBreak", "transferMediaArray", "transferMetaClass", "removeETAText", "transferInternalNew", "transferPersonalArray", "writeMetaArray", " transferMetaBreak", "removeETAData", "transfermetaClass", "transfermetaText", " transferMetaNew", "transferInternalData", "removeMetaData", "removeMetaText", "transferPersonalData", "transferNoPart", "removeMetaClass", "removeETAClass", " transferMetNew", "transferNoText", " transferMetBreak", "transferNoClass", "transferMetaPart", "removeMetaPart", "transferMetData", "transferETAPart", "transferPersonalDATA", "transferETAClass", "writeMetaPart", "transferMetBreak", "transferInternalBreak", "transferMetaBreak", "transferMediaData", "transferETAData", "transferETAText", "transferMetaDATA", "transferMetNew", "transferMetaText", "transferPersonalPart", "transferMetaArray", "transferMediaPart"], "startTime": ["endTimes", " startStream", "startPoint", "StartTime", "endStream", " startValue", "endLine", "startedLine", "StartStream", "startStream", "startValue", " startTimes", "endValue", "startedValue", "StartLine", " startLine", " startPoint", "startedTime", "startTimes", "endTime", "StartTimes", "endPoint", "startedPoint", "startLine"], "transferredBytesNum": ["translatedBytesNum", "transferredPartsNum", "translatedbytesSum", "transportedbytesNo", "transferredPartsSum", "transferredBytesVal", "transendedPartsLen", "transportedBytesNo", "translatedbytesNo", "transferredBytesSum", "translatedbytesNum", "transferredPartsLen", "transferredbytesVal", "translatedBytesNo", "transportedbytesMon", "transferredFilesNo", "transendedPartsNum", "transendedBytesNum", "transferredPagesNo", "transferredTokensSum", "transendedBytesLen", "transendedPartsStr", "translatedBytesVal", "transferredbytesNo", "transferredPagesMon", "transferredbytesNum", "transferredPartsMon", "transferredbytesSum", "transferredPartsVal", "transportedBytesMon", "translatedbytesVal", "transferredFilesSum", "transferredFilesNum", "transportedBytesSum", "transferredBytesNo", "transferredTokensNum", "transendedBytesSum", "transportedbytesSum", "transferredbytesMon", "transferredBytesMon", "transendedBytesStr", "transferredPartsNo", "translatedBytesSum", "transferredBytesStr", "transportedBytesNum", "transferredBytesLen", "transendedPartsSum", "transferredPagesSum", "transferredPagesNum", "transferredFilesVal", "transferredTokensLen", "transferredPartsStr", "transportedbytesNum", "transferredTokensStr"], "elapsedTime": ["elavedLine", "elapsedClock", "elapsedPath", "elroredPath", "elcedLine", " elavedPath", "elapseValue", "ElapseName", "elroredTime", "elapsedValue", "ElapsedValue", "elapsedLine", " elroredTime", "elashedTime", " elapsedLine", "elapseLine", "elapseClock", " elroredClock", "elapsePath", "elroredClock", "elroredValue", " elavedTime", "elapseTime", " elavedLine", "elavedTime", "elavedPath", "elashedName", "elroredName", " elroredLine", "elcedClock", "ElapseTime", "elcedTime", " elapsedPath", " elapsedClock", "elashedValue", "elroredLine", "elapseName", "ElapseValue", "elapsedName", "ElapsedName", "ElapsedTime"], "opts": ["prens", "OPTS", " opments", " opns", "prers", "opps", "OPments", " opty", "optrs", "prets", "oprs", "optTs", " optts", "OPts", " optte", "optTS", "opments", "optts", " optters", " opps", "OPTs", " opte", "optments", "OPps", "opTs", "OPte", "opters", "opns", "optte", "opty", "preTS", "optty", " opTS", "optns", " opters", "opte", "OPty", " oprs", " optps", " opTs", "OPters", "opTS"], "server": ["system", "address", "prefix", "version", "serv", "peer", "port", "socket", "uri", "user", "service", "ssl", "string", "domain", "site", "resource", "source", "path", "host", "http", "value", "erver", "database", "type", "secret", "name", "client", "vers", "Server", "localhost", "ser"], "username": ["account", "address", "filename", "prefix", "port", "user", "uri", "mobile", "string", "ername", "profile", "usr", "token", "subject", "character", "text", "database", "auth", "method", "manager", "uid", "users", "family", "name", "client", "machine", "nick", "email", "ame", "property", "USER", "dn", "key", "driver", "localhost", "login", "config", "attribute", "sword"], "password": ["session", "account", "column", "prefix", "port", "user", "mask", "service", "string", "resource", "profile", "path", "token", "pad", "host", " passwords", "database", "auth", "fax", "phrase", "secret", "priv", "name", "device", "client", "channel", "Password", "pass", "picture", "PASS", "key", "padding", "attribute", "word", "sword", "agent"], "filePath": ["fullName", "FILEPath", "ilepath", "Filepath", "singleUrl", " fileInfo", "FilePath", "ilePoint", "ileName", "playpath", "fileInfo", "resourceLocation", "filePoint", " fileCode", " fileType", "ileHalf", "fileLocation", "FileName", "resourceUrl", "FileUrl", "fileHalf", "playName", "resourceCode", " filePoint", " filepath", "resourceInfo", "FILECode", "singleName", "resourceHalf", "fullpath", " fileHalf", "resourceName", "FileInfo", "FILEpath", "FileLocation", "fileUrl", " fileLocation", "singlepath", "filepath", "fileType", "FILEName", "ilePath", "fullPath", "singlePath", "playType", "fileCode", "fullPoint", "resourceType", "resourcePath", "resourcepath", "playPath", "FileType", " fileUrl"], "idx": [" idy", "Idw", " idxs", "midn", "Idx", "midx", "indx", "intxs", " idn", " idX", "indn", "idX", "intX", "Idxc", "indy", "IdX", "intx", "idy", "idxs", "indc", "indX", "Idy", "midX", " idc", "indw", "Idxs", "idc", "idxc", " idxc", "indxc", "idn", "inty", " idw", "midc", "idw"], "fileName": ["FilePart", " fileInfo", "baseName", "FilePath", "baseUrl", "fileInfo", "basePath", "FileName", "FileUrl", "filePart", "resourceInfo", "resourcePart", "resourceName", "FileInfo", "basePart", " filePart", "fileUrl", "resourcePath", " fileUrl"], "url": ["plug", "f", "bug", "bel", "g", "uri", "user", "service", "ssl", "i", "resource", "web", "path", "host", "str", "http", "org", "sl", "z", "URL", "json", "blog", "base", "p", "page", "www", "gl", "object", "connection", "io", "open", "client", "o", "b", "browser", "l", "Url", "li", "api", "https", "config", "proxy"], "urlc": ["sslfc", " urlp", "slci", "cald", " urlf", "httpp", "urlconn", "urlcs", "Urlfc", "calcon", "urli", "httpc", "webcon", "toolconn", "webclient", "webf", "toold", " urlpc", "Urlpc", " urlfc", "urlcon", " urlcon", "sslcs", "sli", "toolc", "urlclient", " urlcs", "urld", "calc", " urlci", "calconn", "urlp", "urlf", "webc", "Urlc", "slp", " urlconn", "calf", "calclient", "urlci", "Urlcs", "sslc", "slc", " urlclient", "urlpc", "httpi", "urlfc", "sslpc", "toolcon", " urli", "httpci", " urld"], "os": ["oss", "obs", "OS", "ris", "bits", "bos", "socket", "las", "aos", "ose", "oid", "ol", "cos", "mos", "los", "us", "is", "bs", "op", "oser", "conn", "iso", " bos", "fits", "dos", "res", "boot", "io", "s", "Os", "opus", "ios", "ops", "o", "c", "oses", "pos", "ros", "ps", "osi", "ob", "so", "oos", "out", "oS", "fs"], "bis": ["oss", "pins", "obs", "nis", "lis", "ris", "bits", "ori", "bos", "uds", "bb", "ses", "aos", "oris", "sb", "bi", "abs", "ais", "sin", "ois", "cos", "usb", "buff", "fb", "is", "binary", "abi", "bs", "obb", "ubis", " bos", "vs", "co", " cis", "ins", "phys", "bin", "bps", "cb", "ls", "boot", "inner", "rots", "bles", "opus", "ios", "obj", "b", "bytes", "alis", "oi", "ob", "fs", "sis"], "buffer": ["queue", "border", "length", "uffer", "texture", "reference", "flush", "bb", "string", "resource", "document", "FFER", "feed", "layer", "buff", "buf", "fb", "pause", "input", "binary", "available", "base", "block", "vector", "reader", "timeout", "table", "header", "device", "Buffer", "batch", "channel", "b", "background", "memory", "cache", "position", "padding", "sequence", "message"], "br": ["bar", "bre", "next", "bl", "length", "gr", "dr", "rb", "ref", "bh", "hr", "BR", "bi", "ler", "span", "div", "bro", "cr", "str", "bal", "fr", "tr", "bc", "buf", "el", "gap", "bp", "wr", "yr", "err", " Br", "bn", "bd", "Br", "arr", "shr", " str", "B", "b", "pre", "lr", "width", "or", "j", "aa", "ele", "bridge", "nr", "ber", "ctr", "ch", "li", "r", "mr", "ver"]}}
{"id1": "12537270", "id2": "8665321", "code1": "    public Vector parse(String link) {\n        addMessage(\"Parsing: \" + link);\n        links.removeAllElements();\n        URLConnection conn = null;\n        Reader rd = null;\n        EditorKit kit = new HTMLEditorKit();\n        Document doc = kit.createDefaultDocument();\n        doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE);\n        URL url = null;\n        try {\n            url = new URL(link);\n        } catch (MalformedURLException err) {\n            System.out.println(\"Malformed URL\");\n            return links;\n        }\n        try {\n            conn = new URL(link).openConnection();\n            rd = new InputStreamReader(conn.getInputStream());\n        } catch (Exception err) {\n            err.printStackTrace();\n            return links;\n        }\n        try {\n            kit.read(rd, doc, 0);\n            ElementIterator it = new ElementIterator(doc);\n            javax.swing.text.Element elem;\n            while ((elem = it.next()) != null) {\n                SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A);\n                if (s != null) {\n                    if (s.toString().indexOf(\"script\") >= 0) continue;\n                    String lnk = \"\";\n                    try {\n                        lnk = s.getAttribute(HTML.Attribute.HREF).toString();\n                    } catch (Exception err) {\n                        continue;\n                    }\n                    int j = 0;\n                    if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j);\n                    URL urlLink = new URL(url, lnk);\n                    if (!url.getHost().equals(urlLink.getHost())) continue;\n                    String str = urlLink.toString();\n                    if (!str.startsWith(\"http\")) continue;\n                    if (str.endsWith(\".pdf\")) {\n                        continue;\n                    }\n                    for (int i = 0; i < leaveSuffix.length; i++) {\n                        if ((str.endsWith(leaveSuffix[i]))) continue;\n                    }\n                    boolean skip = false;\n                    for (int i = 0; i < suffix.length; i++) {\n                        if ((str.endsWith(suffix[i]))) skip = true;\n                    }\n                    if (!skip) {\n                        try {\n                            conn = urlLink.openConnection();\n                        } catch (Exception err) {\n                        }\n                        String contentType = null;\n                        if (contentType == null) contentType = conn.getContentType();\n                        if (contentType.equals(\"application/pdf\")) {\n                            continue;\n                        } else if (!contentType.equals(\"text/html\")) {\n                            continue;\n                        }\n                    }\n                    if (!links.contains(urlLink.toString())) {\n                        links.addElement(urlLink.toString());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"link": ["address", "bug", "msg", "data", "rel", "uri", "parse", "string", "source", "xml", "links", "ln", "path", "line", "id", "http", "lang", "URL", "text", "tag", "html", "base", "lock", "load", "add", "file", "page", "inline", "linked", "type", "location", "connection", "style", "href", "image", "name", "route", "Link", "match", "l", "ink", "loc", "li", "local", "like", "word", "info", "e", "message"], "conn": ["Connection", "ca", "ctx", "Config", "dr", "pg", "socket", "ssl", "connect", "ci", "con", "dc", "cn", "cr", "db", "rot", "pc", "apt", "nc", "cp", "rec", "nt", "p", "ai", "co", "er", "act", "ct", "connection", "err", "io", "rn", "open", "rt", "client", "cmd", "c", "rc", "Conn", "ctrl", "n", "ann", "ac", "pt", "loc", "ch", "r", "mc", "enc", "config", "out", "col"], "rd": ["dr", "rr", "rb", "rw", "ru", "wd", "hr", "dra", "xd", "dc", "sr", "fr", "ds", "ra", "RS", "dd", "RM", "fd", "rog", "rss", "reader", "rid", "rg", "rn", "rm", "bd", "adr", "rt", "RD", "lr", "rs", "rc", "nd", "rx", "rl", "r", "ld", "RR", "mr", "rh"], "kit": ["et", "loader", "tools", "f", "tool", "plugin", "ui", "cat", "bug", "parse", "site", "feed", "cr", "rot", "pit", "ku", "t", "ki", "kat", "lib", "init", "ut", "kin", "p", "nt", "base", "os", "kt", "qt", "reader", "w", "tk", "fit", "ct", "Kit", "k", "bot", "net", "io", "spec", "sci", "rt", "py", "b", "sit", "util", "browser", "pot", "auto", "wt", "iz", "api", "config", "h", "info"], "doc": ["docs", "f", "d", "dr", "data", "msg", "ref", "bug", "parse", "xml", "document", "div", "dc", "db", "dec", "http", "bc", "di", "pc", "text", "tag", "desc", "html", "base", "mm", "root", "file", "in", "page", "de", "dom", "m", "pub", "tx", "open", "dir", "md", "pos", "po", "Doc", "loc", "body", "DOC", "tt", "val", "mc", "api", "config", "out", "coll", "info"], "url": ["address", "f", "bug", "github", "uri", "src", "service", "ssl", "source", "resource", "xml", "path", "feed", "host", "server", "http", "hub", "ur", "org", "sl", "el", "URL", "blog", "base", "html", "file", "page", "www", "gl", "location", "cdn", "connection", "href", "image", "name", "util", "lr", "ll", "l", "Url", "log", "view", "loc", "rl", "config", "pull"], "it": ["et", "lit", "st", "mit", "you", "ci", "end", "ic", "pit", "iter", "t", "iterator", "iti", "its", "init", "ite", "p", "nt", "v", "in", "se", " It", "ait", "stat", "edit", "ip", "IT", "It", "sit", "or", "l", "dit", "iz", "split", "r", "info", "id"], "elem": ["elet", "eleler", "leler", "eler", "Elet", "Element", " Eler", "Eject", "pelement", " elev", "Eler", "lelement", "seject", " Elem", "eject", " Element", "selev", "elev", "lelet", "lelem", " eject", "element", "selement", " element", "selem", "eleject", "Elev", " Eject", "elelement", "peler", "pelem", "Elem", "elelem", "pelet"], "s": ["session", "S", "f", "sync", "a", "d", "ses", "g", "service", "ssl", "sb", "string", "sf", "es", "abs", "parts", "ds", "attr", "t", "sl", "p", "sch", "os", "v", "params", "ns", "se", "gs", "u", "ls", "scope", "m", "spec", "sets", "submit", "services", "ws", "xs", "ops", "set", "c", "b", "o", "details", "rs", "ss", "ps", "ts", "n", "sv", "js", "si", "sym", "strings", "r", "h", "fs", "e"], "lnk": ["dlks", "knky", "lnK", "dlke", "nlk", "fnky", "nlK", "linky", "llck", "dnky", "knk", "dnk", "olnk", "nlke", "linke", "knK", "dlky", "lenk", "lenke", "olnki", "llk", "lenK", "dnke", "lnks", "linK", "lnke", "nlks", "dlk", "lnck", "lnky", "nlck", "dlck", "lenki", "olnky", "llks", "llky", "olnK", "fnk", "fnke", "nlky", "lenky", "fnK", "lenks", "dnK", "knki", "lnki", "dlK"], "j": ["x", "a", "aj", "g", "ie", "ni", "jj", "ja", "ij", "qi", "end", "ind", "fr", "adj", "z", "note", "pr", "jc", "J", "p", "jo", "v", "part", "m", "k", "br", "y", "name", "obj", "job", "o", "syn", "pos", "b", "dj", "l", "jp", "ne", "kj", "jl", "js", "uj", "n", "oj", "key", "ch", "si", "ji", "li", "index", "im"], "urlLink": ["urlFeed", "URLLine", "UrlLink", " urlKey", "UrlConfig", " urlLine", "UrlUrl", "httpLine", "httpFeed", "urlUrl", "imageLine", "urlConfig", "fileLink", " urlFeed", "URLUrl", "urlLine", "imageCode", "httpLink", "URLFeed", "imageLink", " urlConfig", "urlCode", "urlLinks", "fileLinks", "fileConfig", "urlKey", "httpUrl", " urlLinks", "fileUrl", " urlUrl", "fileLine", "imageLinks", "UrlKey", "URLLink", "fileCode", "fileKey", " urlCode"], "str": ["ext", "inst", "f", "kr", "st", "gr", "dr", "data", "g", "hr", "string", "div", "sr", "line", "dec", "cr", "fr", "tr", "t", "sta", "sl", "pr", "text", "txt", "wr", "sp", "res", "exp", "char", "inner", "elt", "arr", "br", "name", "STR", "step", "b", "prev", "l", "Str", "ctr", "js", "r", "enc", "spr", "coll", "stri"], "i": ["hi", "phi", "f", "x", "ui", "ti", "uri", "ni", "bi", "lc", "ci", "qi", "gi", "slice", "di", "z", "abi", "pi", "chi", "zi", "p", "v", "in", "ai", "num", "ix", "u", "m", "iu", "yi", "io", "ip", "ii", "y", "info", "o", "b", "ri", "I", "multi", "fi", "c", "l", "jp", "n", "si", "vi", "key", "li", "ini", "mi", "oi", "ji", "uli", "index", "r", "xi", "eni", "e", "id"], "skip": [" skipped", "g", " skipping", "fast", " loop", " repeat", "success", "replace", "jump", "iter", "scan", " bypass", "add", "error", " scan", "sp", "Skip", " dup", " duplicate", "ips", "pass", "cmp", "loop", "stop", "complete", "copy", "active"]}}
{"id1": "3024987", "id2": "22441244", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "label": 1, "substitutes": {"in": ["re", "a", "data", "inn", "source", "i", "slice", "read", "with", "entry", "is", "input", "arin", "init", "inas", "rec", "reading", "min", "din", "url", "file", "rin", "ins", "bin", "m", "err", "inner", "io", "buffer", "image", "inside", "or", "win", "In", "pass", "n", "inc", "include", "IN", "ini", "r", "login", "again", "Reader", "id"], "reader": ["loader", "x", "rr", "source", "i", "ler", "per", "feed", "handler", "read", "iter", "iner", "input", "writer", "ra", "reading", "file", "rer", "er", "worker", "io", "inner", "buffer", "rar", "b", "her", "or", "stream", "ink", "parser", "rx", "driver", "r", "ner", "pointer", "Reader", "oder"], "baout": ["abaOUT", "aain", "BAout", "vaout", "BAOut", "vain", "abain", "BaOut", "BAparent", "waoutput", "daOUT", "abaOut", "vaparent", "baOUT", "bain", "Baout", "BAin", "waout", "BAoutput", "wain", "dain", "baOut", "BAOUT", "baoutput", "Baparent", "waOut", "daout", "abaout", "aaoutput", "daOut", "baparent", "Bain", "vaOut", "aaout", "aaOut"], "out": ["ext", "OUT", "ref", "user", "builder", "output", "line", "server", "with", "lib", "writer", "inas", "again", "parent", "Out", "base", "array", "file", "err", "inner", "to", "io", "image", "buffer", "arr", "up", "client", "obj", "o", "outs", "exec", "write", "cache", "inc", "pool", "object", "null"], "bytes": ["android", "comments", "bits", "data", "content", "lines", "odes", "Bytes", "tes", "string", "es", "output", "blocks", "ipes", "parts", "ies", "zip", "classes", "its", "binary", "text", "bs", "items", "os", "rows", "ns", "units", "ls", "files", "bps", "css", "les", "cells", "objects", "pages", "ones", "ips", "outs", "codes", "size", "reads", "values", "pieces", "seconds", "body", "strings", "null"]}}
{"id1": "8000624", "id2": "13362846", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"dest": ["delete", "target", "rest", " Dest", "filename", "data", "content", "src", "them", "orig", "source", "wb", "Dest", "path", "output", "exit", "tmp", "comb", " destination", "class", "dist", "folder", "desc", "cont", "txt", "sup", "file", "die", "destroy", "temp", "w", "img", "bin", "opt", "table", "done", "name", "later", "obj", "write", "flat", "test", "transform", "object"], "in": ["issue", "gin", "f", "vin", "re", "x", "isin", "inn", "source", "i", "thin", "wave", "ln", "con", "sin", "plus", "ax", "input", "lib", "init", "fa", "kin", "din", "conn", "lin", "reader", "rin", "ins", "bin", "m", "connection", "inner", "s", "image", "up", "b", "as", "inside", "l", "win", "In", "pass", "n", "cin", "inc", "IN", "ac", "nin", "ini", "r", "login", "h", "again", "pin", "pull", "id"], "out": ["ext", "target", "sync", "OUT", "x", "data", "socket", "user", "other", "no", "i", "app", "output", "off", "plus", "lib", "writer", "this", "vert", "Out", "ou", "conn", "file", "url", "part", "w", "temp", "timeout", "bin", "object", "one", "err", "call", "net", "io", "inner", "image", "name", "up", "client", "o", "b", "outside", "outs", "exec", "not", "or", "outer", "external", "n", "cache", "inc", "nin", "our", "ex", "copy", "again", "pin"], "c": ["ca", "cm", "cl", "f", "cu", "x", "d", "content", "cf", "lc", "i", "ci", "ic", "C", "dc", "cr", "bc", "pc", "t", "ce", "fc", "p", "cy", "v", "esc", "sc", "u", "ct", "cb", "m", "arc", "comment", "char", "exc", "buffer", "code", "ec", "abc", "o", "cc", "rc", "l", "n", "ac", "oc", "ch", "xc", "r", "uc", "enc", "config", "pointer", "col", "e"]}}
{"id1": "9802073", "id2": "22752444", "code1": "    public void testAutoCommit() throws Exception {\n        Connection con = getConnectionOverrideProperties(new Properties());\n        try {\n            Statement stmt = con.createStatement();\n            assertEquals(0, stmt.executeUpdate(\"create table #testAutoCommit (i int)\"));\n            con.setAutoCommit(false);\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (0)\"));\n            con.setAutoCommit(false);\n            con.rollback();\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (1)\"));\n            con.setAutoCommit(true);\n            con.setAutoCommit(false);\n            con.rollback();\n            con.setAutoCommit(true);\n            ResultSet rs = stmt.executeQuery(\"select i from #testAutoCommit\");\n            assertTrue(rs.next());\n            assertEquals(1, rs.getInt(1));\n            assertFalse(rs.next());\n            rs.close();\n            stmt.close();\n        } finally {\n            con.close();\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 0, "substitutes": {"con": ["Connection", "ocon", "core", "Con", "connect", " CON", "conf", "syn", "non", "n", "ctrl", "pool", "config", "un", "sync", "x", "cn", "pr", "cas", "can", "conn", "ran", "connection", "po", "en", "close", "log", "col", "pin", "crit", "an", "ca", "ctx", "cl", "plan", "union", "cond", "db", "pc", "cp", "ct", "m", "CON", "ec", "client", "ain", "c", "util", "pre", "Conn", "cache", "ac", "mc", "coll", "common", "session", "custom", "cm", "platform", "row", "user", "cf", "container", "bc", "cr", "fc", "lock", "min", "co", "act", "com", "one", "gen", "conv", " conn", "cc", "rc", "win", "uc", "ver"], "stmt": ["Stnt", "Stau", " stur", "tmt", "Stor", " stb", "Stmb", "slmt", "strmt", "stur", "stct", "stmb", " stnt", "stMT", "thnm", "Stmr", "slur", "slct", " stor", "Stm", "Stmt", "stau", "tmp", "Stur", " stnm", "thock", " stock", "ctb", "strmb", "strnt", "thmt", "stmo", " stm", "ctmp", "stb", "stm", "ctmt", "STnm", "thmp", " stmo", "stnt", "STmt", "Stb", "stmr", "StMT", " stau", "stock", "ctmo", "Stmo", "stnm", " stMT", "ctor", "tm", " stmr", "STock", "tmr", "Stct", "ctm", "stmp", "slMT", "strau", " stmp", " stct", "Stmp", "STmp", "stor", " stmb"], "rs": ["rys", "cs", "ris", "rr", "row", "Rs", "hr", "src", " res", "rd", " rows", "acks", "RC", "sr", "eers", "cr", "ds", "hs", "repl", "ra", "pr", "rates", "RS", "errors", "rows", "sc", "reader", "rss", "ras", "ins", "res", "ls", "ges", "ms", "s", "results", "rt", "xs", "ries", "vers", "ri", "rc", "ros", "ps", "rx", "rl", "r", "ars", "ows", "mr", " RS", "ks"]}}
{"id1": "18339787", "id2": "8932510", "code1": "    private void reload() {\n        if (xml != null) {\n            try {\n                String currentDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n                if (currentDate.equalsIgnoreCase(exchangeRateDate)) {\n                    return;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        XPath xpath = null;\n        try {\n            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            URLConnection conn = null;\n            URL url = new URL(\"http://www.ecb.int/stats/eurofxref/eurofxref-daily.xml\");\n            conn = url.openConnection();\n            xml = docBuilder.parse(conn.getInputStream());\n            xpath = XPathFactory.newInstance().newXPath();\n            exchangeRateDate = xpath.evaluate(\"/Envelope/Cube/Cube/@time\", xml);\n            xpath = XPathFactory.newInstance().newXPath();\n            NodeList currenciesNode = (NodeList) xpath.evaluate(\"/Envelope/Cube/Cube/Cube[@currency]\", xml, XPathConstants.NODESET);\n            currencies = new String[currenciesNode.getLength()];\n            for (int i = 0; i < currencies.length; i++) {\n                currencies[i] = currenciesNode.item(i).getAttributes().getNamedItem(\"currency\").getTextContent();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 0, "substitutes": {"currentDate": ["CurrentDate", "reportedMessage", " currentPrice", " currentTime", "currentMessage", "CurrentDay", "CurrentPrice", "currentKey", "newDate", "reportedDay", " currentKey", "CurrentMessage", "CurrentTime", "CurrentKey", "currentTime", "currentPrice", " currentDay", "newPrice", "newDay", "reportedTime", "newKey", " currentMessage", "currentDay", "reportedDate"], "xpath": ["xath", "xparent", "exlog", "axp", "exPath", "axPath", "expath", "txPath", " xPath", "Xparent", "axath", "xth", "XPath", "exath", " xp", "Xath", "txth", "axpath", "exprop", " xath", "axparent", "Xp", " xlog", "exp", " xth", "Xth", "xlog", " xprop", " xparent", "xPath", "Xpath", "Xprop", "axlog", "txpath", "xp", "xprop"], "docBuilderFactory": ["docbuilderInterface", "docbuilderFC", "xmlBuilderInterface", "xmlbuilderFactory", "docEngineFact", "docBuilderUnit", "documentBuildUnit", "docReaderService", "docBuilderFact", "documentBuildService", "docbuilderUnit", "documentBuilderUnit", "docBuildFactory", "xmlbuilderInterface", "documentBuilderService", "docFactoryFactory", "docFactoryFC", "docbuilderFactory", "docbuilderFact", "xmlbuilderFC", "docEngineFC", "docEngineFactory", "docBuilderInterface", "docBuilderService", "docEngineInterface", "docBuildUnit", "docbuilderService", "docFactoryInterface", "xmlBuilderFactory", "xmlBuilderFact", "docReaderFactory", "docBuilderFC", "xmlbuilderFact", "docBuildService", "documentBuilderFactory", "documentBuildFactory", "docFactoryFact", "xmlBuilderFC", "docReaderUnit"], "docBuilder": [" docFactory", "docParser", "documentbuilder", "documentFactory", "ocumentEngine", "docBuild", " docBuild", "docbuilder", "docFactory", "xmlBuild", "documentParser", "documentBuilder", "documentBuild", "ocumentBuilder", "ocumentBuild", "docEngine", "Docbuilder", "documentEngine", "DocParser", "xmlBuilder", "DocBuilder", "xmlParser", " docEngine", "xmlbuilder", "DocBuild", "ocumentFactory"], "conn": ["loader", "Connection", "session", "ctx", "cm", "serv", "socket", "ssl", "lc", "connect", "ci", "con", "cn", "path", "db", "server", "http", "conf", "cli", "URL", "nc", "cp", "lock", "nt", "ct", "cb", "connection", "client", "channel", "conv", "c", "cmd", "exec", "l", "Conn", "Url", "ann", "log", "loc", "ch", "api", "body", "uc", "enc", "config", "out", "coll"], "url": ["loader", "f", "bel", "serv", "data", "uri", "ssl", "string", "web", "resource", "feed", "path", "host", "db", "str", "server", "http", "fr", "org", "sl", "URL", "blog", "base", "file", "impl", "ls", "www", "gl", "connection", "err", "image", "client", "channel", "build", "l", "ll", "download", "Url", "log", "ob", "config", "coll"], "xml": ["address", "x", "data", "content", "tree", "request", "parse", "document", "graph", "feed", "path", "response", "http", "layout", "zip", "el", "input", "writer", "context", "json", "html", "atom", "txt", "event", "file", "office", "page", "reader", "php", "rss", "events", "temp", "dom", "apache", "image", "element", "arr", "children", "update", "ws", "channel", "ml", "email", "doc", "stream", "log", "wt", "wl", "node", "config", "model", "date"], "exchangeRateDate": ["exactionRateDay", "exchangerateDate", "excurrencyRateTime", "excurrencyRateDuration", "exchangeRateFormat", "exchangeTimeDuration", "exchangeTimeTime", "excurrencyTimeDay", "exchangeRateTime", "exchangerateDay", "exchangerateDuration", "exchangeTimeDate", "exactionRatingDate", "excurrencyRateDay", "exchangeUnitPrice", "exchangeUnitDay", "exchangeRatingDay", "exchangeFactorDate", "exactionRatingPrice", "exchangeRatePrice", "exchangeRateDuration", "excurrencyTimeDate", "exchangeRatingPrice", "exchangeFactorTime", "exchangeFactorDuration", "excurrencyRateDate", "exchangeTimeDay", "exchangeTimeFormat", "exactionRatingDay", "exactionRateFormat", "exchangeRatingFormat", "exactionRatePrice", "excurrencyTimeTime", "exchangeRateDay", "exactionRateDate", "exchangeRatingDate", "exchangerateTime", "exactionRatingFormat", "exchangeUnitDate", "exchangeTimePrice", "exchangeFactorDay", "exchangeUnitFormat", "excurrencyTimeDuration"], "currenciesNode": ["curversionsNode", "curralsRoot", "cururrenciesNode", "currencycurrencySource", "curralsDocument", "verurrenciesArray", " currenciesDocument", "currencycurrencynode", "currencyrenciesSource", "currenciesSource", "curitiesNode", "curriesLine", " currenciesRoot", "currenciesContainer", "cururrenciesArray", "curitiesDay", "curralsNode", "curriesNode", "cururrenciesContainer", "verrenciesNode", "verurrenciesNode", "currencyrenciesPath", "curversionsPath", "cururrenciesLine", " currenciesLine", "verrenciesArray", "curriesDocument", "currenciesDay", "curversionsSource", " curralsRoot", "currenciesRoot", "curriesRoot", "cururrenciesDocument", " curralsNode", "curationsContainer", "verrenciesContainer", "verurrenciesDay", "curitiesArray", "currencyrenciesnode", "currenciesDocument", "curprisesPath", "curcurrencyPath", "curcurrencyNode", "cururrenciesRoot", "curationsNode", "curationsDay", "curcurrencynode", "curitiesContainer", "curralsLine", "verrenciesDay", "currenciesnode", "cururrenciesDay", "currencyrenciesNode", "curcurrencySource", "currenciesArray", "verurrenciesContainer", "curationsArray", "curversionsnode", "curprisesnode", " curralsLine", "currencycurrencyNode", "currencycurrencyPath", "curprisesSource", "currenciesPath", "curprisesNode", " curralsDocument", "currenciesLine"], "currencies": ["characters", " curlations", "Cururrency", "carurrency", "cururrency", "curations", "carrencies", " cururrencies", "carurrencies", "cururrencies", "interations", "Cururrencies", " curums", "consturrency", "charurrencies", "nowurrency", "curacters", "caracters", "constrencies", "constations", "nowums", "charrencies", "charurrency", "nowurrencies", "interlations", "Currencies", "Curums", "nowrencies", " curacters", "curlations", "interurrency", "curums", "constlations", "interrencies", " cururrency", " curations"], "i": ["hi", "phi", "f", "x", "it", "ui", "ti", "uri", "bi", "lc", "ci", "gi", "qi", "end", "slice", "mu", "di", "t", "z", "abi", "pi", "q", "chi", "p", "v", "in", "ix", "ai", "w", "u", "k", "m", "iu", "yi", "io", "ip", "ii", "y", "info", "o", "c", "b", "I", "ri", "multi", "fi", "j", "l", "start", "n", "si", "li", "r", "oi", "ji", "index", "xi", "eni", "e", "id"]}}
{"id1": "2982747", "id2": "15166511", "code1": "    public FileParse(String fileStr, String type) throws MalformedURLException, IOException {\n        this.inFile = fileStr;\n        this.type = type;\n        System.out.println(\"File str \" + fileStr);\n        if (fileStr.indexOf(\"http://\") == 0) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"File\")) {\n            File inFile = new File(fileStr);\n            size = inFile.length();\n            inStream = new FileInputStream(inFile);\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URL\")) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URLZip\")) {\n            URL url = new URL(fileStr);\n            inStream = new GZIPInputStream(url.openStream(), 16384);\n            InputStreamReader zis = new InputStreamReader(inStream);\n            bufReader = new BufferedReader(zis, 16384);\n        } else {\n            System.out.println(\"Unknown FileParse inType \" + type);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"fileStr": [" fileWr", "baseName", "lineStr", "baseStr", " fileTr", "fWr", "fileString", "fileText", "FileText", "imageSTR", "feedSTR", "logStr", "feedExp", "baseString", "urlStr", "FileSTR", "baseBr", " fileUrl", "mailStr", " fileSTR", "imageWr", " filestr", " fileStream", "fileStream", "urlTr", "imageStream", "fSTR", "fstr", "logSTR", "resourceCh", "mailStream", "FileWr", " fileBr", "fileTr", "fileSTR", "resourceString", " fileText", "FileStr", "urlUrl", "Filestr", "baseSTR", "fileWr", "logStream", "urlString", " fileName", "lineSTR", "FileCh", "feedStr", "basestr", "fStr", "FileString", "fileUrl", "imageStr", "urlstr", "urlExp", "FileTr", "resourcestr", "lineBr", " fileCh", "feedStream", "logExp", "mailWr", "fileBr", "mailSTR", "FileName", "FileUrl", "fileName", "urlStream", "fileCh", "linestr", "urlText", "resourceStr", " fileString", "filestr", "fileExp", "urlSTR"], "type": ["time", "Type", "path", "on", "pe", "attr", "by", "class", "value", "block", "ping", "shape", "unit", "y", "title", "right", "code", "link", "non", "current", "index", "model", "address", "rel", "source", "role", "base", "file", "method", "action", "py", "key", "like", "info", "none", "id", "typ", "no", "resource", "str", "function", "part", "state", "level", "comment", "media", "year", "pre", "types", "or", "TYPE", "api", "object", "status", "ty", "format", "port", "site", "off", "t", "parent", "lock", "error", "page", "phrase", "call", "style", "name", "phase", "ype", "post", "ver"], "inFile": ["inLine", "outStream", "infile", " infile", "inputLine", "winUrl", "outFiles", "InUrl", " inPath", "inifile", "inputUrl", "iniUrl", "incFile", "inUrl", " inUrl", " inFolder", "inputStream", "inputFolder", "incFolder", "iniFile", "inputF", "InPath", "indexStream", "incUrl", "InStream", "outfile", "incF", "INFolder", "Infile", "indexfile", "winFile", " inLine", "INLine", "inFiles", "InFile", "inputFile", "winFolder", "INFile", "inF", "outFile", "inFolder", "INStream", "inPath", "indexFiles", "iniPath", "indexFile", "winF", "InFiles"], "url": ["session", "loader", "f", "tool", "sync", "ref", "socket", "uri", "user", "service", "ssl", "string", "source", "web", "resource", "feed", "path", "host", "server", "http", "ur", "zip", "sl", "lib", "URL", "blog", "base", "conn", "file", "page", "impl", "www", "gl", "object", "connection", "image", "force", "open", "coll", "update", "job", "channel", "client", "util", "build", "or", "l", "link", "download", "ll", "Url", "work", "cache", "log", "loc", "ob", "config", "fl", "proxy", "use", "ul", "pull"], "urlconn": ["urlconnect", "urlconnection", "blogconnect", "webcon", "webConn", "URLConn", "URLcon", "blogConn", "filepool", "urlConn", "urlcon", "URLconn", "filecon", "webconnect", "webconn", "urlpool", " urlconf", "blogconn", "httpconf", "URLconnection", "resourceConn", "resourceconn", "URLconnect", "fileconn", "webpool", "httpConn", "collConn", "webconnection", "urlconf", "fileConn", "collconnection", "resourcecon", " urlconnect", "httpconn", " urlConn", "resourcepool", "collconn", "blogconf", " urlconnection", "collcon", "httpconnect"], "inStream": ["InForm", "ginStream", " inPath", "inSt", "INReader", "inputForm", "dinSocket", "InReader", "INSteam", "InStream", " inSteam", "innStream", "inSocket", "outstream", " inUpload", "exStream", "outStreamer", "InContent", "againStream", "icStream", " instream", "incSt", "inputStream", "inputSteam", "inUpload", "binStream", "exStreamer", "icSteam", " inForm", "inputView", "outSteam", "innSteam", "incstream", "inContent", " inSt", "inputFile", "instream", "inForm", "againstream", "icstream", "outFile", "ginPath", "ginSteam", "outPath", "inStreamer", "INSocket", "incStream", "dinReader", "inReader", "Instream", "ginstream", "InSteam", "dinStream", "inView", "innForm", "binSteam", "inPath", "innView", "outStream", "icUpload", "InView", "dinSteam", "InSocket", "againSteam", "binFile", "inSteam", "binStreamer", "InSt", "incContent", "inputPath", "outForm", "exFile", " inContent", "exSteam", "INStream", "againUpload"], "bufReader": ["bufferRead", "cfReader", "cfWriter", "funcLoader", "bufferStream", "bufStream", " bufWriter", "cfRead", "bufLoader", "funcRead", " bufLoader", "ufReader", "buffReader", "buffStream", "ufStream", " bufStream", "bufWriter", "cfLoader", "bufferReader", "ufRead", " bufRead", "buffRead", "funcWriter", "funcReader", "bufRead", "bufferWriter", "ufWriter", "ufLoader", "buffWriter"], "size": ["address", "length", "content", "empty", "path", "capacity", "ize", "small", "speed", "scale", "parent", "base", "large", "load", "file", "page", "fee", "Size", "offset", "storage", "name", "bytes", "width", "max", "position", "loc", "SIZE", "count"], "zis": ["jis", "azais", "zIs", "Ziz", "Zais", "ZIs", "Zos", "Zis", "azos", " zais", "jIs", " ziz", "zos", "zi", " zos", "Zi", "azis", "ziz", "aziz", "ji", "zais", "jiz", "azi", "azIs"]}}
{"id1": "4468255", "id2": "7149578", "code1": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"from": ["d", "path", "http", "entry", "by", "ce", "html", "url", "missing", "er", "From", "self", "open", "code", "original", "old", "before", "link", "at", "auto", "so", "e", "un", "f", "data", "left", "source", "with", " form", "context", "base", "file", "normal", "of", "connection", "io", "stream", "log", "local", "id", "empty", "form", "resource", " file", "line", "without", "zip", "this", "os", "add", "ate", "part", "se", "temp", "client", "dir", "c", "or", "start", "back", "user", "feed", "parent", "one", "range", "name", "vol", "o"], "to": ["yet", "To", "son", "path", "token", "on", "http", "pe", "by", "root", "jo", "but", "sp", "de", "as", "not", "disk", "auto", "so", "target", "sync", "x", "template", "data", "socket", "source", "eto", "two", "top", "base", "file", "connection", "io", "comp", "storage", "process", "tom", "po", "me", "no", "resource", "output", "line", "plus", "db", "dis", "database", "front", "os", "load", "too", "office", "se", "temp", "stat", "dir", "client", "or", "cache", "copy", "TO", "system", "user", "site", "t", "termin", "flo", "parent", "p", "one", "location", "name", "about", "o", "toc", "all", "size", "tto", "null"], "result": ["ure", "real", "length", "allow", "found", "data", "follow", "mask", "ok", "source", "success", "diff", "replace", "plus", "valid", "sign", "accept", "fail", "member", "search", "function", "lock", "event", "error", "url", "die", "math", "card", "part", "effect", "true", "method", "res", "var", "ult", "mer", "err", "comment", "future", "results", "force", "br", "arr", "Result", "up", "info", "term", "cur", "rc", "sum", "compl", "current", "cache", "pass", "ret", "work", "test", "val", "r", "count", "report", "continue", "use", "default", "status", "date", "match", "ver"], "subFiles": ["smallContents", "ubContents", "ubDir", "smallfiles", "newsfiles", " subParents", "subDir", "SubWords", "partfiles", "SubParts", " subFs", "newsFiles", "smallFiles", "ubfiles", "ubFile", "subPages", "subFs", "partFs", "ubFiles", "partFiles", "newFile", " subDir", "subNotes", "subFile", " subfiles", "partParents", "ubNotes", "newPages", "singParents", "newParts", " subPages", " subNotes", "smallNotes", " subContents", "newfiles", "subWords", " subFile", " subWords", "subContents", "newFiles", "singfiles", " subParts", "SubFile", "SubPages", "singFiles", "subParents", "SubFiles", "Subfiles", "newsWords", "subParts", "newsParts", "singFs", "subfiles", "ubPages"], "i": ["hi", "phi", "f", "x", "d", "ori", "ui", "it", "a", "ti", "uri", "ie", "bi", "ci", "gi", "slice", "di", "is", "h", "iv", "z", "pi", "p", "v", "ai", "ix", "u", "k", "iu", "io", "inner", "s", "ip", "ii", "y", "name", "o", "b", "ri", "I", "multi", "c", "j", "l", "n", "si", "key", "li", "ini", "oi", "mi", "index", "xi", "e", "id"], "newDir": ["subConf", "subDir", "subDirectory", "nextDir", "nextFolder", "newD", "oldDir", " newFolder", "newFile", "subD", "oldFile", "subJar", "rawdir", "newConf", "NewFile", " newJar", "subFile", "rawJar", "newDirectory", "oldFolder", "newJar", "rawDir", "NewFolder", "subdir", "NewConf", " newdir", " newFile", "NewD", " newDirectory", " newConf", "newdir", "rawDirectory", "NewDir", "NewDirectory", "newFolder", "nextFile", "oldDirectory", "nextDirectory", " newD"], "in": ["gin", "f", "a", "serv", "it", "data", "pull", "isin", "socket", "ie", "inn", "source", "thin", "con", "diff", "on", "is", "input", "init", "this", "min", "din", "file", "lin", "conn", "reader", "url", "part", "ins", "bin", "m", "err", "inner", "io", "image", "up", "o", "b", "c", "l", "win", "In", "cin", "inc", "IN", "nin", "ini", "r", "ex", "login", "index", "again", "config", "pin", "e", "id"], "out": ["ext", "sync", "OUT", "serv", "cat", "socket", "con", "output", "on", "off", "line", "with", "lib", "writer", "Out", "base", "lock", "ou", "op", "cy", "conn", "file", "can", "co", "w", "img", "bin", "one", "exp", "err", "call", "net", "io", "inner", "name", "up", "client", "obj", "o", "c", "outs", "write", "exec", "all", "sum", "n", "at", "log", "post", "inc", "ex", "again"], "fileLength": ["pageSize", "fileSize", "baseLen", "baselength", "filelength", "FileLength", "baseLength", "fileLen", "Filelength", "pageName", "lineName", "pagelength", "fileName", " fileLen", "lineSize", " fileName", "FileSize", "FileLen", "linelength", "baseSize", "pageLength", " filelength", "lineLength", " fileSize"], "charBuff": ["pairMatrix", " charBuffer", "wordBuffer", "pairBuffer", "charBuffer", "pairBuff", "wordMatrix", " charMatrix", "charMatrix", "wordBuff"], "len": ["et", "lit", " split", "ni", "ln", "line", "iter", "lf", " lang", "nt", "part", "rev", "bin", " Len", "pos", "fin", "en", "l", "Len", "start", "cmp", " pos", "li", "val", "split", "fl", "id"], "oneChar": ["oneCor", "oneCh", "OneCh", "eightCharacter", "eightchar", " oneCor", "singleCor", "singleChar", "fourPixel", "eachChar", "singleCh", "eightPixel", "singleByte", "fourChar", "eachPixel", "eightChar", "fourCharacter", "OneByte", " oneCharacter", "eachCharacter", "oneByte", "OneChar", "eachchar", "oneCharacter", " onechar", "fourchar", "OneCor", "singlechar", "singleCharacter", " oneCh", "onePixel", "onechar", " oneByte"]}}
{"id1": "9109613", "id2": "20920051", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"from_name": ["fromFullName", " from_image", "from_Name", "fromFullalias", "from__Name", " from_Name", " from_word", "fromameno", " from_resource", "fromqfilename", " from_alias", " from_key", "from__address", "from_key", "from_time", "fromThespace", "from_image", "from_filename", " from__Name", " from__alias", "fromqname", "fromFullname", " from_size", "fromamename", "from__name", "from_size", " from__name", " from_no", "fromqpath", "from_address", "fromTheName", " from_filename", "from_word", "fromThename", "fromameName", "from_resource", " from_path", " from_time", "from__alias", "fromTheword", "fromqName", "from_no", "fromametime", " from_space", " from_address", "from_space", "from_path", "from_alias", "fromFulladdress", " from__address"], "to_name": ["to_key", "To_common", "To_name", "from_Name", "to_common", "to_path", "tokName", "to_file", " to_key", " to_file", "tokcommon", "from_names", "from_path", "To_Name", "to_names", "to_Name", "tokname"], "fromFile": ["fromLine", "fromFactory", "fromLibrary", "FromPage", "FromFunction", "ofFolder", "connectionPackage", "onePage", "onefile", "oneFolder", "fromFunction", "FromDir", " fromDir", "oneModel", " fromDirectory", "autoFolder", "FromLibrary", "autoFile", "ofFile", "fromPackage", " fromPage", "oneDir", "sourceLibrary", "fromDir", "fromModel", " fromModel", "fromDirectory", " fromPackage", "ofPackage", "fromFiles", " fromLibrary", "Fromfile", " fromFactory", "connectionFile", "sourcePage", "connectionfile", "fromPage", "toFunction", " fromFunction", "asFactory", "autofile", "fromFolder", "autoPage", "offile", "toFiles", " fromfile", "oneFile", "FromModel", " fromFolder", "FromDirectory", "FromLine", "toFactory", " fromFiles", "toLine", "tofile", "connectionFolder", "FromFile", "sourceFile", "asfile", "FromFolder", "FromFiles", "sourceDirectory", "asFile", "asFiles", "oneFunction", "fromfile", " fromLine"], "toFile": ["fromLine", "cofile", " toPage", "ofTable", "ToPage", " toFactory", "ofFile", "aFiles", "fromDirectory", "ofDir", "targetPlace", " toSourceFile", "baseFile", "noLibrary", " toTable", "targetSourceFile", "targetFactory", "basefile", "ToSourceFile", "TODir", "ToLine", " tofile", "coFile", "tempFactory", "TOPlace", "toSourceFile", "toDir", "baseTable", "toFolder", "ToFiles", "fromFiles", "aFile", "ToPlace", "targetfile", "offile", "nofile", "toPage", "toLibrary", " toDir", "baseDir", "toTable", "ToLibrary", "coFunction", "sofile", "Tofile", "soLibrary", "ToFunction", "soPage", " toDirectory", "toFunction", "fromPage", "ToFile", "tempfile", "noFile", "targetFolder", "noPage", " toFiles", " toLine", "tempFolder", "tempFile", "TOFile", "ToDir", "ToDirectory", "toPlace", "soFile", "toDirectory", "toFiles", " toFunction", "coDirectory", "afile", "targetFile", "targetPage", "targetDir", "toFactory", "toLine", "tofile", "aDir", " toFolder", "TOPage", "ToFactory", "fromDir", "fromfile"], "parent": ["pa", "lc", "path", "server", "pe", "class", "root", "large", "shape", "url", "full", "type", "current", "inc", "pool", "out", "address", "parents", "data", "g", "home", "source", "guard", "pr", "search", "par", "file", "exp", "connection", "owner", "region", "paren", "test", "pt", "key", "complete", "col", "id", "any", "patch", "content", "string", "resource", "div", "rule", "and", "line", "option", "Parent", "part", "directory", "manager", "client", "or", "ac", "api", "master", "session", "child", "port", "point", "user", "section", "remote", "valid", "p", "page", "location", "ip", "name", "term", "loc", "null"], "dir": ["ir", "f", "d", "cat", "dr", "wd", "rel", "home", "container", "per", "path", "dc", "DIR", "director", "db", "dec", "div", "di", "attr", "dis", "iter", "lib", "class", "group", "dist", "rec", "folder", "lock", "root", "block", "url", "file", "die", "fd", "keep", "directory", "manager", "exp", "dev", "name", "Dir", "mod", "build", "or", "doc", "dep", "dict", "inc", "cur", "loc", "def", "r", "out", "coll", "col", "ver"], "from": ["cm", "who", "left", "user", "low", "parse", "source", "form", "empty", "per", "con", "cr", "with", "fr", "without", "by", "ce", "this", "ra", "when", "flo", "base", "can", "ou", "add", "query", "file", "conn", "in", "url", "se", "part", "bean", "normal", "de", "one", "connection", "From", "get", "range", "self", "io", "module", "hand", "name", "vol", "client", "channel", "o", "c", "old", "po", "or", "link", "component", "stream", "start", "auto", "wh", "view", "ch", "api", "clean", "so", "out", "e"], "to": ["target", "will", "To", "sync", "port", "source", "no", "proxy", "go", "eto", "token", "output", "on", "db", "plus", "with", "http", "see", "fb", "two", "top", "by", "flo", "pi", "store", "base", "op", "again", "too", "file", "office", "page", "co", "type", "one", "connection", "io", "tom", "name", "about", "o", "b", "until", "su", "po", "or", "not", "size", "cache", "auto", "tto", "api", "fat", "so", "via", "copy", "out", "object", "TO", "be", "ver"], "buffer": ["number", "queue", "border", "address", "length", "uffer", "data", "flush", "reference", "row", "texture", "string", "resource", "document", "feed", "layer", "server", "read", "character", "iter", "buff", "buf", "duration", "binary", "total", "available", "value", "block", "vector", "shape", "page", "variable", "transfer", "reader", "table", "comment", "header", "seed", "device", "Buffer", "batch", "channel", "bytes", "result", "memory", "cache", "position", "padding", "default", "null", "message"], "bytes_read": ["classes_available", "classesavview", "bytes___available", "bytes___READ", "bytes___view", "bytesESSreceived", "bytesESSput", "lines_received", "bytes_available", "lines_written", "bytesESSwritten", "bytes_received", "bytesavavailable", " bytes_written", "bytesavREAD", "bytesavread", "lines_read", "classes_read", "bytes_view", "bytesayread", "bytesayput", "lines_put", "classesavavailable", " bytes_write", "bytes_write", "bytesaywritten", "bytesavview", "bytes_load", "bytes_put", "classes_view", "bytes_READ", " bytes_load", "bytes_written", "bytesayreceived", "classesavREAD", "bytes___read", "classes_READ", "classesavread", "bytesESSread"]}}
{"id1": "20128728", "id2": "13516684", "code1": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"src": ["inst", "inf", "filename", "st", "rb", "core", "uri", "sb", "source", "upload", "path", "sin", "server", "buf", "sl", "input", "dist", "dest", "front", "url", "file", "in", "sc", "conn", "img", "ls", "files", "s", "image", "obj", "b", "sit", "sq", "sel", "rc", "download", "start", "stream", "loc", "ource", "config"], "dst": ["dsts", "fsts", " dft", "Dsts", " dut", " dput", "idut", "dut", "Dst", "dft", "fdst", "idst", "Ddest", "dput", "fst", "fdsts", "fdft", "Dput", "idsts", "idft", " ddest", "ddest", "fdut", "fdest", "fput", " dsts"], "inChannel": ["outStream", "dinChan", " inClient", "inputchannel", "inChan", "inClient", "inputChannel", "InChan", "InQueue", " inQueue", "Inchannel", "inputStream", " inChan", "innerClient", "outchannel", "outChan", " inStream", "dinChannel", "innerStream", "innerChannel", " inchannel", "outQueue", "INLanguage", "inLanguage", "inchannel", "INChannel", "dinLanguage", "inputLanguage", "INChan", "inputChan", "inStream", "InChannel", "dinchannel", "outClient", "innerChan", "inQueue", "INStream", "INchannel"], "outChannel": ["outStream", "outContext", "outSocket", "OutChan", " outSocket", "againStream", "inChan", "againSocket", "OutChannel", "OutContext", "OutStream", "inContext", "outchannel", "outChan", " outContext", "outConnection", " outchannel", " outChan", " outConnection", "againchannel", "inConnection", "OutConnection", "againChannel", " outStream", "inchannel", "outputStream", "outputChannel", "inSocket", "outputchannel", "inStream", "againChan", "outputChan", "Outchannel"]}}
{"id1": "6421904", "id2": "20920051", "code1": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"input": ["session", "inf", "data", "request", "source", "form", "xml", "document", "resource", "flow", "progress", "http", "this", "text", "context", "value", "load", "raw", "error", "conn", "Input", "php", "temp", "reader", "active", "buffer", "image", "media", "storage", "up", "exec", "instance", "stream", "hole", "current", "audio", "config", "out", "back", "null"], "temporary": ["destporary", "tymanent", "mperature", "emperature", "tempperature", "separmanent", "transolute", "destporal", "theporal", "tporary", "temporal", "tytemp", "semperature", "formporal", "destemporary", "temolute", "tmemporary", "temptemp", "Temmanent", "emporary", "transporary", "semporal", "theporary", "separperature", "tmperature", "Temtemp", "mporary", "emporal", "destacher", "formporary", "timporary", "tmacher", "semmanent", "temperature", "temermanent", "tempporary", "Temporary", "experature", "exporary", "tomporary", "semporary", "timolute", "tempporal", "separporal", "formmanent", "theperature", "theemporary", "theermanent", "tacher", "typoral", "tememporary", "transporal", "transperature", "Temporal", "timemporary", "formtemp", "tomperature", "temtemp", "tmporary", "temacher", "tmermanent", "separporary", "typerature", "exolute", "mporal", "tmtemp", "Temperature", "tempemporary", "tomporal", "timporal", "typorary", "tmporal", "tporal", "tommanent", "timperature", "timermanent", "temmanent", "thetemp", "exporal"], "tempId": ["tmpid", "poraryId", "TempPath", "inputId", " tempName", "tmpPath", "fakeid", "fakeId", "fakeName", "tmpID", "poraryid", "TempID", "inputid", "tempName", "TempName", "tempid", "tempPath", "Tempid", " tempid", "tmpId", "inputPath", "inputID", "tempID", "TempId"], "length": ["number", "ext", "filename", "version", "data", "content", "time", "string", "section", "angle", "Length", "path", "slice", "distance", "capacity", "read", "limit", "duration", "total", "len", "text", "json", "value", "lock", "load", "array", "volume", "shape", "url", "full", "library", "type", "style", "range", "offset", "open", "code", "name", "result", "width", "write", "description", "size", "download", "l", "position", "audio", "driver", "loc", "key", "count", "ob", "sequence", "id"], "digest": ["fest", "generested", " digEST", "digEST", "decested", " digested", "digests", "decist", "Digested", " Digest", "signest", "generest", "Digester", " Digester", "digester", "decEST", "fests", "generist", "signester", "signested", " digester", "digraph", " digests", "generEST", "fester", "fraph", "signests", "DigEST", "decest", "digested", "Digist", " DigEST", "signEST", " digraph", "digist", "signraph", "Digest"], "output": ["application", "target", "queue", "tube", "operation", "address", "data", "socket", "cut", "other", "source", "resource", "put", "web", "document", "exit", "response", "Output", "writer", "binary", "console", "office", "export", "plain", "temp", "connection", "letter", "unit", "image", "channel", "result", "write", "outer", "external", "control", "log", "copy", "config", "out", "object", "null", "message"], "file": ["uri", "time", "per", "path", "server", "http", "pe", "class", "File", "url", "full", "type", "future", "unit", "self", "buffer", "open", "code", "FILE", "current", "auto", "pool", "view", "model", "show", "e", "queue", "f", "data", "socket", "other", "home", "source", "lib", "binary", "folder", "base", "plain", "connection", "po", "log", "local", "fe", "complete", "use", "word", "id", "live", "string", "resource", "document", "rule", "handler", "line", "zip", "this", "entity", "function", "fp", "temp", "play", "directory", "single", "place", "get", "letter", "comment", "up", "dir", "or", "ile", "work", "cache", "object", "create", "message", "real", "filename", "child", "it", "user", "feed", "let", "lock", "p", "page", "php", "style", "image", "force", "name", "l", "picture", "null"], "parent": ["pa", "child", "parents", "data", "port", "home", "source", "resource", "remote", "container", "per", "path", "and", "handler", "class", "base", "root", "p", "large", "Parent", "block", "full", "part", "temp", "directory", "type", "location", "to", "unit", "image", "name", "dir", "or", "create", "cache", "current", "key", " Parent", "fat", "copy", "out", "null", "master", "id"], "now": ["next", " NOW", "low", "last", "time", "cycle", "from", "ci", "hour", "once", "this", "wait", "ow", "since", "day", "load", "first", "Now", "co", "active", "lim", "type", "NOW", "ct", "gen", "comp", "today", "set", "not", "or", "night", "size", "max", "start", "current", "age", "always", "cur", "cmp", "currently", "post", "auto", "node", "view", "info", "date", "id"]}}
{"id1": "838844", "id2": "17996547", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"src": ["inst", "ctx", "filename", "st", "rb", "feat", "ref", "uri", "gb", "ssl", "sb", "source", "string", "resource", "upload", "prot", "Dest", "path", "sin", "RC", "slice", "tmp", "buf", "sth", "input", "sl", "supp", "dist", "username", "secure", "load", "req", "fp", "url", "file", "sc", "reader", "impl", "img", "cb", "gz", "spec", "href", "s", "cpp", "storage", "gn", "vr", "name", "code", "obj", "sit", "sel", "rc", "proc", "download", "stream", "component", "cmp", "dep", "Source", "loc", "fn", "rl", "SourceFile", "ource", "config", "sec", "back", "sn"], "dest": ["target", "orig", "home", "source", "wb", "Dest", "dc", "path", "di", "tmp", "lib", " destination", "class", "dist", "cont", "txt", "temp", "img", "bin", "std", "dir", "obj", "disk", "fn", " dst", "null", "dat"], "in": ["inf", "f", "d", "a", "data", "isin", "inn", "source", "i", "t", "is", "input", "inas", "din", "file", "reader", "ins", "bin", "err", "io", "up", "as", "doc", "win", "ps", "In", "stream", "n", "pass", "inc", "IN", "ini", "r", "ex", "val", "login", "pin"], "p": ["pa", "pb", "pd", "f", "d", "pg", "g", "lp", "pm", "i", "per", "pc", "pe", "t", "h", "pp", "pr", "cp", "pi", "op", "fp", "v", "wp", "bp", "part", "sp", "cop", "m", "s", "py", "o", "pre", "c", "np", "b", "po", "j", "l", "ps", "jp", "parser", "tp", "P", "e"], "ds": ["docs", "d", "uds", "dt", "lp", " db", "ays", "hs", "ads", " DS", "ded", "scripts", "des", "ils", "icks", "ants", "qs", "dm", "vals", "dates", "ld", "sys", "dat", "posts", "ks", "styles", "ans", "pd", "cs", "sync", "data", "words", "points", "dp", "bs", "dd", "gs", "cdn", "Ds", "ups", "rs", "ps", "js", " dd", "sts", "cons", "tools", "els", "lines", "db", "DS", "di", "dist", "amps", "os", "tests", "vs", "dos", "ins", "ls", " sd", "s", "ws", "xs", "ts", "plugins", " props", " ps", "eps", "obs", "gd", "da", "dc", "parts", "dds", "ys", "utils", "nas", "ns", "ss", "df", "models", "dl"], "format": ["filter", "f", "filename", "prefix", "template", "feat", "data", "Format", "plugin", "version", "string", "source", "form", "xml", "path", "handler", "host", "t", "layout", "atter", "class", "tag", "scale", "function", "sche", "fp", "file", "url", "fd", "part", "type", "act", "spec", "style", "letter", "unit", "table", "language", "name", "struct", "ant", "pattern", "nat", "at", "frame", "parser", "fn", "api", "config", "magic", "record", "object", "model", "match"], "hasPixelData": ["hasPictureData", "hasPicOps", "haspixelStyle", " hasPixeldata", "hasBytedata", "hasPicStyle", "hasPixelDATA", "hasPictureDATA", "haspixelData", " hasPixelOps", "hasPixeldata", "hasPixelStyle", "haspixelOps", "hasPicData", "hasByteData", " hasPixelSize", "haspixelSize", "hasPicturedata", "hasPixelSize", "haspixelDATA", "haspixeldata", "hasPixelOps", " hasPixelStyle", " hasPixelDATA", "hasByteSize"], "inflate": [" inflATE", "infloocate", "uninflocate", "infloase", "uninfloute", "uninfloate", "information", "informATE", "incollate", "infloATE", "inflation", "infolute", " information", "infolame", "incollame", "inFlase", "incollocate", "inFlate", "informate", "infloate", "influte", "inflase", "incollute", "uninfloame", "inFlation", "uninflute", "infolate", "informase", "inflame", "infolocate", "infloation", " informase", "uninfloocate", " informate", "infloame", "infloute", "inflocate", "uninflame", " inflation", "inFlATE", " inflase", "inflATE", " informATE", "uninflate"], "pxlen": ["nplin", "pyln", "pxlf", "fxlen", "pngden", "xyfin", "pyden", "pxden", "fxden", "rxfin", "xplength", "xplen", "fxval", "pglf", "xylen", "pyl", "xpval", "cpden", "fxlf", "pxlin", "pxLen", "rxlen", "pylen", "pngln", "pplen", "fxl", "cpln", "pngLen", "rxlin", "nplen", "npden", "xyden", "fxlength", "ppden", "pxval", "pxfin", "pxl", "ppln", "npfin", "rxden", "xyLen", "xylin", "fxln", "pxlength", "xplf", "pxln", "pglen", "cplen", "pnglen", "cpl", "xyln", "ppLen", "pglength", "pgval"], "out": ["session", "dump", "prefix", "OUT", "re", "user", "point", "output", "line", "server", "cli", "lib", "list", "group", "parent", "store", "lock", "Out", "base", "v", "conn", "error", "page", "gen", "err", "inter", "io", "code", "up", "obj", "step", "print", "outs", "work", "cache", "log", "post", "copy", "sys", "again"]}}
{"id1": "15745420", "id2": "12171364", "code1": "    private void download(String address, String localFileName) throws UrlNotFoundException, Exception {\n        String ext = G_File.getExtensao(address);\n        if (ext.equals(\"jsp\")) {\n            throw new Exception(\"Erro ao baixar pagina JSP, tipo negado.\" + address);\n        }\n        File temp = new File(localFileName + \".tmp\");\n        if (temp.exists()) temp.delete();\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            try {\n                URL url = new URL(address);\n                conn = url.openConnection();\n                in = conn.getInputStream();\n            } catch (FileNotFoundException e2) {\n                throw new UrlNotFoundException();\n            }\n            out = new BufferedOutputStream(new FileOutputStream(temp));\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n        } catch (UrlNotFoundException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException ioe) {\n            }\n        }\n        File oldArq = new File(localFileName);\n        if (oldArq.exists()) {\n            oldArq.delete();\n        }\n        oldArq = null;\n        File nomeFinal = new File(localFileName);\n        temp.renameTo(nomeFinal);\n    }\n", "code2": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "label": 0, "substitutes": {"address": ["number", "target", "prefix", "data", "content", "port", "reference", "point", "uri", "service", "request", "string", "source", "resource", "remote", "path", "output", "host", "server", "base", "array", "add", "type", "location", "ip", "image", "ress", "name", "route", "email", "region", "order", "mode", "index", "addr", "key", "ace", "Address", "config", "attribute", "pointer", "enter", "message"], "localFileName": ["localPageType", "currentSourceFilePath", "localFileType", "localFileLocation", "localSourceFileInfo", "localfileName", "localFilesDir", "localFilesUrl", "localImageLocation", "localPlaceUrl", "localPathLocation", "localfileDir", "localFileUrl", "remoteFilePath", "localFilesName", "remoteDirDir", " localFileDir", " localPlaceName", "localDirName", " localPlaceDir", "localFilesPath", "localFileInfo", "localSourceFileName", "localFilePath", "currentFileLocation", "localFileDir", "localFilesType", "remoteDirType", "localPathType", " localPlaceUrl", "localSourceFileType", "localPageLocation", "localImageType", "remotePageType", "currentSourceFileLocation", "localSourceFilePath", "localPathPath", "currentFileInfo", "remoteFileLocation", " localFilePath", "remoteDirPath", "localPlaceDir", "localPagePath", "localStreamName", "currentSourceFileInfo", "localPageInfo", "remoteFileName", "localPlacePath", "localfileUrl", "localPageName", "localfilePath", " localFileUrl", "localDirPath", "localStreamLocation", "currentSourceFileName", "remoteFileDir", "remoteFileType", "localDirType", "currentFileName", "localPlaceName", "localSourceFileLocation", "localDirDir", "remotePageLocation", "localImageName", "remotePagePath", "localSourceFileDir", "remoteDirName", "currentFilePath", "localImagePath", "localStreamInfo", "remotePageName", "localPathName", " localPlacePath", "localStreamPath"], "ext": ["f", "cert", "x", "data", "content", "format", "cfg", "string", "prot", "app", "path", "fx", "zip", "text", "dist", "txt", "req", "EXT", "file", "Ext", "exp", "err", "alt", "xt", "name", "dep", "external", "addr", "ctr", "test", "ex", "enc", "config", "word", "info", "xp"], "temp": ["tem", "session", "f", "cert", "template", "it", "data", "wrap", "emp", "home", "empty", "form", "source", "output", "path", "server", "valid", "tmp", "zip", "iter", "input", "this", "fake", "dest", "store", "base", "p", "txt", "folder", "v", "file", "lock", "full", "part", "mount", " temporary", "EMP", "w", "now", "parent", "unit", "archive", "porary", "c", "old", "stable", "pipe", "memory", "flat", "cache", "test", "local", "loc", "api", "tp", "ex", "cel", "Temp", "null", "dat", "cp"], "out": ["sync", "OUT", "socket", "ssl", "string", "source", "i", "con", "output", "on", "off", "server", "password", "Output", "cli", "input", "writer", "lib", "init", "this", "Out", "lock", "file", "co", "plain", "w", "bin", "exp", "connection", "err", "net", "io", "inner", "s", "image", "call", "name", "up", "client", "conv", "o", "b", "obj", "outs", "write", "exec", "not", "or", "outer", "n", "inc", "log", "key", "ex", "copy", "login", "again", "null"], "conn": ["Connection", "ctx", "sync", "socket", "ssl", "connect", "ci", "con", "cn", "server", "fr", "cli", "URL", "init", "nc", "cp", "lock", "nt", "func", "fp", "ai", " con", "impl", "act", "ct", "connection", "open", "client", "conv", "cmd", "c", "obj", "close", "l", "Conn", "ll", "Url", "n", "cache", "inc", "ch", "api", "uc", "enc", "config", "coll", " connection"], "in": ["issue", "f", "sync", "it", "data", "socket", "inn", "source", "i", "con", "sin", "diff", "on", "is", "cli", "input", "init", "lock", "kin", "min", "din", "lin", "reader", "part", "ins", "bin", "connection", "inner", "s", "image", "up", "client", "exec", "or", "l", "win", "In", "n", "cin", "inc", "ac", "IN", "nin", "ini", "r", "login", "index", "again", "pin", "pull", "id"], "url": ["f", "data", "socket", "uri", "ssl", "string", "source", "web", "host", "db", "server", "http", "fr", "sl", "URL", "blog", "base", "file", "ls", "www", "connection", "open", "client", "channel", "b", "c", "l", "ll", "Url", "n", "loc", "rl", "r", "api", "ob", "fl", "object"], "buffer": ["queue", "border", "length", "uffer", "data", "flush", "reference", "row", "wave", "document", "feed", "pad", "slice", "layer", "read", "limit", "iter", "buff", "buf", "input", "binary", "base", "block", "event", "transfer", "reader", "bin", "slave", "offset", "seed", "Buffer", "batch", "info", "bytes", "b", "result", "memory", "uf", "cache", "position", "padding", "null", "sequence", "message"], "numRead": ["nRead", "numBuild", "nWrite", "commonWrite", "numberWritten", "commonRead", " numWrite", "numberReader", "umWritten", "NumWritten", "numberRead", "NumReader", "umReader", "umRead", "numread", " numBuild", "nWritten", "nread", "commonReader", "umWrite", " numread", "Numread", "numWrite", "NumBuild", "commonWritten", "numReader", "NumRead", " numReader", "nBuild", "numberWrite", "NumWrite"], "numWritten": ["numWriter", "nRead", "numWrit", "NumWrit", " numSent", "nWrite", "nWriter", " numWrite", "NumWritten", "nWrit", "nWritten", "sumWritten", " numWrit", "sumSent", " numWriter", "sumWriter", "numWrite", "sumWrite", "nSent", "numSent", "NumRead", "NumWrite"], "oldArq": [" oldParc", "oldArquest", "oldArtch", "oldArtque", "OldAcquest", "oldParQ", "oldarqs", "oldAcquest", "OldAcq", "OldArq", "oldAcQ", "oldarQ", "oldArque", "oldARch", "oldarch", "oldAcque", "oldArc", "oldAvQ", " oldArqs", "OldArQ", "oldArtQ", "OldArch", "OldArque", "oldarc", "oldAvqs", " oldParq", "OldARch", "oldarque", "oldarquest", "oldArtquest", "oldARque", "oldArqs", " oldArQ", "oldARq", "OldARQ", "oldAvc", "oldArtq", "OldARque", " oldParqs", "OldAcque", "oldAcch", "OldARq", " oldParQ", "oldParq", "OldAcQ", "oldARQ", "oldarq", "oldArch", "oldParqs", "oldArQ", "oldParc", "oldAvq", " oldArc", "OldArquest", "oldAcq"], "nomeFinal": ["nukefinal", "noefinal", "nombFinal", "nombLast", "nombfinal", "nomesfinal", "Nomesfinal", "nomeLast", "nomesFinal", "nOMEfinal", "NomeLast", "NomesFinal", "Nomefinal", "noeFinal", "nomefinal", "NomesLast", "nukeFinal", "noeLast", "NomeFinal", "nOMEFinal", "nomesLast"]}}
{"id1": "8515891", "id2": "20519261", "code1": "    protected String readUrl(String svnUrl) throws IOException {\n        URL url = new URL(svnUrl);\n        URLConnection uc = url.openConnection();\n        if (url.getProtocol().equals(\"https\")) {\n            String userPassword = user + \":\" + password;\n            String encoding = new sun.misc.BASE64Encoder().encode(userPassword.getBytes());\n            uc.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        InputStream is = null;\n        String in = null;\n        try {\n            is = uc.getInputStream();\n            in = read(is);\n        } finally {\n            try {\n                is.close();\n            } catch (Exception e) {\n            }\n        }\n        return in;\n    }\n", "code2": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "label": 0, "substitutes": {"svnUrl": ["svncUrl", " svNUrl", "svcText", " svnLink", "svNText", "svpnURL", "svNLink", " svnText", "svpnLink", "svnwUrl", "svpnFile", "svpnUrl", "svnText", "svncLink", "svnURL", "svnwURL", "svNToken", " svNURL", " svnURL", " svNLink", "svNUrl", "svncFile", "svcUrl", "svcToken", "svnwToken", " svnFile", " svNText", "svnToken", "svnFile", " svNToken", "svnwText", " svnToken", "svNURL", "svnLink", " svNFile", "svcURL", "svncURL", "svNFile"], "url": ["plug", "cl", "f", "bug", "user", "uri", "bb", "ssl", "web", "resource", "path", "bc", "server", "http", "ur", "zip", "sl", "org", "URL", "fc", "this", "blog", "event", "conn", "page", "impl", "u", "ls", "www", "connection", "open", "up", "client", "c", "b", "util", "l", "stream", "Url", "log", "cur", "loc", "ob", "config", "ul", "pull"], "uc": ["cci", "cl", "anc", "cu", "uri", "cf", "UC", "ssl", "lc", "connect", "ci", "con", "uci", "bc", "uca", "hub", "http", "pc", "us", "ucc", "fc", "usc", "cas", "cp", "conn", "sc", "co", "roc", "ub", "tc", "connection", "exc", "contract", "soc", "up", "ec", "client", "c", "exec", "cc", "rc", "auc", "ac", "oc", "cur", "loc", "mc", "ocr", "coll", "ul"], "userPassword": ["userSecret", "Userpassword", "usePassword", " userpassword", " userPass", " userSecret", "UserPass", "usepassword", "UserSecret", "useSecret", "userpassword", "usePass", "UserPassword", "userPass"], "encoding": ["Encryption", "encoder", "enoding", "engoder", "coder", "encoded", "cryption", "enryption", "Encoding", "encryption", "enoder", "Encoded", "enasing", "encasing", "enoded", "engryption", "Encoder", "engoding", "coded", "coding", "engasing", "Encasing"], "is": ["ir", "lis", "cs", "ris", "it", "ori", "serv", "ui", "src", "uri", "iss", "iris", "ie", "abs", "i", "es", "ci", "ais", "isl", "has", "im", "ib", "us", "its", "ics", "isa", "os", "iso", "vs", "ins", "ls", "ms", "s", "ip", "bis", "IS", "ws", "ios", "ri", "as", "was", "irc", "Is", "isc", "are", "js", "isi", "si", "api", "out", "info", "fs", "id"], "in": ["gin", "vin", "isin", "edIn", "inn", "string", "source", "i", "con", "with", "read", "pc", "arin", "input", "inas", "reading", "kin", "raw", "din", "rin", "reader", "ins", "bin", "m", "into", "err", "inner", "inside", "In", "cin", "inc", "IN", "nin", "ini", "atin", "login", "tin", "out", "again", "oin", "pin", "id"]}}
{"id1": "19810820", "id2": "9033639", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"src": ["inst", "rest", "ctx", "sync", "filename", "st", "rb", "ruby", "ses", "ssl", "sb", "source", "upload", "path", "sub", "sin", "RC", "slice", "SOURCE", "server", "tmp", "sl", "sth", "input", "dist", "dest", "func", "sup", "url", "conn", "sc", "img", "ls", "s", "client", "b", "sit", "sq", "sel", "rs", "rc", "download", "lower", "stream", "start", "cur", "Source", "loc", "scene", "config", "sys"], "dst": ["adst", "adST", "fdrc", "ldst", "DST", "drc", "dost", "stst", "bart", "bput", "stlt", "bst", "dart", "Dost", "Dst", "bST", "fdst", "fdput", "dlt", "dST", "stST", "blt", "ldost", "tart", "fdST", "Ddest", "adrc", " dost", "tST", "adput", " dST", "dput", "lddest", "tst", "start", " ddest", "ddest", "ldST", "brc", "tlt"], "preserveModificationTime": ["preserveModifiedFile", "preserveModificationFile", "preserveModifiedtime", "preserveModationtime", "preserveModifyingFile", "preserveMinifiedTime", "preserveMinificationFile", "preserveModifyTime", "preserveModifytime", "preserveMinifiedFile", "preserveModifiedTime", "preserveMinificationtime", "preserveModifyingTime", "preserveModationFile", "preserveMinifiedtime", "preserveModifyingtime", "preserveModationTime", "preserveModificationtime", "preserveMinificationTime"], "inputChannel": ["outputConnection", "inputConnection", "inputGate", "requestChannel", "inputchannel", "requestCode", "inputConsole", "imageChan", "binarychannel", "errorCache", " inputQueue", "inputCache", " inputchannel", "fileChannel", "imagechannel", "outputConsole", "inputStream", "InputSocket", "inputCode", " inputConnection", "outputCode", "outputCache", "fileChan", "InputBuffer", "imageChannel", "binaryGate", " inputSocket", "outputSocket", " inputBuffer", "fileConnection", " inputStream", "outputBuffer", "requestStream", "errorStream", "imageGate", "InputQueue", "inputBuffer", "outputStream", "outputchannel", "requestChan", "inputChan", " inputConsole", " inputCache", "outputGate", " inputChan", "binaryChan", " inputCode", "outputQueue", "errorChan", "fileConsole", "Inputchannel", "inputQueue", "outputChan", "errorChannel", "InputChan", "inputSocket", "binaryChannel", "InputChannel"], "outputChannel": [" outputQueue", "outStream", "writeChannel", " outputManager", " outputButton", " outputchannel", "OutputChan", "writeManager", "OutputStream", "inputStream", "outchannel", "outChan", "OutputChannel", "outChannel", "writeChan", "OutputQueue", " outputStream", "outputButton", "Outputchannel", "outputStream", "outputchannel", "inputButton", "inputChan", "inputManager", "outputQueue", " outputChan", "outButton", "outputChan", "writeStream", "writeQueue", "outputManager"], "length": ["number", "session", "join", "next", "delay", "child", "last", "section", "form", "end", "Length", "with", "limit", "duration", "len", "available", "text", "value", "base", "lock", "load", "volume", "block", "head", "full", "part", "php", "type", "slave", "style", "offset", "buffer", "partial", "result", "build", "width", "l", "sum", "size", "max", "start", "current", "position", "count", "complete", "sequence", "pull", "id"], "total": ["found", "last", "no", "i", "valid", "limit", "otal", "duration", "len", "available", "scale", "base", "Total", "failed", "error", "full", "translation", "part", "type", "used", "offset", "partial", "done", "set", "multi", "result", "toc", "all", "sum", "max", "size", "current", "start", "always", "less", "cur", "key", "count", "complete", "info", "id"]}}
{"id1": "8062076", "id2": "12306305", "code1": "    public void updateUser(User portalUserBean, AuthSession authSession) {\n        DatabaseAdapter dbDyn = null;\n        PreparedStatement ps = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            String sql = \"update WM_LIST_USER \" + \"set    FIRST_NAME=?,MIDDLE_NAME=?,LAST_NAME=?, \" + \"       ADDRESS=?,TELEPHONE=?,EMAIL=? \" + \"where  ID_USER=? and is_deleted=0 and  ID_FIRM in \";\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    String idList = authSession.getGrantedCompanyId();\n                    sql += \" (\" + idList + \") \";\n                    break;\n                default:\n                    sql += \"(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)\";\n                    break;\n            }\n            ps = dbDyn.prepareStatement(sql);\n            int num = 1;\n            ps.setString(num++, portalUserBean.getFirstName());\n            ps.setString(num++, portalUserBean.getMiddleName());\n            ps.setString(num++, portalUserBean.getLastName());\n            ps.setString(num++, portalUserBean.getAddress());\n            ps.setString(num++, portalUserBean.getPhone());\n            ps.setString(num++, portalUserBean.getEmail());\n            ps.setLong(num++, portalUserBean.getUserId());\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    break;\n                default:\n                    ps.setString(num++, authSession.getUserLogin());\n                    break;\n            }\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of updated record - \" + i1);\n            dbDyn.commit();\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) {\n                    dbDyn.rollback();\n                }\n            } catch (Exception e001) {\n            }\n            String es = \"Error update of portal user\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 0, "substitutes": {"portalUserBean": ["portalGroupBEan", "portalUserBoam", "portalUserPean", "portalFileBean", "portalUserBoans", "portalUserAppAN", "portalUsersBeans", "portalGroupBEAN", "portalUserEans", "portalUserEAN", "portalUserBam", "portalFileBeane", "portalUserDeAN", "portalFileBan", "portalFileBeAN", "portalUserAppan", "portalUserAppans", "portalUserBegann", "portalGroupBeAN", "portalFileBAN", "portalUserPeann", "portalFileBeam", "portalUserBegAN", "portalUserBan", "portalUserBeann", "portalUserEan", "portalGroupBeann", "portalUserBAN", "portalFileBans", "portalUserDeann", "portalUserBEans", "portalGroupBEann", "portalUserBEAN", "portalUsersBam", "portalUserDean", "portalUserBEacer", "portalUsersBeam", "portalUserBeans", "portalUserBacer", "portalUserBann", "portalUserEam", "portalFileBam", "portalUserBeacer", "portalUserBegans", "portalUsersBans", "portalUserBEam", "portalUsersBeAN", "portalUserDeam", "portalUserBoAN", "portalUserBoane", "portalFileBacer", "portalUserBeAN", "portalUserBane", "portalUserPeAN", "portalUsersBean", "portalUserBeane", "portalFileBeacer", "portalUserBEann", "portalFileBann", "portalFileBeann", "portalUsersBan", "portalUserBEane", "portalFileBane", "portalUserBoan", "portalGroupBeans", "portalUserBeam", "portalGroupBean", "portalUserBans", "portalFileBeans", "portalUsersBAN", "portalUserPeam", "portalUserBEan", "portalUserAppacer", "portalGroupBEans", "portalUserBegan"], "authSession": ["AuthSocket", "AuthSession", "AuthSite", " authSite", "authSocket", " authClient", "authConnection", "AuthContext", "uthClient", " authConnection", "authSite", "uthContext", " authsession", "Authsession", "adminSite", "inConnection", "uthSession", "adminClient", "adminSession", "AuthConnection", " authContext", "insession", "inSocket", "authClient", "authsession", "uthConnection", "AuthClient", "inSession", "authContext", " authSocket"], "dbDyn": ["dbdsyn", "dbPll", "dbSynam", "dbdilly", " dbDSyn", " dbDynam", "DbDYN", "dbDyl", "dbMyr", " dbDogn", " dbDsyn", "tabledsyn", "dbDilly", "libDilly", "dbGYN", "dbBYN", "dbFyn", "dbPSyn", "dbDaYN", "DbPyr", "dbDsyn", "dbDoynam", "dbGSyn", "dbMyn", "dbDewn", " dbBsyn", "dbCyn", " dbDoYN", "DbDynam", " dbByn", "dbDayn", " dbDgn", "dbDeSyn", " dbDoyn", "DbPyn", "libDyn", "DbSynam", "dbSYN", "dbFSyn", "DbDyl", "dbFsyn", "dbFill", "dbCsyn", "dbByl", "dbDYN", "DbDyr", "dbNyn", "dbdynam", "tableDSyn", "dbDagn", "DbPll", "dbCSyn", " dbBSyn", "dbDasyn", "dbSyl", "dbDoyn", "dbDeyn", "libDyr", "DbSyl", "dbGsyn", " dbDown", "DbDSyn", "dbCill", "dbSyn", "tableDyn", "dbDgn", " dbDwn", "dbBynam", "tabledSyn", "dbBll", " dbDoynam", "dbMilly", "dbPyr", "dbdyn", "dbBgn", "dbDeYN", "DbSYN", "dbBSyn", "dbFynam", "dbFYN", "dbDill", "dbGyn", "dbdill", "dbdYN", " dbDYN", " dbBYN", "tableDsyn", "dbdSyn", "dbPyn", "dbDown", "dbFwn", "dbDSyn", "dbDogn", "DbDyn", "dbByr", "tabledyn", "dbDwn", "libDYN", "dbDoYN", "dbDynam", "DbPSyn", "dbGyr", "dbMYN", "dbDyr", "dbdwn", "dbNyl", " dbDosyn", "dbDll", "dbNYN", "tableDill", "dbDosyn", "dbNynam", "dbBsyn", "dbGll", "tabledill", "DbSyn", "dbByn", "dbdyr", "DbDll"], "ps": ["pa", "ans", "pb", "cs", "pg", "lines", "changes", "pers", "PS", "per", "pes", "fs", "ds", "hs", "pe", "pc", "http", "pp", "its", "pps", "this", "pr", "bs", "p", "ons", "os", "properties", "vs", "ns", "ils", "als", "sp", "gs", "pl", "res", "ls", "css", "Ps", "PD", "ms", "ins", "qs", "pse", "cop", "s", "ws", "py", "ops", "details", "ips", "pre", "pos", "ups", "po", "as", "rs", "ss", "jp", "ros", "ts", "ports", "js", "mp", "fe", "proxy", "posts", "eps", "ks"], "sql": ["session", "join", "install", "lock", "sync", "csv", "msg", "rel", "ssl", "string", "sb", "sf", "ln", "db", "nl", "http", "zip", "sl", "repl", "pr", "sol", "html", "function", " SQL", "sg", "query", "os", "fp", "conn", "url", "params", "shell", "select", "SQL", "statement", "ls", "comment", "acl", "serial", "seed", "job", "details", "printf", "util", "su", "setup", "sq", "ql", "l", "ll", "sv", "log", "si", "general", "fn", "api", "ob", "rl", "sys", "dl", "eps", "la", "id"], "idList": ["idTree", "urlSet", " idSet", "idslist", " idNames", "idSet", "urlLIST", "idLIST", "codeSet", "idsList", "idNames", "IDLIST", "codelist", "urlList", "codeList", "IDlist", "idsTree", "urlTree", "IDList", "codeNames", "idsLIST", "urllist", "urlNames", "IDTree", " idlist", "idlist"], "num": ["number", "nu", "um", "nb", "uri", "ni", "no", "hex", "begin", "form", "i", "div", "con", "zero", "off", "miss", "lang", "init", "len", "mn", "du", "Num", "numbered", "temp", "uu", "lim", "bin", "nam", "NUM", "dom", "gen", "one", "oct", "dim", "type", "unit", "nn", "gru", "coord", "multi", "su", "mult", "np", "mon", "result", "pos", "sum", "size", "nom", "n", "uni", "inc", "norm", "loop", "loc", "nr", "node", "count", "fn", "nov", "index", "col", "sn"], "i1": ["I4", "i4", "I1", "ci1", "xiOne", "i81", "qi1", "xi1", "i9", " i9", "iOne", "qiOne", "ci81", "ci4", "I81", " i81", "xi4", "qi4", "ci9", " i4", "IOne", "I9"]}}
{"id1": "8216539", "id2": "21827619", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"filePath": ["basepath", "Filepath", "singleUrl", "baseName", "FilePath", "baseUrl", "resourceLocation", "FileStr", "fileLocation", "basePath", "baseStr", "FileName", "FileUrl", "fileName", " filepath", "singleLocation", "baseLocation", "fileStr", "resourceName", "FileLocation", "fileUrl", "singlepath", "filepath", " fileStr", "singlePath", "resourcePath", "resourcepath", " fileUrl"], "encoding": ["Encryption", "enclocking", "languagepling", "Encasing", "encoded", "equlocking", "cryption", "equoding", "decoding", "Encoding", "equpling", "decryption", "encryption", "Enclocking", "Encoded", "equging", "encasing", "languageging", "casing", "encpling", "decoded", "Encpling", "Encging", "decasing", "languageoding", "coded", "encging", "coding", "languagelocking"], "testURL": ["appUR", "appurl", "appUrl", "shortTL", "testingurl", "testingURL", "TestUrl", "Testurl", "shorturl", "TestURL", "shortURL", "fileURL", " testUrl", "testingUrl", "testurl", "testUrl", "fileURI", " testURI", " testurl", "testRL", "testingURI", "fileUrl", "TestUR", "testURI", " testRL", "testingRL", "testingUR", "appURL", "testingTL", "testTL", " testTL", "testUR", "fileRL", "shortUrl"], "input": ["wrapper", "inf", "data", "socket", "ssl", "source", "i", "xml", "resource", "form", "flow", "path", "output", "feed", "dc", "through", "upload", "http", "entry", "this", "binary", "init", "text", "ack", "parent", "op", "ou", "raw", "error", "conn", "url", "in", "but", "Input", "reader", "temp", "file", "active", "type", "bin", "act", "img", "connection", "get", "inner", "image", "acl", "element", "client", "inside", "result", "exec", "instance", "rc", "stream", "qa", "current", "ink", "inc", "ac", "audio", "api", "enc", "config", "out", "null", "pull"], "sw": ["wrapper", "iw", "rew", "sm", "wrap", "rw", "sb", "sf", "web", "wb", "sk", "nw", "SW", "sh", "cr", "WS", "ib", " SW", "sl", "writer", "ow", "aw", "sa", "wx", "fp", "wp", "sc", "wr", "Sw", "w", "ww", "now", "io", "hw", "ws", "tw", "we", "en", "rc", "stream", "work", "sv", "wt", "rx", "ew", "sn"]}}
{"id1": "19738435", "id2": "23677142", "code1": "    public Resource parse(URL url, IRDFContainer target) throws RDFException, IOException {\n        parseURL = url;\n        URLConnection connection = url.openConnection();\n        if (charset == null) {\n            charset = Charset.forName(\"UTF-8\");\n        }\n        Reader reader = new InputStreamReader(connection.getInputStream(), charset);\n        return internalParse(reader, target);\n    }\n", "code2": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "label": 0, "substitutes": {"url": ["loader", "address", " URL", "uri", "src", "request", "string", "source", "ssl", "resource", "parse", "proxy", "document", "feed", "path", "host", "str", "server", "http", "entry", "ur", "input", "URL", "text", "base", "error", "file", "page", "conn", "location", "absolute", "io", "image", "buffer", "element", "client", "channel", "l", "link", "stream", "Url", "api", "r", "config", "object", "e"], "target": ["ctx", "address", "data", "content", "format", "reference", "source", "resource", "document", "container", "path", "output", "host", "resources", "response", "t", "project", "class", "this", " Target", "context", "parent", "root", "event", "pointer", "timeout", "to", "collection", "result", "component", "arget", "current", "node", "Target", "config", "object"], "parseURL": ["parserUrl", "parseResource", " parseType", "readResource", " parseUrl", "parseType", "readUrl", "parserType", "parserURL", "readType", "parserResource", "parseUrl", " parseResource", "readURL"], "connection": ["application", "Connection", "ctx", "which", "uri", "service", "source", "connect", "resource", "section", "container", "con", "director", "handler", "bc", "db", "response", "character", "writer", "text", "context", "creator", "function", "database", "conn", "directory", "timeout", "normal", "io", "open", "connected", "client", "channel", "relation", "c", "or", "ion", "pool", "body", "config", "out"], "charset": ["chaptersetter", "choipsET", "chaseting", "charsect", "choipsets", "chansect", "chanset", "chaset", "chasET", "chARSET", "chipsET", "choipset", "Chasec", "charseting", "chipsect", "charsET", "ChasET", "chARSet", "charsetter", "chARSetter", "chipseting", "chasec", "Charsect", "charsec", "Charsec", "chARSec", "choarsET", "choarset", "charsets", "chARSect", "choarseting", "choarsets", "chaptersET", "choipseting", "chasetter", "ChARSec", "chapterset", "chipsec", "CharsET", "ChARSET", "chipset", "Charset", "ChARSet", "chipsets", "ChARSect", "Charsetter", "chansec", "chansET", "Chasetter", "chasets", "Chaset", "chaptersec"], "reader": ["loader", "x", "rr", "data", "row", "source", "i", "resource", "ler", "container", "per", "feed", "director", "handler", "server", "read", "entry", "iter", "input", "writer", "context", "reading", "in", "pointer", "er", "worker", "io", "rar", "keeper", "channel", "or", "stream", "parser", "driver", "r", "object", "Reader", "oder"]}}
{"id1": "2668853", "id2": "19096138", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"infile": ["inputfp", "minfile", "inputfilename", "infilename", " infilename", " infiles", "minFile", "outfp", "inputfile", "inputfiles", "inFile", "minfp", "infp", "minfilename", "infiles", "inputFile", "outFile", "outfilename", "outfiles", " inFile"], "outfile": ["Outfile", "outputfilename", " outfolder", "outputFile", "infilename", " outfp", "outputfile", "OutFile", "outfp", "infolder", "Outfull", " outFile", "infp", "outfull", " outfilename", "outfolder", " outfull", "outputfull", "outputfp", "outputfolder", "Outfolder", "outFile", "outfilename"], "in": ["gin", "f", "a", "re", "data", "socket", "inn", "source", "i", "con", "ic", "is", "input", "init", "inas", "this", "min", "din", "conn", "lin", "reader", "rin", "ins", "bin", "m", "err", "inner", "s", "image", "up", "b", "inside", "as", "win", "In", "cin", "inc", "ac", "IN", "nin", "ini", "r", "ex", "login", "again", "pin", "e"], "out": ["session", "target", "ext", "sync", "OUT", "point", "socket", "other", "home", "no", "exit", "output", "on", "off", "line", "lib", "writer", "Out", "base", "lock", "op", "error", "file", "conn", "co", "bin", "exp", "err", "net", "io", "to", "s", "inner", "image", "name", "up", "client", "obj", "o", "b", "exec", "outs", "write", "as", "outer", "In", "work", "cache", "inc", "post", "pass", "ex", "copy", "again"], "buffer": ["queue", "border", "address", "length", "uffer", "data", "row", "flush", "reference", "bb", "source", "wave", "resource", "feed", "pad", "slice", "layer", "server", "limit", "iter", "buff", "buf", "pause", "input", "binary", "value", "base", "shape", "transfer", "url", "reader", "bin", "offset", "seed", "Buffer", "batch", "bytes", "b", "result", "size", "memory", "split", "padding", "null"], "read": ["length", " receive", "Read", "connect", "limit", "input", "wait", "sleep", "select", "k", "open", " parse", "current", "run", "inc", " ride", "index", "lex", "next", "sync", "x", " sleep", "ad", "parse", "send", " use", "reader", " check", "seek", "write", "exec", "pass", "count", "r", " load", " connect", "use", " copy", "id", " write", "allow", "find", "check", "line", "ind", " send", " reach", "load", "add", "se", "play", " request", "get", "READ", "ride", " get", "start", "work", "copy", "end", "feed", "tell", "iter", " Read", " find", "reading", "fill", " r", "skip", " reader", "size", "reads"], "success": ["construct", "found", "better", "data", "content", "follow", "fast", "yes", "safe", " succ", "cess", "successful", "status", "zero", "rolling", "correct", "response", "valid", "selected", "accept", "rolled", "initial", "fail", " successful", "value", "failed", "ccess", "roll", "func", "error", "winner", "first", "full", "true", "danger", " succeed", "results", "warning", "done", "ceed", " Success", "job", "result", "successfully", "good", "Success", "pass", "ok", "complete", "continue", "default", "again", "null"]}}
{"id1": "5237257", "id2": "20100809", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fileName": [" fileId", "FileFolder", "FilePath", "resourceLocation", "resourceFolder", " fileType", "fileLocation", "FileName", "resourceUrl", "FileUrl", " fileFolder", "fileId", "resourceName", "resourceId", "FileLocation", "fileUrl", "FileId", " fileLocation", "fileType", "resourceType", "resourcePath", "fileFolder", "FileType", " fileUrl"], "filePath": [" fileId", "Filepath", " fileInfo", "FilePath", "fileInfo", "resourceLocation", "fileLocation", "FileName", " filepath", "resourceInfo", "fileId", "resourceFile", "fileFile", "resourceName", "FileInfo", " fileFile", "resourceId", "FileLocation", " fileLocation", "filepath", "FileFile", "resourcePath", "resourcepath", "FileId"], "in": ["issue", "gin", "f", "re", "a", "x", "data", "socket", "inn", "source", "i", "wave", "resource", "con", "on", "ax", "is", "input", "init", "this", "base", "kin", "din", "file", "url", "conn", "reader", "rin", "lin", "ins", "bin", "m", "err", "work", "inner", "io", "image", "name", "up", "client", "b", "inside", "as", "l", "win", "In", "stream", "n", "cin", "inc", "IN", "ac", "nin", "ini", "r", "copy", "login", "again", "pin", "id"], "out": ["ext", "sync", "OUT", "prefix", "point", "socket", "user", "source", "i", "output", "on", "off", "server", "with", "option", "lib", "writer", "this", "by", "Out", "error", "conn", "file", "office", "url", "part", "bin", "object", "one", "err", "connection", "net", "io", "to", "call", "image", "inner", "name", "up", "obj", "cmd", "o", "client", "outs", "exec", "or", "In", "qa", "n", "at", "cache", "inc", "IN", "log", "nin", "work", "ex", "copy", "extra", "again", "null", "config", "pin", "id"]}}
{"id1": "15896098", "id2": "22479286", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"source": ["target", "filename", "data", "content", "format", "src", "uri", "from", "service", "string", "resource", "output", "path", "ources", "SOURCE", "slice", "password", "input", "text", "dest", "base", "file", "url", "reader", "connection", "seed", "buffer", "image", "code", "result", "size", "cache", "Source", "SourceFile", "ource", "config", "object", "message"], "md": ["cm", "um", "pd", "nm", "d", "dh", "sm", "wd", "hm", "pm", "gd", "amd", "rpm", " Md", "mm", "am", "Cmd", "bf", "MD", "dd", "od", "mand", "M", "mt", "m", "ms", " MD", "bd", "rm", "dig", "mb", "hash", "MF", "vd", "dm", "cmd", "mod", "hd", "df", "mac", "mag", "mp", "mc", "mo", "metadata"], "byteData": ["ByteNumber", "hardInfo", "bufferSize", "serviceDATA", "ByteDATA", " byteArray", "bitNumber", "hardDATA", " bytedata", "hardData", "ByteData", "serviceString", "ByteInfo", "sourceData", "sourceBytes", " byteDATA", "ByteBytes", " byteBytes", "byteString", "byteInfo", "byteSeries", "bitArray", "ByteSeries", "bitInfo", "bytedata", "sourceString", "hardSeries", "ByteArray", " byteSize", "bufferArray", "byteArray", "serviceData", "bitData", "servicedata", "byteDATA", "byteNumber", "sourceArray", " byteSeries", "ByteSize", "bufferData", "bufferDATA", " byteString", " byteNumber", " byteInfo", "byteBytes", "sourcedata", "byteSize", "sourceDATA"], "sb": ["abb", "pb", "xb", "bh", "rb", "nb", "bb", "lp", "src", "gb", "eb", "sf", "wb", "bc", "db", "BB", "buff", "buf", "fb", "binary", "bs", "lb", "bf", "sg", "bsp", "bm", "bp", "ls", "SB", "cb", "ub", "ab", "bd", "buffer", "mb", "bt", " eb", "ws", "b", " SB", "sq", "kb", "sv", "kB", "ob", "bg"], "i": ["hi", "phi", "f", "x", "it", "d", "data", "ui", "ti", "uri", "ie", "bi", "ci", "qi", "gi", "slice", "di", "abi", "pi", "q", "p", "v", "ix", "ai", "in", "part", "w", "u", "k", "iu", "io", "inner", "s", "ip", "ii", "y", "info", "o", "c", "ri", "I", "b", "multi", "j", "l", "index", "n", "si", "key", "li", "ini", "r", "oi", "ji", "mi", "h", "xi", "e", "id"], "hexString": ["pexStr", "pexLine", "shortString", "crossStr", "hexLine", "hexArray", "crossLine", "pexString", " hexStr", "shortstring", " hexstring", "stringBuffer", "tempArray", "hexService", "formString", "hexStr", "stringArray", "hexBuffer", "crossString", "rawArray", " hexArray", "tempBuffer", " hexBuffer", "formService", "rawBuffer", " hexService", "crossstring", "stringString", "tempString", "rawString", "formArray", "shortArray", "formstring", "shortBuffer", "pexstring", "rawService", " hexLine", "tempstring", "hexstring", "stringService", "rawstring"], "hex": ["lit", "rex", "length", "sync", "digit", "data", "format", "color", "alpha", "string", "sex", "form", "none", "shift", "str", "id", "http", "character", "buff", "zip", "nexus", "text", "pixel", "utf", "raw", "num", "chrom", "temp", "closure", "bin", "pex", "exp", "oct", "char", "letter", "comp", "hash", "ip", "serial", "coord", "pack", "sum", "cmp", "wh", "ctr", "cookie", "ex", "null", "rh", "bit"], "checksum": ["cksums", " checksup", "checkums", "checkup", "cksum", "checkpace", "checkum", " checksums", "checksums", " checkssum", "checkssum", "cksumption", "cksup", "ckspace", "ckssum", "checkspace", "checkumption", "checksumption", "checksup", " checksumption", " checkspace"]}}
{"id1": "22264586", "id2": "16719805", "code1": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"strPath": ["StrLog", "StrPath", "striFile", "STRPath", "StrName", "strName", "StrFile", "stpath", " strpath", "stName", "stripath", "strpath", "stFile", " strName", "stPath", "strFile", "STRFile", "STRpath", "STRLog", " strFile", "striPath", "strLog", "striLog", "Strpath"], "dstPath": ["fstFile", "fstsPath", "ddestDir", "sdstpath", "dstFile", "fstspath", "dstpath", "drcName", "dstsDir", "fstsFile", "dstsPath", "sdndName", "dndPath", "drcPath", "sdndDir", "sdstName", "sdndpath", "fstsDir", "dstName", "sdndPath", "dstspath", "dblpath", "dndpath", "drcpath", "sdstPath", "dstDir", "fstPath", "dblPath", "ddestName", "dstsFile", "dndName", "ddestpath", "dndDir", "fstDir", "dblFile", "dblDir", "fstpath", "ddestFile", "drcDir", "sdstDir", "ddestPath"], "src": ["inst", "ctx", "sync", "st", "rb", "ruby", "ssl", "sb", "source", "upload", "path", "sub", "RC", "ources", "slice", "SOURCE", "sin", "host", "tmp", "sl", "project", "input", "iv", "this", "dist", "scripts", "secure", "obl", "rob", "txt", "front", "sup", "url", "in", "sc", "ls", "img", "cb", "sort", "s", "self", "client", "sit", "sq", "sel", "rs", "rc", "download", "stream", "cmp", "cur", "Source", "loc", "split", "reverse", "ource", "config", "sys", "back"], "dest": ["delete", "target", "rest", " Dest", "d", "cat", "wd", "gd", "home", "source", "thin", "wb", "Dest", "dc", "div", "db", "ds", "di", "tmp", "comb", "zip", "project", "du", "dist", "desc", "folder", "secure", "txt", "front", "sup", "des", "destroy", "dd", "prop", "temp", "img", "de", "cdn", "slave", "style", "default", "done", "later", "result", "dep", "trans", "flat", "wh", "test", "out", "dat"], "list": ["filter", "LIST", "lc", "path", "entry", "members", "url", "full", "type", "www", "remove", "arr", "code", "ll", "keys", "run", "strings", "config", "names", "queue", "bl", "version", "parents", "data", "lists", "source", "listed", "group", "base", "cont", "chain", "stack", "sort", "pair", "set", "write", "stream", "test", "key", "like", "info", "none", "id", "delete", "cl", "lines", "string", "diff", "str", "load", "array", "part", "ls", "stat", "s", "dir", "split", "val", "coll", "status", "la", "map", "read", "is", "json", "parent", "p", "files", "name", "batch", "all", "l", "size", "dl", "null"], "i": ["hi", "phi", "f", "length", "x", "a", "ui", "data", "ti", "uri", "ie", "bi", "gi", "ci", "qi", "slice", "mu", "di", "abi", "pi", "p", "v", "ix", "ai", "part", "u", "type", "m", "io", "ip", "ii", "y", "info", "o", "b", "ri", "I", "multi", "c", "j", "start", "n", "me", "si", "key", "li", "oi", "r", "ji", "index", "xi", "e", "id"], "dest1": ["src0", "src2", "source2", "Dest1", "homeone", "home1", "destOne", "Dest0", "DestOne", " destone", "source1", "sourceone", "source0", "dest0", "destone", "srcOne", "Dest2", "sourceOne", "dest2"], "src1": ["rc1", "rcOne", "rc2", "source2", "src2", " srcone", "rcone", "srcone", "source1", "sourceone", "srcOne", " src2", "sourceOne", " srcOne"], "sourceChannel": ["sourceChan", "ourceChannel", "Sourcechannel", "ourceChan", "srcChannel", "SourceChannel", "sourceStream", "SourceStream", "sourceContext", "targetStream", " sourceStream", " sourceContext", "targetContext", "SourceChan", "srcStream", "srcContext", "ourceContext", "targetChan", "srcChan", "sourcechannel", " sourcechannel", " sourceChan", "ourceStream", "SourceContext", "targetchannel"], "targetChannel": ["TargetConnection", "sourceChan", "destContext", " targetManager", "argetChan", "targetManager", " targetConnection", "TargetManager", "argetchannel", "TargetContext", "sourceContext", "targetConnection", "TargetChannel", "targetContext", " targetchannel", "TargetChan", "targetChan", "destChan", " targetContext", " targetChan", "sourcechannel", "destConnection", "argetChannel", "destChannel", "Targetchannel", "targetchannel", "argetManager"]}}
{"id1": "15799935", "id2": "18489832", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "label": 1, "substitutes": {"context": ["queue", "system", "ca", "ctx", "Context", "version", "template", "content", "cf", "service", "request", "resource", "document", "container", "support", "contact", "host", "subject", "kernel", "project", "input", "ce", "community", "text", "parent", "event", "processor", "front", "reader", "translation", "concept", "environment", "manager", "network", "connection", "state", "media", "cms", "collection", "client", "channel", "c", "present", "component", "cache", "definition", "current", "view", "cca", "driver", "center", "mc", "config", "coll", "message"], "part": ["Parts", "pod", "patch", "plan", "point", "from", "service", "section", "source", "upload", "app", "per", "parts", "chapter", "parent", "html", "base", "p", "block", "event", "file", "translation", "type", "connection", "place", "state", "comment", "to", " Part", "image", " parts", "partial", "media", "art", "name", "channel", "pre", "phase", "po", "or", "component", "Part", "start", "position", "body", "area", "PART", "object", "mission", "message"], "localAttachment": ["localExtacher", " localExtacement", "localArtachment", " localAttribution", "localAddment", "localAddention", "localAttail", "localAssention", "localAvacher", "localAttachension", " localExtacher", "localattment", " localAttachachment", "localattrollment", "localAddail", "localArtention", "localAttachacement", "LocalAttail", "localArtment", "localAddrollment", "localAttachribution", "localInstension", "localArtail", "localAttention", " localPartribution", " localAttacher", " localAttrollment", "localPartension", " localPartachment", " localAttention", "localattention", "localPartention", "localInstachment", " localAttension", "localAttachrollment", "LocalAttachment", "localAssment", "localAttacement", " localExtachment", "localAttment", " localAttment", "LocalAttment", " localAttachention", "localAttachachment", "LocalAssail", "localAttension", "localAssachment", "localAssail", "localPartribution", "localExtachment", " localPartension", " localExtention", "localAvacement", "localAttacher", "localExtacement", "localAttrollment", "LocalAssention", "LocalAssment", "localInstention", "localExtention", " localAttacement", "localAddachment", "LocalAttention", "localAttachacher", "localAvention", "localPartachment", "localAttribution", "localAvachment", " localPartention", "localAttachention", " localAttachrollment", "localattachment", "localInstribution", "LocalAssachment"], "accountId": ["accInfo", " accountName", "jobId", "jobid", "accid", "jobName", "appInfo", "contactName", "feedId", "appId", "feedID", " accountid", "appid", "accountName", "contactId", "AccountID", "AccountId", "appID", "contractid", " accountID", "Accountid", "accID", "accountInfo", "AccountName", " accountInfo", "contactid", "feedid", "jobID", "contractId", "feedName", "accountid", "contractName", "accountID", "accId"], "attachmentId": ["attensionId", "addachmentID", "adentionIndex", "extachmentid", "attachedType", "attociationUrl", "attlementID", "attociationId", "attentionInfo", "attagramID", "addentionUrl", "attachmentid", "attachmentReference", "attmentReference", "adachmentInfo", "attmissionid", "attptionID", "atociationID", "adentionInfo", "extachmentId", "atachmentName", "attachedId", "atachmentId", "attociationName", "atociationId", "adachmentID", "addentionId", "adachmentId", "attentionid", "attagramIndex", "atachmentReference", "extensionSource", "attentionType", "attentionID", "extachmentSource", "adentionId", "attptionIndex", "attmentId", "adentionID", "attmentID", "attachedID", "adachmentIndex", "attachmentUrl", "attociationID", "attentionId", "attmentName", "attmissionId", "attlementReference", "attentionIndex", "attentionUrl", "atociationName", "addentionType", "attagramId", "attachmentType", "attptionId", "addachmentId", "extensionId", "addentionID", "attociationReference", "attachedUrl", "attensionSource", "atachmentID", "attlementId", "attmissionSource", "attachmentSource", "attptionInfo", "attociationType", "attensionid", "attachmentID", "addachmentUrl", "extachmentID", "attentionSource", "atociationReference", "attensionID", "extensionid", "extensionID", "attagramInfo", "attachmentIndex", "attachmentInfo", "addachmentType", "attachmentName", "attlementName", "attmissionID"], "in": ["gin", "f", "a", "it", "data", "socket", "inn", "source", "i", "con", "plus", "slice", "is", "input", "init", "p", "load", "din", "file", "conn", "url", "reader", "ins", "bin", "err", "inner", "image", "up", "inside", "as", "or", "In", "pass", "cin", "inc", "ac", "IN", "nin", "ini", "copy", "login", "again", "info", "pin", "pull", "id"], "saveIn": ["aveOut", "savein", " saveOut", "stageAs", "writein", " saveIN", "savIn", "saveOut", "aveAs", " saveIns", "stageIn", "SaveIn", "savAs", "writeIN", "aveIN", "savOut", "stageIns", "writeOut", "SaveAs", "savin", " savein", "saveIns", "stageOut", "saveIN", "aveIn", "SaveOut", "SaveIns", "writeIn", "avein"], "saveAs": [" saveOut", "copyAs", "writeIn", "writeAs", "copyIn", "createAS", "saveAt", "openAS", "createFile", "openAs", "SaveIn", "createAs", "createAt", "saveas", "saveFile", " saveAS", "copyAS", "openFile", "openAt", "writeOut", "copyas", " saveas", "SaveAs", "Saveas", "saveAS", "SaveAS", "writeAS", " saveAt", " saveFile", "SaveOut", "saveOut"], "out": ["ext", "sync", "OUT", "a", "data", "other", "string", "source", "flow", "output", "path", "line", "off", "plus", "writer", "this", "init", "Out", "v", "file", "conn", "page", "temp", "bin", "err", "io", "to", "s", "image", "inner", "default", "name", "up", "client", "o", "c", "as", "outs", "exec", "outer", "at", "cache", "inc", "ex", "copy", "again", "null"], "copySize": [" copyLength", "copyLength", "copyAddress", "opensize", "bytesize", "openLength", "copySIZE", "Copysize", "lesize", "CopySize", "leSize", "saveLength", "leLength", "CopyTime", " copyTime", "savesize", "copysize", "byteTime", "openSize", "byteLength", " copySIZE", "byteAddress", "leSIZE", " copyAddress", "CopyLength", " copysize", "saveAddress", "copyTime", "openSIZE", "saveSize", "byteSize"], "contentUriString": ["contentIrisstring", "contentUrisUnit", "contentUioStr", "contentUrisStr", "contentUristring", "contentUpiStr", "contentIiStr", "contentUiNumber", "contentUiniNumber", "contentIiNumber", "contentIrisStr", "contentUiniString", "contentUriUnit", "contentIrisString", "contentUriInt", "contentUioInt", "contentIriStr", "contentUiString", "contentUuriByte", "contentIrisUnit", "contentIriInt", "contentUridUnit", "contentUuriString", "contentUioString", "contentUridString", "contentUridStr", "contentUriNumber", "contentUpiString", "contentIriByte", "contentUpistring", "contentUiniStr", "contentUiByte", "contentUriByte", "contentUrisString", "contentIiByte", "contentUriStr", "contentUuriStr", "contentUiStr", "contentUiniByte", "contentIrisInt", "contentIriUnit", "contentIiString", "contentIriNumber", "contentIristring", "contentUrisstring", "contentUiostring", "contentIriString", "contentUpiInt", "contentUiUnit", "contentUuriNumber", "contentUrisInt"], "mSize": ["iName", "pLength", "cCount", "mCount", "iCount", "pSize", "cSize", "mName", "pCount", "cLength", "iSize", "iLength", "pName", "mLength", "cName"], "mContentUri": ["mContentIci", "mContentIris", "mContentOUri", "mContentUci", "mContentOUci", "mContentUrris", "mContentUrric", "mResourceUci", "mContentIri", "mResourceUri", "mResourceUris", "mResourceIris", "mContentUris", "mContentOUric", "mResourceUric", "mResourceIci", "mContentUrri", "mResourceIri", "mResourceIric", "mContentUrci", "mContentUric", "mContentOUris", "mContentIric"], "cv": ["cover", "ca", "ctx", "cm", "pb", "cs", "um", "cu", "csv", "core", "que", "content", "vm", "cf", "lc", "CV", "bc", "cr", "buf", "iv", "fc", "VC", "nc", "vc", "cp", "vv", "v", "fp", "vs", "sc", "co", "GV", "keep", "ov", "cb", "nv", "vr", "vp", "cd", "coll", "conv", "c", "iq", "cc", "rc", "uv", "auc", "ctrl", "sv", "loc", "xc", "mc", "cap", "enc", "uc", "lv", "av"], "uri": ["address", "prefix", "ui", "data", "format", "point", " ur", "gb", "string", "i", "resource", "ci", "qi", "path", "oid", " url", "http", " Uri", "cli", "URI", "iv", "username", "universal", "pi", "base", "query", "url", " URI", "environment", "uid", "location", "href", "range", "storage", "route", "ri", "iri", "uni", "api", "mi", "metadata", "attribute", "proxy", " scheme", "id"]}}
{"id1": "22801734", "id2": "5989666", "code1": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "code2": "    private String postXml(String url, String soapAction, String xml) {\n        try {\n            URLConnection conn = new URL(url).openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection hConn = (HttpURLConnection) conn;\n                hConn.setRequestMethod(\"POST\");\n            }\n            conn.setConnectTimeout(this.connectionTimeout);\n            conn.setReadTimeout(this.connectionTimeout);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/soap+xml, text/*\");\n            if (soapAction != null) {\n                conn.setRequestProperty(\"SOAPAction\", soapAction);\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(xml);\n            out.close();\n            BufferedReader resp = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder buf = new StringBuilder();\n            String str;\n            while ((str = resp.readLine()) != null) {\n                buf.append(str);\n            }\n            return buf.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"path": ["ath", "PATH", "address", "filename", "platform", "prefix", "data", "content", "format", "uri", "string", "home", "source", "resource", "alias", "host", "zip", "context", "dest", "folder", "base", "root", "p", "url", "file", "temp", "Path", "directory", "location", "image", "name", "archive", "code", "dir", "route", "pattern", "cache", "loc", "pointer"], "jarFile": ["parsePath", "zipDir", " jarDir", "parsefile", "jarPath", " jarPath", "parseFactory", "javaFile", "JarPath", "Jarfile", "JarF", "zipfile", "jarF", "javafile", "jarDir", " jarF", " jarFactory", "jarFiles", "jarFactory", "zipFile", "zipF", " jarFiles", "zipPath", "JarFiles", "zipFactory", "JarFile", "javaDir", "JarDir", "parseFile", "javaFiles", "jarfile", " jarfile"], "f": ["d", "x", "g", "cf", "i", "sf", "feed", "fr", "t", "fb", "fc", "lf", "F", "fa", "folder", "tf", "base", "p", "bf", "v", "fp", "file", "url", "fd", "full", "w", "files", "m", "io", "s", "dir", "rf", "o", "c", "b", "fi", "l", "flat", "df", "cache", "fw", "r", "fe", "framework", "h", "fm", "fs", "e"], "parent": ["target", "pa", "ctx", "prefix", "child", "parents", "port", "reference", "point", "home", "source", "i", "resource", "handler", "host", "line", "and", "folder", "base", "p", "root", "function", "Parent", "file", "url", "part", "directory", "type", "location", "offset", "image", "name", "dir", "paren", "cache", "cmp", "test", "pool", "loc", "fat"], "buf": ["queue", "bh", "rb", "data", "feat", "bb", "src", "gb", "bi", "wb", "pad", "bc", "tmp", "buff", "fb", "bed", "bu", "cv", "len", "seq", "lb", "bf", "fd", "bp", "lim", "bin", "img", "cb", "Buff", "ab", "bd", "exc", "buffer", "header", "br", "Buffer", "batch", "bytes", "b", "uf", "pool", "loc", "cap", "ob", "padding", "config", "bag", "la"], "zipinputstream": ["zInputStream", "zipInputstream", "zipintpool", "zipbitstream", "fileinputstream", "zipoutputport", "zipoutputsystem", "zipInputsample", "fileinputpath", "zipInputsteam", "zinputsteam", "zipimportpath", "zInputstream", "zipeventlength", "fileoutputport", "fileoutputStream", "fileinputport", "zipInputpool", "zipimportstream", "zinputpool", "zipInputsize", "zipoutputsize", "zipimportStream", "zipentrysteam", "zInputsteam", "zipinputpool", "fileinputsize", "archiveinputlength", "archiveInputstream", "zipoutputstream", "zinputstream", "zipbitStream", "fileInputsample", "zipinputpath", "zipoutputsample", "zipinputsteam", "archiveinputstream", "zipoutputlength", "zipInputsystem", "zipentrystream", "fileinputStream", "zipchildstream", "zipchildStream", "fileinputsteam", "zipeventstream", "zipeventStream", "zipintstream", "zipinputsize", "zInputsystem", "zipbitport", "archiveinputStream", "zInputpool", "fileInputpath", "zipInputStream", "zinputsystem", "zipintStream", "zipentryStream", "zipinputlength", "fileInputstream", "zinputStream", "zipbitsystem", "fileInputsize", "archiveInputlength", "zipInputpath", "zipinputsystem", "archiveInputStream", "zipoutputpool", "zipchildsteam", "fileinputsample", "zipinputport", "zipInputlength", "zipinputsample", "fileInputStream", "zipoutputsteam", "zipInputport", "zipimportsize", "zipoutputpath", "fileoutputsteam", "zipoutputStream", "zipimportsample", "zipinputStream"], "zipentry": ["zipdata", "Zipelement", "lexenter", "gzEntry", "zonedata", " zipenter", "fileEntry", "lexEntry", "ziparchive", "lexreader", "expEntry", "zeninner", "zfile", "fileauthor", "zenenter", " zipconnection", "gzenter", "Zipenter", "expenter", " zipreader", "Zipconnection", "gzarchive", "zipfile", "Zipauthor", "lexinner", "gzentry", "fileelement", "zipelement", " zipEntry", "expentry", "Zipreader", "zipinner", "zEntry", " zipauthor", "Zipdata", "ziprant", "zelement", "filerant", "fileentry", "Ziprant", " ziprant", " zipdata", "zipconnection", "lexentry", "zipreader", "zenentry", "filefile", "lexelement", "Zipinner", " zipelement", "zonereader", "Zipfile", "Ziparchive", "ZipEntry", " ziparchive", "zoneEntry", "zipenter", "zipauthor", "Zipentry", "zoneentry", "zentry", "expconnection", "zipEntry", "zenEntry"], "entryName": [" entryPath", " entryPart", "EntryType", "EntryName", "sectionname", "entryType", "entryPath", "fieldName", "sectionName", "sectionDesc", "sectionPart", "EntryPath", " entryname", "fieldPath", "EntryPart", "sectionType", " entryDesc", "entryPart", "entryDesc", "Entryname", "sectionPath", "fieldPart", "entryname", "EntryDesc", "fieldname", " entryType"], "n": ["number", "nu", "un", "x", "d", "nb", "left", "g", "no", "i", "nl", "t", "z", "len", "nc", "ng", "nt", "p", "v", "in", "ns", "num", "w", "u", "k", "m", "s", "nor", "na", "y", "nn", "name", "o", "b", "pos", "c", "N", "j", "en", "l", "ne", "nr", "dn", "r", "h", "e", "sn"], "fileoutputstream": ["fileoutstream", "zipOutputStream", "fileimagelength", "fileoutputcont", "fileinputStream", "fileoutputsize", "fileputsystem", "fileapplicationStream", "feedoutputsize", "feedOutputStream", "fileimagestream", "zipinputsystem", "fileoutStream", "fileinputsystem", "fileimagesystem", "fileOutputlength", "fileexitstream", "feedoutputform", "fileinputstream", "fileoutputform", "fileinputsize", "fileoutputlength", "fileputStream", "fileexitcont", "fileinputlength", "zipoutputsystem", "fileoutputsystem", "fileOutputstream", "zipoutputcont", "fileputlength", "fileOutputform", "zipoutputstream", "fileexitsystem", "zipOutputstream", "fileOutputStream", "fileoutsystem", "fileOutputsize", "feedOutputstream", "fileoutcont", "zipOutputsystem", "zipinputcont", "feedoutputstream", "zipoutputStream", "fileapplicationstream", "fileOutputsystem", "feedOutputsize", "fileputstream", "fileinputform", "feedOutputform", "fileapplicationlength", "fileinputcont", "zipOutputlength", "fileexitStream", "fileputform", "fileoutputStream", "fileimageStream", "fileputsize", "feedoutputStream", "zipoutputlength", "zipinputStream"], "newFile": ["largeLine", "oldfile", "newLine", "NewLine", "openfile", " newFolder", "openLine", "newDir", "oldFile", "oldLine", "NewFile", "baseFile", "baseFolder", "oldFolder", "basefile", "NewFolder", "largefile", "largeFolder", "openFile", "largeFile", "Newfile", " newLine", "NewDir", "newFolder", "baseDir", "newfile", " newfile", "openDir", " newDir"], "key": ["any", "x", "data", "ie", "service", "string", "section", "country", "resource", "rule", "str", "entry", "character", "option", "list", "Property", "Key", "value", "base", "nice", "lease", "page", "part", "prop", "type", "k", "connection", "char", "style", "pair", "default", "name", "code", "link", "keys", "item", "val", "field", "index", "attribute", "object", "col", "KEY", "id"], "property": ["number", "expression", "operation", "address", "filename", "prefix", "data", "integer", "ie", "service", "string", "section", "resource", "profile", "rule", "option", "character", "class", "Property", "username", "value", "prototype", "function", "p", "lock", "lease", "properties", "variable", "prop", "type", "style", "unit", "contract", "module", "language", "name", "argument", "description", "feature", "item", "position", "attribute", "field", "object", "info"], "x64": ["xx55", " x24", "bit64", "X64", "x39", " xx39", "xp24", "x58", "ext64", "bit55", " xx32", " xx24", " x39", "xx58", "bit1024", "x24", " xx64", "wx58", "ext58", "x55", "wx32", "x1024", "ext55", "X32", "X58", " x58", " x32", "ext1024", "xx1024", "wx64", "xx64", "xp39", "xp32", "bit58", "x32", "xp64"], "arch": ["ure", "ext", "archs", "install", " architecture", "version", "platform", "anc", "patch", "cat", "app", "host", "str", "Arch", "cast", "urn", "zip", "tag", "ror", "chart", "array", "error", "url", "ARCH", "ith", "prop", "library", "var", "type", "act", "boot", "hard", "arc", "spec", "char", "itect", "arm", "oct", "rep", "ar", "ress", "art", "code", "family", "build", "release", "rc", "ype", "addr", "ver", "ask", "brand", "work", "mac", "ch", "ace", "model", "auth", "dict"]}}
{"id1": "2518655", "id2": "16215393", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"fnOut": ["lsOut", " fnOUT", "fnOUT", "fpEx", "fnEx", "FNOutput", "fnOutput", " fnIn", "fpOUT", "FNEx", " fnEx", "fpOut", "FNIn", "fpOutput", "fnIn", "lsFile", "fpIn", " fnOutput", "lsOutput", "fnFile", "fpFile", "FNOut", " fnFile", "lsOUT"], "writer": ["loader", "walker", "a", "usher", "socket", "builder", "ler", "per", "nw", "output", "wa", "handler", "wire", "server", "riter", "editor", "entry", "layer", "war", "file", "winner", "fd", "reader", "wr", "Writer", "w", "temp", "er", "worker", "writers", "widget", "inner", "buffer", "director", "ws", "write", "outer", "work", "parser", "driver", "key", "r", "writ", "word", "out", "writing"], "i": ["hi", "phi", "f", "x", "ori", "ui", "ti", "uri", "ie", "bi", "ci", "gi", "qi", "strength", "di", "h", "z", "abi", "pi", "chi", "p", "v", "ai", "ix", "part", "u", "type", "k", "m", "iu", "io", "s", "ip", "ii", "o", "b", "c", "I", "ri", "fi", "multi", "j", "n", "si", "key", "li", "ini", "oi", "mi", "ji", "index", "xi", "eni", "e", "id"], "fInput": ["fileinput", "sfInput", " fOutput", "fileOutput", "sfinput", "finput", "sfSource", "sfFormat", "fFormat", "fOutput", "fileFormat", "sfOutput", " fFormat", "fSource", " fSource", "fileInput", " finput", "fileSource"], "in": ["vin", "f", "version", "gin", "data", "isin", "socket", "inn", "ln", "sin", "line", "input", "init", "inas", "reading", "kin", "scan", "min", "din", "conn", "lin", "reader", "rin", "ins", "bin", "connection", "inner", "s", "c", "b", "inside", "win", "In", "n", "cin", "inc", "IN", "nin", "ini", "ner", "login", "out", "again", "pin", "id"]}}
{"id1": "1421557", "id2": "5414088", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"infile": ["inputfp", "Infiles", "inputfilename", "infilename", " infilename", " infiles", "outfp", "inputfile", "inputfiles", "inFile", "infp", "Infile", "Infilename", "infiles", " infp", "InFile", "inputFile", "outFile", "outfilename", "outfiles"], "outfile": ["Outfile", "outputfilename", " outfolder", "infilename", " outfp", "outputfile", "OutFile", "outfp", "infolder", "newFile", " outFile", "infp", " outfilename", "outfolder", "newfolder", " outname", "outputfp", "Outname", "Outfolder", "outputfolder", "outFile", "outname", "outfilename", "newfile", "newname"], "in": ["gin", "vin", "a", "re", "data", "isin", "socket", "inn", "source", "i", "thin", "ic", "con", "sin", "is", "input", "init", "inas", "base", "min", "din", "conn", "reader", "rin", "ins", "bin", "m", "into", "err", "inner", "s", "image", "b", "inside", "as", "win", "In", "pass", "cin", "inc", "ac", "IN", "nin", "ini", "r", "login", "again", "pin", "id"], "out": ["session", "sync", "OUT", "socket", "point", "home", "no", "source", "output", "exit", "on", "off", "line", "lib", "writer", "parent", "Out", "base", "ou", "error", "file", "conn", "co", "timeout", "bin", "one", "err", "net", "io", "to", "inner", "image", "name", "up", "client", "job", "o", "obj", "outs", "exec", "write", "or", "outer", "In", "work", "cache", "inc", "post", "ex", "copy", "again"], "buffer": ["queue", "border", "address", "length", "uffer", "data", "flush", "reference", "bb", "source", "wave", "feed", "slice", "layer", "server", "limit", "iter", "buff", "buf", "fb", "input", "binary", "len", "value", "base", "raw", "transfer", "url", "reader", "type", "offset", "seed", "Buffer", "batch", "bytes", "b", "write", "result", "size", "cache", "split", "count", "padding", "null"], "read": ["lex", " write", "f", "length", "x", "sync", "allow", "next", " copy", "find", "ad", "check", "parse", "i", "Read", "connect", "send", "end", "feed", "tell", "slice", "ind", "limit", "iter", "input", "wait", "len", " Read", "reading", "load", "add", "raw", "sleep", "reader", "select", "play", "se", "fill", "seek", "io", "get", "ride", "READ", "ip", "_", " count", "write", "exec", "close", "size", "reads", "start", "work", "n", "pass", "run", "inc", "current", "count", "copy", "use", " skip", "id"], "success": ["primary", "growth", "construct", "better", "data", "content", "follow", "fast", "flash", " succ", "successful", "status", "cess", "path", "rolling", "response", "valid", "model", "rolled", "initial", "fail", " successful", "value", "modified", "failed", "ccess", "roll", "func", "respons", "winner", "error", "first", "true", "method", "danger", "comment", " succeed", "results", "warning", "open", "done", "right", " Success", "ceed", "result", "successfully", "good", "Success", "pass", "xx", "complete", "continue", "default", "again", "null", "message"]}}
{"id1": "22320592", "id2": "13891080", "code1": "    private static void loadDefaultPreferences() {\n        try {\n            URL url = ClassLoader.getSystemResource(\"OpenDarkRoom.defaults.properties\");\n            preferences.load(url.openStream());\n        } catch (FileNotFoundException e) {\n            log.error(\"Default preferences file not found\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"url": ["loader", "address", "f", "bel", "data", "ref", "rel", "jar", "uri", "user", "service", "ssl", "string", "source", "xml", "resource", "path", "feed", "server", "http", "entry", "org", "sl", "el", "URL", "base", "file", "page", "reader", "gl", "location", "element", "buffer", "image", "name", "b", "browser", "l", "stream", "Url", "config", "object", "e", "id"]}}
{"id1": "5436973", "id2": "20920051", "code1": "    public String httpToStringStupid(String url) throws IllegalStateException, IOException, HttpException, InterruptedException, URISyntaxException {\n        String pageDump = null;\n        getParams().setParameter(ClientPNames.COOKIE_POLICY, org.apache.http.client.params.CookiePolicy.BROWSER_COMPATIBILITY);\n        getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpGet httpget = new HttpGet(url);\n        httpget.getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpResponse response = execute(httpget);\n        HttpEntity entity = response.getEntity();\n        pageDump = IOUtils.toString(entity.getContent(), \"UTF-8\");\n        return pageDump;\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["address", "f", "version", "uri", "service", "request", "string", "ssl", "i", "resource", "domain", "source", "path", "feed", "host", "str", "server", "http", "sl", "URL", "html", "base", "page", "file", "ls", "www", "location", "connection", "secret", "href", "image", "name", "channel", "route", "l", "Url", "https", "api", "config", "id"], "pageDump": [" pageBumping", "pageDsump", "pageBumper", " pageBump", "pageDash", "pageDoumps", "pageDumping", "pageDoump", "pageDoumping", "pageBumping", " pageDumps", "pageDoumper", "pageLumping", "pageLumps", " pageDumm", "pageDsumper", " pageBumper", " pageBumm", "pageBumm", "pageBump", " pageDumping", "pagedash", "pageFumps", "pageDumps", "pageFash", " pageDumper", "pageLump", "pageDoumm", "pageFump", "pagedumper", "pageDumm", " pageBumps", "pageDsumps", "pagedumps", "pageDumper", "pagedump", "pageBumps", " pageBash", "pageDsumm", "pageBash", " pageDash", "pageFumper", "pageLumper"], "httpget": ["httpfind", "httpGet", "urlset", "httpGET", "phpget", "HttpGet", "httGET", "urlGet", "Httpget", "phGet", "httprequest", "phstart", "hrgot", " httpGet", "phpGET", "hrget", "phpfind", " httpGET", "urlrequest", "httpset", "hrGet", "phgot", "httpgot", "httstart", "phget", " httpgot", "httget", " httpfind", " httpset", "httpstart", " httprequest", "Httpset", "Httprequest", "hrstart", "httfind", "phpstart", "urlget", " httpstart"], "response": ["application", "data", "uri", "received", "request", "ception", "resource", "document", "success", "output", "status", "server", "http", "onse", "Response", "json", "respond", "reply", "error", "page", "full", "method", "res", "environment", "connection", "get", "collection", "relation", "result", "resp", "body", "api", "object", "e", "message"], "entity": ["data", "content", " entities", "service", " Entity", "ity", "xml", "resource", "document", "output", "ent", "person", "server", "model", "entry", "Response", "json", "query", "event", "error", "page", "translation", "environment", "security", "connection", "agent", "unit", "image", "element", "collection", "result", "instance", "component", "article", "Entity", "resp", "body", "object", "e", "message"]}}
{"id1": "19494842", "id2": "7166270", "code1": "    private void callService() {\n        try {\n            URL url = new URL(baseUrl + servicePath + attributes);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            StringBuffer buf = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                buf.append(inputLine);\n            }\n            in.close();\n            answer = buf.toString();\n        } catch (MalformedURLException e) {\n            answer = \"Malformed Url:\" + e.getMessage();\n            return;\n        } catch (IOException e) {\n            answer = \"I/O exception: \" + e.getMessage();\n            return;\n        }\n    }\n", "code2": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "label": 1, "substitutes": {"url": ["queue", "address", "f", "socket", "uri", "user", "service", "ssl", "string", "source", "i", "resource", "web", "path", "feed", "host", "server", "http", "ur", "sl", "URL", "this", "json", "blog", "base", "file", "conn", "connection", "open", "client", "b", "l", "ll", "stream", "Url", "log", "r", "e"], "in": ["gin", "f", "re", "data", "socket", "inn", "ssl", "source", "i", "line", "is", "fb", "input", "init", "kin", "din", "file", "lin", "reader", "impl", "ins", "bin", "into", "err", "inner", "s", "buffer", "image", "fac", "client", "b", "c", "win", "In", "stream", "inc", "IN", "ini", "r", "login", "h", "out", "again", "id"], "inputLine": ["myLINE", "inputBody", "inputline", " inputLINE", " inputL", "streamString", "InputLine", " inputBody", "requestString", " inputString", "outputline", "inputL", "outputLine", "streamLine", "streamBody", "requestL", "inputValue", "outputLINE", "myLine", "InputString", "streamline", "InputBody", "outputValue", " inputValue", "inputLINE", "Inputline", "requestline", "requestLine", "myValue", "myline", "inputString", "InputL", " inputline"], "buf": ["queue", "ctx", "pb", "f", "bh", "rb", "data", "nb", "bb", "gb", "cf", "string", "sb", "abs", "builder", "wb", "pad", "bc", "db", "buff", "fb", "bu", "binary", "cv", "ff", "context", "cas", "pkg", "base", "bf", "array", "fp", "cb", "ab", "exc", "buffer", "header", "br", "Buffer", "coll", "conv", "b", "result", "uf", "af", " buffer", "log", "pool", "aux", "append", "ob", "bag"], "answer": ["issue", "install", "address", "prefix", "Answer", "uri", "side", "site", "empty", "string", "feed", "response", "server", "option", "stuff", "entry", "message", "duration", "question", "username", "search", "value", "reply", "array", "say", "blank", "swers", "name", "update", "about", "order", "result", " answers", "settings", "su", "answered", "description", "cache", "ask", "knowledge", "complete", "attribute", "word", "fix", "status", "sn"]}}
{"id1": "339517", "id2": "1508161", "code1": "    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n        URL url = getClass().getResource(name);\n        InputStream in = url.openStream();\n        try {\n            return ClassFile.read(in);\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "label": 0, "substitutes": {"name": ["loader", "named", "address", "filename", "prefix", "data", "uri", "request", "string", "source", "i", "resource", "path", "str", "class", "this", "parent", "base", "file", "part", "type", "connection", "NAME", "Name", "ame", "size", "pass", "n", "definition", "key", "config", "default", "object", "info", "names", "id"], "url": ["loader", "f", "found", "user", "uri", "service", "ssl", "string", "source", "i", "resource", "feed", "rule", "host", "resources", "server", "http", "sl", "el", "URL", "class", "this", "base", "file", "page", "reader", "ls", "connection", "io", "image", "open", "b", "instance", "l", "ll", "Url", "rl", "r", "config", "id"], "in": ["gin", "f", "data", "isin", "socket", "inn", "ssl", "source", "i", "resource", "con", "token", "read", "ax", "is", "input", "inas", "init", "din", "lin", "reader", "rin", "ins", "bin", "err", "inner", "s", "image", "b", "inside", "as", "win", "In", "stream", "n", "inc", "ac", "IN", "nin", "ini", "r", "ex", "login", "out", "again", "id"]}}
{"id1": "22441244", "id2": "7087108", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"hsession": ["hess", "hmsession", "hSession", "hsSession", "hmession", "hhessions", "rsessions", "opensessions", "hssession", "hsess", "hsessions", "HSession", "hhess", "opensession", "rsSession", "hession", "hhESSION", "HSsession", "rssession", "hocket", "hhSession", "rsocket", "hhsession", "opensESSION", "hsESSION", "HSocket", "rsession", "hsocket", "opensSession", "rsESSION", "hmessions", "hmess", "hhession", "hessions", "HSSession"], "session": ["application", "mail", "Session", "port", "service", "site", "resource", "document", "host", "server", "response", "essions", "sl", "project", "class", "context", "parent", "event", "manager", "security", "connection", "state", "client", "ession", "cache", "proxy", "message"], "repositoryName": ["repoitoryAddress", "reposositoryName", "repoitoryEmail", "repositorname", "repoositoryAddress", "repoositoryName", "repoositoryPath", "repositorName", "reposienceName", "reposuationEmail", "repoitoryNAME", "repoitoryPath", "repositorAddress", "reposositoryPath", "repositorPath", "reposienceAddress", "reposositoryname", "repositoryEmail", "repoositoryNAME", "reposositoryAddress", "reposiencePath", "reposuationName", "reposiencename", "repositoryAddress", "reposositoryNAME", "repositoryname", "repoositoryname", "repoitoryname", "reposureEmail", "repoositoryEmail", "repositoryNAME", "reposositoryEmail", "reposureName", "repositoryPath", "reposurename", "reposuationname", "reposuationNAME", "reposureNAME", "repoitoryName"], "ideIdint": ["ideIdx", "ideTypeint", "ideidx", "rideidInt", "ideTypeInt", "ideIDx", "ideTimeint", "eIdint", "eConfigint", "ideFInt", "ideIdInt", "rideidx", "eConfigints", "ideConfigout", "rideIdint", "eConfigout", "ideFx", "eIdout", "ideidm", "eIdints", "ideIdout", "ideIdints", "ideTimeInt", "ideTimeints", "ideTimeout", "ideFm", "ideIdm", "ideIDint", "rideIdx", "ideFint", "ideTypeints", "ideidint", "rideidm", "ideTypeout", "ideidInt", "rideidint", "ideConfigint", "eConfigInt", "eIdInt", "rideIdm", "ideIDm", "ideConfigints", "ideIDInt", "rideIdInt", "ideConfigInt"], "to": ["target", "account", "To", "address", "mail", "prefix", "template", "uri", "from", "mobile", "site", "source", "company", "tel", "token", "sub", "contact", "with", "top", "by", "reply", "office", "location", "topic", "title", "name", "client", "about", "route", "settings", "po", "phone", "TO", "options", "message"], "cc": ["ca", "account", "cl", "cs", "address", "cf", "from", "company", "lc", "ci", "contact", "dc", "cn", "cr", "password", "ce", "nc", "sc", "card", "ct", "tc", "call", "comment", "cus", "code", "cd", "ec", "client", "c", "CC", "rc", "ac", "phone", "cca", "uc"], "bcc": [" brc", "ruc", "bq", "fcc", "abq", "abcc", "bce", " bq", "fce", "bc", "abrc", "frc", " bce", "abuc", " buc", "abce", "abc", " bc", "rce", "rc", "rcc", "fq", "brc", "buc"], "subject": ["author", "mail", "prefix", "template", "format", "content", "uri", "request", "sub", "host", "reason", "Subject", "text", "username", "html", "head", "reply", "method", "state", "comment", "header", "title", "ject", "description", "phone", "object", "message"], "body": ["wrapper", "pod", "length", "template", "data", "content", "left", "tree", "uri", "fun", "string", "source", "empty", "resource", "money", "line", "reason", "response", "password", "text", "html", "function", "base", "foot", "lock", "query", "url", "shell", "plain", "part", "bound", "secret", "connection", "comment", "style", "inner", "header", "media", "name", "code", "Body", "description", "how", "pass", "view", "summary", "config", "object", "message"], "attachments": ["Attachachment", "Attachment", "embedents", "attments", "embedment", "attachachment", "attachents", "attents", "embedachment", "Attachents", "attment", "embedments", "Attachments"], "isHtml": ["IsChail", "isXtml", "isXail", " isHail", "isVail", "isHttp", "IsChtml", "isShtml", "isHanded", "isHHTML", "IsHanded", " isHHTML", "isHail", "isShail", "isChanded", "isVHTML", "IsHttp", "isVone", "isChttp", "isChone", "isShHTML", "isChtml", "isHone", "isWhtml", "IsChttp", "isChHTML", "isWhttp", "isChail", "IsChanded", " isChtml", " isHone", "isWhanded", "isXttp", "isShone", "isXanded", "isWhail", "isVtml", "IsHail", "IsHtml", " isChail", " isChone", " isChHTML"], "charset": ["chaseting", "chansetting", "cheansetter", "cheansetting", "chaspace", "chearset", "chanspace", "chansect", "chanset", "chaset", "chasET", "chARSET", "chearspace", "cheanset", "chARSeting", "chipsET", "charsetting", "charseting", "chashesET", "chipsect", "chashesetic", "charsET", "chARSet", "cheansect", "charsetic", "charsetter", "chearsetting", "chearsect", "charspace", "cheansET", "chearsetter", "chasheset", "chipsetting", "charsets", "chARSect", "chasetter", "chashesetter", "chARSetic", "chansetter", "CharsET", "Charsets", "cheanspace", "Charseting", "chipset", "Charsetic", "Charset", "chearsET", "chARSetting", "chansET", "chashespace", "chasets", "charsect", "chashesets", "chARSets"], "headers": ["comments", "authors", "content", "lines", " emails", "ers", " recipients", "classes", "groups", "errors", "properties", "params", "files", "writers", "header", " cookies", "users", " messages", "settings", "types", "mails", "strings", "status", "names", "options", "metadata"], "priority": ["queue", "comments", "author", "prefix", "length", "template", "domain", "reason", " recipients", " title", "lang", "class", "security", "secret", "state", "level", "comment", "title", "language", "code", "quote", "mode", "phone", "theme", " severity", "status", "date"], "email": ["lex", "ext", "account", "address", "mail", "template", "data", "Email", "pm", "service", "ssl", "xml", "em", "document", "send", "contact", "output", "builder", "line", "response", "password", "server", "zip", "el", "liner", "note", "text", "username", "html", "base", "entity", "event", "url", "office", "export", "fax", "call", "letter", "element", "gmail", "generic", "name", "update", "international", "print", "result", "oe", "echo", "ilo", "external", "article", "example", "auto", "enter", "view", "online", "default", "object", "model", "create", "business", "e", "message"], "user": ["account", "author", "plugin", "data", "mobile", "string", "resource", "profile", "role", "token", "person", "member", "context", "username", "creator", "User", "er", "type", "uid", "friend", "connection", "ip", "users", "name", "info", "client", "result", "USER", "me", "consumer", "login", "use", "object", "model", "e", "id"], "identity": ["quantities", "initialifier", "instality", "idententity", "authentITY", "idities", "IDENTities", "idifier", "identicate", "IDENTifier", "authenticate", "identsity", "initialentity", "identsentity", "authorifier", "ethnicity", "initialality", "instITY", "authentic", "ethnicentity", "ethnicities", "installITY", "installity", "IDENTity", "identificate", "identic", "installic", "authentity", "authority", "identsicate", "quantentity", "authorities", "identality", "identITY", "authorificate", "installentity", "authorITY", "identsificate", "instentity", "authorentity", "IDENTentity", "initiality", "instity", "ethnicality", "ethnicifier", "authoric", "idality", "authoricate", "quantifier", "idity", "identities", "authorality", "identifier", "idITY", "authententity", "quantity", "authentificate", "idic"], "_returnPath": ["_constructNode", "_forwardLog", " _forwardLog", "_resultPath", "_backPath", "_returnpath", " _returnCol", " _backAddress", " _returnLog", "_ReturnName", "_forwardPath", "_returnAddress", "_returnCol", "_returnFrom", "_backAddress", "_backFrom", "_accessPath", "_forwardUrl", " _returnName", "_constructCol", "_relationPath", "_ReturnFrom", "_replyPtr", " _backName", "_requestUrl", "_backName", "_ReturnAddress", "_returnPtr", " _returnUrl", "_accessLog", "_requestpath", "_requestPath", "_replyPath", "_replyUrl", " _returnNode", "_replypath", "_constructPath", " _forwardUrl", "_returnName", "_backNode", "_relationCol", "_ReturnPath", "_successPtr", "_successPath", " _returnFrom", "_returnUrl", "_successUrl", " _forwardPath", " _backCol", "_returnNode", " _backFrom", "_resultFrom", "_requestPtr", " _returnAddress", "_backCol", "_relationNode", "_replyLog", " _backPath", "_accessUrl", " _backNode", "_resultAddress", "_returnLog", "_successpath"], "_from": ["copywithout", "_source", " _with", " _without", "lexsource", "nonfrom", "nonFrom", " _From", "copyfrom", "lexfor", "lexto", " _about", " _source", "placefrom", " _for", "_for", " _set", "copyto", "_From", "_about", "nonset", "_with", "copywith", "nonto", "placewith", "placewithout", "placeto", "lexfrom", "_set", "_without"], "_replyTo": ["_applyTO", "_addAddress", "_respondUrl", "_ReplyTo", " _replyUrl", "_respondPath", "_replAs", "_replyAddress", "_applyFrom", "_replyFrom", "_replyTO", "_ReplyFrom", "_addFrom", "_returnAs", "_ReplyPath", "_replyAs", " _ReplyUrl", "_returnTO", "_applyTo", "_addTo", " _replyFrom", " _ReplyTo", " _ReplyFrom", "_replTo", "_applyAddress", "_ReplyUrl", "_returnAddress", "_returnTo", "_respondTo", "_returnUrl", "_replyPath", "_returnFrom", "_replyUrl", "_ReplyAs", "_respondFrom", "_replFrom", " _replyPath", "_addTO", " _ReplyPath"], "_to": ["_home", "_about"], "_cc": [" _cca", "__cd", "__cca", "__ce", " _ce", "_cd", "__cc", "_ce", " _cd", "_cca"], "_bcc": ["_brq", "_rcc", " _abca", "_rq", "_abq", "_rca", "_bca", "_abca", "_brca", "_bce", " _abq", " _abcc", "_rce", "_bq", "_brcc", " _abce", " _bq", "_brce", "_abcc", " _bca", "_abce", " _bce"]}}
{"id1": "20735941", "id2": "14450108", "code1": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "code2": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "label": 0, "substitutes": {"home": ["bar", "house", "f", "version", "user", "domain", "resource", "path", "host", "plus", "server", "Home", "hub", "project", "this", "class", "search", "folder", "store", "parent", "base", "root", "book", "first", "foo", "library", "directory", "www", "location", "owner", "name", "HOME", "dir", "up", "build", "include", "log", "h", "default", "back", " HOME"], "fileName": ["fullName", "FilePart", "filename", "fileDir", "routeUrl", "FilePath", "fPath", "Filename", "filePath", "FileName", "resourceUrl", " fileDir", "fullname", "fullPart", "filePart", " filePath", "FileDir", "routeName", "routePath", "resourceName", "fname", " filePart", "fileUrl", "fullPath", " filename", "fName", "resourcePath", "fDir", " fileUrl"], "file": ["f", "live", "child", "it", "filename", "data", "user", "source", "resource", "flow", "money", "path", "output", "db", "line", "feed", "http", "handler", "rule", "zip", "el", "lib", "class", "File", "folder", "store", "parent", "base", "function", "value", "book", "lock", "fp", "page", "full", "plain", "part", "play", "connection", "place", "get", "image", "buffer", "change", "name", "up", "dir", "le", "or", "ile", "l", "FILE", "work", "log", "run", "local", "fe", "use", "object", "model", "be", "e"], "url": ["address", "f", "data", "rel", "socket", "uri", "bb", "service", "ssl", "string", "source", "i", "resource", "web", "path", "feed", "rule", "host", "server", "http", "ur", "org", "sl", "zip", "lib", "el", "URL", "base", "page", "conn", "impl", "ls", "www", "object", "location", "connection", "io", "jar", "image", "name", "job", "b", "lr", "l", "download", "Url", "log", "loc", "api", "r", "ob", "ource", "rl", "coll", "il"], "in": ["gin", "f", "a", "data", "isin", "socket", "inn", "source", "i", "resource", "con", "line", "plus", "is", "input", "init", "din", "conn", "reader", "lin", "ins", "bin", "into", "io", "inner", "s", "image", "up", "c", "b", "inside", "as", "l", "In", "stream", "n", "inc", "ac", "IN", "ini", "r", "login", "again", "pull"], "out": ["ext", "sync", "OUT", "serv", "data", "socket", "source", "i", "resource", "flow", "app", "output", "line", "is", "input", "writer", "this", "init", "Out", "conn", "page", "plain", "co", "bin", "object", "err", "net", "io", "inner", "to", "s", "up", "client", "o", "b", "outs", "exec", "write", "In", "inc", "IN", "ex", "copy", "again", "null"]}}
{"id1": "886783", "id2": "12171364", "code1": "    private static void doGet(LNISoapServlet lni, String itemHandle, String packager, String output, String endpoint) throws java.rmi.RemoteException, ProtocolException, IOException, FileNotFoundException {\n        String itemURI = doLookup(lni, itemHandle, null);\n        URL url = LNIClientUtils.makeDAVURL(endpoint, itemURI, packager);\n        System.err.println(\"DEBUG: GET from URL: \" + url.toString());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setDoInput(true);\n        fixBasicAuth(url, conn);\n        conn.connect();\n        int status = conn.getResponseCode();\n        if (status < 200 || status >= 300) {\n            die(status, \"HTTP error, status=\" + String.valueOf(status) + \", message=\" + conn.getResponseMessage());\n        }\n        InputStream in = conn.getInputStream();\n        OutputStream out = new FileOutputStream(output);\n        copyStream(in, out);\n        in.close();\n        out.close();\n        System.err.println(\"DEBUG: Created local file \" + output);\n        System.err.println(\"RESULT: Status=\" + String.valueOf(conn.getResponseCode()) + \" \" + conn.getResponseMessage());\n    }\n", "code2": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "label": 0, "substitutes": {"lni": ["slni", "rldi", "rlni", "lnia", "slti", "lti", " ldi", " lnia", "Lnia", "slnia", "rlNI", " lNI", " lti", "lNI", "Ldi", "Lni", "ldi", "sldi", "Lti", "rlti", "LNI"], "itemHandle": ["itemsHandler", " itemHandler", "itemsHandle", "itemsName", " itemName", "Itemhandle", "serverHand", "serverName", "ItemHandle", "itemHand", "itemsHand", "ItemHand", "serverhandle", "ItemName", "serverHandle", "itemHandler", "ItemHandler", "itemName", " itemHand", "itemhandle", " itemhandle"], "packager": ["packageager", "packsager", "packaged", "Packatter", "packsaging", "packaging", "Packaging", "packsulator", "packatter", "cookaged", "cookaging", "packsatter", "packageaging", "packulator", "paramaging", "Packagers", "Packager", "packagers", "Packaged", "packageulator", "Packulator", "paramagers", "cookager", "cookagers", "paramaged", "paramager", "packageatter"], "output": ["application", "queue", "target", "address", "debug", "filename", "version", "prefix", "data", "format", "reference", "point", "string", "source", "xml", "document", "resource", "web", "response", "Output", "model", "input", "console", "binary", "error", "file", "page", "office", "connection", "header", "buffer", "module", "image", "generated", "o", "ilo", "write", "outer", "memory", "external", "control", "log", "null", "online", "config", "object", "message"], "endpoint": ["ENDpoints", "startPoint", "endedpoint", "endedpointer", " endpo", "endpo", "endpointer", "endedPoint", "Endpointer", "endedpoints", " endocol", "ENDpoint", " endpoints", "ENDpo", "startpointer", "endocol", "ENDocol", "Endpo", "Endpoint", "endpoints", "startpoints", "endPoint", "EndPoint", "startpoint", "Endocol", "Endpoints"], "itemURI": ["itemuri", "itemID", "ItemID", "itemUrl", "baseID", "ItemUrl", "containerUrl", "baseURI", "clienturi", "ItemURL", "ItemURI", " itemID", "Itemuri", "containerURL", "clientUrl", "clientURL", " itemuri", "containeruri", "baseURL", "containerURI", "baseuri", "clientURI", " itemURL", "itemURL"], "url": ["address", "f", "user", "uri", "ssl", "string", "source", "web", "resource", "path", "host", "bc", "str", "server", "http", "entry", "ur", "org", "sl", "el", "URL", "base", "file", "page", "impl", "method", "ls", "www", "gl", "location", "connection", "io", "image", "job", "channel", "client", "c", "lr", "l", "download", "ll", "Url", "log", "loc", "li", "rl", "key", "ob", "ch", "coll", "il", "id"], "conn": ["oss", "Connection", "session", "ca", "ctx", "cm", "cl", "sync", "serv", "socket", "cf", "ssl", "connect", "ci", "con", "dc", "cn", "db", "http", "pc", "conf", "fail", "org", "adj", "cli", "init", "nc", "cp", "nt", "co", "ai", "impl", "act", "ct", "cb", "connection", "err", "net", "io", "open", "rt", "connected", "ec", "client", "conv", "c", "exec", "po", "not", "en", "rc", "Conn", "close", "n", "ann", "oa", "loc", "ch", "api", "uc", "enc", "ob", "config", "coll", "col", "auth"], "status": ["cm", "version", "prefix", "sync", "msg", "content", "received", "sex", "ssl", "source", "xml", "success", "progress", "sr", "reason", "response", "id", "str", "server", "zip", "fail", "cli", "class", "json", "score", "error", "rate", "ix", "STAT", "method", "type", "security", "err", "state", "level", "stat", "warning", "Status", "code", "stage", "pre", "result", "size", "current", "body", "api", "login", "index", "date", "grade", "message"], "in": ["gin", "a", "data", "isin", "socket", "inn", "source", "i", "con", "ic", "sin", "input", "inas", "init", "din", "lin", "reader", "rin", "ins", "bin", "into", "err", "inner", "io", "s", "up", "b", "c", "rc", "win", "In", "stream", "n", "inc", "IN", "nin", "ini", "r", "copy", "login", "again", "pin", "pull", "id"], "out": ["ext", "gin", "sync", "OUT", "serv", "data", "user", "socket", "point", "line", "off", "plus", "lib", "writer", "this", "init", "group", "Out", "min", "ou", "file", "plain", "img", "bin", "exp", "err", "connection", "net", "io", "s", "up", "client", "o", "b", "outs", "exec", "outer", "n", "inc", "log", "ch", "ex", "copy", "again"]}}
{"id1": "21125261", "id2": "6188784", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"is": ["ir", "lis", "ists", "ris", "serv", "iss", "src", "iris", "ses", "i", "es", "ais", "does", "has", "gets", "its", "opens", "ics", "isa", "os", "in", "iso", "ai", "ins", "res", "ls", "s", "bis", "IS", "mis", "ws", "ios", "as", "Is", "ps", "stream", "isi", "si", "out", "info", "fs", "id"], "byteArrayOutputStream": ["byteStringInputPath", "byteArrayByteSteam", "byteStringOutputFile", "byteArrayInputFile", "byteArrayoutputContext", "byteArrayOutputSteam", "byteArrayOutputPath", "byteStringOutputString", "byteStringInputContext", "byteStringInputStream", "byteStringInputSteam", "byteArrayByteFile", "byteStringOutputStream", "byteArrayFilePath", "byteArrayByteString", "byteStringInputString", "byteArrayoutputPath", "byteArrayInputSteam", "byteStringOutputPath", "byteArrayInputString", "byteArrayFileString", "byteArrayInputContext", "byteArrayOutputString", "byteArrayIOSteam", "byteArrayFileContext", "byteArrayFileStream", "byteArrayOutputContext", "byteArrayInputStream", "byteArrayFileFile", "byteStringOutputContext", "byteArrayIOStream", "byteArrayOutputFile", "byteStringOutputSteam", "byteArrayInputPath", "byteArrayoutputStream", "byteStringInputFile", "byteArrayFileSteam", "byteArrayIOFile", "byteArrayoutputSteam", "byteArrayIOString", "byteArrayByteStream"], "def": ["defined", "f", "d", "re", "data", "ref", "parse", "da", "entry", "di", "conf", "bus", "class", "init", "this", "dist", "DEF", "pro", "desc", "DE", "dem", "base", "sup", "file", "des", "Def", "de", "decl", "dev", "der", "spec", "obj", "dir", "md", "design", "define", "df", "definition", "frame", "config", "default", "info", "e", "id"], "se": ["lex", "sem", "ze", "ses", "ie", "ade", "parse", "site", "te", "es", "service", "sk", "isse", "sh", "ase", "pe", "see", "zip", "sl", "ce", "sche", "est", "esse", "SE", "be", "sp", "de", "ke", "ge", "pse", "s", "cle", "inse", "su", "le", "sel", "ss", "ne", "me", "sle", "si", "spe", "fe", "so", "ser", "ae", "sec", "ve", "ste", "sea", "e"], "linkId": ["blockId", " linkType", "lineID", "linkid", "loadID", "linkType", "blockType", "linkLength", "lineInfo", " linkLength", " linkid", "Linkid", "LinkType", "loadInfo", "blockLength", " linkID", "linkID", "linkInfo", "blockid", "loadId", "lineId", " linkInfo", "LinkId", "LinkLength"], "segmentId": [" segmentsId", "segmentIndex", "pementInfo", "pegmentIndex", "segmentsId", " segmentsType", "sementNumber", " segmentsPath", "segerNumber", "segmentCount", "pegmentInfo", " segmentsCount", " segmentPath", "segmentsIndex", "segmentsType", "segerId", "pementIndex", "segementId", "segementCount", "segmentNumber", "sementType", "segerIndex", "segmentPath", "segmentsPath", "segementPath", "segementType", " segmentCount", "pementNumber", " segmentType", "segmentsCount", "segmentsNumber", "sementPath", "sementIndex", "segmentInfo", "sementId", "segmentsInfo", "sementCount", "segerInfo", "pegmentNumber", "pementId", "pegmentId", "segmentType", "sementInfo"], "linkSegments": ["linkEngles", "lineSegines", "linkConnectment", "linkConnectments", "lineFragments", "linkFragments", "linkEngment", "linkEngines", "linkShipment", "linkSegensions", "linkShipments", " linkSegensions", "linkShipines", "linkConnectensions", " linkEngments", " linkSeggments", "linkEngments", "lineFragings", "lineFragment", "linkShiples", "linkSegings", "linkEngensions", " linkEngment", "lineSegles", "linkIncregments", "linkVariings", "linkFragment", "linkFragensions", "linkSeggments", "lineSegments", " linkEnggments", "lineSegment", "linkVariment", "linkIncrements", "linkVarigments", "linkIncreings", "lineFraggments", "linkFraggments", "linkFragines", "linkConnectgments", "lineSeggments", "linkFragings", "lineFragines", "linkVariments", "linkEnggments", "linkFragles", " linkSegment", "linkSegines", "lineSegings", "lineFragles", " linkEngensions", "linkSegles", "linkSegment", "linkIncrement"], "segments": ["sements", " seagements", "gements", "pegment", "pelements", "peagements", "pegements", " selements", "Seggements", "Seggments", "gelements", "geagements", "Seggment", "gegments", "selements", "segment", "pements", "segements", "pegments", "gegment", "gegements", " segment", "seagements", "Segments", " sements"], "frameProperties": ["frameprops", "frameScheproperties", "frameproeters", "frameproptions", "frameproproperties", "framePropeters", " frameproptions", " frameProproperties", "frameProproperties", "framePropperties", " frameProptions", " frameproproperties", "framePromproperties", " frameproperties", " frameprops", "framePrometers", "framePromperties", " frameProeters", " frameproeters", "framePropproperties", "frameproperties", "frameScheps", "frameProptions", "frameProps", "framePromps", "frameScheperties", "frameProeters", "framePropps", "frameScheptions", " frameProps"], "time": ["Time", "video", " times", "f", "length", "x", "live", "delay", "data", "depth", "port", "times", "cycle", "weight", "end", "money", "vel", "cost", "t", "once", "speed", "duration", "TIME", "value", "runtime", "event", "rate", "v", "ime", "file", "sleep", "play", "timeout", "type", "one", "now", "image", "name", "clock", "step", "c", "set", "timer", "ice", "size", "mode", "start", "age", "work", "tim", "count", "h", "date", "etime", "e", "id"], "vehicle": ["Vehicycle", "vehler", "bridiger", " vehicleicles", "pericycle", " vehline", " vehicleicle", "horicycle", "vehometry", "bridicle", "perline", "Vehish", "vehicular", "Vehicles", "Vehler", "devicle", "devometry", "horicle", "portometry", "vehline", "bridometry", "deviger", "pericle", " vehler", "perish", "porticle", "portiger", "vehiger", "devicular", "bridicular", "Vehicle", " vehicleler", "Vehline", "vehish", "vehicycle", " vehicleline", "horline", "horish", "vehicles", " vehicles", "porticular"]}}
{"id1": "1357662", "id2": "4798332", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"destination": ["constination", "destDirectory", "destion", "Destinator", "pathination", "destruction", "Destinations", "Destinate", "destinations", "declination", "pathinated", "Destination", "destinated", "homeinations", "sourceinator", "pathinator", "anotherDirectory", "constinate", "anotherinator", "coordinator", "coordination", "homeination", "coordruction", "homeinate", "Destinated", "sourceinated", "homeinator", "declion", "declruction", "coordion", "restion", "sourceination", " destDirectory", "anotherinated", "declinator", "constinator", "destinate", "restination", "anotherination", "restruction", "destinator", "restinator", " destinator", "sourceDirectory", "constinations", " destinated"], "srcChannel": ["syncChannel", "sourceChan", "sourcePath", "syncStream", " srcClient", "destHandler", " srcchannel", " srcStream", "sourceChannel", "rcChannel", " srcChan", "rcClient", " srcHandler", "srcStream", "sourceHandler", "destchannel", "destChan", "srcChan", "sourceClient", "rcPath", "sourcechannel", " srcPath", "srcPath", "srcchannel", "rcChan", "srcHandler", "rcchannel", "srcClient", "destStream", "syncChan"], "destChannel": ["descChan", "restChannel", "DestCommand", "destCommand", "descChannel", " destchannel", "restchannel", "targetChannel", "destHandler", " destChan", " destHandler", "DestChan", "Destchannel", "srcCommand", "descchannel", "destClient", "destchannel", "targetChan", "srcChan", "destChan", "DestHandler", " destClient", "restChan", "srcchannel", "srcHandler", "DestChannel", "descCommand", "srcClient", "targetchannel", "restClient"]}}
{"id1": "1769771", "id2": "14047629", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "label": 1, "substitutes": {"in": ["f", "data", "inn", "source", "i", "diff", "input", "base", "lock", "query", "min", "file", "url", "lin", "reader", "ins", "bin", "m", "inner", "io", "image", "name", "c", "l", "win", "In", "work", "inc", "IN", "ex", "login", "index", "again", "config", "pin", "id"], "out": ["ext", "target", "dot", "prefix", "OUT", "x", "point", "user", "string", "resource", "output", "off", "server", "writer", "Out", "base", "p", "v", "file", "conn", "plain", "w", "call", "io", "image", "default", "name", "up", "o", "c", "b", "outs", "exec", "write", "external", "n", "cache", "ex", "extra", "again"], "inChannel": ["outStream", "InClient", " inClient", "inputchannel", "inChan", "binChan", "inClient", "inputChannel", "InChan", "Inchannel", "inputStream", " inChan", "binStream", "outchannel", " inStream", "outChan", "winChannel", "insStream", "binchannel", "winchannel", "binChannel", "binClient", " inchannel", "insClient", "InStream", "inchannel", "INChannel", "insChannel", "INChan", "inputChan", "inStream", "winChan", "InChannel", "outClient", "winStream", "INStream", "INchannel", "insChan"], "outChannel": ["outStream", "OutChan", "inputchannel", "outputCh", "inChan", "inputChannel", "OutChannel", "outManager", "nChan", "outputController", "outchannel", "outChan", "outController", "outConnection", " outchannel", "inCh", " outChan", " outConnection", "inController", "inConnection", "OutConnection", " outManager", " outStream", "nStream", "inchannel", " outCh", "inputController", "outputStream", "outputChannel", "outputchannel", "inputChan", "inStream", "inManager", "outCh", "outputChan", "nChannel", "Outchannel", "nManager"]}}
{"id1": "14877116", "id2": "20100809", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"source": ["path", "subject", "host", "server", "small", "project", "input", "ce", "class", "url", "type", "unit", "self", "open", "current", "view", "config", "template", "from", "service", "slice", "context", "base", "file", "reader", "connection", "archive", "component", "stream", "local", "use", "info", "grade", "content", "reference", "string", "resource", "document", "SOURCE", "see", "this", "text", "secure", "se", "directory", "single", "slave", "table", "client", "start", "Source", "ource", "scene", "Target", "proxy", "object", "create", "site", "remote", "sin", "parent", "scope", "inner", "image", "seed", "force", "name", "channel", "route", "null"], "target": ["next", "sync", "template", "it", "content", "port", "format", "reference", "the", "other", "site", "proxy", "resource", "remote", "home", "path", "output", "token", "host", "server", "director", "t", "iter", "project", "top", "dest", "folder", "parent", "base", "root", "database", "nt", "event", "file", "mount", "type", "single", "manager", "scope", "tor", "connection", "tail", "to", "range", "force", "name", "archive", "client", "result", "or", "download", "component", "arget", "external", "current", "bolt", "view", "Source", "transform", "Target", "copy", "ource", "out", "object", "null", "master", "global"], "replace": ["delete", "cover", "sync", "prefix", "allow", "follow", "rel", "stall", "other", "compatible", "remote", "flash", "move", "apply", "align", "repl", "insert", "hide", "store", "repeat", "multiple", "share", "reply", "only", "inline", "protect", "place", "rm", "remove", "range", "change", "force", "update", "route", "write", "placed", "include", "same", "append", "complete", "copy", "use", "create", "match"], "bufferSize": ["queueSize", "bufferLength", "flushSize", "flushsize", " buffersize", "queuesize", " bufferize", " bufferLen", "queueLength", "blocksize", "buffersize", "blockLen", "bufferLen", "blockLength", " bufferLength", "Buffersize", "BufferSize", "flushize", "Bufferize", "bufferize", "queueLen", "blockSize"], "src": ["inst", "ctx", "sync", "serv", "rb", "socket", "ruby", "gb", "ssl", "sb", "resource", "flash", "RC", "sr", "bc", "sh", "server", "http", "attr", "tmp", "sl", "input", "reflect", "dest", "secure", "req", "fp", "url", "in", "sc", "reader", "cb", "gz", "href", "archive", "result", "sq", "sel", "rc", "proc", "stream", "cur", "Source", "loc", "fn", "SourceFile", "ource", "copy", "ser", "proxy", "sn"], "tarn": ["Taur", "treen", "Tarm", "tann", "ptann", " tina", " treen", "starn", "taron", "Turn", "streen", "starl", "ttron", " tern", "Tarn", "ptreen", "taur", " tarl", "torarm", "torann", "Taron", " torn", "ttaur", "tern", "Tina", " tarm", "ttarn", "ptern", "ptarn", "taarn", "tarl", "rtann", "turn", " tann", "torarn", " taur", "Tream", "ttann", "rtarn", "torn", " taron", " tream", " tron", "ptina", "Tann", " turn", "tream", "ptaur", "tron", "taann", "stern", "ptarl", "Tron", "rtarm", "Torn", "torurn", "taream", "taaron", "rtorn", "tina", "tarm"], "tardir": ["tvardir", "tardeddir", "untardown", "tardr", "tarddir", "taronown", "tardire", "tadar", "tardingr", "untardar", "untartar", "untardin", "tardin", "tadart", "tardingire", "tardore", "untarddir", "untardedr", "untardedire", "taronir", "tardar", "untartin", "tarantar", "untardart", "tartin", "tardedr", "tardingir", "untadar", "untartir", "untardire", "untardore", "tartir", "tardedir", "untadir", "tantore", "tartown", "tartr", "tantar", "tvardar", "tantir", "taronin", "tarantin", "tartar", "tardart", "untardeddir", "tardown", "tadir", "tvardore", "tartdir", "untadore", "untartown", "tvardart", "tarantown", "tarantir", "tardedire", "tantart", "untardr", "tadore", "untadart", "tardingdir", "untardedir", "untardir", "tartire", "taronar"], "n": ["number", "nu", "un", "d", "nb", "g", "ni", "i", "ln", "nw", "cn", "nl", "t", "z", "nc", "mn", "ng", "len", "p", "v", "conn", "ns", "num", "u", "don", "k", "m", "rn", "nor", "na", "nn", "o", "c", "b", "pos", "N", "j", "l", "ne", "dn", "nr", "norm", "pn", "fn", " i", "e", "sn"], "tar": ["csv", "cat", "dr", "eor", "jar", "hr", "safe", "flash", "sr", "cr", "sh", "war", "tr", "tif", "attr", "tmp", "zip", "di", "ra", "sa", "dest", "tf", "transfer", "file", "shape", "Tar", "tra", "temp", "tc", "tor", "gz", "ar", "box", "rar", "arr", "shr", "buffer", "archive", "trap", "skip", "cro", "pack", "sum", "trans", "car", "sv", "ray", "tg", "tan"], "bytes": ["bits", "data", "words", "Bytes", "lines", "tes", "es", "objects", "blocks", "resources", "ipes", "gets", "nets", "len", "bs", "items", "rows", "vs", "ls", "files", "bps", "boot", "steps", "les", "s", "elt", "bles", "cells", "ios", "pages", "frames", "ops", "b", "vals", "outs", "ones", "runs", "reads", "values", "pieces", "seconds", "cycles", "eps"], "readn": ["readl", "writeN", " readno", "readno", " readl", "writeno", "readen", " readnum", "readN", "worken", "worknum", "runl", "readlen", "writelen", " readlen", "passlen", "passno", " readen", "passn", "runN", "workN", "writeen", "workn", "Readlen", "writen", "ReadN", " readN", "readnum", "passN", "runlen", "Readn", "runn", "writenum", "Readl"]}}
{"id1": "5998352", "id2": "755203", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"reference": ["number", "primary", "target", "hello", "address", "prefix", "version", "re", "relative", "filename", "format", "ref", " Reference", "uri", "request", "string", "compatible", "resource", "document", "proxy", "remote", "path", "output", "Reference", "distance", "server", "see", "binary", "References", "REF", "database", "variable", "url", "directory", "type", "single", "location", "connection", "buffer", "pair", "collection", "name", "archive", "code", "relation", "c", "order", "description", "memory", "external", "forward", "test", "specified", "report", "rice", "ference", "length", "attribute", "index", "copy", "pointer", "sequence", "message"], "source": ["target", "ref", "g", "src", "ie", "service", "string", "i", "resource", "proxy", "output", "SOURCE", "slice", "server", "iter", "input", "writer", "ce", "text", "context", "parent", "url", "reader", "se", "temp", "connection", "io", "table", "buffer", "code", "result", "view", "Source", "driver", "fe", "r", "ource", "copy", "config", "object", "e"], "destination1": ["destinator2", "constinationOne", "destinate1", "constination2", "destention1", "Destination0", "DestinateOnce", "destinations01", "destaration0", "destributionOne", "DestinationOnce", "destentionOnce", "constinator1", "constinator01", "destarationOne", "constinator2", "destinations1", "Destension0", "constinatorOne", "destinateOnce", "DestinationOne", "destinationOne", "constination1", "destinate2", "destination01", "Destination1", "Destinate1", "destinations2", "destaration1", "destinatorOnce", "DestensionOne", "destribution1", "destribution0", "destinatorOne", "constination01", "destensionOne", "destension0", "destinationsOne", "destentionOne", "destinate01", "destinateOne", "destinator1", "DestinateOne", "destination0", "destension1", "destinator01", "destinationOnce", "Destension1"], "destination2": ["coordinate2", "destinate02", "desticationSecond", "destinationSecond", "destinating4", "destinate1", "coordinate8", "coordination8", "descination02", "descinationSecond", "destination8", "coordination2", "Destinationtwo", "destation2", "destication22", "destinate22", "destinations1", "destignment02", "destation1", "destination4", "destributionSecond", "coordinationSecond", "destication8", "destinate8", "destinations02", "Destination4", "destinate2", "descinations02", "destation4", "destignment2", "destination22", "Destinate4", "Destination1", "descination1", "Destinatetwo", "descinations1", "coordinate22", "Destinate1", "destinations2", "destinationsSecond", "destinateSecond", "destication2", "destinate4", "destribution22", "destination02", "destinatetwo", "Destinate2", "destinating1", "Destination2", "destribution8", "coordinateSecond", "destinating2", "descinationsSecond", "destignment1", "coordination22", "destribution2", "destinationtwo", "descination2", "destinatingtwo", "destignmentSecond", "destationtwo", "descinations2"], "tee": ["leee", " tef", "seee", "TEe", "etteae", "lee", "chei", " tepe", " teea", "leec", "etteee", "teae", " teee", "eee", " teae", " teec", "eeee", "lei", "see", "teea", "tepe", "TEee", " tei", "tec", "teec", "ceee", "chee", "tei", "TEea", "ettef", "chepe", "cec", "TEc", " teffe", "eeffe", "cee", "eeec", "ceea", " tec", "leffe", "teffe", "teee", "ettee", "chef", "lef", "lepe", "tef", "seae", "sef"]}}
{"id1": "7981642", "id2": "10385815", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"mail": ["address", "prefix", "msg", "Email", "user", "uri", "ul", "company", "string", "source", "xml", "proxy", "own", "contact", "host", "id", "server", "password", "label", "dial", "zip", "drive", "group", "text", "username", "folder", "html", "front", "url", "office", "file", "mount", "fax", "m", "ge", "alt", "Mail", "name", "dir", "md", "old", "download", "mails", "pass", "dn", "view", "phone", "log", "body", "gal", "login", "gmail", "model", "tel", "message"], "email": ["hello", "ext", "address", "filename", "Email", "wd", "uri", "home", "xml", "contact", "line", "id", "server", "password", "model", "label", "zip", "sl", "el", "inet", "class", "note", "text", "username", "folder", "lock", "url", "file", "office", "fax", "cdn", "letter", "alt", "ail", "Mail", "ip", "element", "name", "dir", "en", "mails", "addr", "dn", "log", "phone", "view", "login", "gmail", "info", "message"], "pwd": [" pwt", "Pwa", "hpass", "pspa", "hwt", "pppassword", " pw", "pw", "pppass", "ppwd", "pwt", "pskey", "pswt", "Pwh", "Pw", "pswd", "hkey", " pwh", "hwa", "hwd", " ppass", "pkey", "hw", "ppass", "hpa", "ppwh", " ppassword", "Ppassword", "pwa", "Pwd", "ppassword", " pwa", " pkey", "ppa", "Ppass", " ppa", "pwh"], "firstname": ["fullName", "firstemail", "firstpass", "parentemail", " firstName", "lastpass", "secondName", "fullname", " firstame", "lastName", "fullame", "parentName", " firstemail", "fullpass", "secondpass", "parentpass", "secondname", "lastemail", "parentname", "firstame", " firstpass", "lastame", "firstName"], "lastname": ["fullName", "prevday", "firstemail", " lastday", " lastnames", " lastkey", "prevName", "nextkey", "prevemail", "secondName", "fullname", "firstday", " lastemail", "prevname", "lastName", "fullame", " lastame", "secondame", " lastName", "nextname", "lastday", "secondname", "firstnames", "lastemail", "nextame", "nextName", "firstame", "lastame", "fullnames", "lastkey", "lastnames", "firstName", "secondkey"], "connection": ["application", "session", "Connection", "system", "ca", "condition", "cf", "lc", "connect", "document", "con", "graph", " Connection", "handler", "bc", "db", "server", "response", "di", "this", "nc", "context", "communication", "function", "p", "database", "creator", "conn", "sc", "directory", "manager", "m", "management", "connected", "client", "relation", "c", "cc", "component", "Conn", "ion", "driver", "config", "h", "object"], "attrs": [" attls", "atacts", "Attars", "atras", "addresses", "Attresses", "aggrs", "addars", " attresses", "addaches", "addras", "Attps", "aggns", "attacts", " attns", "attributes", "matrs", "attr", "atributes", "Attributes", " attributes", "addributes", "atrs", " attacts", "addps", " attaches", "Attras", "Attr", "attars", "aggaches", "attps", " attps", "attaches", " attars", "atresses", "addrs", "matresses", "addns", "attras", "addls", "attresses", "attns", "matr", "Attrs", "aggributes", "atps", "addr", "matacts", "Attls", "attls", " attr", "atr"], "sha": ["ga", "pa", "ca", "ema", "sm", "pg", "alpha", "ya", "alias", "da", "wa", "sh", "password", "sa", "meta", "mm", "base", "sche", "volume", "shi", "ka", "ma", "asha", "lambda", "m", "ta", "SHA", "acl", "md", "sum", "va", "ha", "eta", "mac", "HA", "si", " SHA", "h", "la", "ua"], "digest": ["mdest", "digess", "mdhash", " dighash", " digEST", "digEST", "decested", "valider", " digested", "validhash", "diger", " digess", "digests", "Digested", "signest", "Digester", "digester", "signester", "Digess", "decester", "signested", " digester", " digests", "decess", "DigEST", " diger", "mder", "decest", "digested", "validest", "mdests", "signEST", "dighash", "Digest", "validests"], "hash": ["cover", "dot", "version", "Hash", "bh", "user", "hex", "sh", "rh", "password", "json", "value", "html", "base", "block", "url", "bin", "secret", "alt", "image", "dig", "code", "hed", "her", "build", "ash", "sum", "ph", "ha", "kh", "pass", "mac", "key", "body", "h", "auth", "match", "message"], "ctx": ["cci", " cx", "ca", "cm", "cl", "cs", "Context", "cu", "cf", " c", "ck", "lc", "ci", "cn", "cr", "bc", "pc", "cv", "context", "cas", "vc", "pkg", "cp", "conn", "sc", "ct", "cb", "tc", "comp", "tx", "hw", " context", "conv", " rc", "c", "client", " conn", "cc", "sq", " cs", "rc", "jp", "ctrl", "cmp", "fw", "qa", "cca", "loc", "xc", "mc"], "newName": ["newEmail", "oldEmail", "NewName", " newEmail", "Newname", " newAddress", "NewAddress", "oldPath", "oldname", " newPath", "newPath", "NewPath", "newAddress", "oldAddress", " newname", "NewEmail", "newname"], "oldName": ["oldEmail", "OldHome", "OLDClass", " oldN", "oldPref", "OLDName", "oldClass", "oldname", " oldEmail", "OLDN", "OLDname", "OldN", " oldHome", "OldEmail", "OldName", "OldPref", " oldname", "oldHome", "Oldname", "oldN", "OLDHome", "OldClass", " oldPref", "OLDPref", " oldClass", "OLDEmail"]}}
{"id1": "3375724", "id2": "22552318", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    private synchronized void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().matches(ERR_MISSING_TABLE)) {\n                e.printStackTrace(System.out);\n                throw new IOException(\"Error on initial data store read\");\n            }\n            String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                }\n                e2.printStackTrace(new PrintWriter(System.out));\n                throw new IOException(\"Error initializing data store\");\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        e4.printStackTrace(System.out);\n                        throw new IOException(\"Unable to cleanup data store resources\");\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                    throw new IOException(\"Unable to reset data store auto commit\");\n                }\n            }\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"pArquivoTXT": ["pArquivoLTxt", "pArquivTEMP", "pArquivaTXT", "pArquivoFxt", "pArquivMxt", "pArquivoFEXT", "pArquivaFARGET", "pArquivoDxt", "pArquivoFARGET", "pArquivoLXT", "pArquivoLBT", "pArquivoTBT", "pArquivoLxt", "pArquivaTEMP", "pArquivoBEMP", "pArquivoBARGET", "pArquivTxt", "pArquivoMBT", "pArquivBEMP", "pArquivoMxt", "pArquivMEMP", "pArquivoLTARGET", "pArquivoMXT", "pArquivoTEXT", "pArquivoTxt", "pArquivoBxt", "pArquivoDXT", "pArquivBEXT", "pArquivMBT", "pArquivoBXT", "pArquivTBT", "pArquivoDEMP", "pArquivaTxt", "pArquivoLEMP", "pArquivoFBT", "pArquivTEXT", "pArquivoFXT", "pArquivoLTEMP", "pArquivaFxt", "pArquivoTARGET", "pArquivoLTXT", "pArquivBxt", "pArquivBXT", "pArquivMXT", "pArquivoFEMP", "pArquivoBEXT", "pArquivoMEMP", "pArquivoDEXT", "pArquivTXT", "pArquivaTARGET", "pArquivaFXT", "pArquivaFEMP", "pArquivoTEMP"], "pAndamento": [" pAndensiono", " pOramento", " pOramentO", " pAndmentos", " pAndemento", " pAndementol", " pAndensionos", " pOrementos", " pAndamentos", " pAndensionO", " pAndamentol", " pAndmentO", " pOramentos", " pAndensionol", " pOremento", " pAndmento", " pOrementO", " pAndmentol", " pAndamentO", " pAndementO", " pOramentol", " pOrementol", " pAndementos"], "numeroDoRegistro": ["numeroDoRegestros", "numeroDoRegpectrar", "numeroDoRegistros", "numeroDoRegestrar", "numeroDoRegastros", "numeroDoRegpectrano", "numeroDoregestrar", "numeroDoregestros", "numeroDoRegpectro", "numeroDoregestro", "numeroDoregistro", "numeroDoregestrano", "numeroDoRegastrar", "numeroDoRegastrano", "numeroDoregistrar", "numeroDoRegistrano", "numeroDoregistros", "numeroDoregistrano", "numeroDoRegistrar", "numeroDoRegestrano", "numeroDoRegpectros", "numeroDoRegestro", "numeroDoRegastro"], "in": ["session", "cl", "f", "data", "g", "inn", "i", "con", "slice", " IN", "with", "t", "is", "kin", "query", "scan", "url", "reader", "rin", "part", "ins", "bin", "m", "err", "connection", "get", "s", "c", "b", "l", "In", "n", "cin", "inc", "IN", "nin", " out", "r", "ex", "ini", "login", "h", "out", "again", "config", "ner"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialCampinos", "stmtLimpezaInicioCombination", "stmtLimpezaInicialCombination", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialdestino", "stmtLimpezaInicialCampination", "stmtLimpezaInicioDestination", "stmtLimpezaInicialDestination", "stmtLimpezaInicialDesario", "stmtLimpezaInicialDesination", "stmtLimpezaInicialCampaco", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialCombaco", "stmtLimpezaInicialdestinos", "stmtLimpezaInicioDestino", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicioDestaco", "stmtLimpezaInicialdestaco", "stmtLimpezaInicialDestario", "stmtLimpezaIniciaDestinos", "stmtLimpezaInicioCombaco", "stmtLimpezaInicialDesaco", "stmtLimpezaInicioDestario", "stmtLimpezaInicialCombino", "stmtLimpezaInicioCombario", "stmtLimpezaInicialCombario", "stmtLimpezaInicialdestario", "stmtLimpezaInicialDestinos", "stmtLimpezaInicialdestination", "stmtLimpezaInicialDesino", "stmtLimpezaInicialDestaco", "stmtLimpezaInicialCampino", "stmtLimpezaInicioCombino"], "sql": ["install", "filename", "csv", "data", "msg", "software", "rel", "socket", "ssl", "string", "sb", "sf", "db", "liquid", "nl", "http", "layout", "zip", "sl", "where", "el", "kl", "sn", "sol", "json", " SQL", "html", "sg", "query", "expr", "lua", "url", "params", "QL", "shell", "select", "SQL", "statement", "ls", "type", "err", "spec", "comment", "s", "seed", "acl", "cmd", "details", "util", "result", "setup", "sq", "ql", "description", "sv", "log", "body", "fn", "rl", "summary", "sys", "dl", "eps", "id"], "stmtDestino": ["stmtdestino", "stmCombaco", "stmDestro", "stmDestaco", "stmtCombino", "stmtDesto", "stmtDestaco", "stmtdesto", "stMTDestorno", "stmCombro", "stMTDestINO", "stMTDestino", "stMTDesto", "stmDestorno", "stmtCombro", "stmtdestorno", "stmtdestINO", "stmtCombaco", "stmtdestro", "stmtComborno", "stmtDestro", "stmtDestorno", "stmtDestINO", "stmDestino", "stmCombino", "stmComborno", "stmtdestaco"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABECASHI", "TAMANHO_DO_CABECARHOU", "TAMANHO_DO_CABOCALSCO", "TAMANHO_DO_CABOCALHOU", "TAMANHO_DO_CABECARCO", "TAMANHO_DO_CABECULHOU", "TAMANHO_DO_CABCULHO", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABECASPO", "TAMANHO_DO_CABECALSHO", "TAMANHO_DO_CABECALSHI", "TAMANHO_DO_CABECALHOU", "TAMANHO_DO_CABECALLCO", "TAMANHO_DO_CABCULHOU", "TAMANHO_DO_CABECALSCO", "TAMANHO_DO_CABECALLHOU", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABOCALSHI", "TAMANHO_DO_CABECASHO", "TAMANHO_DO_CABOCALSHOU", "TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABECALPO", "TAMANHO_DO_CABOCALHI", "TAMANHO_DO_CABECULPO", "TAMANHO_DO_CABOCALCO", "TAMANHO_DO_CABCALHOU", "TAMANHO_DO_CABCALPO", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABECALCO", "TAMANHO_DO_CABCALHO", "TAMANHO_DO_CABOCALSHO", "TAMANHO_DO_CABECALSHOU", "TAMANHO_DO_CABOCALHO", "TAMANHO_DO_CABECALLPO", "TAMANHO_DO_CABCULHI", "TAMANHO_DO_CABECASHOU", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABECARHI", "TAMANHO_DO_CABCALHI", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABCULPO"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAPEADRO", "TAMANHO_DO_RODAPEECDO", "TAMANHO_DO_RODAP_RO", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAPJRO", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPEADDo", "TAMANHO_DO_RODAP_Do", "TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAPEJdo", "TAMANHO_DO_RODAPELLDO", "TAMANHO_DO_RODAPEECDo", "TAMANHO_DO_RODAPELLdo", "TAMANHO_DO_RODAPEADdo", "TAMANHO_DO_RODAPELLRO", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAPJDO", "TAMANHO_DO_RODAPE_PO", "TAMANHO_DO_RODAPEJRO", "TAMANHO_DO_RODAP_PO", "TAMANHO_DO_RODAPJPO", "TAMANHO_DO_RODAPEECPO", "TAMANHO_DO_RODAPJDo", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAPJdo", "TAMANHO_DO_RODAPELLDo", "TAMANHO_DO_RODAPEADDO", "TAMANHO_DO_RODAPEJPO", "TAMANHO_DO_RODAPE_RO"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADANDOJ", "TAMANHO_DOS_METADADOS__", "TAMANHO_DOS_METADANDO__", "TAMANHO_DOS_METADADOTOS__", "TAMANHO_DOS_METADADOTOSJ", "TAMANHO_DOS_METADADOJ", "TAMANHO_DOS_METADADOSJ", "TAMANHO_DOS_METADANDOS_", "TAMANHO_DOS_METADANDO_", "TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADADICESJ", "TAMANHO_DOS_METADADICES__", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADADAS_", "TAMANHO_DOS_METADEDOS_", "TAMANHO_DOS_METADEDOs_", "TAMANHO_DOS_METADADO__", "TAMANHO_DOS_METADANDOSJ", "TAMANHO_DOS_METADADICES_", "TAMANHO_DOS_METADANDOS__", "TAMANHO_DOS_METADADOs_", "TAMANHO_DOS_METADADOTOS_"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_POR_RESS", "TAMANHO_MEDIO_POR_GS", "TAMANHO_MEDIO_POR_regESS", "TAMANHO_MEDIO_PORCREGS", "TAMANHO_MEDIO_PORCREGIES", "TAMANHO_MEDIO_PORPRECIS", "TAMANHO_MEDIO_POR_REGESS", "TAMANHO_MEDIO_PORPRECIES", "TAMANHO_MEDIO_POR_RIS", "TAMANHO_MEDIO_PORCGES", "TAMANHO_MEDIO_PORPREGIS", "TAMANHO_MEDIO_PORCREGES", "TAMANHO_MEDIO_POR_REGINS", "TAMANHO_MEDIO_POR_RIES", "TAMANHO_MEDIO_PORPRECESS", "TAMANHO_MEDIO_POR_regINS", "TAMANHO_MEDIO_PORCGIES", "TAMANHO_MEDIO_PORCGIS", "TAMANHO_MEDIO_POR_RECS", "TAMANHO_MEDIO_POR_REGIES", "TAMANHO_MEDIO_POR_regIES", "TAMANHO_MEDIO_POR_regIS", "TAMANHO_MEDIO_PORCREGIS", "TAMANHO_MEDIO_PORPREGINS", "TAMANHO_MEDIO_POR_GIS", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_POR_REGS", "TAMANHO_MEDIO_PORPREGESS", "TAMANHO_MEDIO_POR_RINS", "TAMANHO_MEDIO_POR_RECINS", "TAMANHO_MEDIO_PORCGS", "TAMANHO_MEDIO_POR_RECESS", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_GIES", "TAMANHO_MEDIO_PORPREGIES", "TAMANHO_MEDIO_POR_GES", "TAMANHO_MEDIO_PORPRECINS", "TAMANHO_MEDIO_POR_RECES", "TAMANHO_MEDIO_POR_RECIES"], "tamanhoDosArquivos": ["tamanhoDosArquervo", "tamanhoDosArQUivos", "tamanhoDosArquivelos", "tamanhoDosArQUivoes", "tamanhoDosArquiveo", "tamanhoDosArQUivo", "tamanhoDosArquervos", "tamanhoDosArquervoes", "tamanhoDosArQUIVos", "tamanhoDosArquivalos", "tamanhoDosArqIVols", "tamanhoDosArquivo", "tamanhoDosArquiveos", "tamanhoDosArquervlos", "tamanhoDosArqivo", "tamanhoDosArqivlos", "tamanhoDosArquIVos", "tamanhoDosArqIVo", "tamanhoDosArquivaloes", "tamanhoDosArqivols", "tamanhoDosArqivos", "tamanhoDosArQUIVoes", "tamanhoDosArquivols", "tamanhoDosArqIVos", "tamanhoDosArQUIVlos", "tamanhoDosArquiveols", "tamanhoDosArquivalo", "tamanhoDosArquervols", "tamanhoDosArQUIVo", "tamanhoDosArquivallos", "tamanhoDosArQUivlos", "tamanhoDosArquIVo", "tamanhoDosArquIVols", "tamanhoDosArquIVoes", "tamanhoDosArquivoes", "tamanhoDosArquIVlos", "tamanhoDosArqIVlos", "tamanhoDosArquivlos"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimmato", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstimante", "quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstimmante", "quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstivante", "quantidadeDeRegistrosEstipato", "quantidadeDeRegistrosEstivato", "quantidadeDeRegistrosEstivado", "quantidadeDeRegistrosEstimato", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstipante", "quantidadeDeRegistrosEstipado"], "registro": ["registulo", " registulo", "regitros", "regitron", " regestron", "regitulo", "regastulo", "regestulo", " regestulo", "regestros", " regestro", " registron", "regastros", "regastro", "regestro", "regitro", "regastron", "registron", "regestron", "registros", " registros", " regestros"], "campos": [" jamo", "campOs", " campo", " jamos", " campOS", " jamOS", "Campos", "CampOs", "CampOS", "Campo", "campo", "campOS", " jamOs", " campOs"]}}
{"id1": "13783898", "id2": "8430178", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"infile": ["inputfp", "Infiles", "inputfilename", "infilename", " infilename", " infiles", "outfp", "inputfile", "inputfiles", "inFile", "infp", "Infile", "Infilename", "infiles", " infp", "InFile", "inputFile", "outFile", "outfilename", "outfiles"], "outfile": ["Outfile", "outputfilename", " outfolder", "infilename", " outfp", "outputfile", "OutFile", "outfp", "infolder", "newFile", " outFile", "infp", " outfilename", "outfolder", "newfolder", " outname", "outputfp", "Outname", "Outfolder", "outputfolder", "outFile", "outname", "outfilename", "newfile", "newname"], "in": ["gin", "vin", "a", "re", "data", "isin", "socket", "inn", "source", "i", "thin", "ic", "con", "sin", "is", "input", "init", "inas", "base", "min", "din", "conn", "reader", "rin", "ins", "bin", "m", "into", "err", "inner", "s", "image", "b", "inside", "as", "win", "In", "pass", "cin", "inc", "ac", "IN", "nin", "ini", "r", "login", "again", "pin", "id"], "out": ["session", "sync", "OUT", "socket", "point", "home", "no", "source", "output", "exit", "on", "off", "line", "lib", "writer", "parent", "Out", "base", "ou", "error", "file", "conn", "co", "timeout", "bin", "one", "err", "net", "io", "to", "inner", "image", "name", "up", "client", "job", "o", "obj", "outs", "exec", "write", "or", "outer", "In", "work", "cache", "inc", "post", "ex", "copy", "again"], "buffer": ["queue", "border", "address", "length", "uffer", "data", "flush", "reference", "bb", "source", "wave", "feed", "slice", "layer", "server", "limit", "iter", "buff", "buf", "fb", "input", "binary", "len", "value", "base", "raw", "transfer", "url", "reader", "type", "offset", "seed", "Buffer", "batch", "bytes", "b", "write", "result", "size", "cache", "split", "count", "padding", "null"], "read": ["lex", " write", "f", "length", "x", "sync", "allow", "next", " copy", "find", "ad", "check", "parse", "i", "Read", "connect", "send", "end", "feed", "tell", "slice", "ind", "limit", "iter", "input", "wait", "len", " Read", "reading", "load", "add", "raw", "sleep", "reader", "select", "play", "se", "fill", "seek", "io", "get", "ride", "READ", "ip", "_", " count", "write", "exec", "close", "size", "reads", "start", "work", "n", "pass", "run", "inc", "current", "count", "copy", "use", " skip", "id"], "success": ["primary", "growth", "construct", "better", "data", "content", "follow", "fast", "flash", " succ", "successful", "status", "cess", "path", "rolling", "response", "valid", "model", "rolled", "initial", "fail", " successful", "value", "modified", "failed", "ccess", "roll", "func", "respons", "winner", "error", "first", "true", "method", "danger", "comment", " succeed", "results", "warning", "open", "done", "right", " Success", "ceed", "result", "successfully", "good", "Success", "pass", "xx", "complete", "continue", "default", "again", "null", "message"]}}
{"id1": "3584508", "id2": "539195", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"url": ["loader", "address", "f", "re", "bel", "data", "ref", "uri", "src", "ssl", "string", "source", "resource", "xml", "web", "remote", "feed", "path", "host", "server", "http", "sl", "URL", "base", "file", "page", "ls", "www", "connection", "image", "name", "lr", "l", "download", "stream", "Url", "loc", "r", "ource", "object", "id"], "input": ["session", "inf", "f", "address", "data", "socket", "bb", "ssl", "parse", "source", "i", "resource", "form", "xml", "ack", "feed", "progress", "upload", "plus", "http", "accept", "this", "binary", "context", "base", "load", "error", "but", "in", "file", "Input", "reader", "temp", "request", "bin", "act", "connection", "inner", "get", "image", "element", "buffer", "open", "client", "exec", "instance", "l", "stream", "qa", "cache", "current", "inc", "audio", "api", "config", "index", "out", "active", "pull"], "output": ["application", "queue", "target", "operation", "address", "data", "socket", "other", "source", "resource", "put", "flow", "web", "document", "layer", "response", "Output", "production", "writer", "binary", "console", "ou", "file", "environment", "network", "connection", "unit", "image", "buffer", "default", "write", "result", "outer", "stream", "external", "cache", "current", "log", "control", "config", "copy", "out", "object"], "b": ["bar", "pb", "f", "d", "nb", "a", "rb", "x", "bb", "sb", "bi", "i", "abs", "line", "db", "bc", "fb", "buf", "binary", "bs", "lb", "base", "p", "bf", "v", "file", "bin", "cb", "m", "k", "ab", "buffer", "mb", "br", "B", "batch", "c", "l", "n", "r", "ob", "h", "be", "e", "bit"]}}
{"id1": "6188784", "id2": "23666867", "code1": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"source": ["target", "sync", "src", "ie", "from", "site", "i", "resource", "remote", "origin", "path", "sin", "ources", "SOURCE", "slice", "iter", "input", "parent", "base", "file", "reader", "down", "ins", "connection", "inner", "unit", "name", "up", "route", "start", "stream", "cache", "Source", "ource", "copy", "use", "id"], "dest": ["delete", "target", "d", "which", "src", "orig", "home", "thin", "wb", "Dest", "exit", "dc", "comb", "tmp", " destination", "dist", "desc", "folder", "cont", "sup", "die", "destroy", "down", "temp", "img", "de", "bin", "style", "done", "later", "dir", "coord", "result", "flat", "test"], "in": ["issue", "gin", "f", "it", "plugin", "isin", "socket", "src", "ie", "inn", "i", "thin", "resource", "con", "sin", "plus", "pc", "input", "init", "parent", "base", "min", "din", "conn", "file", "url", "reader", "ins", "bin", "m", "err", "connection", "work", "inner", "into", "s", "image", "name", "up", "client", "c", "inside", "as", "win", "In", "include", "n", "cin", "inc", "ac", "IN", "nin", "ini", "r", "login", "again", "pin", "pull", "id"], "out": ["ext", "sync", "OUT", "prefix", "cat", "socket", "other", "no", "i", "output", "off", "password", "option", "lib", "writer", "this", "vert", "parent", "Out", "ou", "file", "conn", "plain", "part", "w", "down", "timeout", "bin", "one", "exp", "call", "connection", "net", "io", "err", "inner", "buffer", "name", "up", "client", "channel", "o", "obj", "outside", "exec", "outs", "not", "write", "outer", "n", "at", "pool", "our", "ex", "extra", "again", "id"], "size": ["number", "address", "any", "length", "x", "sync", "content", "flush", "time", "empty", "end", "send", "capacity", "ize", "small", "speed", "sized", "clear", "len", "scale", "add", "shape", "transfer", "export", "seek", "izes", "Size", "unit", "offset", "open", "name", "bytes", "order", "width", "ice", "en", "close", "sum", "start", "mode", "n", "max", "si", "iz", "loc", "count", "SIZE", "sec", "e", "depth"], "buf": ["ba", "ctx", "rb", "data", "feat", "src", "cf", "BU", "la", "bc", "buff", "fb", "ra", "len", "ff", "cv", "cas", "pkg", "seq", "bf", "fam", "vec", "bin", "cb", "box", "bd", "buffer", "br", "Buffer", "coll", "bytes", "b", "uf", "ha", "cmp", "uc", "bag", "map"]}}
{"id1": "8452134", "id2": "2009072", "code1": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "code2": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "label": 0, "substitutes": {"fileToCheck": [" fileToWork", "filetoWork", " fileWillCheck", " fileWillcheck", "fileWillWork", "filetoCheck", "entryToCheck", "entryTOcheck", "fileToWork", "fileTOcheck", "fileTOWork", "entryTocheck", "filetoTest", "fileWillCheck", "entryTOTest", "fileTOCheck", "fileToTest", "fileWillTest", "fileTOTest", "entryToTest", "fileTocheck", " fileWillTest", " fileWillWork", "entryTOCheck", "filetocheck", "fileWillcheck", " fileTocheck", " fileToTest"], "ftp": ["pttp", " ftpr", "ctp", " ftr", "ttP", "ntip", "lfpi", "lfp", " ftpy", "ptp", "iftpatch", "oftping", "aftcp", "fttp", "ftop", "oftpc", "fxtp", "fxsp", " ftop", "aftsp", "ptb", "oftop", "fundp", "nowpi", "ftr", "ntp", " ftcp", "etp", "etip", " ftps", "iftpy", "etr", " ftb", " ftP", "lfps", "ftpoint", "ctpoint", "ttp", "ftpi", " fttp", "ttping", "ttcp", "ttpoint", "ctP", "oftp", "fundtp", "iftp", "ufpr", "fxp", "handp", "ftpr", " ftpoint", "lfpr", "aftpi", "ftip", " ftpatch", "ttpc", "ftps", "ftP", "fpi", "ftpc", "fp", "ftpy", "etcp", "ntcp", "afpi", "ptpatch", "ifttp", "iftpo", "fxpi", " ftping", "nowcp", " ftip", "ftping", " ftpc", "ttop", "afcp", "fcp", "ftcp", "ufpi", "ftpatch", "ctcp", "ufps", "handtp", "ftpo", "fpo", "fundpi", "ftsp", "ftb", "handsp", "afp", "aftp", "afttp", "nowp", "ntr", "iftb", " ftpi", "handpi", "fundcp", " ftpo", "ufp", "fpy", "nowtp"], "found": ["defined", "sent", "f", "x", "find", "left", "received", "from", "checked", "successful", "success", "path", "built", "valid", "response", "read", "iter", "Found", "len", "search", "failed", "nt", "error", "only", "file", "first", "expected", "finding", "missing", "installed", "owned", "finder", "err", "used", "given", "ed", "done", "pos", "old", "result", "loaded", "good", "all", "flat", "ret", "val", "count", "index", "default", "active"], "reply": ["sent", "address", "next", "length", "sync", "prefix", "rr", "data", " replies", "service", "request", "from", "send", "status", "ply", "zero", "reason", "response", "server", "read", "answer", "dy", "repl", "cause", "len", "text", "respond", "lying", "base", "query", "error", "ix", "part", "bot", "err", "connection", "call", "comment", "buffer", "force", "code", "info", "echo", "result", "write", "link", "Reply", "article", "resp", "post", "continue", "index", " response", "message"]}}
{"id1": "9272325", "id2": "335223", "code1": "    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {\n        HttpURLConnection urlConn = null;\n        try {\n            String params = generatorParamString(parameters);\n            URL url = new URL(reqUrl);\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setRequestMethod(\"POST\");\n            urlConn.setConnectTimeout(5000);\n            urlConn.setReadTimeout(5000);\n            urlConn.setDoOutput(true);\n            byte[] b = params.getBytes();\n            urlConn.getOutputStream().write(b, 0, b.length);\n            urlConn.getOutputStream().flush();\n            urlConn.getOutputStream().close();\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n        return urlConn;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"reqUrl": ["reqURL", "requURL", "reqUr", "requUrl", " reqUr", "requEmail", "requestEmail", "requestUrl", "downloadLine", "downloadURL", "reqRoute", "downloadUrl", "requestRoute", "downloadEmail", " reqURL", "reqEmail", "requestURL", "requRoute", "requLine", "requestUr", " reqRoute", "reqLine", "requestLine", "requUr"], "parameters": ["mandeter", "paramams", "paramParameters", "paramsParameters", "mandations", "paramseter", "arameter", "parameter", "arameters", "mandeters", "pareters", "parations", "paramsations", "aramams", "paramations", "pareter", "mandParameters", "paramseters", "paramsams", "parParameters"], "urlConn": ["reqConn", "webCon", "bbConn", "blogCon", "httpConnect", "URLconn", "httpCon", "baseConn", "blogConnection", "reqconn", "reqComm", "buildCon", "urlConnector", "logConn", "userInfo", " urlConnect", "lComm", " urlExec", "bbConnector", "elConnect", "webSync", "blogContainer", "bbCon", "elCon", "webConnection", "elConn", "URLConn", "bbConnection", "blogConn", "httpComm", " urlConnection", "httpSync", "elConnection", "httpConn", "returnConnect", "urlSync", "baseConnect", "httpConnection", "urlInfo", "buildConnector", " urlInfo", "baseCon", "logConnect", "lconn", "httpInfo", "urlComm", "URLConnect", "returnConn", "URLClose", " urlCon", "obConn", "webConnect", "urlCon", " urlReg", "lConn", "urlReg", "baseConnection", " urlconn", "lConnection", "logConnection", "httpReg", "userConnection", "urlConnect", "httpExec", "reqConnection", " urlClose", "httpconn", " urlSync", "buildConn", "urlContainer", "urlconn", "userConn", "logCon", "httpConnector", "buildConnection", "returnCon", "webExec", "obConnection", "webConn", "obReg", "urlExec", "returnConnection", "urlClose", "urlConnection", "webClose", "webconn", "webContainer", " urlContainer", "obConnect", "userConnect"], "params": ["prefix", "data", "lines", "uri", "request", "string", "Parameters", "resources", "response", "http", "parts", "param", "tmp", "points", "URL", "par", "json", "query", "req", "database", "array", "properties", "ams", "res", "apps", "bps", "manager", "s", "_", "pages", "bytes", "settings", "l", "ps", "Param", "Url", "tags", "body", "api", "config", "Par", "names", "options", "posts", "rules"], "url": ["Config", "f", "bel", "data", " URL", "uri", "ssl", "string", "lc", "i", "web", "source", "resource", "path", "host", "layer", "server", "http", "ur", "sl", "URL", "blog", "base", "orb", "page", "conn", "ls", "www", "gl", "connection", "obj", "job", "c", "lr", "l", "ll", "Url", "n", "log", "loc", "api", "r", "ob", "rl", "config"], "b": ["bar", "ba", "pb", "f", "bl", "a", "emb", "rb", "data", "nb", "bb", "gb", "sb", "i", "wb", "db", "buff", "buf", "fb", "binary", "bs", "base", "lb", "bf", "v", "bin", "boot", "ab", "bd", "buffer", "mb", "br", "B", "obj", "c", "bytes", "l", "body", "r", "ob", "null", "e"]}}
{"id1": "18504192", "id2": "3958807", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 1, "substitutes": {"in": ["d", "data", "src", "inn", "i", "diff", "input", "parent", "base", "min", "file", "url", "reader", "part", "ins", "bin", "m", "inner", "io", "image", "buffer", "name", "c", "old", "b", "or", "In", "at", "inc", "ac", "IN", "ini", "copy", "index", "again", "info", "login", "id"], "out": ["target", "prefix", "OUT", "data", "point", "string", "output", "line", "password", "writer", "dest", "again", "Out", "base", "p", "file", "conn", "part", "w", "temp", "err", "connection", "call", "io", "name", "obj", "client", "o", "c", "b", "outs", "exec", "external", "n", "cache", "inc", "ex", "copy", "object"], "source": ["target", "sync", "core", "src", "ie", "service", "ssl", "from", "i", "origin", "sin", "ources", "SOURCE", "slice", "server", "iter", "sl", "project", "input", "writer", "dest", "parent", "secure", "se", "reader", "scope", "connection", "slave", "get", "unit", "self", "storage", "channel", "clone", "client", "settings", "component", "size", "stream", "start", "view", "Source", "ource", "copy", "use", "proxy", "null"], "destination": ["dependination", "contining", "Destinator", "Destinations", " destining", " destinations", "testinations", "destinations", "declination", "destinated", "Destination", "testinated", "dependinated", "Destinated", "declification", "testination", "dependinator", "declinator", "Destining", "continator", "dependification", "Destification", "declinated", "contination", "destification", "testinator", "destinator", " destinator", "destining", "continated", " destinated"]}}
{"id1": "3731077", "id2": "7425022", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"from": ["ca", "address", "f", "d", "a", "data", "left", "user", "src", "source", "form", "resource", "remote", "origin", "path", "with", " form", "without", "by", "ce", "this", "base", "front", "add", "file", "url", "part", "se", "of", "From", "io", "range", "name", "original", "client", "o", "c", "about", "before", "as", "old", "or", "start", "at", "config", "back", "id"], "to": ["target", "To", "f", "point", "socket", "site", "source", "eto", "output", "token", "with", "t", "two", "top", "by", "this", "dest", "again", "parent", "base", "p", "database", "root", "too", "file", "office", "os", "temp", "type", "one", "into", "of", "location", "io", "storage", "name", "client", "about", "o", "b", "until", "as", "toc", "po", "or", "size", "at", "auto", "null", "api", "so", "copy", "object", "TO"], "parentDir": ["parentdir", " parentDirectory", " parentFile", "currentDir", "rootDir", "currentFile", "currentFolder", "rootFile", "currentdir", "outFolder", "ParentDirectory", "ParentFile", " parentdir", "ParentDir", "parentDirectory", "outDir", "rootDirectory", "rootFolder", "parentFile", " parentFolder", "parentFolder", "outFile", "Parentdir", "ParentFolder", "outDirectory"], "in": ["vin", "gin", "sync", "it", "plugin", "isin", "ie", "inn", "source", "i", "form", "con", "on", "diff", "with", "pc", "input", "arin", "fc", "init", "rec", "kin", "min", "din", "conn", "lin", "url", "reader", "part", "rin", "ins", "bin", "m", "err", "inner", "io", "image", "o", "pre", "inside", "exec", "trial", "or", "l", "win", "rc", "In", "work", "cin", "ac", "inc", "IN", "nin", "ini", "r", "login", "again", "pin", "id"], "out": ["gin", "sync", "OUT", "plugin", "user", "other", "app", "output", "on", "off", "ot", "option", "org", "input", "writer", "init", "ico", "vert", "Out", "p", "can", "op", "ou", "conn", "cy", "co", "w", "bin", "call", "net", "io", "inner", "about", "channel", "o", "c", "client", "outs", "exec", "or", "outer", "win", "at", "auto", "ac", "inc", "cin", "ex", "again"], "ic": ["nic", "cl", "cs", "anc", "icc", "cu", "sync", "lc", "i", "ci", "dc", "bc", "auto", "pc", "voc", "input", "fc", "vc", "ico", "ik", "ics", "op", "conn", "pic", "co", "ai", "ix", "ct", "io", "ig", "iac", "cus", "ec", "o", "c", "cc", "or", "irc", "rc", "IC", "cin", "ac", "inc", "loc", "acs", "xc", "mc", "uc", "enc", "ex", "aic"], "oc": ["nic", "ca", "ocon", "anc", "circ", "oci", "ack", "i", "ci", "dc", "bc", "aco", "mic", "alloc", "pc", "org", "voc", "OC", "fc", "og", "vc", "oco", "cy", "can", "op", "co", "sc", "oca", "roc", "io", "soc", "cus", "ec", "o", "c", "cc", "toc", "or", "wic", "acs", "ac", "inc", "loc", "cur", "xc", "mc", "uc", "AC", "ob", "enc", "aic", "ocol"]}}
{"id1": "14303294", "id2": "16556717", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"passwordHash": ["passwordPass", " PasswordHash", "privatehash", "privateSalt", "privatePassword", "Passwordhash", " PasswordCode", "PasswordCode", "passwordhash", " passwordSalt", " PasswordPass", " passwordPassword", "PasswordHash", " passwordCode", "passwordPassword", "passwordSalt", "PasswordPass", "privateHash", " passwordPass", "passwordCode", "PasswordPassword", " passwordhash"], "PasswordSalt": [" PasswordSecret", "passwordSecret", "Password256", " PasswordHash", " Password256", "PASSSalt", " passwordSalt", "PasswordSecret", " passwordPassword", "PasswordHash", "PASSHash", "passwordPassword", "passwordSalt", " passwordSecret", "password256", "PASS256", "PASSPassword", " PasswordPassword", "PasswordPassword"], "hash": ["number", "address", "Hash", "data", "content", "row", "user", "check", "string", "hex", "sh", "response", "sha", "password", "search", "value", "html", "base", "block", "array", "error", "url", "dig", "buffer", "change", "image", "code", "update", "her", "result", "build", "ash", "sum", "size", "ha", "kh", "cache", "mac", "log", "pool", "work", "key", "crypt", "copy", "h", "auth", "message"], "digest": ["mdest", "generested", "hashester", "Digher", "digusher", " digger", "Digusher", " digall", "Digener", " digested", "digger", "diger", "hashener", "Digested", "signest", "generest", "signger", "Digester", "signer", "digester", "signester", "generester", " digester", "mdested", "mdusher", "signher", " diger", "integester", "digested", "integall", "digher", "digall", "Digger", " digusher", "integest", "integested", " digher", "Diger", " digener", "hasher", "hashest", "generall", "digener", "Digest", "mdester"]}}
{"id1": "7945594", "id2": "12039034", "code1": "    public static void fileDownload(String fAddress, String destinationDir) {\n        int slashIndex = fAddress.lastIndexOf('/');\n        int periodIndex = fAddress.lastIndexOf('.');\n        String fileName = fAddress.substring(slashIndex + 1);\n        URL url;\n        try {\n            url = new URL(fAddress);\n            URLConnection uc = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n            File file = new File(destinationDir + \"/download.pdf\");\n            FileOutputStream fos = new FileOutputStream(file);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos));\n            int inputLine;\n            while ((inputLine = in.read()) != -1) out.write(inputLine);\n            in.close();\n        } catch (Exception ex) {\n            Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n", "code2": "    public static ArrayList<RoleName> importRoles(String urlString) {\n        ArrayList<RoleName> results = new ArrayList<RoleName>();\n        try {\n            URL url = new URL(urlString);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            StringBuffer buff = new StringBuffer();\n            String line;\n            while ((line = in.readLine()) != null) {\n                buff.append(line);\n                if (line.equals(\"</RoleName>\")) {\n                    RoleName name = ProfileParser.parseRoleName(buff.toString());\n                    results.add(name);\n                    buff = new StringBuffer();\n                } else {\n                    buff.append(NL);\n                }\n            }\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        } catch (ParsingException e) {\n        }\n        return results;\n    }\n", "label": 1, "substitutes": {"fAddress": ["sfaddress", " faddress", "sfAdd", "rfLocation", "bLocation", " fEmail", "bPath", "sfOrder", "sfPath", "fPath", "urlOrder", "sfMessage", "bAdd", "fingAddress", "fileAddress", "fileLocation", "fAdd", "rfMessage", "fMessage", "FAdd", "fOrder", "fingEmail", "sfLocation", "fingAdd", "FAddress", "faddr", "baddress", "bEmail", "fingaddr", "faddress", " fOrder", "fLocation", "fileAdd", " fLocation", " fMessage", "urlAddress", "urladdress", "urlAdd", "sfAddress", " fPath", "FLocation", " faddr", "baddr", "rfAddress", "fEmail", "bAddress", "rfaddress", " fAdd"], "destinationDir": ["destinationDur", "destinatedDur", "destippingDir", "destippingArea", "declinationDir", "destinatedDar", "DestributionDir", "DestinationDir", "destinationDIR", "destributionArea", "destativeArea", "destributionDur", "destativeDirectory", "declinatedDur", "destinePath", "declinationDur", "destineDur", "declinatedPath", "destinationDirectory", "DestinationDIR", "destributionDirectory", "destativeDIR", "destinatedDir", "declinatedDir", "destinatedPath", "DestributionDirectory", "destributionPath", "DestributionArea", "DestributionDIR", "destippingDirectory", "destinationArea", "destributionDar", "DestinationArea", "destinationPath", "destributionDir", "destippingDIR", "declinationPath", "DestinationDirectory", "destativeDir", "destinationDar", "declinationDar", "destineDar", "declinatedDar", "destributionDIR", "destineDir"], "slashIndex": ["slashedindex", "slushIndex", "slashCount", "sllashCount", "sllashIndex", "SlashCount", "Slashedindex", "SlashIndex", "slushindex", "slargeindex", "SlashedLength", "slargeCount", "SlashedCount", "slashindex", "slargeLength", "slargeIndex", "sllashLength", "slashedLength", "sllashindex", "SlashedIndex", "SlashLength", "Slashindex", "slashLength", "slushLength", "slashedCount", "slashedIndex"], "periodIndex": ["dollarStart", " periodOffset", "moneyIndex", "dollarindex", " periodindex", "dollarOffset", "dollarIndex", "moneyStart", "periodindex", " periodStart", "moneyOffset", "moneyindex", "periodOffset", "periodStart"], "fileName": ["filePath", "fileAddress", "FileName", " filePath", "filename", " filename", "fName", " fileAddress", "FileAddress", "FilePath", "fPath", "fname", "Filename"], "url": ["plug", "f", "re", "bel", "bug", "rel", "socket", "uri", "user", "service", "ssl", "string", "resource", "web", "feed", "path", "str", "server", "http", "ur", "org", "sl", "URL", "blog", "base", "ou", "page", "conn", "u", "uu", "www", "connection", "image", "open", "up", "channel", "c", "l", "link", "ll", "download", "Url", "log", "oc", "loc", "li", "api", "rl", "ch", "config", "ob", "fl", "proxy", "ul"], "uc": ["cci", "um", "anc", "cu", "union", "UC", "lc", "ci", "con", "uci", "bc", "hub", "http", "pc", "ucc", "fc", "nc", "usc", "ou", "conn", "sc", "u", "uu", "com", "tc", "connection", "exc", "soc", "cus", "ec", "c", "cc", "rc", "auc", "stream", "ac", "cur", "unc", "oc", "mc", "ul"], "in": ["gin", "f", "it", "data", "socket", "inn", "source", "i", "con", "is", "cli", "input", "init", "this", "din", "conn", "reader", "lin", "ins", "bin", "into", "err", "io", "inner", "s", "image", "up", "c", "b", "inside", "rc", "In", "stream", "n", "cin", "inc", "ac", "IN", "nin", "ini", "r", "login", "again"], "file": ["f", "filename", "data", "socket", "source", "resource", "per", "path", "output", "line", "rule", "zip", "this", "class", "File", "folder", "book", "parent", "base", "fp", "page", "full", "files", "connection", "place", "to", "letter", "io", "name", "up", "dir", "o", "b", "l", "ile", "FILE", "log", "fe", "e"], "fos": ["Fos", "sfo", "Fops", "fOS", "sfis", "sfos", "fileops", " fo", "Fob", "Fis", " fOs", "fOs", "fileos", "fops", "fis", "fo", " fob", "fileob", "FOs", "Fo", " fis", " fops", "sfOS", "fob", "fileOs", " fOS", "FOS"], "out": ["f", "sync", "OUT", "data", "flush", "string", "output", "line", "writer", "init", "Out", "block", "ou", "plain", "w", "down", "bin", "err", "net", "io", "inner", "s", "to", "up", "update", "o", "b", "write", "outs", "exec", "outer", "work", "log", "inc", "copy", "again"], "inputLine": ["outputBlock", "errorLine", "inputRow", "inputline", " inputLINE", "InputEl", "inputEl", " inputL", "InputLine", " inputChar", " inputBlock", "inputChar", "outputRow", "outputEl", "outputline", "inputL", "errorRow", "outputLine", "outputChar", "outputL", "outputLINE", "InputChar", "InputBlock", "errorLINE", "inputBlock", " inputRow", "inputLINE", "errorL", "Inputline", " inputEl", "InputL", " inputline"]}}
{"id1": "13122204", "id2": "19322941", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"filename": ["nil", "uri", "src", "string", "source", "Filename", "path", "slice", "kl", "username", "folder", "json", "database", "txt", "utf", "fp", "url", "file", "fil", "fits", "fd", "directory", "files", "location", "jet", "module", "title", "name", "archive", "download", "FILE", "loc", "fn", "SourceFile", "il", "metadata"], "tempdir": ["zipDir", "zipdir", "Tempdirectory", " tempfolder", "tmppath", "tmpfile", " tempDIR", "testDir", "temdirectory", "testfolder", "tmpDIR", "tempfolder", "temdir", "zipfile", "tempdirectory", "tmpDir", "tmpfolder", "Temppath", "tmpdirectory", " temppath", "temfolder", "temDir", "tempDir", " tempfile", "Tempfolder", "Tempdir", " tempdirectory", "testdir", "tempfile", "temppath", "testdirectory", " tempDir", "tempDIR", "tmpdir", "zipDIR"], "dest": ["delete", "session", "target", "rest", " Dest", "st", "ui", "src", "git", "home", "source", "usr", "wb", "Dest", "output", "dc", "exit", "const", "slice", "handler", "di", "tmp", "zip", "iter", "comb", "writer", "dist", "desc", "store", "folder", "cont", "txt", "sup", "transfer", "die", "export", "walk", "temp", "opt", "de", "img", "cdn", "gen", "inner", "default", "done", "later", "std", "dir", "result", "proc", "trans", "flat", "outer", "test", "loc", "transform", "out", "null"], "fis": ["Fos", "ffos", "bos", "ffi", "ffus", "ffis", "fisi", "bi", "flais", "fus", "bus", "Fis", "flos", "bisi", "vus", "Fisi", "vos", "flis", "fais", "bais", "bis", "flisi", "fi", "Fais", "vi", "vis"], "BUFFER": ["TAFIN", " BUPLE", "TAFFER", " BUPER", "BUFIN", "CUPER", "CUFIN", "FAVER", " BUFIX", "CUVER", "UMVER", "MAFIX", "MAFFER", " BUVER", "BUFF", "BUFIX", "FAFIN", "BUVER", " BUFF", "FAFFER", "BUPLE", "UMFFER", "UMFIN", "MAPLE", "FAPER", "TAPER", "MAPER", "BUPER", "TAPLE", " BUFIN", "UMFF", "TAVER", "TAFIX", "CUFF", "CUFFER"], "zis": [" zi", "jis", "zori", "xhas", "zIS", " zIS", "jiss", "ziss", "Zisa", "Zais", "fes", "zipiss", "ezas", "zs", "zie", "ezori", " zas", "xis", "Zis", " zori", " zais", "zas", "zi", "zhas", "Zes", "xiss", " zes", "fais", " zs", "zisa", "fisa", "ezhas", "zipIS", "jie", "xs", "xori", " zhas", "ezis", "xIS", " zisa", "zipis", " ziss", "ji", "zais", "xas", "zes", "xi", "xie", "zips", " zie"], "entry": ["ga", "next", "ry", "cat", "je", "ie", " Entry", "lc", "source", "feed", "ent", "line", "valid", "server", "fr", "pe", "zip", "porter", "iterator", "folder", "nt", "file", "se", "reader", "part", "ident", "de", "exp", "inter", "ge", "connection", "inner", "spec", "element", "image", "archive", "ries", "obj", "her", "result", "match", "or", "rc", " reader", "stream", "inc", "enter", "si", "li", "ace", "cel", "record", "Entry", "info", "la", "e", "id"], "count": ["number", "f", "length", "allow", "next", "child", "core", "content", "cond", "counter", "time", "last", "weight", "end", "feed", "ind", "read", "limit", "iter", "list", "writer", "len", "parent", "base", "lock", "add", "file", "in", "part", "num", "type", "offset", "Count", "code", "name", "c", "b", "write", "skip", "size", "sum", "start", "max", "cache", "current", "log", "key", "val", "index", "use", "e", "id"], "data": ["number", "extra", "length", "d", "content", "format", "alpha", "feed", "zero", "pad", "str", "id", "read", "slice", "shift", "zip", "buf", "input", "binary", "len", "value", "base", "p", "block", "load", "reader", "buffer", "image", "name", "batch", "bytes", "write", "result", "pack", "size", "start", "DATA", "body", "index", "info", "la", "dat", "message"], "fos": ["Fos", "ffoos", "Fops", "Foos", "afops", "ffos", "bos", "fosi", "bios", "infosi", "infoos", "bops", "afis", "foos", "infops", "afios", "ffosi", " fios", "fios", "afos", "fops", "bis", "Fosi", "infos", "ffops", " fops"]}}
{"id1": "1362", "id2": "22752444", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 0, "substitutes": {"a": ["ga", "tta", "an", "A", "ba", "ans", "f", "any", "d", "address", "aj", "data", "ama", "ad", "alpha", "au", "abs", "empty", "ack", "access", "e", "list", "another", "aw", "sa", "am", "p", "array", "sup", "ma", "u", "img", "apps", "m", "ab", "s", "na", "aaa", "o", "b", "c", "as", "result", "all", "aa", "l", "ata", "va", "something", "work", "at", "oa", "auto", "ac", "aux", "area", "index", "active", "la", "ae"], "swapped": ["rewoped", "swap", "waped", " swapping", "rewaped", "rewapping", "rewap", "swapping", "Swapped", "wap", " swap", "floped", "swaped", "flapped", " swaped", "Swaped", "swoped", "wapping", "waps", "swaps", "Swapping", "wapped", "rewapped", "Swap", "Swoped", "flapping", "rewaps", "flap", " swaps"], "i": ["hi", "adi", "f", "next", "x", "d", "ui", "ori", "ami", "it", "ti", "uri", "ie", "ni", "bi", "ci", "gi", "qi", "ind", "di", "h", "ki", "iv", "init", "pi", "p", "mini", "v", "sup", "in", "ai", "ix", "u", "m", "k", "iu", "io", "ip", "ii", "y", "module", "info", "b", "ri", "I", "anti", "multi", "fi", "j", "l", "start", "uni", "si", "key", "li", "api", "mi", "oi", "ini", "index", "xi", "eni", "e", "id"], "tmp": ["kk", " ff", "f", "opp", "x", "nb", "st", "bb", "emp", "ie", "alpha", "angle", "pad", "stuff", "t", "pp", "yy", "tv", "dest", "qq", "p", "txt", "front", "v", "sup", "foo", "part", "temp", "vt", "m", "tc", "xxx", "obj", "b", "pre", "prev", "j", "mmm", "amp", "addr", "cmp", "test", "mp", "tt", "area", "append"]}}
{"id1": "1362", "id2": "1357662", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 0, "substitutes": {"a": ["ga", "tta", "an", "A", "ba", "ans", "f", "any", "d", "address", "aj", "data", "ama", "ad", "alpha", "au", "abs", "empty", "ack", "access", "e", "list", "another", "aw", "sa", "am", "p", "array", "sup", "ma", "u", "img", "apps", "m", "ab", "s", "na", "aaa", "o", "b", "c", "as", "result", "all", "aa", "l", "ata", "va", "something", "work", "at", "oa", "auto", "ac", "aux", "area", "index", "active", "la", "ae"], "swapped": ["rewoped", "swap", "waped", " swapping", "rewaped", "rewapping", "rewap", "swapping", "Swapped", "wap", " swap", "floped", "swaped", "flapped", " swaped", "Swaped", "swoped", "wapping", "waps", "swaps", "Swapping", "wapped", "rewapped", "Swap", "Swoped", "flapping", "rewaps", "flap", " swaps"], "i": ["hi", "adi", "f", "next", "x", "d", "ui", "ori", "ami", "it", "ti", "uri", "ie", "ni", "bi", "ci", "gi", "qi", "ind", "di", "h", "ki", "iv", "init", "pi", "p", "mini", "v", "sup", "in", "ai", "ix", "u", "m", "k", "iu", "io", "ip", "ii", "y", "module", "info", "b", "ri", "I", "anti", "multi", "fi", "j", "l", "start", "uni", "si", "key", "li", "api", "mi", "oi", "ini", "index", "xi", "eni", "e", "id"], "tmp": ["kk", " ff", "f", "opp", "x", "nb", "st", "bb", "emp", "ie", "alpha", "angle", "pad", "stuff", "t", "pp", "yy", "tv", "dest", "qq", "p", "txt", "front", "v", "sup", "foo", "part", "temp", "vt", "m", "tc", "xxx", "obj", "b", "pre", "prev", "j", "mmm", "amp", "addr", "cmp", "test", "mp", "tt", "area", "append"]}}
{"id1": "18631594", "id2": "5723876", "code1": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"input": ["address", "prefix", "data", "format", "request", "string", "source", "i", "form", "xml", "ssl", "alpha", "output", "empty", "plus", "str", "password", "accept", "list", "this", "text", "value", "base", "raw", "array", "file", "url", "in", "Input", "reader", "temp", "addin", "s", "buffer", "image", "inside", "pattern", "IN", "out", "null"], "msgDigest": ["cmdDigse", "encDigEST", "msgDigse", "MsgDer", "msgHashender", "msgdigest", "msgdigect", "MsgDigester", "cmddigest", "msgdigender", "cmdDigect", "cmddigested", "msgdigse", "mddigest", "msgDer", "MsgDler", "msgModse", "msgDigester", "msgSandest", "msgSandler", "msgDester", "encDigester", "msgHashester", "msgHashest", "msgModect", "msgModested", "cmddigse", "cmdDigested", "msgDesigner", "msgdigested", "encDigender", "msgSignler", "msgSignest", "msgCommse", "msgCommect", "msgCommest", "msgDiger", "msgDender", "encdigester", "msgDigested", "msgSignester", "msgDigect", "mdDigester", "MsgDest", "mdDiger", "msgDigender", "MsgDigest", "MsgDiger", "msgSigner", "msgDigEST", "msgCommested", "msgDesignest", "msgSandester", "msgdigester", "msgDigler", "msgDest", "msgModest", "encdigest", "mdDigest", "cmddigect", "msgdigEST", "cmdDigest", "MsgDester", "mddigester", "encDigest", "mddiger", "msgHashEST", "msgdiger", "encdigEST", "encdigender", "msgDler", "msgSander", "msgDEST", "msgDesignester", "MsgDigler"], "rawData": [" rawDATA", "RawText", " rawPart", " rawText", "RawDATA", " rawBytes", "RawPart", "channelByte", "RAWDATA", "RawData", "channelData", "RAWData", "rawDATA", "rawByte", "rawPart", " rawByte", "rawBytes", "RawBytes", "RAWText", "RawByte", "channelBytes", "rawText", "RAWPart"], "encoded": ["ecoded", "encrypted", "decrypted", "encoder", "enoding", "Encrypted", "enrypted", "decoding", "Encoding", "enccoded", "decoder", "enoder", "ecoding", "Encoded", "enoded", "decoded", "eccoded", "Encoder", "ecrypted", "Enccoded", "encoding"], "retValue": ["RetResult", " retVal", " retText", "RetString", "retValues", "RetValues", "retVal", " retString", "returnText", "returnValue", " retResult", "retString", "RetValue", "returnValues", "RetText", "returnResult", "retResult", "returnString", " retValues", "returnVal", "RetVal", "retText"]}}
{"id1": "12306305", "id2": "7908169", "code1": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"srcFile": [" srcFiles", " srcTime", "sslFile", "sourcePath", "restF", "destPath", "rcPage", "destFiles", "destPage", "destTime", " srcPage", "srcTime", "srcFiles", " srcF", "srcfile", "srcF", " srcName", "rcFile", "restFile", "restfile", "rcTime", "sslF", "sourceFiles", "sourceDir", "srcDir", " srcfile", "sslName", "rcPath", "sslfile", "restName", " srcPath", "srcPath", "rcDir", "srcPage", "sourceFile", "rcfile", "destDir", "sourcefile", " srcDir", "rcFiles", "srcName"], "destFile": ["srcFolder", "DestSourceFile", "distLine", "destDirectory", "targetName", " destSourceFile", "DestDir", " destinationFile", " destDir", "DestPage", "destFiles", "destName", "restFiles", "sourceFolder", "restSourceFile", "destPage", "distFile", "srcLine", "DestFolder", "destTime", "srcTime", "DestFilename", "srcFiles", "restFilename", " destTime", " destFilename", "restDir", " destName", "sourcePage", "destLine", "restFile", "srcPlace", "restfile", "destPlace", " destinationFiles", "DestFile", " destPage", "sourceDir", "srcDir", "DestName", "destSourceFile", "targetFile", "DestFiles", "targetFiles", " destinationPage", "destFolder", " destDirectory", "destFilename", "targetPage", "targetDir", " destinationFilename", "destfile", "targetDirectory", " destfile", "restFolder", "sourceFile", "Destfile", "destDir", " destFolder", "sourceFilename", "distTime", " destPlace", "sourceDirectory", "distPlace", " destLine", " destFiles", "srcName"], "preserveFileDate": ["preservedTimeDate", "preservePageTime", "preserveDirectoryDate", "preserveTimedate", "preserveTimeDate", "preservedFiledate", "preservedTimeDay", "preservedFileTime", "preserveFiledate", "preservedTimeTime", "preservingFileFormat", "preserveFileTime", "preserveTimeFormat", "preserveTimeTime", "preserveFilesDay", "preserveDateDate", "preserveTimeDay", "preservingTimeFormat", "preserveDateFormat", "preservingTimedate", "preservePageDay", "preserveDirectoryFormat", "preserveFileDay", "preservingTimeDate", "preservingFiledate", "preserveFileFormat", "preservingFileDate", "preserveDatedate", "preserveFilesdate", "preservedFileDate", "preserveFilesTime", "preserveFilesDate", "preservePageDate", "preserveDirectorydate", "preservedFileDay", "preservePagedate", "preservedTimedate"], "input": ["target", "address", "internal", "child", "data", "socket", "ssl", "request", "source", "i", "form", "upload", "feed", "Output", "entry", "binary", "context", "parent", "event", "error", "conn", "file", "in", "url", "Input", "reader", "temp", "active", "img", "single", "connection", "io", "inner", "image", "self", "buffer", "up", "client", "channel", "result", "exec", "instance", "stream", "current", "audio", "api", "copy", "config", "out", "object", "null"], "output": ["application", "target", "video", "operation", "address", "next", "child", "core", "socket", "other", "source", "put", "exit", "response", "Output", "writer", "console", "binary", "parent", "entity", "ou", "file", "office", "temp", "environment", "connection", "io", "unit", "image", "self", "client", "channel", "o", "ilo", "write", "download", "outer", "external", "current", "control", "audio", "copy", "config", "out", "null"]}}
{"id1": "1798720", "id2": "21656668", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"packageName": ["applicationName", "pkgName", "PackageNames", "sourceName", "packagename", "PackagePath", "pluginNames", "packageNames", "sourcePath", "modulename", "applicationNames", "pluginName", "pluginPath", "directoryDir", " packagePath", " packageNames", "pkgNames", "applicationname", "directoryname", "PackageName", "sourcename", "pkgname", " packagename", "directoryPath", "sourceDir", "moduleName", "pluginname", "Packagename", "pkgPath", "packagePath", "directoryName", "applicationPath", "modulePath", "moduleDir"], "fileContents": ["fileContent", "fileParts", "FileContents", "singleNames", "singleContent", " fileParts", "FileNames", "FileContent", "doParts", "FileTextures", "doNames", "fileSources", "FileSources", " fileTextures", " fileSources", "doContent", "resourceSources", " fileContent", "fileTextures", "resourceTextures", "FileParts", "singleParts", "resourceNames", "doContents", "singleContents", "resourceContents"], "fileNames": [" fileValues", "modelNames", "letternames", "resourceTypes", "Filenames", "FileValues", "multipleName", " fileNumbers", "modelnames", "FileContents", "fTypes", "fNames", "FileTypes", "FileName", "fContents", "FileNames", " filenames", "placeValues", "fileTypes", "FileNumbers", "fileValues", "fileName", " fileName", "fileNumbers", "multipleTypes", " fileTypes", "placeNames", "placeNumbers", "filenames", "resourceName", "letterNames", "letterContents", "modelContents", "fName", "resourcenames", "resourceNames", "multipleNames", "multiplenames"], "dirBase": ["fileBased", "packageRoot", "folderBased", "Dirbase", "moduleBased", "directoryBase", "dirRoot", "fileDir", "DirPath", "folderbase", "directoryDir", " dirRoot", "moduleBase", "DIRbase", " dirPath", "DirRoot", "DirBase", "directorybase", "dirbase", "fileBase", "folderPart", "filePart", "directoryBased", "dirPath", "packagePath", "dirDir", "folderBase", "moduleDir", "dirBased", "DIRBased", "packagebase", "DIRBase", " dirbase", "packageBase", "dirPart", "DIRPart", "modulebase", "filebase"], "packageDir": ["PackageDir", "packageFolder", "directoryDirectory", "PackagePath", "PackageDirectory", "folderPath", "directoryFile", "directoryFolder", "packageBar", "directoryDir", " packagePath", "moduleBase", " packageFolder", "packageFile", "packageDirectory", "moduleBar", "parentDir", "directoryPath", "PackageFile", " packageDirectory", "parentName", "packagePath", "directoryName", "folderBar", "folderBase", "parentFile", " packageFile", "parentFolder", "modulePath", "packageBase", " packageBar", "moduleDir", "folderDir", " packageBase"], "created": ["needed", "edited", "existent", "updated", "found", "controlled", "claimed", "founded", "confirmed", "successful", "made", "path", " existed", "raised", "activated", "creation", "added", "formed", "authorized", "icated", "failed", "creator", "sc", "true", "owned", "established", "worked", "were", "used", "ed", "Created", "aaaa", "paid", "generated", "loaded", "result", "required", "produced", "called", "null", "create", " Created"], "currentPath": [" currentPoint", "reportedRoot", " currentFolder", " currentRoot", "CurrentPath", "publicPath", "currentDirectory", "currentpath", "publicpath", "CurrentPoint", "reportedpath", "publicPoint", "CurrentDirectory", "Currentpath", "CurrentRoot", "publicDirectory", "currentPoint", "reportedPath", "currentRoot", " currentDirectory", " currentpath", "CurrentFolder", "currentFolder", "reportedFolder"], "i": ["hi", "phi", "f", "x", "d", "it", "ui", "ori", "ti", "ie", "uri", "g", "bi", "gi", "ci", "qi", "slice", "di", "h", "z", "init", "pi", "q", "zi", "p", "v", "ix", "ai", "part", "u", "type", "m", "iu", "yi", "io", "inner", "ip", "ii", "y", "name", "info", "b", "ri", "I", "c", "fi", "multi", "j", "start", "me", "n", "si", "isi", "key", "li", "ini", "oi", "ji", "mi", "index", "xi", "eni", "e", "id"], "file": ["f", "filename", "child", "it", "data", "source", "resource", "per", "path", "rule", "feed", "http", "pe", "File", "folder", "base", "function", "fp", "full", "files", "place", "io", "letter", "s", "unit", "name", "up", "dir", "b", "le", "or", "ile", "l", "work", "log", "fe", "use", "out", "il", "e"], "fos": ["Fos", "foes", "Fops", "Foos", " foS", "FoS", " foes", "infoos", "faos", " fo", "Fis", "pios", "foos", "infops", "phoS", "phos", "voes", " fios", "fios", " faos", "vos", "vo", "fops", "fis", "phops", "foS", "fo", "Fios", " foos", "pos", "pops", "infos", "Fo", "Foes", "po", " fis", "infis", "phaos", " fops", "Faos", "vops"], "fileSrc": ["fileDource", "FileSRC", "fileNRC", "fileAsrc", "FileDRC", "filescc", " fileSRC", " fileDrs", "fileNrc", "filesrc", "fileSRC", "FileDoy", "FileSource", "fileSoy", "fileAsoy", " fileDrc", "FileSrc", " fileScc", "FileDource", "fileSrs", "fileDrs", "fileAsRC", " fileDRC", " fileDcc", "fileNrs", "filesRC", "fileDoy", "fileDcc", "fileAsource", "FileSoy", " fileSrs", "FileDrc", "fileScc", "fileDRC", "fileSource", "fileDrc", "filesrs", "fileNcc"], "fileDst": ["FileSsh", "fileShSt", "fileSst", "FileDsc", "fileShst", "contentShSt", "fileFrc", "fileDST", "fileStst", "fileFsh", "contentShst", "fileDsc", "fileDSt", "contentDrc", "fileSST", "contentDST", "FileSrc", "contentShrc", "fileStST", "fileSSt", "FileDsh", "fileFst", "contentShST", "fileFsc", "FileDst", "fileStrc", "contentDSt", "fileStSt", "FileSsc", "fileDsh", "fileSsh", "fileShST", "contentDst", "fileSsc", "FileDrc", "FileSst", "fileDrc", "fileShrc"], "reader": ["loader", "author", "ry", "rr", "data", "row", "more", "ler", "builder", "per", "feed", "director", "handler", "layer", "server", "read", "editor", "holder", "entry", "iter", "e", "book", "reading", "url", "in", "rer", "er", "worker", "io", "inner", "rar", "buffer", "image", "right", "keeper", "rc", "stream", "parser", "audio", "driver", "report", "r", "ner", "Reader", "oder"], "writer": ["wrapper", "master", "walker", "author", "data", "words", "rw", "usher", "socket", "source", "former", "xml", "builder", "ler", "document", "per", "director", "handler", "layer", "wire", "server", "riter", "war", "editor", "with", "entry", "iter", "maker", "rator", "sheet", "book", "value", "office", "wr", "Writer", "w", "er", "worker", "writers", "widget", "style", "inner", "buffer", "header", "ee", "later", "ws", "written", "player", "write", "outer", "work", "parser", "driver", "key", "r", "writ", "ner", "word", "out", "writing", "e", "message"], "line": ["number", "column", "f", "sync", "row", "lines", "point", "string", "lc", "source", "end", "no", "feed", "LINE", "str", "id", "layer", "model", "entry", "message", "character", "cr", "lf", "text", "base", "day", "block", "jo", "url", "page", "lin", "inline", "part", "stroke", "ge", "connection", "comment", "letter", "style", "header", "char", "unit", "Line", "name", "code", "cle", "job", "look", "c", "write", "l", "link", "pass", "key", "r", "word", "col", "cell"]}}
{"id1": "8770016", "id2": "88047", "code1": "    public InputStream loadResource(String location) throws GenericConfigException {\n        URL url = getURL(location);\n        try {\n            return url.openStream();\n        } catch (java.io.IOException e) {\n            throw new GenericConfigException(\"Error opening URL resource at location [\" + url.toExternalForm() + \"]\", e);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"location": ["loader", "target", "operation", "address", "Location", "filename", "length", "data", "content", "point", "uri", "string", "source", "resource", "path", "resources", "response", "uration", "layout", "URL", "class", "context", "base", "error", "file", "pointer", "timeout", "type", "directory", "level", "href", "language", "collection", "name", "LOC", "route", "l", "description", "position", "loc", "local", "rl", "localhost", "area", "config", "object", "info", "options", "message"], "url": ["loader", "plug", "address", "f", "bug", "data", "ref", "rel", "jar", "bb", "uri", "ssl", "string", "source", "resource", "xml", "web", "remote", "path", "str", "server", "http", "org", "sl", "URL", "base", "event", "file", "page", "connection", "image", "buffer", "element", "open", "name", "job", "route", "l", "link", "stream", "Url", "external", "log", "loc", "rl", "ob", "config", "object", "e"]}}
{"id1": "16931472", "id2": "13981689", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"result": ["session", "re", "data", "row", "source", "resource", "document", "output", "response", "message", "list", "group", "json", "event", "array", "page", "res", "manager", "table", "results", "buffer", "Result", "order", "feature", "cache", "view", "report", "complete", "record", "status", "map", "match", "dict"], "target": ["session", "next", "version", "template", "it", "data", "content", "reference", "the", "request", "site", "source", "proxy", "resource", "output", "token", "host", "response", "server", "http", "goal", "project", "this", "class", " Target", "favorite", "parent", "html", "base", "database", "event", "task", "that", "page", "environment", "type", "manager", "location", "connection", "owner", "tail", "style", "unit", "image", "about", "client", "route", "download", "link", "arget", "external", "current", "Target", "config", "theme", "object", "layout", "master"], "url": ["loader", "address", "user", "uri", "socket", "service", "ssl", "string", "source", "resource", "path", "feed", "str", "server", "http", "org", "sl", "URL", "blog", "base", "file", "page", "connection", "io", "buffer", "channel", "build", "browser", "l", "stream", "Url", "view"], "reader": ["loader", "bird", "f", "ry", "rr", "row", "i", "ler", "builder", "feed", "handler", "layer", "server", "read", "http", "editor", "e", "iter", "iterator", "input", "writer", "reading", "file", "in", "rer", "er", "worker", "err", "io", "buffer", "ri", "rc", "stream", "over", "rx", "parser", "driver", "report", "ner", "Reader"], "line": ["side", "lc", "pe", "limit", "sl", "block", "header", "buffer", "code", "link", "non", "view", "body", "e", "cell", "sync", "plugin", "data", "parse", "home", "source", "profile", "LINE", "lined", "liner", "base", "file", "Line", "log", "key", "li", "info", "id", "cl", "live", "lines", "string", "no", "rule", "str", "response", "zip", "el", "lf", "text", "lin", "comment", "le", "or", "status", "message", "row", "user", "point", "strip", "site", "end", "nl", "iter", "ine", "lock", "error", "page", "inline", "err", "style", "range", "name", "look", "email", "o", "l", "definition", "frame", "lo", "rl"], "entry": ["extra", "ry", "ener", "data", "row", "ie", "uri", "service", "counter", "string", "section", "source", "resource", "builder", "per", "feed", "exit", "ent", "layer", "editor", "writer", "member", "value", "entity", "page", "se", "part", "ge", "connection", "owner", "inner", "element", "archive", "her", "term", "match", "or", "link", "rc", "key", "ner", "Entry", "enter", "e", "cell"], "fromIndex": [" fromOffset", "fromLength", " fromPoint", "toOffset", " fromLength", "FromOffset", "FromSection", "FromPosition", "toPoint", "toIndex", "fromPosition", "startIndex", "FromLength", "sourceIndex", "FromPoint", " fromPosition", "startLength", "startPosition", " fromSection", "sourcePosition", "sourcePoint", "fromSection", "fromPoint", "toPosition", "FromIndex", "startOffset", "sourceSection", "fromOffset"], "r": ["f", "re", "d", "rr", "R", "rb", "ru", "sr", "cr", "fr", "attr", "pr", "q", "p", "array", "v", "w", "u", "res", "er", "m", "rg", "ar", "range", "vr", "b", "ri", "lr", "c", "rs", "l", "rc", "nr", "rl", "ner", "mr", "e"]}}
{"id1": "3046085", "id2": "8490297", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 0, "substitutes": {"s": ["S", "f", "a", "data", "content", "uploads", "ses", "string", "source", "i", "es", "sample", "sb", "str", "parts", "t", "is", "text", "p", "v", "in", "w", "ls", "m", "south", "speech", "sets", "testers", "services", "ws", "b", "ss", "ps", "less", "n", "js", "strings", "r", "e", "sharing"], "tokenizer": ["tunator", "Tokenator", "generener", " tokenener", "okener", "Tokenizable", " tokenize", "tokenizable", "hanizable", "hanize", "okeniner", "Tokenization", "okeniser", "tokenner", "serializer", "Tokenner", " tokenization", "hanator", "serialner", " tokenizable", "lexizer", "lexization", "numberizer", "generizer", "generize", "tunize", "numberizing", " tokenzer", "hanizer", " tokeniser", "tokenener", "tokenizing", " tokenator", "tunizable", "generizable", "tunizer", "okenizable", "lexizable", "Tokeniser", "lexize", " tokener", "okenizer", "tokenize", "tokenization", "tokeniner", "hanoser", "serialer", "Tokenizer", "numberizable", "serialize", " tokenoser", "hanization", "generator", "Tokenoser", "sonizable", "sonize", "generler", " tokenler", "okenizing", "okenzer", "sonizer", "okenize", "sonener", "tokenoser", "Tokeniner", "okenator", "tokener", "haniner", "sonization", "tokeniser", "tokenator", "okenler", " tokenizing", "tokenzer", "numberler", "okenener", "sonator", "tokenler", "Tokener", " tokenner", "Tokenize", "okenization", "sonzer"], "title": ["song", "author", "filename", "version", "template", "prefix", "length", "format", "content", "company", "string", "source", "profile", "layer", "id", "Title", "label", "text", "meta", "username", "license", "photo", "url", "type", "bot", "team", "media", "art", "name", "description", "genre", "summary", "music", "theme", "master", "metadata"], "artist": ["cover", "song", "master", "video", "target", "season", "author", "patch", "source", "alias", "output", "layer", "Artist", "track", "writer", "tag", "username", "creator", "chart", "photo", "winner", "episode", "team", "image", "media", "art", " artists", "archive", "player", "album", "feature", "genre", "audio", "music", "theme", "piece", "voice", "metadata"], "location": ["video", "address", "station", "live", "length", "Location", "content", "mobile", "time", "path", "layer", "lang", "motion", "game", "url", "level", "image", "media", "language", "region", "weather", "lace", "position", "audio", "loc", "area", "theme", "layout"], "rating": ["season", "live", "training", "alpha", "weight", "game", "random", "rate", "score", "rock", "episode", "tracking", "style", "fps", "media", "scoring", "trial", "resolution", "album", "rank", "breaking", "genre", "boarding", "picking", "playing", "padding", "ranking", "sharing"], "overplay": ["gameface", "gameplay", "reface", "rebid", "microface", "microplay", "overface", "overlay", "relay", "microlay", "gamelay", "microbid", "overbid", "gamebid", "replay"], "temp": ["prefix", "template", "data", "content", "format", "emp", "string", "source", "empty", "path", "str", "id", "font", "tmp", "track", "tag", "fake", "base", "p", "txt", " temporary", "type", "tc", "unit", "tx", "partial", "media", "name", "original", "stage", " tmp", "flat", "current", "cache", "test", "pt", "loc", "body", "area", "Temp", "layout", "message"], "tags": ["ids", "styles", "comments", "shirts", "features", "words", "phones", "stats", "blocks", "resources", "sections", "packages", "atts", "reports", "thumbnails", "ags", "relations", "tracks", "tests", "products", "events", "Tags", "files", "users", "assets", "types", "keys", "plugins", "modules", "images", "strings", "dates", "videos", "fields", "bugs", "bots", "stars", "names", "terms"], "bytes": ["comments", "bits", "data", "words", "content", "Bytes", "lines", "tes", "es", "blocks", "balls", "parts", "notes", "gets", "errors", "tracks", "resses", "params", "units", "files", "bps", "les", "articles", "pages", "objects", "ips", "letters", "outs", "codes", "size", "values", "pieces", "keys", "seconds", "body", "strings", "packs"], "hasher": ["rusher", "Hasbuilder", " hasipper", "hasusher", "hadipper", "gother", "gotest", " hashing", "hadest", " hashers", " hasest", "haster", "hasipper", "Hasest", "gotbuilder", "hashing", "hardhers", "rusipper", "macest", "hadher", "hardhing", "hardest", "hasbuilder", "hasest", "havehers", " haster", "macer", "sher", "machers", " hasusher", "hadusher", "haser", "havehing", " hasbuilder", " haser", "gotter", "shers", "Hasher", "rususher", "macher", "hardher", "Haster", "sest", "haveher", "ser", "rusest", "haveest", "hashers"]}}
{"id1": "6341264", "id2": "15905041", "code1": "    public static byte[] getJarEntry(String jarName, String entry, int port) {\n        byte[] b = null;\n        try {\n            String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName());\n            String protocol = \"http://\";\n            int x = codebase.indexOf(protocol) + protocol.length();\n            String s2 = codebase.substring(x);\n            int x2 = s2.indexOf('/');\n            String downloadHost = s2.substring(0, x2);\n            if (downloadHost.indexOf(':') == -1) {\n                downloadHost += \":\" + port;\n            }\n            URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry);\n            JarURLConnection jurl = (JarURLConnection) url.openConnection();\n            JarEntry je = jurl.getJarEntry();\n            InputStream is = jurl.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            int size = (int) je.getSize();\n            b = new byte[size];\n            int rb = 0;\n            int chunk = 0;\n            while ((size - rb) > 0) {\n                chunk = bis.read(b, rb, size - rb);\n                if (chunk == -1) {\n                    break;\n                }\n                rb += chunk;\n            }\n            bis.close();\n            is.close();\n            bis = null;\n            is = null;\n            url = null;\n            jurl = null;\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return b;\n    }\n", "code2": "    public void createPartControl(Composite parent) {\n        viewer = new ScrollingGraphicalViewer();\n        viewer.setRootEditPart(new ScalableRootEditPart());\n        viewer.setEditPartFactory(new BlockEditPartFactory());\n        viewer.setEditDomain(new EditDomain());\n        viewer.createControl(parent);\n        viewer.setKeyHandler(new GraphicalViewerKeyHandler(viewer));\n        ActionRegistry actionRegistry = new ActionRegistry();\n        createActions(actionRegistry);\n        ContextMenuProvider cmProvider = new BlockContextMenuProvider(viewer, actionRegistry);\n        viewer.setContextMenu(cmProvider);\n        Block b = new Block();\n        b.addChild(new ChartItem());\n        viewer.setContents(b);\n        System.err.println(\"!!! \" + viewer.getContents().getChildren().get(0));\n        viewer.select((EditPart) viewer.getContents().getChildren().get(0));\n        PaletteRoot root = new PaletteRoot();\n        PaletteGroup toolGroup = new PaletteGroup(\"Chart Tools\");\n        List toolList = new ArrayList();\n        ToolEntry tool = new SelectionToolEntry();\n        toolList.add(tool);\n        root.setDefaultEntry(tool);\n        tool = new MarqueeToolEntry();\n        toolList.add(tool);\n        toolGroup.addAll(toolList);\n        PaletteGroup templateGroup = new PaletteGroup(\"Templates\");\n        List templateList = new ArrayList();\n        CombinedTemplateCreationEntry entry = new CombinedTemplateCreationEntry(\"Rect\", \"Rect\", new ChartItem(), new SimpleFactory(ChartItem.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        CombinedTemplateCreationEntry entry1 = new CombinedTemplateCreationEntry(\"Line\", \"Line\", new ChartLine(), new SimpleFactory(ChartLine.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        templateList.add(entry);\n        templateList.add(entry1);\n        templateGroup.addAll(templateList);\n        List rootList = new ArrayList();\n        rootList.add(toolGroup);\n        rootList.add(templateGroup);\n        root.addAll(rootList);\n        final PaletteViewer v = new PaletteViewer();\n        v.setPaletteRoot(root);\n        v.createControl(parent);\n        v.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(\"selectionChanged \" + v.getActiveTool());\n            }\n        });\n        deleteAction.setSelectionProvider(viewer);\n        viewer.getEditDomain().setPaletteViewer(v);\n        viewer.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(event.getSelection());\n                deleteAction.update();\n            }\n        });\n        viewer.getEditDomain().getCommandStack().addCommandStackEventListener(new CommandStackEventListener() {\n\n            public void stackChanged(CommandStackEvent event) {\n                undoAction.setEnabled(viewer.getEditDomain().getCommandStack().canUndo());\n                redoAction.setEnabled(viewer.getEditDomain().getCommandStack().canRedo());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"jarName": ["JarName", "jobName", "jarPath", "zipFamily", "zipAlias", " jarPath", "JarPath", "reportAlias", "jobPath", "jarname", "jobVersion", " jarAlias", "JarVersion", "reportFamily", "jarFamily", " jarVersion", " jarFamily", "jobname", "Jarname", "zipName", " jarname", "reportName", "jarVersion", "jarAlias"], "entry": ["address", "next", "filename", "ry", "data", "jar", "uri", "ie", "service", "string", "source", "parse", "resource", "end", "path", "str", "server", "zip", "file", "type", "connection", "offset", "element", "image", "code", "archive", "name", "info", "route", "start", "key", "ticket", "Entry", "enter", "e", "id"], "port": ["target", "address", "length", "delay", "version", "patch", "point", "uri", "service", "time", "string", "path", "Port", "host", "server", "limit", "PORT", "pi", "file", "timeout", "type", "offset", "ip", "name", "pid", "pos", "ports", "position", "key", "count", "index", "ort"], "b": ["abb", "bar", "pb", "f", "xb", "d", "emb", "a", "nb", "bb", "gb", "eb", "sb", "i", "wb", "db", "ib", "zb", "erb", "fb", "usb", "buff", "buf", "binary", "bs", "base", "p", "bf", "orb", "obb", "v", "lb", "bp", "library", "bin", "boot", "cb", "ab", "bd", "s", "buffer", "mb", "bt", "beta", "br", "B", "c", "bytes", "l", "r", "ob", "e"], "codebase": [" codeb", "Codebase", "Codefile", "broadfull", "Codebas", "mapfile", "codebas", " codebas", " codefull", "mapbas", "geBase", "workfull", "workbase", "CodeBase", "gebase", "contentfile", "codeBase", "codefull", "codefile", "broadbase", "contentunit", "workb", "Codeb", "broadb", "geb", "contentbase", "codeb", "workBase", "mapbase", "gebas", "codeunit", "mapunit", "contentbas", "Codeunit", "broadBase", " codeBase"], "protocol": ["hypocol", "hypprot", "predocol", "protprot", "Proturl", "propometry", "proturl", "extocol", "protometry", "propology", "Prototype", "protology", "exturl", "Protocol", "hypology", "extology", "prototype", "extotype", "protose", " protose", "horometry", "Protose", "horology", "Protometry", "predprot", "propocol", "predose", "Protology", "horocol", "extprot", "horurl", "extose", " prototype", "propurl", " proturl", "hypose", "predology"], "x": ["lex", "rex", "ctx", "f", "xa", "d", "check", "xd", "fx", "ax", "xf", "pe", "cross", "z", "p", "wx", "v", "ix", "w", "X", "ww", "m", "exp", "xxx", "xes", "tx", "y", "xt", "xxxx", "xs", "pos", "en", "index", "max", "work", "rx", "xx", "dx", "val", "xc", "ex", "h", "xi", "xp", "xxxxxxxx", "id"], "s2": ["x4", "s14", "x1", " s96", "v5", "x14", " s14", "x96", "l1", "p1", "S4", "l2", "S256", "s256", "v1", "l5", "s5", "x256", "v2", "S1", "p5", " s1", "latter", "S2", "vatter", " s4", "s4", "s1", "p2", "patter", "s96", "satter", " s256"], "x2": ["ix1", "x1", "X2", " xtwo", "rx1", "ix6", "X1", "ixtwo", " x52", "rx52", "X52", "xtwo", "rx5", "x5", "xp6", "x52", "x6", "xp1", " x6", "X5", " x1", "xp2", " x5", "ix2", "xptwo", "rx2"], "downloadHost": ["transferPath", "urlhost", "writePort", "urlPort", "writehost", "DownloadPort", " downloadPath", "downloadAddress", "urlDomain", " downloadPort", "transferhost", "transferPort", "DownloadAddress", "downloadPort", "externalhost", " downloadForm", "downloadhost", "writeHost", "externalRoot", "externalPort", "DownloadDomain", "transferDomain", " downloadhost", " downloadRoot", "transferAddress", "downloadRoot", " downloadAddress", "externalHost", " downloadDomain", "urlHost", "downloadForm", "writePath", "DownloadForm", "transferHost", "DownloadHost", "transferRoot", "DownloadPath", "writeForm", "downloadPath", "downloadDomain", "writeDomain"], "url": ["rel", "jar", "uri", "bb", "user", "ssl", "abs", "source", "web", "il", "host", "server", "http", "ur", "sl", "zip", "org", "el", "URL", "blog", "base", "orb", "file", "page", "ls", "www", "gl", "connection", "image", "job", "obj", "build", "j", "l", "ll", "link", "Url", "loc", "li", "rl", "ob", "fl", "proxy", "ball", "ul"], "jurl": ["gcoll", "jjUrl", "jpfile", "jjcoll", "JUrl", "gURL", "jjurl", " jURL", "jpul", " jUrl", "gurl", " jweb", "JURL", "jfile", "Jcoll", "ajurl", "jpURL", "jpcoll", " jul", "jobfile", " jsl", "jul", "jweb", "joburl", "ajweb", "jURL", "jpurl", "jcoll", "jobsl", " jbb", "jobweb", "jsl", " jcoll", "jobbb", "jbb", "ajbb", "jpUrl", "jobUrl", "jjul", "jobURL", "gUrl", "ajsl", "Jfile", "Jurl", "jUrl"], "je": ["esi", "jar", "ie", "ni", "jj", "ja", "gi", "fr", "xe", "zip", "Obj", " ze", "jo", "ju", "se", "jen", "java", "pse", "elt", "ii", "ee", "py", "obj", "job", "su", "oe", "j", "jp", "ne", "jl", "js", "Je", "si", "isi", "ji", "be", "la"], "is": ["oss", "ir", "nis", "lis", "address", "ris", "ori", "isin", "jar", "iss", "isl", "ses", "oris", "ie", "bi", "i", "es", "ais", "src", "iris", "ci", "sin", "il", "ib", "http", "zip", "its", "uri", "bs", "isa", "os", "iso", "ai", "vs", "in", "ils", "ins", "state", "s", "ii", "bb", "IS", "mis", "ios", "tis", "ri", "as", "ice", "Is", "are", "isi", "si", "li", "ob", "info", "be", "id"], "bis": ["oss", "obs", "pins", "esi", "nis", "lis", "ris", "ori", "bos", "serv", "isin", "ses", "bb", "iss", "iris", "abs", "bi", "i", "sb", "ais", "sin", "slice", "cos", "http", "di", "bus", "fb", "buff", "usb", "zip", "uri", "binary", "abi", "init", "bs", "base", "lock", "obb", "os", "ubis", "ins", "ls", "bin", "bps", "cb", "boot", "connection", "inner", "IS", "mis", "bes", "ios", "obj", "ri", "Is", "download", "js", "ob"], "size": ["cm", "cl", "address", "sync", "length", "core", "content", "g", "time", "form", "ci", "end", "send", "cr", "capacity", "ize", "small", "speed", "z", "sized", "len", "when", "scale", "base", "large", "shape", "esc", "sc", "co", "se", "fee", "now", "Size", "err", "unit", "range", "code", "name", "c", "width", "en", "rc", "sum", "max", "mode", "close", "si", "iz", "loc", "body", "SIZE", "cel", "enc", "sec", "ner", "use", "e", "sn"], "rb": ["abb", "pb", "xb", "rub", "nb", "rr", "ru", "rw", "RF", "bb", "src", "gb", "eb", "sb", "rd", "ruby", "reb", "wb", "sr", "db", "cr", "erb", "fb", "buf", "rob", "lb", "orb", "bf", "obb", "rab", "cb", "RB", "rg", "rm", "adr", "rar", "mb", "vr", "rt", "rf", " rc", "ri", "lr", "rc", "nr", "loc", "rl", "r", "ob"], "chunk": ["copacket", "charone", "cunc", " Chunks", "unchink", "choy", " chunker", "unchunk", "poy", "cone", "chink", "cherunk", "chacket", " Chunk", "cunk", "bone", "chunker", "copink", "cherink", "jacket", "charunks", "packet", "unchunks", " chink", "chunks", "bink", "charunk", "chone", "cheracket", "cacket", "copunc", "cherunc", " Chunker", "chrow", "bunk", "copoy", "charink", "prow", "punk", "chunc", "cink", "coprow", " Chink", " chunks", "junk", "cunks", "copunk", "jrow", "unchunker", "bunks", "joy"]}}
{"id1": "8132219", "id2": "9727056", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    @Override\n    public OBJModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        OBJModel model = loadModel(url.openStream(), skin);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "label": 0, "substitutes": {"inFile": ["inPlace", "infile", "InFilename", " infile", "outFiles", "binfile", "binFiles", "outPlace", "InSourceFile", "inputfile", "binPlace", "INFilename", " inFilename", "inputFiles", "inputPlace", "binFile", "INfile", "outfile", "Infile", "inSourceFile", "inFiles", "inFilename", "InFile", "inputFile", "INFile", " inSourceFile", "INSourceFile"], "outFile": ["infile", "outFilename", "outFiles", "outputFile", "outputFiles", "outputfile", "outPlace", " outPlace", "againPlace", " outFiles", "outfile", "outputFilename", "inFiles", "inFilename", " outFilename", " outfile", "againFilename", "outputPlace", "againFile", "againfile"], "in": ["f", "x", "a", "data", "inn", "source", "i", "ic", "is", "input", "base", "din", "file", "url", "reader", "part", "rin", "ins", "bin", "m", "connection", "inner", "io", "image", "name", "c", "as", "In", "work", "n", "inc", "IN", "ini", "like", "config", "index", "again", "pin", "id"], "out": ["ext", "dot", "version", "OUT", "x", "prefix", "data", "user", "string", "resource", "output", "line", "Output", "writer", "Out", "p", "v", "file", "conn", "plain", "part", "w", "bin", "call", "to", "io", "image", "buffer", "default", "name", "client", "obj", "o", "c", "b", "outs", "write", "exec", "external", "n", "cache", "log", "ex", "copy", "null"], "inChannel": ["outStream", "outLanguage", "inputchannel", "INConnection", "iniChannel", "inChan", "inputChannel", "INSocket", "INFlow", "sinSocket", "inputStream", " inChan", "iniStream", "inichannel", "outchannel", "outChan", "winLanguage", " inSocket", "outConnection", "winChannel", " inFlow", "winchannel", "inFlow", " inchannel", "sinChan", "inConnection", "inLanguage", "inchannel", " inConnection", "INChannel", "INChan", "inSocket", "inputChan", "inStream", "sinFlow", "iniLanguage", "winStream", "INStream", "sinChannel", "INchannel"], "outChannel": ["outStream", "outContext", "OutChan", " outPath", "newContext", "outPath", "inChan", "OutChannel", "OutContext", "OutStream", "newStream", "outchannel", "outChan", " outContext", "outConnection", " outchannel", " outChan", " outConnection", "againchannel", "inConnection", "OutConnection", "againChannel", "newChan", "againPath", " outStream", "inchannel", "newChannel", "outputChannel", "outputchannel", "againChan", "outputChan", "inPath", "Outchannel"]}}
{"id1": "14047629", "id2": "22401746", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "label": 0, "substitutes": {"source": ["session", "target", "loader", "data", "content", "src", "service", "parse", "request", "proxy", "resource", "document", "remote", "path", "ources", "SOURCE", "server", "project", "input", "class", "text", "cp", "parent", "load", "processor", "fp", "file", "transfer", "in", "reader", "connection", "inner", "image", "buffer", "comp", "info", "result", "exec", "proc", "stream", "Source", "ource", "config", "use", "out", "object", "status"], "process": ["session", "target", "system", "processing", "port", "script", "Process", "resource", "document", "app", "cess", "path", "progress", "output", "press", "plus", "command", "project", "console", "class", "parent", "p", "share", "processor", "task", "file", "method", "worker", "thread", "call", "image", "display", "open", "job", "machine", "pid", "exec", "result", "program", "pipe", "proc", "index", "python", "work", "run", "parser", "loop", "post", "node", "use", "object", "status", "master"], "processStdOut": ["processStdOUT", "processStdinOutput", "processSttOUT", "processSTdOUT", "processStDOut", "processSttOutput", "processStdOutput", "processStDObj", "processStDOutput", "processSTDObj", "processStdinOUT", "processSTDOUT", "processSTdOutput", "processStdinObj", "processSTdObj", "processStDOUT", "processSttObj", "processSTDOutput", "processSTDOut", "processStdinOut", "processSttOut", "processStdObj", "processSTdOut"], "processStdIn": ["processSTdIns", "processSttIndex", "processStadin", "processSTstdIndex", "processSTstdin", "processStbIn", "processSTdIn", "processStbIN", "processStadIN", "processStstdIndex", "processStdinIN", "processStstdIn", "processStbIndex", "processSTstdIn", "processSttIn", "processStdinIn", "processStdIns", "processStstdin", "processStstdIns", "processSttIns", "processStbin", "processSttin", "processStdinOut", "processSTdin", "processStbIns", "processSTdIndex", "processStbOut", "processStdIN", "processStadIn", "processStdin", "processStdIndex", "processStadOut", "processStdinin", "processSTstdIns"]}}
{"id1": "693636", "id2": "12417893", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"SHOPPING_ID": ["SHOPPING_IDS", "SHOPPING_Id", "SHOPPTINGIDId", "SHOPPINGOCKIDs", "SHOPPINGINGId", "SHOPPIP_Id", "SHOPPIP_id", "SHOPPYING_IDs", "SHOPPTING_IDS", "SHOPPIP_ID", "SHOPPIPINGId", "SHOPPYING_IDS", "SHOPPTING_NAME", "SHOPPTINGIDid", "SHOPPINGIDid", "SHOPPTING_ID", "SHOPPIPINGID", "SHOPPYING_ID", "SHOPPTINGIDIDS", "SHOPPINGINGID", "SHOPPIP_IDS", "SHOPPINGINGIDS", "SHOPPINGOCKID", "SHOPPINGINGNAME", "SHOPPINGIDIDs", "SHOPPING_NAME", "SHOPPING_id", "SHOPPINGIDId", "SHOPPINGIDID", "SHOPPTINGIDID", "SHOPPINGIDNAME", "SHOPPING_IDs", "SHOPPIPINGid", "SHOPPTING_id", "SHOPPINGOCKIDS", "SHOPPYING_Id", "SHOPPINGOCKId", "SHOPPIPINGIDS", "SHOPPTING_Id", "SHOPPINGINGid", "SHOPPINGIDIDS"], "con": ["wan", "session", "ca", "ctx", "cons", "un", "cm", "row", "cond", "cf", "Con", "connect", "cn", "pen", "bc", "db", "cr", "pc", "conf", "commit", "fc", "cas", "fa", "can", "query", "conn", "co", "ran", "act", "com", "ct", "connection", "CON", "fac", "ec", "client", "conv", "c", "exec", "cc", "en", "rc", "Conn", "win", "close", "ctrl", "ann", "cache", "ac", "log", "cur", "loc", "pool", "inc", "mc", "ex", "uc", "coll", "col"], "insert_cart": ["insert_table", "insertkcart", "insertingpack", "insertfulart", "initkcoll", " insert_pod", "insertingCart", "insertAdcycle", "insert_card", "insertpcycle", "pushingCart", "initkcart", "insertfulhard", "insertkcoll", "push_cart", " insert_table", "insertkcontainer", "initkcontainer", "init_cycle", " insert_art", " insert_front", "insertAdcontainer", " insert_card", "insertkcycle", "insert_front", "insert_pod", "insertpcoll", "insert_cycle", "insert_coll", "insert_hard", "insert_container", "insertfulcart", "insertAdcart", "insertpcontainer", "insertingcart", "init_container", "insertAdcoll", "insertfulcat", "insertpcart", "pushingpack", "insert_art", "pushingcart", "init_cart", "push_Cart", "insert_pack", " insert_cat", "insert_Cart", "push_pack", "init_coll", "insert_cat", "initkcycle", " insert_hard"]}}
{"id1": "9275622", "id2": "12066447", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "label": 1, "substitutes": {"_file1": ["_zip1", "_fone", "_resource1", "_files01", "_fileOne", "_f1", "_mail2", "_zipOne", "_files0", "_mail0", "_fOne", "_File2", "_mail01", "_fileone", "_files1", "_resourceone", "_files2", "_file01", "_fileFirst", "_resourceFirst", "_file0", "_File01", "_File0", "_fFirst", "_File1", "_mail1", "_resourceOne", "_zipone", "_zipFirst"], "_file2": [" _files4", "_play2", "_Filesecond", "_playsecond", "_play3", "_model1", "_File5", "_filesTwo", " _file4", " _filesTwo", "_playTwo", " _fileTwo", "jmodelsecond", "jmodel2", "jmodel5", "_File2", "_play5", "jfile2", "_play1", " _files3", "jfile1", "_files2", "_file3", "_model5", "_filesecond", "_files4", "_play4", "_File1", "jfile5", "_modelsecond", "_file4", "jmodel1", "_fileTwo", "jfilesecond", "_files3", " _files2", "_file5", " _file3", "_model2"], "fis": ["Fos", "lfis", "fas", " fils", " fris", "lfais", " fas", "Fris", "fris", "cfas", " fais", "Fils", "cfris", "lfiss", "afis", "afi", "Fis", " fiss", "infils", " fi", "afiss", "cfis", "afais", "fais", "cfiss", "fiss", "infiss", "cfos", "fils", "Fas", "fi", "infos", "Fiss", "lfi", "infis"], "fos": ["Fos", "foes", "feoses", "Foos", "lis", "fOS", "lOS", "feis", "flOS", "infios", "gus", "faos", "poes", "floes", "fus", " fo", "infoos", "goses", "Fis", "los", "flos", "foos", "Fros", " fios", "fios", "infros", " fus", " faos", "Fus", "infaos", "flis", "Fios", "fo", " foos", " fros", "pos", "foses", "gos", "infos", "Fo", "Foses", "feos", "infus", "pis", "pOS", "fros", "Faos", "feus", "info", "loes", "gis"], "canalFuente": ["canalBuente", "canallBuente", "canallBuencia", "canalBuze", "canalsFuencia", "canalFUje", "canalsBuente", "canalCraento", "canaledBuje", "canalFUence", "canalBuento", "canaledFuje", "canalKuze", "canalsFuento", "canalsFuente", "canaledFuze", "canalBuestro", "canalFUze", "canalCraente", "canalBuencia", "canalSuze", "canalSuestro", "canalFUente", "canalsFuence", "canalCraencia", "canalBuje", "canalSuente", "canallFuence", "canalFuze", "canallFuze", "canalCraence", "canallBuence", "canalFUestro", "canalFuestro", "canalsBuento", "canaledBuze", "canalFuje", "canalKuence", "canallBuze", "canaledBuestro", "canalSuje", "canallFuente", "canalFuence", "canalKuente", "canalKuencia", "canalKuento", "canalFuento", "canalsBuencia", "canaledBuente", "canalFUencia", "canalsBuence", "canalBuence", "canallFuencia", "canaledFuente", "canalFuencia", "canaledFuestro"]}}
{"id1": "810342", "id2": "16623181", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"view": ["session", "gu", "f", "can", "template", "ui", "row", "port", "user", "check", "request", "section", "form", "container", "VIEW", "review", "im", "views", "server", "http", "see", "layout", "el", "input", "by", "this", "list", "group", "window", "html", "base", "lock", "block", "event", "query", "head", "page", "v", "full", "reader", "ou", "screen", "manager", "widget", "box", "style", "View", "buffer", "image", "display", "change", "self", "edit", "up", "update", "client", "vol", "sel", "link", "show", "index", "cache", "body", "config", "out", "object", "model", "use", "vis", "e", "cell"], "url": ["loader", "address", "f", "length", "data", "socket", "uri", "jar", "ssl", "string", "source", "resource", "web", "builder", "path", "host", "server", "http", "hub", "fb", "sl", "zip", "URL", "blog", "base", "file", "page", "www", "gl", "location", "connection", "buffer", "image", "open", "name", "client", "channel", "job", "b", "email", "browser", "download", "l", "link", "stream", "Url", "log", "position", "ob", "config", "ul", "id"], "in": ["data", "isin", "socket", "inn", "source", "resource", "con", "sin", "on", "is", "input", "arin", "init", "din", "file", "lin", "reader", "rin", "ins", "inner", "s", "buffer", "bis", "b", "as", "doc", "win", "In", "stream", "cin", "inc", "ac", "IN", "nin", "ini", "login", "out", "again", "pin"], "bin": ["loader", "an", "gin", "nb", "socket", "bb", "ruby", "inn", "bi", "source", "con", "sin", "is", "input", "lib", "binary", "init", "abi", "ban", "kin", "lock", "din", "file", "lin", "reader", "bot", "connection", "bn", "inner", "buffer", "b", "inside", "fin", "browser", "win", "cache", "cin", "run", "IN", "body", "ini", "record", "spin", "out", "login", "oin", "pin"], "line": ["cl", "column", "data", "row", "lines", "user", "service", "parse", "string", "lc", "section", "end", "LINE", "str", "id", "nl", "entry", "pe", "ine", "el", "lf", "text", "base", "block", "file", "page", "lin", "inline", "part", "type", "ge", "comment", "letter", "range", "unit", "ip", "name", "Line", "code", "job", "up", "look", "b", "le", "l", "link", "definition", "log", "key", "val", "word", "out", "status", "pin", "e", "cell"], "version": ["cover", "install", "video", "filename", "bug", "plugin", "patch", "format", "string", "section", "id", "server", "vision", "option", "project", "username", "vert", "value", "license", "v", "type", "product", "dev", "secret", "unit", "image", "beta", "Version", "name", "update", "info", "versions", "code", "VERSION", "release", "download", "description", "feature", "python", "position", "driver", "null", "model", "date", "pull", "ver"], "build": ["install", "help", "length", "bug", "Build", "hold", "patch", "follow", "rel", "push", "row", "home", "builder", "built", "valid", "make", "label", "where", "tag", "lock", "base", "load", "block", "add", "boot", "building", "style", "comment", "unit", "image", "name", "update", "info", "job", "print", "release", "how", "work", "run", "log", "test", "clean", "use", "uild", "show", "pull", "ver"]}}
{"id1": "23310397", "id2": "15768167", "code1": "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        mButton1 = (Button) findViewById(R.id.myButton1);\n        mButton2 = (Button) findViewById(R.id.myButton2);\n        mTextView1 = (TextView) findViewById(R.id.myTextView1);\n        mButton1.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpPost httpRequest = new HttpPost(uriAPI);\n                List<NameValuePair> params = new ArrayList<NameValuePair>();\n                params.add(new BasicNameValuePair(\"str\", \"post string\"));\n                try {\n                    httpRequest.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n        mButton2.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpGet httpRequest = new HttpGet(uriAPI);\n                try {\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        strResult = eregi_replace(\"(\\r\\n|\\r|\\n|\\n\\r)\", \"\", strResult);\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"savedInstanceState": ["savingInstanceState", "savingInstanceInfo", "savedinstanceState", "savedinstanceInfo", "savedanceState", "savedInstInfo", "savingInstState", "savedInstanceConfig", "savingInstanceStates", "savedInstanceInfo", "savedInstData", "savedCaseStates", "savedinstanceConfig", "savingInstanceData", "savingInstConfig", "savingInstData", "savingInstInfo", "savedinstanceStates", "savedInstanceStates", "savedCaseState", "savedinstanceData", "savedInstanceData", "savingInstanceConfig", "savedCaseConfig", "savedanceStates", "savedInstStates", "savedanceData", "savedanceInfo", "savedInstConfig", "savedCaseInfo", "savedInstState", "savingInstStates"], "mButton1": ["mChannelOne", "mChannelFirst", "mOptionId", "MButtonOne", "MActionId", "MAction2", "mButtonId", "mAction2", "MAction1", "mBorder1", "mButton01", "MButtonFirst", "MButton2", "mChannel1", "mBorderFirst", "mText2", "mAction1", "mText01", "MChannelFirst", "mButtonOne", "MButton01", "MButtonId", "mActionOne", "mText1", "MChannel1", "mOption2", "mChannel2", "mBorder2", "mChannelId", "mButtonFirst", "mOption1", "MChannel01", "mTextFirst", "mOptionOne", "MChannel2", "MActionOne", "mChannel01", "mActionId", "MButton1", "mBorder01"], "mButton2": [" mText1", "mEditorTwo", "mAction2", " mText02", "mLabel2", "mLabel1", "mOptionTwo", " mButton02", " mButtonTwo", " mEditor2", " mEditorTwo", "mText2", "mLabelTwo", "mAction1", " mEditor1", " mTextTwo", "mText1", "mOption2", "mTextTwo", "mAction02", "mButton02", "mText02", " mText2", "mOption1", "mButtonTwo", "mEditor1", "mEditor2", "mActionTwo", "mOption02"], "mTextView1": ["mContextview11", "mTextviewOne", "mTextview8", "mContextView1", "mTextDisplay1", "mTEXTviewOne", "mContextView11", "mTEXTView11", "mTEXTview2", "mTextview11", "mTextview4", "mTextviewp", "mTextContainer11", "mContextView5", "mTextDisplay2", "mTextViewOne", "mTextViewp", "mTEXTview1", "mTextForm1", "mTextVIEW1", "mContextView0", "mTextVIEW0", "mTextField2", "mTextContainer1", "mTextVIEW4", "mTEXTview5", "mTextStreamp", "mTextView4", "mTextVIEW11", "mTextForm2", "mTextView8", "mTextVIEW5", "mTextVIEW2", "mTextView2", "mTextVIEWp", "mTextVIEWOne", "mTextview5", "mTextForm8", "mTextDisplay5", "mTextView11", "mTEXTView4", "mTEXTView8", "mTEXTView2", "mTextStream11", "mTextContainer8", "mContextview0", "mTextDisplay4", "mTextContainer2", "mContextView2", "mContextViewp", "mTEXTview11", "mTextField1", "mTextForm11", "mTextField5", "mTextview2", "mTextView0", "mTextView5", "mTEXTview8", "mContextviewp", "mTextDisplayOne", "mTEXTView5", "mTEXTview4", "mTextview0", "mTextStream1", "mTextview1", "mTEXTViewOne", "mContextview1", "mContextview2", "mTextStream0", "mTEXTView1", "mTextStream2", "mContextview5"], "v": ["video", "f", "version", "x", "Value", "port", "g", "i", "server", "Ev", "t", "vv", "value", "function", "p", "V", "page", "vs", "w", "m", "Version", "conv", "c", "b", "j", "en", "l", "env", "sv", "n", "view", "ve", "val", "h", "model", "e"], "uriAPI": ["URIPython", "uriPA", "cliPython", "uiPython", "URIAP", "durationPython", "urlCA", "uriCA", "URIAPI", "uiAPI", "directoryAPI", "durationAP", "riapi", "idPA", "urlPA", "riPython", "riAPI", "URIPA", "idCA", "idAPI", "URISSL", "URICA", "uriapi", "directorySSL", "uriAP", "cliAPI", "riAP", "URIapi", "urlAPI", "uriPython", "durationAPI", "directoryapi", "uriSSL", "uiapi", "cliapi", "riSSL"], "httpRequest": ["ttpRequest", "externalAsk", " httpReturn", " httpClient", "httpCause", "saferequest", "httpsClient", "externalResponse", "HttpMessage", "httpsrequest", "safeAsk", "htmlResponse", "htmlCause", "uriRequest", "httprequest", "httpClient", "htmlRequest", "safeResponse", "htmlrequest", "HttpRequest", "uriResponse", "httpsReturn", "ttpClient", "buildMessage", "ttprequest", "buildRequest", "httpAsk", "buildrequest", "httpsRequest", "HttpResponse", " httpCause", "ttpReturn", " httpAsk", "uriCause", "externalRequest", "httpMessage", " httprequest", "Httprequest", " httpMessage", "externalrequest", "safeRequest", "buildResponse", "httpReturn", "urirequest"], "params": ["pins", "data", "changes", "uri", "request", "string", "i", "Parameters", "resources", "response", "http", "parts", "param", "list", "par", "json", "items", "query", "relations", "array", "properties", "vs", "url", "ras", "ams", "type", "apps", "results", "ip", "services", "details", "pos", "result", "settings", "ps", "values", "keys", "body", "api", "config", "arms", "eps", "names", "options", "posts", "rules"], "httpResponse": ["ttpRequest", "htmlResp", "HttpClient", "ttpReply", "ttpResp", "HttpReply", " httpResult", "htmlResponse", "HTTPReply", "serverResult", "htmlresponse", "httpresponse", "htmlResult", "httpClient", " httpResp", "HTTPResp", "HttpRequest", " httpReply", "ttpClient", "ttpResponse", "httpResp", "serverResponse", "Httpresponse", "HTTPResponse", "HttpResponse", "serverResp", " httpresponse", "ttpResult", "externalRequest", "serverRequest", "httpResult", "HttpResult", "HttpResp", "httpServer", "httpReply", "htmlServer", "HTTPRequest", "htmlReply", "ttpServer", "externalResult", "externalResponse", "HttpServer", "externalClient"], "strResult": ["stringresult", "strresult", "Strresult", "stringResults", "strResults", "stringResult", "strResponse", "StrResponse", " strresult", "StrResult", " strResults", "stringResponse", "StrResults", " strResponse"]}}
{"id1": "12236729", "id2": "18974466", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"inputFile": ["outputFiles", "outputfile", "sourcePath", "inputfile", "currentDir", "currentFile", "inputFiles", " inputDir", "sourceFiles", "currentFiles", "inputDir", " inputfile", " inputPath", "outputPath", "inputPath", " inputFiles", "outputDir", "sourceFile", "sourcefile", "currentfile"], "outputFile": ["tempFile", "OutputFile", "referenceFilename", "outputfile", " outputFilename", "Outputfile", "OutputDirectory", "inputfile", "OutputDir", "referenceDir", " outputfile", "tempDirectory", "outputDirectory", " outputDir", "tempDir", "referencefile", "inputDir", "outputFilename", "tempfile", "outputDir", "inputFilename", "referenceFile", " outputDirectory"], "in": ["gin", "f", "a", "pull", "socket", "inn", "source", "i", "ln", "con", "sin", "read", "is", "input", "init", "kin", "lock", "min", "din", "conn", "lin", "file", "reader", "ins", "bin", "into", "err", "connection", "inner", "get", "s", "image", "up", "inside", "as", "l", "win", "In", "n", "cin", "inc", "IN", "nin", "ini", "r", "login", "again", "pin", "e", "id"], "out": ["sync", "OUT", "socket", "i", "output", "off", "plus", "line", "writer", "parent", "Out", "v", "file", "conn", "error", "plain", "w", "temp", "bin", "one", "err", "net", "io", "up", "obj", "o", "b", "outside", "outs", "write", "exec", "outer", "over", "n", "cache", "inc", "post", "at", "log", "ex", "copy", "extra", "again", "null"], "c": ["cm", "cl", "f", "d", "cu", "a", "x", "cf", "lc", "i", "ci", "C", "line", "cr", "pc", "character", "ce", "fc", "p", "cy", "v", "esc", "sc", "u", "ct", "m", "k", "char", "code", "ec", "cd", "o", "b", "cc", "l", "rc", "n", "ch", "xc", "count", "uc", "r", "pointer", "col", "e", "id"]}}
{"id1": "6371607", "id2": "13233761", "code1": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"realmIds": ["realmIdes", "realmIDes", "realmByIdls", "realmRefos", "realMPathos", "realmIntids", "realmIDList", "realMIdids", "realmByIds", "realMByIdList", "realmRefls", "realmIdos", "realmIDs", "realMPaths", "realmIntes", "realMIdes", "realmIdls", "realmByIdList", "realmIntos", "realmByIdes", "realMPathes", "realMIdList", "realmPathos", "realmIDls", "realMByIdes", "realMIdos", "realmRefs", "realMIds", "realmRefList", "realMByIdls", "realMByIds", "realmInts", "realmPathes", "realmPaths", "realmIdList", "realmIdids", "realMPathids", "realMIdls", "realmPathids", "realmRefids", "realmRefes"], "psImpl": ["cssIter", "csImpl", " psimpl", "psIter", "csimpl", "qsHelper", " psIter", " psHelper", "cssExpl", "epsimpl", "cssimpl", "dsimpl", "psimpl", "cssImpl", "qsimpl", "qsImpl", "psHelper", "epsIter", "csHelper", " psExpl", "psExpl", "epsImpl", "epsHelper", "dsImpl", "epsExpl", "dsHelper"], "iter": ["walker", "ir", "itter", "next", "it", "gener", "cher", "ie", "parse", "i", "former", "end", "ler", "line", "cer", "entry", "limit", "iterator", "ator", "el", "init", "ite", "list", "apper", "page", "in", "reader", "er", "izer", "ter", "inter", "sort", "err", "inner", "finder", "Iter", "outer", "loop", "inc", "loc", "upper", "ner", "index", "coll", "enter", "e"], "realmId": ["realmrid", "RealmsPath", "realarmID", " realmnHash", " realmnOffset", "workmId", "ironmaId", "ironmId", "realdmOffset", "realmConfig", "realmrOffset", "RealmID", "realamNum", "realfNum", "realmaId", "workfid", "realmsName", "realmNum", "ironmaID", "realmHash", "realmcInt", "realmnOffset", " realmnConfig", "RealmId", "realamID", "realrmInt", "realmid", "ironmaInt", "RealmsName", "realmaID", "workmID", "realmRef", "realmnConfig", "RealmsId", "realarmName", "realfid", "realmrId", "realmeId", "realrmRef", "workmid", "realmaInt", "ironmID", "ironmInt", "workmNum", "realfID", "realarmPath", "realmOffset", "RealmName", "realamid", "realmsID", " realmHash", "realdmHash", "workfNum", "realmrHash", "realdmConfig", "realmcID", "realamId", "realdmId", "realmnHash", "workfId", "realfId", "realmaRef", "realmsId", " realmOffset", "realmrConfig", "realmcId", "RealmsID", " realmConfig", "workfID", "realmnId", "realmeID", "realrmId", "realmInt", "ironmRef", "realarmId", "realmcRef", "realmrNum", "realmID", "realmPath", "ironmaRef", "RealmPath", "realmsPath", "realmName", "realmeName", "realmePath", " realmnId", "realrmID", "realmrID"]}}
{"id1": "21979462", "id2": "3809087", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"url": ["loader", "address", "f", "bel", "data", "ref", "user", "uri", "service", "ssl", "source", "resource", "remote", "path", "rule", "server", "http", "sl", "el", "URL", "base", "file", "page", "gl", "connection", "image", "buffer", "name", "job", "b", "lr", "l", "link", "Url", "loc", "config"], "in": ["gin", "f", "re", "it", "data", "isin", "inn", "ssl", "source", "i", "ln", "ic", "db", "read", "fr", "is", "fb", "input", "init", "min", "din", "lin", "reader", "impl", "ins", "bin", "into", "err", "inner", "s", "buffer", "cms", "b", "ilo", "as", "In", "af", "n", "at", "inc", "ac", "IN", "rx", "nin", "ini", "r", "login", "h", "out", "again"], "sb": ["abb", "pb", "xb", "bh", "rb", "nb", "amb", "bb", "gb", "src", "eb", "sf", "wb", "db", "bc", "ib", "zb", "BB", "erb", "usb", "sth", "buff", "buf", "fb", "sa", "bs", "lb", "bf", "sg", "obb", "bsp", "bm", "bp", "Bs", "ls", "SB", "cb", "ub", "bd", "s", "buffer", "mb", "bt", " eb", "B", "b", "lr", " SB", "kb", "sv", "si", "lab"], "str": ["cl", "f", "bl", "st", "dr", "data", "string", "lc", "i", "div", "sr", "line", "cr", "read", "fr", "tr", "iter", "sl", "list", "pr", "text", "txt", "wr", "sp", "ct", "exp", "err", "spec", "char", "s", "arr", "br", "name", "STR", "obj", "b", "result", "l", "doc", "Str", "pass", "n", "cur", "key", "r", "enc", "coll", "stri"]}}
{"id1": "16048516", "id2": "6371589", "code1": "    public static SVNConfiguracion load(URL urlConfiguracion) {\n        SVNConfiguracion configuracion = null;\n        try {\n            XMLDecoder xenc = new XMLDecoder(urlConfiguracion.openStream());\n            configuracion = (SVNConfiguracion) xenc.readObject();\n            configuracion.setFicheroConfiguracion(urlConfiguracion);\n            xenc.close();\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        }\n        return configuracion;\n    }\n", "code2": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"urlConfiguracion": ["urlConfigurator", "urlConfureaci", "urlConfigutado", "urlConfigureaci", "urlConfiguraton", "urlConfigauraton", "urlConfigureaton", "urlConfigutabet", "urlConfigurerator", "urlConfureacion", "urlconfigaurator", "urlConfureation", "urlConfigURator", "urlconfigauracion", "urlConfigureracion", "urlConfigurateaci", "urlConfigureacion", "urlConfuracion", "urlConfigaurator", "urlConfuraci", "urlConfigurateator", "urlConfigurabet", "urlConfigurateacion", "urlconfiguraton", "urlconfigurator", "urlConfigURation", "urlConfigurateation", "urlConfiguraci", "urlConfiguration", "urlConfigurado", "urlConfigurerado", "urlConfigURaton", "urlconfiguracion", "urlConfigureation", "urlConfurator", "urlConfigURacion", "urlConfureator", "urlConfigurerabet", "urlconfigauraci", "urlconfigauraton", "urlconfiguraci", "urlConfuration", "urlConfigutacion", "urlConfigauracion", "urlConfigureator", "urlConfigureabet", "urlConfigutator", "urlConfigauraci", "urlConfigureado", "urlConfigURaci"], "configuracion": ["Configureateur", "configuraci", "configuralacion", "configoration", "configaurab", "configuralator", "Configureacion", "configureacion", "configutant", "configoraton", "configuration", "calureacion", "Configurant", "configuralation", "configutaton", "configaurateur", "configutacion", "Configureation", "configauraci", "Configureaci", "configureaci", "Configureant", "configuraton", "caluration", "configaurator", "configuralant", "configureab", "Configurateur", "configoracion", "configuraateur", "Configurab", "configuralaton", "calureaton", "configurateur", "Configureab", "configurab", "Configureaton", "configauration", "configurant", "Configuration", "configureation", "configoraci", "Configuraton", "calureation", "Configurator", "Configureator", "caluraci", "configauraton", "Configuraci", "configuraacion", "calureaci", "caluraton", "configureant", "configutaci", "Configuracion", "configurator", "configureaton", "configureateur", "configuraab", "configuralaci", "configauracion", "configuraator", "caluracion", "configureator"], "xenc": ["Xenv", "xEnc", "Xenc", "xec", "xsen", "fxens", "xmlens", "ixsen", "fxenz", "ixec", " xstream", " xEnc", "xmlenv", "fxEnc", "xmlEnc", "XEnc", "Xens", "ixenc", "xmlenc", "ixstream", "exsen", "fxenc", " xenz", "xenz", "xenv", "exstream", "exec", " xec", "xens", " xens", "Xenz", "xstream", " xenv", "exenc", " xsen"]}}
{"id1": "8064604", "id2": "7761195", "code1": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"mgr": ["Mr", "cgr", "mfg", " mr", "mru", "dmrr", " mtr", "pfg", " mfg", "cr", "prr", "pgr", " mru", "mtr", "dmru", "Mtr", "carr", "Marr", " mrr", "mrr", "marr", "Mgr", " marr", "pru", "dmgr", "ctr", "dmfg", "mr"], "cfg": [" conf", "Hash", " chain", "g", "gp", "cf", "gate", "Conf", " config", "db", "conf", " cache", " cf", " configuration", "chain", "bm", "file", "cb", "Msg", "gen", " msg", "MC", "cache", "mem", "mc", " ssh", "config", "map"], "sock": [" socks", "focks", "socket", "sink", "socks", "dsocket", "Socks", " sink", "focket", "opensock", "opensocket", "opensink", "opensocks", "Sink", "Socket", "fink", "Sock", " socket", "dsocks", "dsink", "dsock", "fock"], "_cman": [" _cgr", "_fmn", " _cmn", " _mcmn", "_mmn", "_fgr", "_mman", "_fman", " _cwr", "_mwr", "_mcgr", "_mcwr", " _mcgr", "_mcmn", "_cwr", "_mgr", "_cmn", "_cgr", " _mcwr", "_mcman", " _mcman", "_fwr"], "_sock": ["_csock", "_sindk", "_fsink", "_openserve", "_nsocks", " _wsocks", "_jsdk", "_issock", "_sesdk", "_Snc", "_opensocket", "_sesocket", "_socks", "_opensock", "_cserve", " _wsnc", "_issocket", "_serve", "_nsock", "_sdk", "_csocks", "_wsod", "_opensocks", "_sinock", "_fsocket", " _sod", "_wsnc", "_sod", " _socks", "_issocks", "_snc", "_sesock", "_wocks", "_socket", "_Socks", "_sesocks", "_jsocket", "_wsocks", "_csocket", "_sink", "_fsock", "_wsock", "_Serve", "_issink", "_nsod", "_sinocket", "_Sock", " _snc", "_Socket", "_sinocks", " _wsock", " _wsod", "_fsocks", "_nsnc", "_jsock", "_wocket", "_Sod", "_wock", "_wink", "_jsocks"], "i": ["hi", "phi", "f", "d", "it", "x", "ui", "data", "ti", "uri", "ie", "ni", "bi", "ci", "gi", "qi", "mu", "di", "is", "pi", "value", "xi", "p", "my", "v", "in", "ai", "ix", "num", "u", "k", "m", "iu", "io", "inner", "ip", "ii", "y", "o", "b", "multi", "I", "ri", "j", "l", "index", "n", "si", "li", "ini", "mi", "ji", "r", "field", "h", "oi", "info", "e", "id"], "key": ["number", "length", "prefix", "cert", "patch", "pick", "row", "data", "point", "check", "ie", "trust", "string", "source", "section", "qi", "token", "shift", "rule", "wire", "sign", "str", "entry", "label", "search", "text", "Key", "value", "q", "base", "root", "op", "lock", "kid", "nice", "cy", "query", "mix", "type", "fee", "ke", "k", "phrase", "secret", "connection", "char", "ip", "pair", "json", "name", "code", "change", "pid", "order", "link", "sum", "kh", "ask", "mac", "ace", "index", "fix", "KEY", "match", "id"], "_sout": ["_nort", "_sinout", "_Sort", "_sinio", "_nout", "_sort", "_sinort", "_SOut", "_nio", "_sinOut", "_Sout", "_sio", "_sOut", "_nOut", "_Sio"], "_sinp": ["_iner", "_bisu", "_bisp", "_inps", "_insu", "_insp", "_inp", "_sinu", "_inser", "_biser", "_bisps", "_insps", "_siner", "_inu", "_sinps"], "rand": ["bird", "next", "dr", "rr", "pick", "user", "go", "pad", "cr", "NG", "ind", " random", "ng", "grad", "dist", "random", "roll", "min", "chain", "round", "reader", "gen", "bot", "dev", "state", "range", "rar", "reg", "pattern", "gram", "rc", "nd", "win", "start", "max", "r", "Rand", "rh", "id"], "hex": ["lit", "rex", "length", "x", "digit", "row", "check", "cf", "alpha", "string", "form", "sex", "orig", "div", "token", "pad", "shift", "zip", "buff", "iter", "cross", "text", "dest", "scale", "json", "lock", "raw", "chain", "mix", "num", "temp", "closure", "bin", "pex", "exp", "secret", "oct", "char", "letter", "ip", "serial", "quant", "box", "batch", "su", "pattern", "pack", "cube", "sum", "ph", "cmp", "kh", "wh", "alph", "tri", "transform", "loc", "view", "ex", "crypt", "ticket", "index", "cookie", "auth", "rh", "id"], "seed": ["address", "finger", "delay", "digit", "data", "row", "pick", "user", "ruby", "alpha", "string", "sample", "sex", "source", "token", "shift", "grain", "feed", "slice", "host", "password", "sha", "zip", "input", "scale", "json", "folder", "random", "kid", "root", "dd", "sleep", "shadow", "phrase", "secret", "slave", "char", "serial", "sql", "name", "step", "pattern", "sum", "prime", "test", "cookie", "driver", "rice", "dose", "padding", "theme", "index", "eed", "sudo", "id"], "pass": ["oss", "session", "prefix", "push", "Pass", "wd", "parse", "strip", "flash", "feed", "path", "press", "line", "host", "password", "read", "access", "fail", "cross", "text", "lock", "task", "handle", "rss", "act", "worker", "gen", "secret", "oct", "process", "ress", "code", "keeper", "channel", "step", "pos", "skip", "Password", "ss", "proc", "cache", "run", "post", "PASS", "test", "report", "use", "ass", "auth"], "md5": ["mn512", " md512", "MDol", "dig5", "mp2", " md8", "MD8", " MD5", "MD2", " MD23", "digless", "mn23", "sha512", "mdol", " md23", "md512", " md2", "dig2", "dig3", "MD512", "md23", " md3", "mn5", " MD55", " md55", "MD3", "sha2", "md3", "MDless", "md2", "digol", "mn55", "md55", "mp5", "mp3", "mdless", "md8", "mp8", " mdol", "sha5", "sha8", " mdless", " MD512", "MD5"], "hash": ["version", "ruby", "string", "host", "db", "sha", "password", "text", "html", "base", "lock", "block", "url", "handle", "fill", "secret", "style", "alt", "dig", "header", "code", "hed", "her", "build", "ash", "sum", "ha", "kh", "cache", "addr", "mac", "h", "auth", "id"], "banner": ["canener", "Banener", "blueoser", "banni", "planni", "planner", "Banner", " bannel", "banler", " banoser", "bonler", "bnn", "bannel", "binning", "planning", "bann", "bluener", "bluenel", "binn", "canning", "bnner", "Banning", "plannel", "banener", "bonener", "Banler", "canner", "bnning", "plann", "binner", "canler", "binni", "bonning", " banning", "banoser", "planoser", "bonner", "bluening", "bnni", "banning"], "txt": ["htm", "ext", "rect", "gold", "csv", "data", "wd", "lines", "utt", "git", "xml", "thin", "diff", "rpm", "str", "fx", "tmp", "zip", "buff", "fb", "notes", " text", "text", "json", "html", "kt", "qt", "pdf", "vt", "rss", "cb", "bot", "gz", "xxx", "elt", "tx", "xt", "rt", "xs", "obj", "struct", "details", "bytes", "mobi", "np", "tty", "Text", "hea", "js", "test", "rx", "parser", "tin", "config", "info"], "items": ["ids", "styles", "ends", "grades", "data", "features", "words", "lists", "lines", "days", "abs", "xml", "links", "phones", "effects", "packages", "boxes", "members", "photos", "groups", "orders", "rooms", "opens", "flows", "rows", "products", "events", "Items", "files", "apps", "ants", "qs", "owners", "results", "cells", "articles", "pages", "objects", "ops", "bytes", "ips", "cats", "values", "keys", "item", "models", "pieces", "plugins", "images", "posts", "locks"], "sname": [" sbase", "gname", "gbase", "skey", " sadmin", "sbase", "sadmin", "gkey", " skey", "nskey", "mstitle", "msname", "nsname", "dsadmin", " snames", "snames", "nsbase", "msnames", " stitle", "stitle", "gnames", "dsname", "dstitle", "dsnames", "nsnames", "msadmin"], "spass": [" sposs", " spad", "mposs", "psass", "psoss", "spasses", "mpass", "sposs", "ispiss", "ppiss", " spasses", "ppasses", "mpad", "spad", "pposs", "isposs", "psad", "ppass", " spiss", "mpasses", "psasses", "ispasses", "ispass", "spiss"], "sseed": ["ssecret", "ssseed", "sportssecret", "sspass", "skey", "fhash", "sssecret", "ashash", " shash", "fsex", "fseed", " skey", "asseed", " ssex", "Ssecret", "sportspassword", "askey", "psecret", "pflower", "pseed", "shash", "spassword", "Seed", "fkey", " spassword", "sspassword", "sportspass", "ssex", "ssflower", "Sseed", "Sflower", "sportsseed", "assex", "peed", "sflower", " ssecret"]}}
{"id1": "21092340", "id2": "21125261", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "label": 1, "substitutes": {"pod": ["loader", "plug", "child", "plugin", "peer", "ad", "per", "pad", "host", "Pod", "cer", "pc", "pe", "tmp", "zip", "project", "ce", "pi", "pkg", "p", "od", "part", "pl", "product", "table", "module", "pid", "po", "component", "proc", "cache", "pot", "post", "node", "ods", "object", "bean"], "podArchiveOutputStream": ["podArchivesFileSteam", "podArchivesFileResource", "podArchIVEOutputDirectory", "podArchIVEInputDirectory", "podArchivesFileFile", "podArchiveFileResource", "podArchiveByteFile", "podArchiveWritePath", "podArchivesOutputSteam", "podArchivingWritePath", "podArchiveIOSteam", "podArchiveInputDirectory", "podArchIVEOutputStream", "podArchiveIOResource", "podArchiveIODirectory", "podArchiveInputFile", "podArchivingWriteSteam", "podArchiveFileFile", "podArchivingWriteFile", "podArchiveWriteFile", "podArchiveFileStream", "podArchiveOutputPath", "podArchivingOutputPath", "podArchivesFileStream", "podArchiveOperationResource", "podArchIVEOutputFile", "podArchiveWriteStream", "podArchivingOutputSteam", "podArchiveInputStream", "podArchiveOperationFile", "podArchiveFileDirectory", "podArchiveOutputResource", "podArchiveFilePath", "podArchivingOutputFile", "podArchiveOperationStream", "podArchiveOutputDirectory", "podArchiveInputPath", "podArchivingOutputStream", "podArchiveWriteSteam", "podArchivesOutputFile", "podArchiveIOFile", "podArchiveOutputSteam", "podArchiveByteStream", "podArchIVEInputSteam", "podArchivesOutputResource", "podArchIVEOutputSteam", "podArchiveIOStream", "podArchiveByteDirectory", "podArchiveFileSteam", "podArchiveByteSteam", "podArchiveInputSteam", "podArchiveOperationSteam", "podArchivesOutputStream", "podArchIVEInputFile", "podArchiveOutputFile", "podArchivingWriteStream", "podArchIVEInputStream"], "filename": ["nil", "loader", "application", "named", "f", "prefix", "platform", "which", "uri", "string", "sf", "alias", "Filename", "path", "subject", "label", "kl", "binary", "username", "folder", "kn", "database", "fp", "url", "file", "fil", "dll", "directory", "files", "location", "module", "title", "name", "archive", "route", "property", "l", "download", "FILE", "ename", "fn", "ppa", "SourceFile", "word", "il", "sequence"], "source": ["loader", "target", "src", "uri", "service", "string", "resource", "document", "path", "output", "SOURCE", "slice", "zip", "sl", "input", "text", "parent", "url", "file", "reader", "stack", "connection", "slave", "unit", "image", "seed", "archive", "result", "stream", "Source", "driver", "ource", "copy", "config", "proxy", "use"], "entry": ["address", "child", "it", "data", "row", "ie", "string", "resource", "feed", "path", "line", "zip", "iterator", "this", "parent", "event", "add", "file", "pointer", "reader", "se", "ge", "connection", "letter", "element", "image", "archive", "obj", "result", "or", "stream", "index", "auto", "post", "r", "record", "Entry", "object", "article", "e"]}}
{"id1": "16590954", "id2": "11005804", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"fileString": ["FileStream", "linestring", "resourceStream", "modelString", "resourceString", " filestring", " fileText", "FileStr", "modelText", "baseStr", "FileName", "filestring", "loadText", "fileStream", "lineArray", "lineName", "modelStream", "baseFile", "loadstring", "fileName", "basestring", "FileArray", " fileName", "loadString", "fileArray", "fileText", "lineString", "fileFile", "FileString", "FileText", "fileStr", "loadName", " fileFile", "resourceStr", "baseString", "FileFile", " fileStr", "Filestring", "modelStr", " fileArray", "resourceText"], "ext": ["version", "filename", "x", "data", "content", "format", "prot", "end", "app", "path", "str", "ax", "zip", "class", " Ext", "text", "dist", "desc", "txt", "exe", "req", "EXT", "url", "v", "Ext", "type", "exp", "xt", "name", "code", "dep", "external", "append", "ex", "enc", "config", "extra", "info"], "file": ["queue", "bar", "f", "filename", "it", "socket", "jar", "source", "wave", "resource", "per", "output", "path", "db", "line", "http", "pe", "zip", "let", "class", "binary", "File", "folder", "parent", "base", "fp", "url", "page", "full", "part", "files", "single", "place", "get", "unit", "buffer", "force", "module", "change", "name", "up", "b", "le", "build", "l", "ile", "FILE", "flat", "work", "cache", "ger", "log", "test", "doc", "local", "fe", "h", "model", "use"], "i": ["hi", "phi", "f", "x", "ori", "it", "ui", "uri", "ni", "ci", "qi", "slice", "ind", "limit", "di", "abi", "pi", "p", "mini", "v", "ai", "iu", "yi", "ip", "ii", "multi", "c", "I", "j", "l", "uni", "si", "key", "li", "ini", "mi", "index", "xi", "eni"], "dir": ["ir", "filename", "prefix", "data", "format", "rel", "jar", "uri", "src", "string", "domain", "div", "path", "output", "DIR", "db", "str", "tmp", "zip", "lib", "class", "dist", "folder", "pkg", "base", "url", "directory", " directory", "manager", "type", "module", "name", "Dir", "doc", "cur", "loc", "area", "config", "direction", "coll", "info", "id"], "jarFile": ["archiveDir", " jarDir", "tarLine", "sessionFile", "jarLine", "javaFile", "tarSourceFile", "jarF", "sessionfile", "reportF", "javaFolder", "jarSourceFile", "javafile", "jarDir", "sessionLine", " jarFolder", "javaF", "jarFiles", "archiveFile", "sessionSourceFile", "jarFolder", " jarFiles", "tarFile", " jarLine", "archiveFolder", " jarSourceFile", "javaDir", "archiveFiles", "reportSourceFile", "reportfile", "reportFile", "tarF", "javaFiles", "jarfile", "tarfile", " jarfile", "javaSourceFile"], "fstrm": ["fstM", "fstcm", "fsrM", " fstrum", "fgrcm", "Fstrmd", "fstum", "fbrm", "fstm", "fstrum", " fstrM", " fsrum", " fsrcm", "fgrm", "fsrmd", "fbrM", " fsrm", "fsrum", "Fsrmd", "fstrmd", "fsrcm", "fsrm", " fsrM", "Fstrm", "FsrM", "Fsrcm", "fstrM", "fgrM", "Fsrm", " fstrcm", "fstmd", "fgrmd", "Fstrcm", "fstrcm", "fbrcm", "FstrM", "fbrum"], "in": ["gin", "f", "sync", "socket", "inn", "read", "is", "input", "binary", "init", "p", "min", "din", "conn", "reader", "rin", "part", "ins", "bin", "m", "into", "io", "to", "s", "inner", "image", "up", "c", "inside", "or", "l", "In", "stream", "n", "inc", "ac", "IN", "nin", "r", "login", "again", "pin", "pull", "id"], "out": ["sync", "OUT", "user", "source", "flow", "resource", "output", "off", "line", "plus", "server", "writer", "this", "init", "group", "Out", "v", "conn", "plain", "part", "bin", "m", "exp", "err", "connection", "net", "to", "io", "inner", "image", "self", "call", "up", "client", "channel", "outside", "c", "b", "outs", "all", "doc", "outer", "inc", "pool", "again", "null"], "temp": ["tem", "f", "dump", "template", "it", "wrap", "emp", "home", "source", "form", "path", "output", "db", "server", "Output", "tmp", "iter", "zip", "input", "writer", "fake", "dest", "store", "base", " Temp", "p", "folder", "v", "export", "full", " temporary", "directory", "w", "single", "get", "unit", "buffer", "storage", "archive", "porary", "c", "build", "or", "doc", "pipe", " tmp", "cache", "test", "local", "controller", "api", "key", "clean", "Temp", "config"], "fstrm2": ["fstrms02", "fstrM0", "fstrp1", "fhrms02", "fstm2", "fstM0", "fstrM1", "fstrms2", "fstrM2", "fstrm0", "fstrM02", "fstrp2", "fstrms1", "fstrms002", "fhrms002", "fstM2", "fstrms0", "fstm0", "fhrm1", "fstrmr1", "fstrm02", "fhrms2", "fhrm002", "fstrmr02", "fhrms1", "fstrmr2", "fstrM002", "fstrm1", "fstrmr002", "fstM1", "fstrm002", "fstm1", "fhrm02", "fhrm2", "fstrp0"], "ostrm": ["oscrt", "obsrt", "istrom", "oodrt", "obsrem", "obsrm", "obrom", "oodrob", "odm", "oscmr", "ophrt", "otherrm", "oopmr", "ostrob", "ophm", "obmr", "otherrt", "ostrom", "istrt", "obsrob", "otherrom", "odrm", "ostrt", "odmr", "ostmr", "oscm", "ooprom", "ostrem", "oodrem", "obrm", "istrm", "ooprm", "istmr", "ooprt", "ostm", "odrt", "oscrm", "oodrm", "othermr", "ophrm", "ophmr", "obrt"], "docFile": ["DocFiles", "docFiles", "documentFiles", "documentDir", "DocF", "docF", "DocFile", " docF", "DocDir", " docDir", "docDir", "documentF", "documentFile", " docFiles"]}}
{"id1": "19849797", "id2": "189963", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"sourceFile": ["srcFolder", " sourcefile", "destDirectory", "SourceDirectory", " sourceFolder", "sourceFolder", "ourceDirectory", "srcfile", "ourceUrl", "SourceUrl", "destUrl", "sourceDir", "srcDir", "sourceUrl", "SourceFolder", "ourceFile", "destfile", "Sourcefile", "SourceDir", "ourcefile", "sourcefile", "srcFile", " sourceDir", "SourceFile", "sourceDirectory"], "destFile": ["destDirectory", "DestPath", "DestDir", "DestDirectory", "resultLine", " destDir", "destPath", "destFiles", "srcLine", "srcFiles", "srcDirectory", "srcfile", "resultFile", "destLine", "targetfile", "resultfile", "targetPath", "foreignPath", "DestFile", "sourceFiles", "sourceDir", "srcDir", "resultDir", "destPoint", "foreignfile", "targetFile", "targetFiles", "DestFiles", "foreignFile", " destDirectory", "DestPoint", "foreignFiles", "targetDir", " destPoint", "destfile", "sourcePoint", " destfile", "Destfile", "destDir", "srcFile", "targetLine", " destFiles"], "source": ["session", "target", "wrapper", "core", "reference", "src", "uri", "service", "from", "ie", "site", "resource", "remote", "status", "output", "sin", "SOURCE", "slice", "server", "iter", "input", "ce", "this", "context", "dest", "parent", "secure", "root", "file", "url", "reader", "scope", "object", "manager", "connection", "slave", "get", "inner", "unit", "image", "table", "seed", "storage", "client", "channel", "route", "result", "component", "size", "stream", "index", "current", "start", "cache", "si", "Source", "view", "api", "ource", "scene", "use", "config", "proxy", "null", "id"], "destination": ["constination", "constribution", "destion", "domation", "dominator", "participinate", "Destinator", " destinated", "distination", " destribution", "generination", "destruction", "Destinate", "Destribution", "dominated", "Destion", "destinated", "Destination", "distion", "participinator", "participination", "generinated", "domination", " destruction", "Destruction", "Destinated", "destation", "construction", " destation", "constinator", "identinator", "destribution", "identination", "destinate", "distinator", "distinated", "distruction", "generruction", "destinator", "Destation", "participinated", " destinator", "identinate", "generinator", " destion", "identinated"]}}
{"id1": "6987642", "id2": "9398454", "code1": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"password": ["number", "sword", "address", "prefix", "data", "words", "content", "wd", "user", "Pass", "string", "confirmed", "token", "path", "sha", " Password", "input", " passwords", "text", "username", "value", "p", "database", "phrase", "secret", "hash", "SHA", "name", "code", "pattern", "Password", "pass", "PASS", "crypt", "padding", "word", "out", "auth", "message"], "md": ["pd", "d", "dh", "dr", "sm", "data", "hm", "ad", "pm", "gd", "amd", "mad", "ind", "sha", "di", " Md", "mn", "ng", "grad", "mm", "am", "Cmd", "MD", "dd", "od", "mand", "ma", "mt", "m", "ms", " MD", "bd", "dig", "rm", "mb", "hash", "mg", "vd", "dm", "cmd", "mod", "nd", "hd", "me", "mac", "mag", "mp", "mc", "mo", "metadata"], "encodedPassword": ["Encodedpassword", "enccodedPassword", "EncodedPassword", "encryptedpassword", "encodeUser", "encachedString", "encachedPassword", "enodedText", "encachedSecret", "encryptedText", "encryptedPassword", "encryptedSecret", "encodedUser", "encodingText", "EnccodedUser", "enryptedSecret", "enodedString", "EncodedString", "enccodedString", "encachedText", "enryptedText", "encodingPassword", "encodedString", "EncodedUser", "enccodedUser", "enodedPassword", "encodedpassword", "encryptedUser", "encryptedString", "encodingSecret", "encodepassword", "enryptedPassword", "encodingString", "encodedText", "encodeString", "encodedSecret", "EnccodedString", "EnccodedPassword", "enryptedString", "enccodedpassword", "enodedSecret", "Enccodedpassword", "encodePassword"]}}
{"id1": "10451698", "id2": "3806532", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"source": ["target", "filename", "sync", "data", "src", "ie", "from", "service", "string", "site", "resource", "sf", "proxy", "document", "path", "section", "SOURCE", "slice", "server", "iter", "project", "remote", "class", "ce", "folder", "parent", "secure", "origin", "root", "volume", "file", "url", "reader", "directory", "connection", "slave", "unit", "seed", "force", "image", "storage", "name", "archive", "client", "result", "stream", "start", "cache", "flat", "view", "current", "Source", "null", "ource", "copy", "use", "config", "object", "model"], "destinationDirectory": ["destructionPath", "destinationFile", "destinatorPoint", "destinationSystem", " destationDir", "destinationsFile", " destinationDir", " destinationFile", "destationPath", "DestinationPoint", "DestinationPath", "destinationDatabase", " destationPath", "destinatorDatabase", "destributionFolder", "destinatorSystem", "DestinationsDatabase", " destationDirectory", "destinationsSystem", "destinatorPath", "destinationPoint", "destinationFolder", "destinationsDirectory", "destinatorDirectory", "destructionFile", " destationFile", "destributionDirectory", "DestinationFolder", "destporaryDirectory", "DestinationsDirectory", "destinationsPoint", "destationFile", "DestributionDirectory", "DestributionPath", "destributionPath", "destporarySystem", "destationDirectory", "DestinationsPath", "DestributionPoint", "destructionDir", "DestributionFolder", "destructionDirectory", "DestinationsSystem", "destinationPath", "DestinationDatabase", "destinationsDatabase", "destributionPoint", "destporaryPath", "DestinationDirectory", "destinationsFolder", "destinationDir", "destporaryDatabase", "DestinationSystem", "destationDir", "destinationsDir", "destinatorFolder", " destinationPath", "destinationsPath"], "newDir": ["firstFile", " newDIR", "smallDIR", "nextDir", "firstDirectory", "Newdir", "NewFile", "smallFile", "smallDirectory", "newDirectory", "smallDir", "firstDir", "newDIR", " newdir", " newDirectory", "firstDIR", "newdir", "NewDir", "NewDirectory", "nextdir", "NewDIR", "nextFile", "nextDirectory"], "children": ["filename", "child", "parents", "data", "content", "words", "which", "other", "begin", "web", "rules", "Children", "sub", "blocks", "pes", "plus", "packages", "balls", "members", "each", "list", "iv", "opens", "when", "parent", "errors", "rows", "tests", "url", "mount", "events", "ins", "files", "sort", "roots", "ums", "collection", "pages", "kids", " Children", "all", "values", "current", "scenes", "plugins", "iblings", "loc", "uc", "projects", "names", "ul", "ools"], "i": ["hi", "f", "x", "d", "ori", "ui", "it", "ti", "ie", "uri", "bi", "lc", "ci", "gi", "qi", "end", "slice", "mu", "di", "h", "pi", "xi", "q", "p", "v", "in", "ai", "ix", "part", "u", "type", "m", "k", "iu", "io", "inner", "range", "ip", "ii", "y", "name", "o", "b", "ri", "I", "multi", "c", "fi", "j", "start", "n", "si", "key", "li", "ini", "oi", "mi", "ji", "index", "info", "e", "id"], "newFile": ["createfile", " newFiles", "createDir", "nextDir", "nextDirectory", "newSource", "nextFiles", "oldFiles", "oldDir", "createFile", "newSourceFile", "createSource", "oldFile", "NewFile", "newDirectory", " newSourceFile", "NewSourceFile", "NewFiles", "newFiles", "nextfile", "nextSourceFile", "Newfile", " newDirectory", "nextSource", "NewDir", "NewDirectory", "nextFile", "NewSource", "oldDirectory", "newfile", " newfile"], "output": ["application", "target", "operation", "address", "four", "core", "socket", "service", "other", "resource", "web", "flow", "put", "layer", "response", "Output", "kernel", "option", "generation", "writer", "console", "binary", "again", "parent", "error", "file", "page", "full", "temp", "network", "connection", "unit", "image", "display", "default", "change", "generated", "update", "o", "ilo", "result", "write", "outer", "external", "current", "control", "oper", "after", "complete", "copy", "config", "out", "object"], "input": ["inf", "child", "data", "socket", "request", "form", "resource", "flow", "ack", "through", "http", "binary", "this", "context", "text", "parent", "load", "raw", "error", "in", "Input", "reader", "temp", "keep", "connection", "inner", "io", "s", "image", "buffer", "self", "update", "client", "exec", "instance", "stream", "current", "inc", "ink", "audio", "config", "index", "out", "active", "pull"], "buff": ["f", "length", "bind", "bug", "rb", "data", "flush", "cod", "bb", "gb", "cf", "uff", "feed", "pad", "slice", "comb", "buf", "fb", "ff", "cp", "text", "txt", "load", "shape", "bin", "cb", "Buff", "boot", "gz", "bound", "oct", "char", "rib", "comment", "buffer", "ffff", "batch", "cmd", "b", "pack", "uf", "ph", "count", "fe", "ob", "back", "info", "cell"], "read": ["lex", " write", "f", "length", "x", "d", "sync", "allow", "readable", "find", "check", "parse", "Read", "end", "send", "feed", "and", "tell", "ind", "slice", "wait", "len", "text", "reading", "load", "add", "rate", "transfer", "raw", "reader", "select", "play", "se", "fill", "seek", "k", "io", "get", "buffer", "ip", "READ", "open", " count", "b", "write", "skip", "exec", "en", "close", "size", "reads", "start", "pass", "ask", "loop", "run", "index", "ink", "n", "count", " load", "copy", "use", "create", "id"]}}
{"id1": "5543349", "id2": "20568568", "code1": "    public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) {\n        String code = \"\";\n        UserFunction function = null;\n        ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\");\n        try {\n            URL url = new URL(codeBase, directoryAndFile);\n            InputStream in = url.openStream();\n            BufferedReader inReader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = inReader.readLine()) != null) {\n                code += line + \"\\n\";\n            }\n            inReader.close();\n        } catch (Exception e) {\n            Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");\n        }\n        ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\");\n        FunctionParser funcParser = new FunctionParser();\n        function = funcParser.parseFunction(code);\n        function.setName(mFileName);\n        ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\");\n        return function;\n    }\n", "code2": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"codeBase": ["Codebase", " codebase", "CodeDir", "urlArea", "urlBase", "homeBased", "CodeBase", "codebase", "homeDir", "homeBase", " codeArea", "homebase", "CodeArea", "CodeBased", "codeBased", " codeBased", "urlbase", "codeArea", "codeDir", " codeDir"], "directoryAndFile": ["DirectoryAndFile", "directoryandFile", "directoryAndString", "directoryAndfile", "DirectoryWithfile", "directoryANDFile", "directoryOrfile", "DirectoryAndPath", "directoryWithfile", "DirectoryOrFile", "directoryOrFile", "directoryFromFile", "DirectoryWithFile", "directoryandPath", "directoryOrPath", "directoryFromSourceFile", "directoryandfile", "DirectoryWithPath", "directoryWithFile", "directoryOrSourceFile", "directoryFromPath", "DirectoryOrPath", "directoryANDString", "DirectoryAndfile", "directoryWithString", "directoryAndPath", "directoryAndSourceFile", "directoryandSourceFile", "directoryandString", "DirectoryOrSourceFile", "directoryWithPath", "directoryFromfile", "DirectoryAndString", "directoryANDPath", "DirectoryAndSourceFile", "directoryANDfile", "DirectoryOrfile", "DirectoryWithString"], "mFileName": ["mFilenamePath", "mFilesType", "mFileExt", "MFunctionName", "mSourceFilePath", "mFunctionInfo", "mClassName", "MFilePath", "mFileType", "mSourceFilename", "mFilesExt", "mFilenameVersion", "mCodeType", "mClassPath", "MFunctionname", "MFilesName", "MFilesType", "mFunctionPath", "MSourceFileName", "mCodeVersion", "MFileVersion", "mFilename", "mFilenamename", "MFilesPath", "mCodeName", "mFileInfo", "MFilesExt", "mStringPath", "mFilenameName", "mFilesName", "MFileExt", "mStringExt", "MFileName", "mStringName", "mFunctionname", "mCodename", "MFileInfo", "MSourceFilePath", "mStringType", "mSourceFileVersion", "mFunctionName", "MSourceFilename", "mSourceFileName", "mFileVersion", "mFname", "MSourceFileVersion", "MFileType", "mFInfo", "MFunctionInfo", "mFName", "mFilesPath", "mCodePath", "MFunctionPath", "mCodeExt", "mClassInfo", "mStringname", " mStringPath", " mFilename", " mFilePath", "mFilePath", "mClassname", " mStringName", "mFPath", "MFilename", " mStringname"], "function": ["number", "system", "expression", "operation", "f", "fun", "service", "string", "section", "form", "resource", "document", "output", "role", "handler", "rule", " module", "functional", "lib", " functionality", "class", " library", "member", "value", "array", "func", "file", "event", "fp", "part", "Function", "library", "lambda", "connection", "action", "future", "element", "module", " object", "ctor", "job", "obj", "result", "instance", "feature", "python", "work", "position", "fn", "word", "object", " implementation", "callback"], "url": ["loader", "address", "f", "data", "rel", "jar", "uri", "user", "ssl", "string", "source", "i", "resource", "web", "feed", "path", "server", "http", "ur", "sl", "URL", "blog", "base", "file", "page", "reader", "er", "location", "connection", "image", "name", "update", "b", "browser", "l", "download", "stream", "Url", "log", "key", "api", "r", "ball"], "in": ["loader", "f", "a", "serv", "data", "socket", "inn", "ssl", "source", "i", "resource", "read", "fr", "is", "input", "arin", "din", "file", "lin", "reader", "ins", "bin", "er", "err", "connection", "io", "inner", "buffer", "image", "client", "b", "as", "In", "stream", "inc", "ac", "IN", "ini", "r", "login", "out", "Reader"], "inReader": ["outStream", "inParser", "InParser", "inRead", "INReader", "incFile", "outRead", " inStream", "outWriter", "incRead", "inFile", "InReader", "outParser", "InStream", "InWriter", " inWriter", "incWriter", "INWriter", "incReader", " inParser", "inWriter", " inRead", "INRead", "InRead", "inStream", "InFile", "outReader", "INStream", " inFile"], "line": ["number", "cl", "f", "column", "re", "data", "content", "row", "lines", "string", "source", "i", "lc", "LINE", "str", "id", "lined", "cr", "entry", "pe", "character", "ine", "cell", "lf", "text", "block", "error", "file", "lin", "page", "part", "inline", "type", "char", "comment", "letter", "name", "Line", "c", "write", "le", "l", "link", "pass", "include", "log", "key", "r", "record", "word", "model", "e", "message"], "code": ["number", "hello", "length", "path", "const", "ce", "class", "escape", "Code", "type", "java", "buffer", "change", "program", "body", "config", "e", "callback", "address", "f", "x", "data", "script", "go", "success", "file", "close", "test", "key", "count", "complete", "use", "id", "content", "check", "string", "fore", "zip", "text", "func", "state", "module", "c", "codes", "cache", "coded", "status", "create", "message", "expression", "cod", "end", "error", "page", "co", "closure", "call", "name", "result", "age", "frame", "ode"], "funcParser": ["funcBuilder", "functionBuilder", "funcFile", "ctxParser", "ctxLoader", "fcPar", "funcLoader", "fcParser", "ctxPar", "methodBuilder", "funcLine", "functionFile", "functionLine", "fcLoader", "methodParser", "fcReader", "codeParser", "functionLoader", "functionParser", "codeBuilder", "methodLine", "methodFile", "funcPar", "codeLine", "ctxReader", "functionReader", "codeFile", "funcReader", "functionPar"]}}
{"id1": "14783950", "id2": "11562165", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 1, "substitutes": {"fileList": ["FileStream", "filelist", " fileCollection", "modelEx", "modelCollection", "fileChain", "ziplist", " fileSet", "fileEx", "FileChain", "stringChain", "FileSet", "stringlist", "wordName", "inputStream", "FileName", "FileList", " fileStream", "Filelist", "fileStream", "fileSet", "fileCollection", "wordStream", "modelStream", "wordString", "inputList", "fileString", "zipList", "wordList", "FileString", "inputCollection", "stringList", " fileString", "zipName", " filelist", "modelList", "inputEx", "zipSet", " fileEx", "stringName", " fileChain"], "zipFileName": ["zipFilename", "archiveDirPath", "folderFilePath", "zipFileDir", "zipGlobalPath", "folderGlobalPath", "zipFullNames", "folderFileName", "zipGlobalNames", "zipFullDir", "zipPackageDir", "zipGlobalName", "folderGlobalNames", "zipFullName", "archiveFileDir", "zipFilePath", "zipDirDir", "folderGlobalname", "zipDirname", "archiveDirDir", "zipFullPath", "folderGlobalName", "zipGlobalname", "zipDirPath", "folderFileNames", "archiveFileName", "folderFilename", "archiveDirName", "zipFullname", "zipDirName", "zipPackageName", "zipFileNames", "archiveFilePath", "zipDirNames", "zipPackagePath"], "fos": ["Fos", "FoS", "faos", " fosh", "afis", "Fis", "flos", "fosh", "infoS", "afaos", "afos", "infaos", "flis", "foS", "Fosh", "afoS", "infos", "infis", "flosh", "Faos"], "zos": ["tz", "phi", "bos", "nz", "budget", "ses", "ozo", "lins", "LOS", "es", "zen", "inos", "zz", "zik", "zers", "cos", "zb", "zag", "ZA", "zip", "bag", "z", "zar", "abi", "zl", "onz", "zer", "zy", "zi", "jobs", "webkit", "os", "obb", "jas", "fits", "zo", "dos", "zzy", "closure", "zon", "css", "zx", "gz", "bis", "bes", "oses", "lol", "outs", "rez", "fi", "kos", "ros", "iframe", "zan", "uz", "chini", "seconds", "loop", "osi", "packs", "spin", "zes", "ZI"], "iter": ["walker", "ir", "itter", "f", "next", "it", "ener", "cher", "fer", "gener", "ie", "parse", "i", "former", "end", "slice", "http", "fr", "is", "iner", "iterator", "list", "ator", "el", "ite", "file", "chain", "keep", "er", "izer", "inter", "ter", "err", "sort", "inner", "finder", "ip", "liter", "Iterator", "inse", "set", "order", "Iter", "outer", "inc", "oper", "iz", "loc", "test", "upper", "ner", "ser", "index", "coll", "enter", "e"], "fileName": ["fullName", "FilePart", "filename", " fileInfo", "fullOpen", "FilePath", "fileInfo", "pageString", "Filename", "localPart", "filePath", "fLine", "filenamename", "fileFull", " fileType", "FileName", "filenameInfo", " fileUrl", "FileUrl", "simpleOpen", "pageName", "FileData", " fileData", "simplePath", "FileLine", " fileLine", "fPart", "filenameFull", "filePart", "currentname", "fileString", "fileOpen", " filePath", "localname", "fileData", "filenameName", "currentUrl", "FileFull", "FileString", "fname", " filePart", " fileString", "fileUrl", "currentData", "simpleName", "currentName", " fileOpen", "pageType", "fullPath", " fileFull", " filename", "fileType", "fileLine", "fName", "localName", "pagename", "localPath", "FileType", "FileInfo"], "ind": ["bind", "length", "x", "d", "pull", "cond", "ad", "inn", "i", "ci", "end", "div", "mid", "eff", "fr", "ord", "z", "len", "ded", "Ind", "vert", "ix", "in", "rib", "ii", "dir", "pos", "j", "pend", "nd", "start", "inc", "pt", "loc", "val", "count", "ld", "index", "wind", "IND", "mind", "id"], "shortName": ["fullName", "longPath", " shortString", "smallname", "longName", "shortString", "smallPath", "longPart", "fullString", " shortname", "Shortname", "shortPath", "longname", "fullname", "ShortName", "shortname", "ShortPath", " shortPath", " shortLine", "smallPart", "ShortString", "shortLine", "shortPart", "fullLine", "fullPath", "ShortPart", "longLine", "smallName"], "fis": ["Fos", " fisa", "gisa", " fris", " fs", "gios", "fris", "cfris", "afis", "Fis", " fiss", "pios", " fios", "afiss", "fios", "cfis", "pisa", "Fs", "afos", "pris", "fisa", "gris", "cfiss", "fiss", "cfos", "afris", "Fiss", "cfs", "pis", "fs", "gis"], "buf": ["queue", "ba", "pb", "bl", "bh", "rb", "data", "feat", "bb", "wb", "bc", "tmp", "buff", "fb", "bu", "grab", "cv", "seq", "ff", "lb", "bf", "v", "vec", "fd", "bp", "lim", "bin", "cb", "Buff", "box", "bd", "buffer", "br", "done", "batch", "b", "bytes", "rc", "uf", "cur", "loc", "uc", "bag", "la"], "bytesRead": ["bytesWrite", "secondsRead", "flowsLength", "wordsLength", "wordsWrite", "flowsRead", "tesRead", "wordsUse", "tesWrite", "secondsLength", "flowsNeed", "bytesSkip", " bytesLoad", "bitsLoad", " bytesWrite", "tesLoad", "secondsWrite", "bitsLength", "bytesLength", " bytesSkip", "bytesLoad", "bitsRead", "bitsSkip", "secondsNeed", "bitsWrite", "bytesUse", " bytesNeed", "bytesNeed", "tesSkip", " bytesLength", "wordsRead", "flowsWrite", " bytesUse", "bitsUse"]}}
{"id1": "5759961", "id2": "1371265", "code1": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "code2": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "label": 0, "substitutes": {"user": ["account", "author", "tool", "bug", "plugin", "data", "content", "you", "service", "request", "string", "home", "resource", "usr", "profile", "word", "per", "app", "rule", "replace", "person", "db", "valid", "password", "editor", "entry", "facebook", "project", "this", "class", "group", "username", "book", "parent", "blog", "base", "creator", "query", "User", "full", "student", "one", "uid", "used", "team", "style", "self", "force", "users", "module", "name", "up", "job", "result", "or", "USER", "me", "log", "clean", "record", "use", "config", "object", "model", "e", "ver"], "digest": ["Digert", "mdest", "genest", "digit", "digge", "bigge", " digEST", "digEST", "bigert", "bigest", "bigester", "genEST", "diger", "signest", "Digester", "signer", "Digge", "digester", "digert", " digge", "mdge", "mdit", "signester", " digester", " digert", "DigEST", " diger", "genit", "genge", "Digit", "Diger", "signEST", "mdEST", "biger", "Digest"], "hash": ["number", "version", "Hash", "depth", "check", "string", "hex", "empty", "db", "id", "sha", "password", "total", "search", "html", "base", "query", "block", "array", "url", "full", "num", "fill", "image", "code", "update", "her", "build", "ash", "sum", "memory", "index", "max", "cache", "mac", "current", "math", "key", "count", "h", "match", "message"], "bigInt": ["bigInteger", "hugeint", "hashInt", "bigint", "hashint", "hashInteger", "largeInt", "bigUrl", "BigInt", " bigint", "hugeUrl", "Bigint", "largeString", " bigString", "largeint", "hashUrl", "largeInteger", "hugeInt", "BigString", "BigInteger", " bigUrl", " bigInteger", "bigString", "hugeInteger"], "hashtext": ["Hashstring", "ashfeed", "hashpath", "Hashfeed", "sumword", "hashword", "sumstring", "ashpath", "HashText", " hashword", "sumText", "hashfeed", "ashText", "ashword", " hashpath", "hashText", "sumtext", "Hashword", "hashTEXT", "ashtext", " hashTEXT", "Hashtext", " hashstring", "sumfeed", "Hashpath", "ashstring", "ashTEXT", "HashTEXT", "hashstring", " hashText", "sumTEXT"]}}
{"id1": "8000624", "id2": "659316", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "label": 1, "substitutes": {"dest": ["delete", "target", "rest", " Dest", "filename", "data", "content", "src", "them", "orig", "source", "wb", "Dest", "path", "output", "exit", "tmp", "comb", " destination", "class", "dist", "folder", "desc", "cont", "txt", "sup", "file", "die", "destroy", "temp", "w", "img", "bin", "opt", "table", "done", "name", "later", "obj", "write", "flat", "test", "transform", "object"], "in": ["issue", "gin", "f", "vin", "re", "x", "isin", "inn", "source", "i", "thin", "wave", "ln", "con", "sin", "plus", "ax", "input", "lib", "init", "fa", "kin", "din", "conn", "lin", "reader", "rin", "ins", "bin", "m", "connection", "inner", "s", "image", "up", "b", "as", "inside", "l", "win", "In", "pass", "n", "cin", "inc", "IN", "ac", "nin", "ini", "r", "login", "h", "again", "pin", "pull", "id"], "out": ["ext", "target", "sync", "OUT", "x", "data", "socket", "user", "other", "no", "i", "app", "output", "off", "plus", "lib", "writer", "this", "vert", "Out", "ou", "conn", "file", "url", "part", "w", "temp", "timeout", "bin", "object", "one", "err", "call", "net", "io", "inner", "image", "name", "up", "client", "o", "b", "outside", "outs", "exec", "not", "or", "outer", "external", "n", "cache", "inc", "nin", "our", "ex", "copy", "again", "pin"], "c": ["ca", "cm", "cl", "f", "cu", "x", "d", "content", "cf", "lc", "i", "ci", "ic", "C", "dc", "cr", "bc", "pc", "t", "ce", "fc", "p", "cy", "v", "esc", "sc", "u", "ct", "cb", "m", "arc", "comment", "char", "exc", "buffer", "code", "ec", "abc", "o", "cc", "rc", "l", "n", "ac", "oc", "ch", "xc", "r", "uc", "enc", "config", "pointer", "col", "e"]}}
{"id1": "6906419", "id2": "9550506", "code1": "    public static String encryptPassword(String password) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA1\");\n            digest.update(password.getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                int halfbyte = (hash[i] >>> 4) & 0x0F;\n                int two_halfs = 0;\n                do {\n                    if ((0 <= halfbyte) && (halfbyte <= 9)) {\n                        buf.append((char) ('0' + halfbyte));\n                    } else {\n                        buf.append((char) ('a' + (halfbyte - 10)));\n                    }\n                    halfbyte = hash[i] & 0x0F;\n                } while (two_halfs++ < 1);\n            }\n            return buf.toString();\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    private String cookieString(String url, String ip) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update((url + \"&&\" + ip + \"&&\" + salt.toString()).getBytes());\n            java.math.BigInteger hash = new java.math.BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            filterConfig.getServletContext().log(this.getClass().getName() + \" error \" + e);\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"password": ["sword", "address", "prefix", "data", "words", "content", "wd", "user", "string", "confirmed", "token", "path", "project", "input", " passwords", "text", "username", "p", "database", "array", "phrase", "secret", "buffer", "seed", "name", "pattern", "Password", "pass", "PASS", "key", "crypt", "padding", "word", "auth", "message"], "digest": ["initText", "hashester", "diffested", " digEST", "digEST", "DigText", "Digeter", " digText", "diffester", "diffest", " digested", "diger", "digests", "Digested", " digeter", "signest", "Digester", "signer", "digester", "signester", " digester", "initests", " digests", "Digests", "initEST", "DigEST", " diger", "hasheter", "digested", "Diger", "signEST", "diffEST", "digText", "digeter", "initest", "hasher", "hashest", "Digest"], "hash": ["number", "cover", "filter", "address", "f", "version", "Hash", "bug", "bh", "check", "mask", "hex", "wave", "diff", "sh", "id", "sha", "search", "value", "html", "block", "query", "array", "error", "url", "ashes", "handle", "history", "bin", "secret", "char", "buffer", "image", "header", "code", "hed", "batch", "build", "ash", "sum", "memory", "ha", "index", "cache", "kh", "log", "key", "body", "count", "h", "map", "auth", "match", "message"], "buf": ["abb", "queue", "ba", "ctx", "pb", "f", "bh", "rb", "data", "nb", "port", "runner", "bb", "src", "sb", "home", "builder", "wb", "pad", "bc", "db", "uber", "tmp", "buff", "fb", "bu", "cv", "cas", "pkg", "bf", "func", "fp", "v", "url", "vec", "img", "bin", "cb", "Buff", "box", "ab", "buffer", "vr", "abc", "Buffer", "coll", "conv", "b", "uf", "va", "af", "fw", "uv", "cur", "cmp", "aux", "cap", "append", "uc", "ob", "config", "out", "bag", "la"], "i": ["hi", "phi", "f", "length", "a", "x", "d", "ui", "it", "ti", "uri", "ie", "ci", "gi", "qi", "slice", "mu", "di", "h", "init", "abi", "pi", "p", "mini", "v", "ix", "ai", "u", "type", "iu", "io", "ip", "ii", "info", "o", "b", "c", "I", "multi", "fi", "ri", "j", "l", "n", "uni", "si", "key", "li", "ini", "count", "oi", "ji", "index", "xi", "e", "id"], "halfbyte": ["Halfbit", "halfbit", "superchar", "quarterbit", "Halfchar", " halfabyte", "thirdsecond", "postbit", "quarterurl", "wardurl", "quarterbyte", " halfByte", "sidebit", "littlebit", "halfnumber", " halfbit", "halfbytes", "littlebyte", "quarterabyte", " halfchar", "halfchar", "halfreference", "postabyte", "littleByte", "HalfByte", "quarterbytes", "quartersecond", "superbit", " halfbytes", "Halfbyte", "quarterByte", "superbyte", "halfabyte", "halfByte", "sidebyte", "quarternumber", " halfurl", "halfsecond", "littlereference", "halfurl", "sideByte", " halfreference", " halfnumber", "thirdnumber", "sidereference", "wardbyte", "wardbytes", "thirdbyte", "postbyte", " halfsecond"], "two_halfs": ["two_partis", "two_Halfbytes", "two_quarterrows", "two_Halfis", "two_partrows", "two_thirdrows", "two_commons", "two_quarterows", "two_hatows", "two_thirds", "two_halfions", "two_thirdis", "two_thirdbytes", "two_parts", "two_halfbytes", "two_commonows", "two_hatrows", "two_commonrows", "two_Halfrows", "two_commonions", "two_hats", "two_hations", "two_Halfs", "two_halfrows", "two_quarters", "two_partbytes", "two_halfis", "two_quarterions", "two_halfows"]}}
{"id1": "14567939", "id2": "10715601", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"name": ["hello", "account", "named", "address", "data", "user", "string", "alias", "path", "plus", "member", "class", "parent", "function", "base", "file", "part", "type", "normal", "secret", "NAME", "image", "hash", "Name", "ame", "create", "n", "definition", "key", "clean", "word", "object", "info", "names", "auth", "id"], "password": ["sword", "account", "prefix", "data", "words", "wd", "user", "paste", "string", "token", "path", "input", " passwords", "text", "username", "value", "stroke", "phrase", "security", "secret", "wallet", "hash", "seed", "priv", "device", "code", "pattern", "Password", "pass", "PASS", "key", "crypt", "padding", "attribute", "word", "auth"], "digest": ["mdest", "commested", "decit", "Digher", "digit", "checkher", "decature", "digender", "digusher", "decested", "checkested", "Digusher", " digested", "mdender", "diger", "commit", "signusher", "Digested", "dest", "signest", "checkester", "Digester", "signer", "dested", "digester", "digature", "signester", " digender", "mainester", " digester", "commature", "checkest", "mdusher", "dature", " diger", "decest", "digested", "digher", "mainest", "commest", " digusher", "mainer", "Digender", " digher", "Diger", "mainested", "dit", "Digest", "mdester"]}}
{"id1": "4501356", "id2": "6517139", "code1": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "code2": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "label": 1, "substitutes": {"profileDiff": ["styleDiff", "imageDust", "styleInfo", " profileInfo", "profDiff", " profileDelta", "profilePath", "profilediff", "stylediff", " profilePath", "picturediff", " profilediff", "settingsDiff", "summaryInf", "profileDelta", "messageDiff", "familyInfo", " profileEdit", "pictureInfo", "settingsDust", "familyDiff", "pictureName", "messagePath", "familyInf", "messageInfo", "profdiff", "profileDie", "profileDust", "styleName", "summaryInfo", " profileName", "summaryEdit", "imageDiff", "imageDelta", "profileInf", "profileName", "profPath", "profInfo", "profileInfo", " profileInf", "summaryDiff", "imageDie", "messagediff", "pictureDiff", "settingsDelta", " profileDie", "familyEdit", "settingsDie", "profileEdit", " profileDust"], "normaliseWhitespace": ["normaliseWhpacepaces", "normaliseWhipesspace", "normaliseWitespace", "normaliseWitesSpace", "normaliseWpacespaced", "normaliseWhpacespaces", "normaliseWhpacespace", "normaliseWhickspaces", "normaliseWhpacespaced", "normaliseWhipespaced", "normaliseWhitespaced", "normaliseWhipspace", "normaliseWpacesSpace", "normaliseWhipsSpace", "normaliseWitespaced", "normaliseWitesspace", "normaliseWpacespace", "normaliseWhitespaces", "normaliseWhipsspace", "normaliseWhitesspace", "normaliseWhitesSpace", "normaliseWhickspaced", "normaliseWhickspace", "normaliseWhipespaces", "normaliseWhpacesspace", "normaliseWpacespaces", "normaliseWhpaceSpace", "normaliseWhipespace", "normaliseWitespaces", "normaliseWhpacepace", "normaliseWhpacesSpace", "normaliseWpacesspace", "normaliseWhicksspace", "normaliseWhipspaces"], "md": ["f", "pd", "d", "msg", "wd", "pm", "gd", "amd", "mad", "diff", "db", "sha", "ds", "editor", "meta", "mm", "Cmd", "bf", "MD", "dd", "od", "mand", "ma", "mt", "m", " MD", "bd", "rm", "dig", "mb", "hash", "mg", "dm", "cd", "sd", "cmd", "b", "hd", "df", "me", "mac", "mag", "mp", "mc", "metadata", "message"]}}
{"id1": "15362793", "id2": "1235538", "code1": "    public static String ReadURL(URL url, boolean textonly) {\n        try {\n            URLConnection uconn = url.openConnection();\n            Object ucont = uconn.getContent();\n            if (ucont instanceof InputStream) return ReadInputStream((java.io.InputStream) ucont, textonly); else return \"\" + ucont;\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 0, "substitutes": {"url": ["address", "bug", "user", "uri", "jar", "service", "ssl", "string", "source", "web", "resource", "path", "host", "str", "server", "http", "fr", "ur", "sl", "URL", "this", "secure", "base", "conn", "file", "page", "impl", "connection", "err", "io", "image", "or", "l", "ll", "link", "twitter", "Url", "loc", "api", "config"], "textonly": ["Textempty", "extempty", "textempty", "extonly", "Textonly", "extOnly", " textOnly", "TextOnly", " textempty", "textOnly"], "uconn": ["ucconnect", "ucconn", "uConn", "UConn", "ucconfig", "unconf", "Uconnection", "Uconf", "uconf", "Uconnect", "unconnection", "ucconnection", "unConn", "Uconfig", " uconnection", " uconfig", " uconnect", "uconnection", "Uconn", " uconf", "uconnect", " uConn", "unconn", "uconfig"], "ucont": ["cufort", "cunt", "rcent", "rcont", "bcront", "bcfort", "ucent", "unicomm", "rcONT", "ucient", "cuent", "ucONT", "unicnt", "ucfort", "acont", "ucore", "uciont", "uccONT", "cuomm", "ucant", "bcnt", "ucront", "uccfort", "uccont", "bcomm", "uccore", "acnt", "acant", "unicfort", "acent", "unicent", "uccnt", "unicont", "unicront", "ucomm", "ucint", "unicore", "cuont", "bcont", "ucnt", "cuant", "uccront", "uccent", "unicONT", "uciant", "rcore"]}}
{"id1": "5676111", "id2": "19687456", "code1": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 0, "substitutes": {"cnt": ["fNT", "Cnd", " cwd", "Cwd", "encNT", "cnd", "encnt", "rcnt", "fnt", "Cnt", "cwd", "rcNT", " cnd", " cnn", " cnc", "cNT", " cNT", "cst", "Count", "cnc", "rcnd", "encst", " count", "cnn", "fount", "Cst", "fwd", " cst", "Cnc", "count", "CNT", "Cnn", "encnn", "rcnc"], "url": ["session", "ir", "f", "bel", "socket", "uri", "bb", "git", "ssl", "source", "resource", "web", "path", "host", "str", "server", "http", "ur", "sl", "org", "URL", "blog", "file", "page", "impl", "ls", "www", "connection", "get", "image", "open", "name", "client", "channel", "c", "b", "l", "ll", "download", "Url", "cache", "log", "cur", "loc", "r", "config", "coll"], "conn": ["oss", "Connection", "ca", "ctx", "cm", "socket", "ssl", "connect", "ci", "con", "cn", "dc", "server", "http", "org", "cli", "init", "nc", "cp", "p", "os", "ens", "co", "ai", "act", "ct", "cb", "connection", "err", "io", "open", "ec", "client", "conv", "c", "exec", "not", "en", "Conn", "n", "ann", "cur", "loc", "ch", "api", "ob", "enc", "out", "coll", "col"], "is": ["ir", "lis", "ris", "ui", "uri", "src", "iss", "iris", "ie", "isl", "i", "es", "ci", "ais", "ssl", "ois", "ib", "http", "us", "iter", "init", "bs", "isa", "os", "in", "ai", "iso", "res", "io", "s", "ip", "bis", "open", "IS", "ws", "info", "ios", "ri", "as", "or", "close", "Is", "isc", "are", "isi", "loc", "api", "ob", "im", "il", "id"], "filename": ["nil", "queue", "f", "length", "prefix", "format", "uri", "string", "source", "sf", "ername", "path", "output", "Filename", "nl", "password", "class", "username", "folder", "utf", "fp", "file", "fil", "fd", "directory", "files", "location", "phrase", "connection", "title", "family", "name", "l", "size", "ename", "loc", "key", "fn", "login", "il"], "fos": ["Fos", "fdis", " ficks", " fose", "fose", "Ficks", "fdicks", "fdo", "gios", "efoss", "go", "efos", "fus", " fo", "goses", "los", "Fis", " foss", "fios", "Foss", " fus", "Fus", "loses", "Fose", "fis", "foss", "Fios", "fo", "efose", "fdos", "ficks", "foses", "gos", "efus", "Fo", "Foses", " fis", "lo", "lios"], "buffer": ["number", "queue", "border", "address", "length", "uffer", "data", "flush", "reference", "bb", "counter", "source", "wave", "document", "output", "feed", "layer", "server", "read", "limit", "iter", "buff", "buf", "fb", "pause", "input", "binary", "duration", "base", "vector", "shape", "page", "file", "reader", "transfer", "phrase", "offset", "header", "seed", "Buffer", "batch", "channel", "bytes", "b", "result", "memory", "size", "cache", "position", "padding", "null", "sequence"]}}
{"id1": "4599372", "id2": "411595", "code1": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"len": ["lit", "f", "length", "data", "lp", "string", "i", "lc", "ln", "lt", "line", "str", "limit", "sl", "el", "list", "lf", "base", "file", "lin", "part", "code", "pos", "le", "en", "l", "size", "ll", "Len", "n", "loc", "split", "val", "count", "fn", "enc", "body", "li", "e"], "sw": ["iw", "serv", "rw", "bb", "sb", "sf", "es", "wb", "nw", "wa", "SW", "sr", "sh", "WS", " SW", "zip", "sl", "writer", "ow", "aw", "sa", "wx", "wp", "sc", "wr", "Sw", "w", "sp", "ww", "io", "hw", "ws", "wra", "tw", "ss", "stream", "sv", "fw", "wt", "wh", "fl", "so", "ew", "lv", "null", "sn"]}}
{"id1": "4686922", "id2": "19147281", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"resourcePath": [" resourceId", " resourceUrl", "stringpath", "sourcePath", "resourceFolder", " resourceFolder", "sourcepath", "servicepath", "ResourceUrl", "resourceUrl", "servicePath", "sourceId", "sourceUrl", "ResourcePath", "Resourcepath", "stringFolder", "resourceId", "ResourceId", " resourcepath", "stringPath", "resourcepath", "serviceFolder"], "dest": ["target", " Dest", "filename", "data", "content", "src", "home", "source", "resource", "sac", "wb", "Dest", "path", "output", "const", "resources", "tmp", "comb", "project", " destination", "class", "dist", "desc", "store", "folder", "txt", "sup", "file", "destroy", "transfer", "die", "prop", "temp", "img", "de", "contract", "default", "done", "later", "route", "result", "trans", "flat", "config"], "in": ["gin", "f", "re", "isin", "socket", "inn", "source", "i", "resource", "thin", "con", "sin", "plus", "is", "input", "arin", "init", "this", "rec", "kin", "din", "conn", "file", "lin", "reader", "rin", "url", "ins", "bin", "connection", "inner", "image", "up", "c", "b", "as", "inside", "win", "In", "pass", "n", "inc", "cin", "IN", "nin", "ini", "r", "like", "login", "again", "id"], "out": ["ext", "f", "sync", "OUT", "a", "user", "socket", "source", "i", "app", "output", "off", "server", "cos", "ax", "lib", "writer", "this", "parent", "Out", "conn", "file", "co", "w", "ins", "temp", "bin", "boot", "one", "err", "net", "io", "s", "image", "up", "client", "obj", "o", "b", "outside", "outs", "exec", "all", "outer", "In", "n", "at", "inc", "cache", "norm", "cookie", "auto", "ex", "copy", "again", "null"]}}
{"id1": "21125261", "id2": "23452437", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"is": ["ir", "lis", "ists", "ris", "serv", "iss", "src", "iris", "ses", "i", "es", "ais", "does", "has", "gets", "its", "opens", "ics", "isa", "os", "in", "iso", "ai", "ins", "res", "ls", "s", "bis", "IS", "mis", "ws", "ios", "as", "Is", "ps", "stream", "isi", "si", "out", "info", "fs", "id"], "byteArrayOutputStream": ["byteStringInputPath", "byteArrayByteSteam", "byteStringOutputFile", "byteArrayInputFile", "byteArrayoutputContext", "byteArrayOutputSteam", "byteArrayOutputPath", "byteStringOutputString", "byteStringInputContext", "byteStringInputStream", "byteStringInputSteam", "byteArrayByteFile", "byteStringOutputStream", "byteArrayFilePath", "byteArrayByteString", "byteStringInputString", "byteArrayoutputPath", "byteArrayInputSteam", "byteStringOutputPath", "byteArrayInputString", "byteArrayFileString", "byteArrayInputContext", "byteArrayOutputString", "byteArrayIOSteam", "byteArrayFileContext", "byteArrayFileStream", "byteArrayOutputContext", "byteArrayInputStream", "byteArrayFileFile", "byteStringOutputContext", "byteArrayIOStream", "byteArrayOutputFile", "byteStringOutputSteam", "byteArrayInputPath", "byteArrayoutputStream", "byteStringInputFile", "byteArrayFileSteam", "byteArrayIOFile", "byteArrayoutputSteam", "byteArrayIOString", "byteArrayByteStream"], "def": ["defined", "f", "d", "re", "data", "ref", "parse", "da", "entry", "di", "conf", "bus", "class", "init", "this", "dist", "DEF", "pro", "desc", "DE", "dem", "base", "sup", "file", "des", "Def", "de", "decl", "dev", "der", "spec", "obj", "dir", "md", "design", "define", "df", "definition", "frame", "config", "default", "info", "e", "id"], "se": ["lex", "sem", "ze", "ses", "ie", "ade", "parse", "site", "te", "es", "service", "sk", "isse", "sh", "ase", "pe", "see", "zip", "sl", "ce", "sche", "est", "esse", "SE", "be", "sp", "de", "ke", "ge", "pse", "s", "cle", "inse", "su", "le", "sel", "ss", "ne", "me", "sle", "si", "spe", "fe", "so", "ser", "ae", "sec", "ve", "ste", "sea", "e"], "linkId": ["blockId", " linkType", "lineID", "linkid", "loadID", "linkType", "blockType", "linkLength", "lineInfo", " linkLength", " linkid", "Linkid", "LinkType", "loadInfo", "blockLength", " linkID", "linkID", "linkInfo", "blockid", "loadId", "lineId", " linkInfo", "LinkId", "LinkLength"], "segmentId": [" segmentsId", "segmentIndex", "pementInfo", "pegmentIndex", "segmentsId", " segmentsType", "sementNumber", " segmentsPath", "segerNumber", "segmentCount", "pegmentInfo", " segmentsCount", " segmentPath", "segmentsIndex", "segmentsType", "segerId", "pementIndex", "segementId", "segementCount", "segmentNumber", "sementType", "segerIndex", "segmentPath", "segmentsPath", "segementPath", "segementType", " segmentCount", "pementNumber", " segmentType", "segmentsCount", "segmentsNumber", "sementPath", "sementIndex", "segmentInfo", "sementId", "segmentsInfo", "sementCount", "segerInfo", "pegmentNumber", "pementId", "pegmentId", "segmentType", "sementInfo"], "linkSegments": ["linkEngles", "lineSegines", "linkConnectment", "linkConnectments", "lineFragments", "linkFragments", "linkEngment", "linkEngines", "linkShipment", "linkSegensions", "linkShipments", " linkSegensions", "linkShipines", "linkConnectensions", " linkEngments", " linkSeggments", "linkEngments", "lineFragings", "lineFragment", "linkShiples", "linkSegings", "linkEngensions", " linkEngment", "lineSegles", "linkIncregments", "linkVariings", "linkFragment", "linkFragensions", "linkSeggments", "lineSegments", " linkEnggments", "lineSegment", "linkVariment", "linkIncrements", "linkVarigments", "linkIncreings", "lineFraggments", "linkFraggments", "linkFragines", "linkConnectgments", "lineSeggments", "linkFragings", "lineFragines", "linkVariments", "linkEnggments", "linkFragles", " linkSegment", "linkSegines", "lineSegings", "lineFragles", " linkEngensions", "linkSegles", "linkSegment", "linkIncrement"], "segments": ["sements", " seagements", "gements", "pegment", "pelements", "peagements", "pegements", " selements", "Seggements", "Seggments", "gelements", "geagements", "Seggment", "gegments", "selements", "segment", "pements", "segements", "pegments", "gegment", "gegements", " segment", "seagements", "Segments", " sements"], "frameProperties": ["frameprops", "frameScheproperties", "frameproeters", "frameproptions", "frameproproperties", "framePropeters", " frameproptions", " frameProproperties", "frameProproperties", "framePropperties", " frameProptions", " frameproproperties", "framePromproperties", " frameproperties", " frameprops", "framePrometers", "framePromperties", " frameProeters", " frameproeters", "framePropproperties", "frameproperties", "frameScheps", "frameProptions", "frameProps", "framePromps", "frameScheperties", "frameProeters", "framePropps", "frameScheptions", " frameProps"], "time": ["Time", "video", " times", "f", "length", "x", "live", "delay", "data", "depth", "port", "times", "cycle", "weight", "end", "money", "vel", "cost", "t", "once", "speed", "duration", "TIME", "value", "runtime", "event", "rate", "v", "ime", "file", "sleep", "play", "timeout", "type", "one", "now", "image", "name", "clock", "step", "c", "set", "timer", "ice", "size", "mode", "start", "age", "work", "tim", "count", "h", "date", "etime", "e", "id"], "vehicle": ["Vehicycle", "vehler", "bridiger", " vehicleicles", "pericycle", " vehline", " vehicleicle", "horicycle", "vehometry", "bridicle", "perline", "Vehish", "vehicular", "Vehicles", "Vehler", "devicle", "devometry", "horicle", "portometry", "vehline", "bridometry", "deviger", "pericle", " vehler", "perish", "porticle", "portiger", "vehiger", "devicular", "bridicular", "Vehicle", " vehicleler", "Vehline", "vehish", "vehicycle", " vehicleline", "horline", "horish", "vehicles", " vehicles", "porticular"]}}
{"id1": "3309233", "id2": "19322946", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    @Test\n    public void test_lookupType_FullSearch_MatchingWordInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupType/cluster\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":29055,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":29056,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29065,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":29066,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29069,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":29070,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29095,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":29096,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":21013,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Sensor Cluster\\\",\\\"icon\\\":\\\"54_03\\\"},{\\\"itemTypeID\\\":21014,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":32241,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Drive Cluster EDF-285\\\",\\\"icon\\\":\\\"24_11\\\"},{\\\"itemTypeID\\\":5279,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"F-23 Reciprocal Sensor Cluster Link\\\",\\\"icon\\\":\\\"03_09\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11534,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":17340,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11536,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":17333,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11535,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":17345,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6218,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6222,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected LADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6226,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6230,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Multi-Frequency Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6234,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected RADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":7895,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7893,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7914,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7896,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Omni Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7892,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Radar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11537,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":17336,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Gravimetric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6241,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed LADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Magnetometric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6239,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Multi-Frequency Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6225,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed RADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":20238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20244,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20250,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20260,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20240,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20246,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20252,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20262,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":21722,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Sleeper Nanite Cluster\\\",\\\"icon\\\":\\\"55_15\\\"},{\\\"itemTypeID\\\":20242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20248,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20254,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20264,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"params": ["pins", "ctx", "address", "comments", "data", "lines", "pm", "parse", "source", "i", "Parameters", "resources", "parts", "ds", "los", "reports", "par", "json", "p", "mes", "properties", "page", "sp", "ams", "type", "ls", "files", "phrase", "s", "results", "services", "py", "objects", "details", "settings", "types", "ps", "arms", "values", "Param", "keys", "strings", "config", "Par", "eps", "names", "options", "posts"], "param": ["ctx", "cm", "pb", "address", "vm", "pm", "camp", "string", "lc", " parameter", "path", "meter", "password", "option", "conf", "pc", "project", "monitor", "prom", "Parameter", "par", "mor", "parent", "mm", "am", "p", "km", "rem", "cp", "conn", "page", "mand", "part", "temp", "ams", "single", "connection", "comment", "arm", "contract", "name", "prem", "channel", "ram", "pri", "gram", "aram", "amp", "proc", "Param", "pool", "null", "config", "default", "object", "model", "iam"], "client": ["session", "help", "cm", "cl", "bird", "plugin", "service", "request", "ssl", "proxy", "connect", "resource", "app", "con", "handler", "host", "response", "http", "server", "cli", "project", "ce", "cp", "secure", "base", "p", "conn", "url", "apache", "connection", "comp", "force", "self", "google", "channel", "c", "api", "config", "Client"], "post": ["install", "pb", "next", "f", "pod", "push", "patch", "request", "form", "put", "upload", "send", "feed", "and", "response", "http", "server", "entry", "zip", "pp", "Post", "json", "base", "p", "op", "head", "load", "dd", "wp", "add", "query", "POST", "part", "hop", "comment", "submit", "set", "c", "pre", "pos", "proc", "posted", "body", "api", "create", "e"], "resp": ["comm", "re", "serv", "content", "ref", "rel", "received", "request", "resource", "success", "status", "handler", "rh", "response", "http", "server", "Resp", "fc", "Response", "rec", "json", "respond", "par", "req", "reply", "error", "conn", "page", "sp", "res", "err", "rep", "obj", "exec", "download", "body", "api", "enc", " response", "e"], "entity": ["data", "content", "ity", "string", "resource", "xml", "output", "status", "ent", "line", "person", "response", "entry", "el", "json", "base", "event", "conn", "translation", "connection", "unit", "element", "code", "ec", "coll", "obj", "instance", "article", "Entity", "body", "node", "activity", "enc", "attribute", "object", "model", "e", "agent"], "result": ["address", "data", "content", "row", "string", "source", "resource", "success", "output", "line", "response", "entry", "text", "desc", "value", "json", "url", "page", "translation", "res", "location", "place", "results", "Result", "name", "details", "property", "instance", "description", "ret", "report", "record", "default", "object", "status", "match", "message"]}}
{"id1": "10445819", "id2": "7927042", "code1": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "code2": "    private void loadDynamically(File result, String extraPath) {\n        URL url = null;\n        InputStream is = null;\n        FileOutputStream fos = null;\n        try {\n            url = new URL(homeServerUrl + extraPath);\n            is = url.openStream();\n            fos = new FileOutputStream(result);\n            byte[] buff = new byte[8192];\n            int nbRead;\n            while ((nbRead = is.read(buff)) > 0) fos.write(buff, 0, nbRead);\n        } catch (IOException e) {\n            throw new StellariumException(\"Cannot dynamically load \" + result + \" from \" + url);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"stream": ["wrapper", "ream", "f", "sync", "child", "data", "content", "source", "form", "resource", "ack", "upload", "output", "feed", "host", "draft", "slice", "valid", "http", "server", "read", "zip", "sl", "iv", "input", "window", "cont", "roll", "raw", "v", "file", "url", "reader", "Stream", "temp", "impl", "draw", "s", "serial", "open", "coll", "channel", "sw", "trans", "control", "view", "pool", "body", "clean", "object", "null"]}}
{"id1": "17999474", "id2": "15409512", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 1, "substitutes": {"digOb": ["DigOl", "dimOl", "dimObject", " digObj", " digOl", "digob", " digOB", "dimOb", "signObject", "digOl", " digob", "ditOb", "signob", "digObj", "DigOb", "signObj", "ditObject", "dimObj", "DigObj", "signOb", "DigObject", "ditOB", "Digob", "digObject", " digObject", "signOB", "ditob", "digOB"], "folderName": ["FolderName", "filename", " folderPath", "foldername", "packagename", "folderInfo", "packageName", "folderPath", "FolderInfo", "fileInfo", "filePath", "FolderDir", "Foldername", "foldInfo", " foldername", "packageDir", "fileName", " folderDir", "foldPath", "packagePath", "foldName", "folderDir", "FolderPath", "foldname"], "tmpFolder": ["tempFolder", " temporaryFolder", " tmpfolder", " tmpDirectory", "tempfolder", "mpFolder", "tempDirectory", "tmpDir", " temporaryDirectory", " tmpManager", "tmpfolder", "tempManager", "tempDir", "tmpManager", "tmpDirectory", " tmpDir", " temporaryManager", " temporaryfolder", "mpDir", "mpDirectory", "mpfolder"], "zip": ["lex", " ZIP", "install", "f", "ze", "wrap", "jar", "ie", "cf", "source", " zipper", "flow", "xml", "upload", "ignore", "feed", "slice", "bag", "tmp", "sl", "z", "lib", "ce", "zone", "folder", "pkg", "json", "lock", "p", "fp", "file", "url", "temp", "ipped", "cop", "gz", "io", "ip", "seed", "ress", "ulp", "archive", "py", "job", "pack", "download", "pipe", "flat", "Zip", "copy", "proxy", "clip"], "out": ["loader", "f", "sync", "OUT", "child", "a", "flush", "user", "socket", "source", "flow", "upload", "output", "path", "line", "is", "cli", "z", "writer", "this", "again", "parent", "Out", "base", "os", "conn", "file", "in", "page", "url", "plain", "temp", "gen", "err", "gz", "connection", "io", "box", "obj", "client", "o", "outs", "result", "write", "download", "cache", "log", "null", "ex", "copy", "object", "info"]}}
{"id1": "8150996", "id2": "19134229", "code1": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"in": ["f", "a", "it", "data", "src", "inn", "source", "i", "sin", "input", "init", "base", "min", "din", "file", "lin", "url", "reader", "part", "ins", "bin", "m", "inner", "io", "image", "name", "c", "b", "or", "In", "cache", "cin", "inc", "IN", "ini", "r", "again", "id"], "out": ["ext", "dot", "prefix", "x", "OUT", "data", "point", "user", "output", "off", "line", "server", "cos", "project", "lib", "writer", "Out", "base", "p", "lock", "file", "conn", "plain", "part", "one", "exp", "object", "err", "to", "io", "s", "name", "o", "pos", "b", "outs", "write", "exec", "doc", "at", "cache", "ex", "again", "null"], "is": ["oss", "ir", "nis", "cs", "ori", "ui", "isin", "ie", "iss", "isl", "iris", "abs", "uri", "i", "es", "ci", "ais", "app", "has", "ic", "ois", "im", "ib", "cos", "http", "us", "its", "init", "ics", "isa", "bs", "ai", "iso", "ens", "ins", "ms", "err", "ar", "io", "get", "s", "ip", "IS", "mis", "ios", "ops", "ri", "as", "was", "or", "Is", "are", "js", "isi", "si", "loc", "osi", "ini", "ob", "like", "info", "eni", "fs", "id"], "os": ["oss", "obs", "ans", "OS", "ori", "bos", "ols", "aos", "es", "ose", "ol", "ois", "cos", "ot", "nos", "sys", "los", "us", "mos", "opens", "ors", "bs", "op", "des", "vs", "ens", "ns", "dos", "fits", "ls", "boot", "io", "Os", "bis", "ios", "ops", "o", "oses", "pos", "as", "or", "ss", "ros", "js", "osi", "so", "ows", "oos", "oS", "oes", "fs", "ks"], "buffer": ["queue", "border", "address", "length", "uffer", "data", "flush", "reference", "source", "wave", "resource", "FFER", "feed", "layer", "read", "iter", "buff", "buf", "fb", "input", "binary", "block", "transfer", "reader", "bin", "header", "seed", "Buffer", "batch", "b", "bytes", "result", "size", "cache", "position", "split", "padding", "null", "sequence"], "len": ["f", "length", "bl", "data", "ie", "lc", "ln", "line", "limit", "iter", "el", "lf", "nt", "min", "lin", "fd", "num", "part", " Len", "err", " length", "offset", "pos", "bytes", "le", "fin", "en", "l", "size", "Len", "start", "n", " el", "li", "val", "count", "fn", "fl", "dl", "id"], "ok": ["hack", "f", "sync", "allow", "found", "bug", "check", "Ok", "ack", "yes", "valid", "ready", "fail", "oks", "ak", " cool", "lock", "load", "op", "req", "error", "full", "pl", "boot", "k", "cb", "err", "bool", "self", "ko", "code", "md", "o", "c", "result", "good", "or", "always", "work", "log", "auto", "clean", "val", "OK", "coll", "id"]}}
{"id1": "10281203", "id2": "5707205", "code1": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "            public void run() {\n                Log.d(LOG_TAG, \"Fetching \" + url);\n                WebDbAdapter dbHelper = new WebDbAdapter(mContext);\n                dbHelper.open();\n                boolean errorOccurred = true;\n                int notifyId = 0;\n                String host = AppUtils.getHostFromUrl(url);\n                try {\n                    if (host == null) {\n                        Log.d(LOG_TAG, \"Bad url \" + url);\n                        errorOccurred = true;\n                    } else {\n                        notifyId = showNotification(\"Fetching \" + host, \"Fetching \" + host, android.R.drawable.stat_sys_download, 0);\n                        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);\n                        String userAgent = sp.getString(mContext.getString(R.string.pref_key_user_agent), mContext.getString(R.string.default_user_agent));\n                        Log.d(LOG_TAG, \"Using user agent=\" + userAgent);\n                        AndroidHttpClient ahc = AndroidHttpClient.newInstance(mContext, url, userAgent);\n                        URI uri = new URI(url);\n                        URI norm = new URI(uri.getScheme().toLowerCase(), uri.getUserInfo(), uri.getHost().toLowerCase(), uri.getPort(), uri.getPath(), uri.getQuery(), null);\n                        norm = norm.normalize();\n                        HttpUriRequest get = new HttpGet(norm);\n                        HttpResponse response = ahc.execute(get);\n                        if (response.getStatusLine().getStatusCode() == 200) {\n                            HttpEntity entity = response.getEntity();\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            entity.writeTo(baos);\n                            String data = baos.toString();\n                            for (int i = 0; i < undesirables.length; i++) {\n                                Pattern p = Pattern.compile(undesirables[i], Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n                                data = data.replaceAll(p.pattern(), \"\");\n                            }\n                            long sysMillis = System.currentTimeMillis();\n                            String newFileName = getPath(sysMillis, sp.getBoolean(mContext.getString(R.string.pref_key_store_sdcard), false));\n                            FileOutputStream strm = new FileOutputStream(newFileName);\n                            Log.d(LOG_TAG, \"Writing to \" + newFileName + \" for url \" + url);\n                            String jsData = AppUtils.fromRawResourceFile(R.raw.retain_loadcolors, mContext);\n                            jsData = jsData.replaceAll(\"@css_file\", RETAIN_COLORS_CSS);\n                            strm.write(jsData.getBytes());\n                            strm.write(data.getBytes());\n                            strm.write(jsData.getBytes());\n                            strm.flush();\n                            strm.close();\n                            String entryName = getTitle(newFileName, url);\n                            long newRowId = dbHelper.createEntry(entryName, newFileName, url, sysMillis);\n                            postToast(\"Downloaded \\\"\" + entryName + \"\\\"\");\n                            errorOccurred = false;\n                            if (deleteRowId != 0) {\n                                Log.d(LOG_TAG, \"Deleting rowId=\" + deleteRowId);\n                                dbHelper.deleteEntry(deleteRowId);\n                                if (url == null) postToast(\"Item Deleted\");\n                                mContext.startActivity(new Intent(mContext, RetainActivity.class));\n                            } else {\n                                showNotification(\"Download Complete\", entryName, android.R.drawable.stat_sys_download_done, newRowId);\n                            }\n                        } else {\n                            Log.e(LOG_TAG, \"Response code=\" + String.valueOf(response.getStatusLine().getStatusCode()));\n                        }\n                    }\n                } catch (IOException ioe) {\n                    Log.e(LOG_TAG, \"RETAIN IOException: \" + ioe.getMessage());\n                } catch (URISyntaxException u) {\n                    Log.e(LOG_TAG, \"RETAIN URISyntaxException: \" + u.getMessage());\n                } catch (OutOfMemoryError oome) {\n                    Log.e(LOG_TAG, \"RETAIN OutOfMemoryError: \" + oome.getMessage());\n                } catch (Exception e) {\n                    Log.e(LOG_TAG, \"RETAIN Exception: \" + e.getMessage());\n                }\n                hideNotification(notifyId);\n                if (errorOccurred && host != null) {\n                    showNotification(\"Error Downloading\", host, android.R.drawable.stat_notify_error, 0);\n                    postToast(\"Error fetching \" + host);\n                }\n                dbHelper.close();\n            }\n", "label": 0, "substitutes": {"user": ["custom", "install", "author", "pod", "bug", "row", "string", "home", "site", "alias", "usr", "word", "host", "server", "password", "username", "month", "blog", "creator", "url", "User", "uid", "owner", "comment", "users", "name", "job", "nick", "pid", "write", "USER", "human", "admin", "log", "post", "record", "use", "field", "date"], "databaseID": ["databaseId", "DatabaseID", "dbIDs", " databaseIDs", "connectionID", "dbID", "databaseIDs", "DatabaseIDs", "databaseName", "dbId", "DatabaseName", " databaseId", "DatabaseId", "connectionIDs", "dbName", "connectionName", " databaseName"], "time": ["Time", "tz", "length", "delay", "port", "counter", "string", "times", "home", "end", "money", "host", "read", "hour", "duration", "TIME", "month", "value", "rate", "ime", "sleep", "timeout", "type", "table", "comment", "name", "clock", "year", "set", "timer", "size", "mode", "start", "post", "key", "tim", "date", "etime", "id"], "query": ["join", "condition", "script", "request", "string", "Query", "rule", "command", "answer", "commit", "search", "question", "json", "q", "database", "scan", "error", "conn", "params", "select", "call", "connection", "comment", "sql", "name", "update", "code", "cmd", "execute", "result", "sq", "ql", "work", "post", "general", "report", "eries", "message"], "statement": ["joined", "inst", "session", "join", "expression", "st", "Statement", "slave", "condition", "pg", "study", "i", "document", "builder", "rule", "db", "response", "password", "di", "command", "commit", "note", "function", "database", "jo", "volume", "conn", "ma", "part", "mt", "connection", "stat", "state", "comment", "s", "unit", "sql", "usage", "storage", "media", "language", "style", "execute", "result", "instance", "journal", "start", "si", "parser", "general", "table", "use", "status", "agent"], "count": ["number", "length", "child", "found", "depth", "find", "cond", "i", "limit", "list", "total", "group", "base", "add", "error", "expected", "part", "handle", "type", "state", "table", "get", "offset", "force", "process", "Count", "code", "batch", "set", "c", "result", "size", "sum", "start", "age", "cache", "inc", "key", "index", "id"]}}
{"id1": "18793482", "id2": "16590954", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"locale": ["localue", "locationame", "locality", "cale", "LOCales", "locationales", "localoding", "cales", "locationALE", "locame", "localale", "LocALE", "localALE", "localame", "locationale", "Locame", "langale", "locue", "localality", "cue", "Locales", "localales", "langALE", "LOCALE", "Locale", "Locoding", "locoding", "locALE", "langales", "Locue", "coding", "locales", "LOCale", "langality", "LOCality"], "messageName": ["MessageKey", "phraseName", "format", " messageType", "msgKey", "http", "this", " messageKey", "phraseValue", "text", "messageType", " messageNames", "MessageValue", "add", "plain", "url", "phraseKey", "get", "MessageNames", "s", "messageKey", "_", "messageNames", "language", "msgNames", "MessageType", "msgType", "MessageName", "msgName", "phraseType"], "messageValue": ["applicationName", " messageVal", "applicationType", " messageType", "msgVal", "MessageVal", "messageType", "MessageValue", "messageVal", "applicationVal", "MessageType", "applicationValue", "msgType", "MessageName", "msgValue", "msgName"], "properties": ["Pro", "pb", "data", "xml", "stats", "resources", "conf", "tmp", "perties", "Property", "json", "pro", "txt", "params", "prop", " Properties", "py", "ops", "obj", "ips", "settings", "property", "ps", "api", "config", " props", "options", "metadata"], "i18nPath": ["i18nsText", "i18nsUrl", "i18neUrl", "i11pnPath", "i18nsPath", "i18fPath", "i14nPath", "i18bPath", "i11nCorp", "i14nsPath", "i16nStr", "i11nPath", "i18nsStr", "i18nCorp", "i11pnpath", "i14npath", "i18onText", "i18bpath", "i16nFormat", "i18onUrl", "i18bStr", "i18naPath", "i14nsUrl", "i18bFormat", "i18nFormat", "i16nsFormat", "i14nUrl", "i16nsStr", "i18fpath", "i18fFormat", "i18onPath", "i18onpath", "i14nspath", "i11pnCorp", "i11nUrl", "i18nStr", "i18nText", "i18nsFormat", "i18nePath", "i16nspath", "i18neCorp", "i11npath", "i18nepath", "i14nsText", "i18nspath", "i18pnPath", "i16nPath", "i14nText", "i18naText", "i18nUrl", "i18npath", "i16npath", "i18pnCorp", "i11pnUrl", "i18pnpath", "i18naUrl", "i18napath", "i18pnUrl", "i18nsCorp", "i18fStr", "i16nsPath"], "englishFile": ["EnglishJar", "internetFile", "officialPath", "internetResource", "englishDir", "englishPlace", "ianaFile", "EnglishFile", "ianaJar", "EnglishFiles", "EnglishPlace", "ianaDir", "Englishfile", "examplePath", " englishDir", "officialPlace", "englishResource", "englishPath", " englishPath", " englishFiles", "exampleFile", "englishFiles", "englishJar", "officialfile", "officialFile", "examplePlace", " englishResource", " englishJar", "englishfile", "EnglishPath", "examplefile", "ianaFiles", "EnglishResource", "EnglishDir", "internetPath", "internetFiles"], "propertiesFilePath": ["propertiesfilepath", "propertiesFilesName", "propertiesFileUrl", "pertiesFilepath", "pertiesDirUrl", "propertiesfilePath", "propertiesFilesPath", "propertiesDirPath", "propertiesFilepath", "pertiesDirName", "propertiesFullUrl", "propertiesFullName", "pertiesFileLocation", "propertiesfileUrl", "propertiesfileName", "pertiesDirPath", "pertiesFileName", "propertiesDirpath", "propertiesDirLocation", "propertiesFilespath", "propertiesDirUrl", "pertiesDirpath", "propertiesfileLocation", "pertiesFilePath", "propertiesDirName", "pertiesfilePath", "propertiesFullpath", "propertiesFileName", "pertiesfileName", "pertiesFileUrl", "pertiesfilepath", "propertiesFilesLocation", "pertiesfileLocation", "propertiesFileLocation", "propertiesFullPath"], "file": ["path", "http", "pe", "class", "File", "url", "full", "future", "unit", "buffer", "FILE", "model", "e", "application", "f", "data", "socket", "source", "binary", "folder", "base", "reader", "connection", "io", "stream", "log", "fe", "field", "h", "word", "use", "content", "string", "resource", "handler", "zip", "text", "book", "entity", "function", "fp", "part", "play", "directory", "single", "letter", "module", "media", "language", "up", "le", "property", "or", "ile", "work", "object", "message", "filename", "child", "it", "format", "parent", "lock", "p", "page", "die", "php", "files", "one", "force", "name", "b", "l"], "in": ["gin", "d", "it", "isin", "inn", "i", "con", "ic", "sin", "input", "init", "kin", "p", "din", "lin", "reader", "rin", "ins", "bin", "er", "into", "err", "io", "inner", "s", "image", "b", "ri", "inside", "or", "l", "win", "In", "n", "inc", "cin", "IN", "nin", "ini", "r", "login", "again", "pin"], "out": ["ext", "f", "sync", "OUT", "socket", "string", "home", "i", "builder", "output", "and", "cli", "lib", "by", "Out", "p", "ou", "v", "error", "full", "part", "co", "w", "plain", "bin", "one", "exp", "err", "net", "io", "to", "s", "inner", "image", "up", "obj", "client", "o", "b", "outs", "exec", "outer", "work", "n", "inc", "r", "ex", "fn", "word", "again"], "c": ["cl", "f", "d", "x", "a", "cu", "cf", "lc", "i", "ci", "ic", "con", "dc", "cr", "dec", "character", "col", "ce", "p", "cy", "v", "esc", "sc", "w", "ct", "k", "arc", "char", "code", "ec", "abc", "o", "b", "cc", "ice", "rc", "size", "l", "n", "ac", "ch", "xc", "r", "uc", "enc", "h", "pointer", "C", "e"], "is": ["ir", "lis", "ris", "re", "serv", "it", "ui", "iss", "i", "es", "ais", "does", "path", "has", "str", "ib", "us", "iter", "isu", "its", "isa", "os", "iso", "ins", "res", "get", "s", "bis", "IS", "ios", "ri", "as", "was", "Is", "are", "stream", "si", "api", "info", "id"], "breader": [" breaders", "rowner", " birders", " Breader", " Breaders", "breworer", "breadner", "breadler", "rainer", "brewner", "breaders", "breadER", "brewER", "rainER", " birder", "rainner", "rainorer", "rownner", " birdler", "brewer", " Breadler", " breadler", "rownorer", " BreadER", " birdER", " breadER", "rownER", "breadorer"], "line": ["sync", "plugin", "data", "row", "lines", "strip", "string", "section", "parse", "no", "end", "profile", "feed", "rule", "LINE", "str", "response", "lined", "model", "entry", "character", "nl", "sl", "el", "cell", "lf", "liner", "text", "value", "license", "day", "block", "error", "url", "page", "lin", "part", "inline", "one", "phrase", "style", "letter", "comment", "header", "name", "Line", "code", "look", "write", "le", "l", "link", "pass", "item", "definition", "frame", "log", "key", "split", "body", "li", "lo", "word", "status", "band", "message"], "strBuilder": ["strbuilder", " strReader", "StrBlock", " strParser", "strBot", "styleReader", "bcBuilt", "execParser", "stringbuilder", "arrBuilding", "StrBuilding", "StrReader", "stringBlock", "stringHelper", "StrBu", " strBot", "stringBuilt", "strBuilt", "execBuilder", "stringReader", "stringBuffer", "arrBuild", "stringBuilder", "strReader", " strBu", "styleBot", " strBuild", "arrbuilder", "strBuffer", " strBuilt", "styleBuilding", " strbuilder", "arrBuilder", "bcBuild", "strBuild", " strBuffer", "stringParser", "StrBuffer", "strBlock", "execBuild", "stringBuild", "bcHelper", "stringBuilding", "StrBuilder", "stringBu", " strHelper", "execBuffer", " strBlock", "StrBuild", "strBuilding", "stringBot", "strBu", "bcBuilder", "styleBuilder", " strBuilding", "strParser", "strHelper"], "pieces": ["rings", "bones", "styles", "pins", "tools", "bits", "circle", "features", "words", "lists", "lines", "clips", "bands", "phones", "blocks", "str", "sections", "parts", "cuts", "boxes", "tips", "tops", "photos", "nets", "groups", "cards", "items", "apps", "files", "css", "steps", "marks", "services", "cells", "ops", "objects", "bytes", "letters", "places", "vals", "caps", "cats", "values", "keys", "seconds", "pots", "split", "strings", "stars", "piece", "packs", "names"], "found": ["defined", "sent", "existent", "readable", "exist", "find", "left", "confirmed", "empty", "matched", "successful", "path", "built", "valid", "broken", "fall", " Found", "where", "z", "Found", "available", "search", "F", "lost", "failed", "enabled", "supported", "only", "first", "expected", "full", "identified", "true", "temp", "missing", "installed", "printed", "normal", "got", "finding", "existing", "closed", "used", "err", "given", "still", "changed", "filled", "initialized", "loaded", "result", "old", "not", "pos", "all", "good", "published", "l", "successfully", "fixed", "count", "created", "fl", "default", "null"]}}
{"id1": "19206412", "id2": "7372311", "code1": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 1, "substitutes": {"str": ["f", "kr", "st", "re", "dr", "data", "msg", "hr", "string", "sr", "fr", "tr", "this", "text", "txt", "url", "sp", "er", "exp", "err", "char", "s", "self", "star", "arr", "br", "name", "STR", "obj", "bytes", "result", "doc", "Str", "pass", "strings", "r", "enc", "out", "stri", "e", "dict"], "md": ["um", "pd", "mail", "d", "dh", "sm", "data", "wd", "hm", "ad", "pm", "amd", "rpm", "db", "mu", " Md", "mm", "am", "Cmd", "MD", "dd", "od", "mand", "ma", "mt", "m", "ms", " MD", "bd", "dig", "mb", "mg", "vd", "dm", "code", "cd", "cmd", "mod", "sum", "hd", "df", "me", "mac", "cmp", "mag", "mp", "mk", "mc", "ld", "mo", "map", "metadata"], "hash": ["number", "filter", "address", "f", "dot", "Hash", "check", "hex", "diff", "host", "sh", "id", "sha", "tr", "search", "value", "html", "base", "block", "array", "error", "url", "part", "bin", "chip", "char", "range", "image", "header", "arr", "code", "her", "print", "ash", "sum", "memory", "ha", "kh", "cache", "index", "key", "body", "count", "h", "rh", "ver"], "hexChars": ["hashchars", " hexchars", " hexChARS", "hexKhashes", " hexChats", "hexchacters", " hexchARS", "hashCHashes", "hexChashes", "hashCHash", "hashchases", "hexchARS", "hexCHats", "hexCHash", "hashChases", "hexChacters", "hashchacters", "hexKhash", "hexCharars", "hexCharashes", "hexCharases", "hexchases", "hexCashes", "hashChacters", "hexCHacters", "hexchats", "hexKhars", "hexChats", " hexchats", " hexChashes", "hashChashes", "hexCars", "hexCARS", "hexCash", "hashCHARS", "hexCHashes", "hashchARS", "hexCHases", "hexChases", "hashChars", "hashChARS", "hexChash", "hexCharats", "hexCharARS", "hashChash", "hexchars", "hexKhARS", "hashCHars", "hexChARS", " hexchashes", "hexCharacters", "hexCHars", "hexchashes", "hexCHARS"], "res": ["rex", "cons", "Res", "cs", "ris", "re", "data", "Rs", "pers", "string", "abs", "es", "pres", "response", "us", "bs", "RS", "req", "rows", "des", "Results", "vs", "rss", "ras", "rev", "css", "err", "rus", "results", "s", "arr", "ress", "Result", "vers", "bytes", "RES", "result", "vals", "reg", "details", "rs", "rez", "resolution", "ps", "ss", "ros", "resp", "cache", "ret", "r", "out", "rules"], "i": ["hi", "phi", "f", "length", "a", "x", "d", "it", "ui", "ti", "uri", "ie", "bi", "ci", "gi", "qi", "diff", "mu", "di", "abi", "pi", "base", "p", "v", "in", "ai", "part", "ix", "temp", "u", "k", "m", "iu", "io", "ip", "ii", "y", "code", "info", "o", "c", "b", "I", "multi", "ri", "j", "l", "index", "si", "li", "oi", "ji", "field", "h", "xi", "e", "id"]}}
{"id1": "11341711", "id2": "14785308", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"dir": ["ir", "d", "data", "wd", "source", "path", "director", "DIR", "diff", "db", "zip", "lib", "init", "group", "dist", "dest", "folder", "store", "desc", "base", "root", "pkg", "url", "file", "directory", "manager", "io", "module", "done", "name", "up", "Directory", "md", "Dir", "build", "download", "dep", "doc", "rc", "work", "cache", "log", "run", "config", "direction", "dict"], "sourcedir": ["sortedIR", "sourcesdir", "sourcedIR", "seedIR", "asortedIR", "ssourcediri", "sourcediri", "ssodedir", "sourcedirs", "asourcedirs", "seedir", "sourcedore", "asortedore", "asortedir", "sodedIR", "sortedir", "ssodedIR", "ssourceddir", "asourcedIR", "sourcesore", "ssodediri", "asourcedir", "seeddir", "ssodeddir", "sodediri", "sortedirs", "sourcesir", "sourcesIR", "sodedirs", "sourcesirs", "sodedore", "asortedirs", "sodeddir", "sourceddir", "seediri", "ssourcedIR", "sortedore", "sourcesiri", "ssourcedir", "asourcedore", "sodedir"], "destinationdir": ["destinateDir", "Destificationdirection", "Destinationfolder", "destinationsfile", "DestinationDir", "destinationDIR", "dominationDir", "desturationDir", "dominationdir", "desturationfolder", "desturationdir", "dominatorfile", "destinatordir", "dominatorDir", "destinationsDIR", "destinationfile", "destinatorDir", "destinatedirection", "destinateDIR", "dominationDIR", "desturationdirection", "destinatefolder", "destinatefile", "Destificationdir", "destinatedir", "destificationdirection", "destinationfolder", "dominationfile", "destinatorfile", "destificationdir", "dominatorDIR", "dominatordir", "destinatorDIR", "destinationdirection", "Destinationdirection", "destificationDir", "DestificationDir", "Destificationfolder", "destinationDir", "Destinationdir", "destinationsdir", "destificationfolder", "destinationsDir"], "destinationDirEnding": ["destinationDirectoryEndining", "destinationDirectorySignING", "destinationDirLeading", "destinationPathEndging", "destinationDirBeginining", "destinationPathBeginning", "destinationDirSignining", "destinationDirectorySigning", "destinationDirEndning", "destinationDirectorySignining", "destinationDirENDing", "destinationDirEndining", "destinationDirEndening", "destinationDirENDING", "destinationDirPassING", "destinationDirEndging", "destinationDirLeadening", "destinationDirENDning", "destinationDirSigning", "destinationDirBeginning", "destinationDirPassing", "destinationDirBeginging", "destinationPathEndING", "destinationDirBegining", "destinationDirENDging", "destinationDirSignING", "destinationDirectoryEndING", "destinationDirPassning", "destinationPathBeginging", "destinationDirectorySignening", "destinationDirLeadining", "destinationDirBeginening", "destinationDirEndING", "destinationPathBegining", "destinationDirSignening", "destinationPathBeginING", "destinationPathEndning", "destinationDirBeginING", "destinationPathEnding", "destinationDirectoryEndening", "destinationDirectoryEnding", "destinationDirPassging", "destinationDirLeadING"], "files": ["ids", "docs", "parents", "data", "features", "uploads", "words", "lines", "planes", "actions", "xml", "links", "output", "blocks", "resources", "sections", "balls", "boxes", "classes", " Files", "its", "groups", "reports", "iles", "thumbnails", "items", "flows", "errors", "rows", "file", "tests", "events", "books", "ls", "ins", "Files", "results", "children", "users", "services", "pages", "objects", "runs", "ips", "types", "l", "ps", "index", "keys", "modules", "models", "log", "images", "split", "strings", "fields", "projects", "bugs", "names", "fs", "rules", "locks"], "checkdir": ["checkd", "checkfile", " checklog", "workdirectory", "workFolder", "Checkfile", "ckdir", "lockdir", "ckd", "workdraft", "blockdraft", "checkDir", " checkd", "blockdirectory", "workDir", "checkFolder", "lockFolder", "ckdirectory", "workDIR", "workfolder", "calld", " checkDir", "ckfile", "workdir", "checklog", "checkfolder", "worklog", "callfolder", "CheckDir", "checkdirectory", "calldirectory", "CheckDIR", " checkfile", "searchdraft", "checkdraft", "calldir", " checkDIR", "searchdir", "searchdirectory", "checkDIR", " checkfolder", "locklog", " checkdirectory", "blockdir", "blockDir", " checkFolder", "ckDir", "workfile", "searchDir", "lockDir", "ckfolder", "Checkdir"], "date": [" Date", "d", "data", "dt", "user", "time", "mate", "contact", "sign", "mu", "late", "zone", "Date", "tag", "month", "day", "event", "rate", "ime", "ate", "file", "de", "m", "now", "ge", "state", "image", "change", "open", "name", "update", "md", "set", "doc", "start", "age", "at", "log", "config", "dat", "e"], "msec": ["disec", "csec", "mSec", "dseconds", "rsecond", "lss", "misec", "mseconds", "rseconds", "fmsec", "dsecond", "mnSec", "fmsecond", "mif", "dsec", "rsec", "csecond", "fmisec", "Mseconds", "mss", "msecond", "rss", "Misec", "css", "lseconds", "lsecond", " mif", "mnif", "fmseconds", "Msec", " minsec", " mSec", " minsc", "cseconds", " minif", "mnsc", "Msecond", " minSec", "lsec", " msc", "msc", "mnsec"], "checkFile": ["controlLine", "workFile", "CheckDirectory", "checkfile", "Checkfile", "checkDir", "CheckFile", " checkLine", "changeLine", "checkFiles", "workDir", "changefile", "checkDirectory", "ckDirectory", " checkDir", "ckfile", "workFiles", "controlfile", "checkFilename", "checkLine", "CheckDir", " checkfile", " checkFiles", " checkDirectory", "controlFile", " checkFilename", "ckFiles", "ckFile", "changeFilename", "workfile", "controlFilename", "CheckFiles", "changeFile"], "i": ["hi", "phi", "x", "ui", "ti", "ie", "uri", "bi", "ci", "gi", "qi", "slice", "im", "mu", "di", "is", "pi", "p", "v", "ix", "ai", "part", "u", "m", "iu", "io", "ip", "ii", "y", "info", "ri", "I", "multi", "fi", "b", "j", "n", "si", "vi", "key", "li", "ini", "oi", "ji", "field", "index", "xi", "eni", "e", "id"], "f": ["d", "fun", "cf", "sf", "feed", "fx", "fr", "t", "fb", "h", "fc", "F", "folder", "q", "p", "fp", "file", "v", "fd", "w", "u", "m", "o", "b", "fi", "j", "l", "df", "n", "fn", "fe", "r", "fl", "info", "fs", "e"], "g": ["ga", "gm", "gh", "G", "eg", "gin", "gu", "d", "msg", "pg", "gb", "gp", "gd", "gg", "gi", "go", "gar", "t", "h", "og", "group", "ng", "q", "p", "sg", "file", "gs", "u", "w", "m", "rg", "ge", "ig", "s", "mg", "gn", "reg", "b", "gc", "l", "ger", "n", "erg", "r", "tg", "vg", "bg", "global", "e"], "destinationFile": ["destiningFilename", "destificationDirectory", "destiningFile", "destacementDir", "destacementFile", "destinationsFile", "destacementfile", "DestinationDir", "DestationDir", "destiningfile", "DestificationFile", "destationFilename", "destinatorLocation", "DestationFile", "destiningDir", "destinationFilename", "destinationfile", "destinatorDir", "destinationsDirectory", "destinatorDirectory", "destinationDirectory", "destinatorFile", "destationFile", "destinationsLocation", "destacementFilename", "destationfile", "Destationfile", "DestinationFile", "DestificationLocation", "destificationDir", "DestificationDir", "DestinationDirectory", "destinationDir", "Destinationfile", "destinationLocation", "destationDir", "DestinationFilename", "DestificationDirectory", "destificationFile", "destinationsDir", "DestationFilename", "destificationLocation", "DestinationLocation"], "sourceFile": [" sourcefile", "ourceFiles", "ourceDirectory", "srcfile", " sourceFiles", "inputFiles", "sourceFiles", "srcModule", "sourceDir", "srcDir", " sourceModule", "inputDir", "ourceFile", "inputFile", " sourceDirectory", "Sourcefile", "SourceDir", "ourceDir", "sourcefile", "srcFile", " sourceDir", "SourceFile", "sourceModule", "sourceDirectory", "SourceModule", "inputDirectory"], "infile": ["difffile", "inf", "inputstream", "windir", "inputf", "winfile", " instream", "diffstream", "inputfile", "Instream", "inFile", "diffdir", "outdir", "Infile", " indata", "winFile", "outdata", "InFile", "instream", "inputFile", "Inf", "inputdata", "indata", "outstream", "outFile", "outf", "indir", "winstream", "diffFile", " inFile"], "outfile": [" outpage", "Outfile", "inputline", "Outline", "OutFile", "Outlive", "exfile", "inputfile", "againpage", " outline", "outfunction", "intfile", "intstream", " outFile", "outlive", "outline", " outstream", "intFile", "intlive", "inputfunction", "exstream", "Outstream", "exFile", "Outfunction", "inputFile", "outpage", "againstream", "expage", "outstream", "outFile", "againFile", " outlive", " outfunction", "againfile"], "c": ["cm", "cl", "d", "x", "a", "cu", "string", "lc", "ci", "end", "C", "cr", "dec", "pc", "character", "t", "z", "cont", "p", "cy", "v", "esc", "in", "w", "u", "ct", "m", "k", "char", "comment", "code", "ec", "abc", "channel", "o", "b", "ice", "rc", "index", "l", "n", "ac", "ch", "xc", "r", "uc", "enc", "h", "pointer", "col", "e", "id"]}}
{"id1": "6009527", "id2": "12783713", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"attachmentId": ["attplementationID", "attlementId", "attentionPath", "attimageInfo", "attlementid", "attociationPath", "adachmentPath", "attimageID", "adachmentID", "ttachmentId", "adachmentId", "attlementID", "attociationId", "attentionid", "attachmentID", "attentionInfo", "attociationInfo", "attimageId", "attociationid", "ttociationid", "attentionType", "attentionID", "attachmentid", "Attachmentid", "ttachmentID", "adociationInfo", "adociationId", "attachmentPath", "attachmentType", "adachmentInfo", "AttachmentID", "AttachmentType", "adociationPath", "ttociationId", "ttociationID", "attachmentInfo", "attociationID", "attplementationId", "ttachmentid", "attlementType", "AttachmentId", "attplementationid", "attentionId", "attimagePath", "adociationID"], "attachment": ["attached", "instment", "assment", "adment", "attociation", "attachached", "assachment", "assached", "instachment", "attachruction", "association", "adention", "appachment", "attruction", "adachment", " adaptachment", " attment", "adached", "attention", "attachachment", " adaptention", "appment", "attachention", " adaptment", " attociation", "instruction", " adaptociation", "appention", "instention", "assention", "appruction", " attention", "attment"], "attachmentUri": ["attachmentSuRI", "attachedARI", "attachmentUuri", "attachmentAuri", "attachmentAri", "attachmentIuri", "attachmentCuri", "attachedURI", "attachmentEuri", "attmentIris", "attachmentUti", "attachmentUURI", "attachmentSuti", "attachmentURI", "attachmentIURI", "attmentUri", "attachmentSuuri", "attachmentCuris", "attmentIri", "attachmentEti", "attachedAuri", "attachmentEri", "attachmentCuURI", "attachmentUris", "attachmentSuURI", "attachmentAti", "attachmentIris", "attachedAri", "attachmentARI", "attmentIURI", "attmentUris", "attmentUURI", "attachedUuri", "attachmentERI", "attachmentSuri", "attmentIuri", "attmentUuri", "attachedUri", "attachedUti", "attachedAti", "attachmentCuuri", "attachmentIri", "attachmentSuris"], "contentUri": ["contentIri", "contentFileuri", " contentUris", "resourceURI", "contentIi", "contentFileris", "contentIris", "contentUuri", "contentURri", "contentCi", "contentCris", " contentSuri", "contentURI", "contentSuri", "resourceUris", " contentUdi", "contentSuRI", "contentSuris", "contentUdi", "contentFileRI", "resourceUri", "contentFileri", "contentUsuri", "contentIuri", "contentCuri", "contentSudi", "contentIRI", "contentUsri", "contentUsRI", "resourceIi", "contentURris", "contentUsdi", "resourceUuri", "resourceIris", "contentURi", "contentCdi", "contentUsris", " contentURI", " contentSuris", "contentUi", " contentSudi", "contentCri", " contentSuRI", "resourceUi", "resourceIri", "contentURuri", "contentCRI", "resourceIRI", "resourceIuri", "contentUris"], "file": ["f", "filename", "child", "data", "content", "socket", "uri", "source", "resource", "upload", "path", "able", "output", "line", "handler", "pe", "zip", "input", "this", "binary", "File", "book", "folder", "entity", "base", "load", "fp", "url", "reader", "files", "single", "connection", "to", "letter", "io", "unit", "image", "get", "buffer", "name", "up", "b", "le", "FILE", "stream", "work", "ger", "cache", "log", "auto", "picture", "local", "view", "via", "copy", "use", "object", "model", "create"], "in": ["gin", "f", "sync", "a", "data", "pull", "socket", "inn", "source", "i", "con", "cli", "input", "this", "init", "binary", "din", "url", "conn", "reader", "ins", "bin", "m", "err", "connection", "io", "inner", "s", "image", "up", "o", "c", "b", "as", "or", "win", "In", "inc", "ac", "IN", "nin", "ini", "r", "copy", "login", "again", "pin", "e", "id"], "out": ["ext", "sync", "OUT", "data", "socket", "source", "i", "resource", "output", "on", "line", "cli", "by", "this", "writer", "init", "Out", "base", "lock", "page", "conn", "bin", "one", "err", "connection", "net", "io", "to", "s", "inner", "image", "up", "client", "o", "b", "outs", "exec", "outer", "In", "cache", "inc", "log", "view", "IN", "nin", "ex", "copy", "again", "null"], "intent": ["inst", "android", "ctx", "anc", "it", "feat", "content", "ents", " Intent", "request", "xml", "document", "contact", "anim", "ent", "response", "impact", "ani", "entry", "intention", "this", "init", "text", "context", "entity", "advert", "event", "Activity", "activate", "effect", "concept", "act", "vent", "action", "focus", "element", "animate", "language", "ant", "activation", "category", "term", "spirit", "acc", "feature", "ink", "activity", "eng", "enc", "object", "agent"]}}
{"id1": "12782570", "id2": "22977189", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"wrap": ["cover", "wrapper", "f", "format", "parse", "web", "word", "wb", "div", "flash", "wa", "handler", "wire", "war", "zip", "ow", "binary", "html", "lock", "p", "wx", "wp", "w", "handle", "worker", "now", "get", "box", "self", "image", "force", "process", "ws", "wra", " wrapper", "b", "sw", "util", "we", "build", "create", "or", "pipe", "stream", "work", "cache", "frame", "run", "rap", " wrapped", "api", "h", "bag", "use", " Wrap", "message"], "buffer": ["loader", "wrapper", "bar", "cover", "queue", "pb", "uffer", "template", "msg", "ref", "reference", "bb", "sb", "source", "wave", "flash", "document", "builder", "container", "feed", "handler", "bc", "layer", "response", "server", "message", "iter", "buff", "buf", "fb", "pause", "binary", "writer", "board", "base", "reply", "transfer", "bm", "shell", "reader", "bin", "manager", "cb", "surface", "comment", "header", "image", "Buffer", "batch", "player", "b", "print", "result", "timer", "cache", "frame", "log", "bridge", "view", "report", "copy", "callback"], "encoding": ["ecoded", "Encryption", "ecoder", "encoder", "enoding", "signoding", "engoder", "coder", "encode", "engode", "encoded", "ecryption", "cryption", "enryption", "decoding", "signoder", "Encoding", "decode", "encryption", "decoder", "enoder", "ecoding", "Encoded", "enoded", "engoded", "signoded", "decoded", "engryption", "signode", "Encoder", "engoding", "coded", "coding"], "headers": ["ids", "wrapper", "bits", "data", "content", "hers", "breaks", "lines", "features", "links", "blocks", "stats", "str", "http", "ers", "parts", "boxes", "members", "ppers", "groups", "ints", "heads", "relations", "head", "properties", "params", "als", "events", "files", "writers", "s", "header", "pages", "frames", "details", "objects", "vals", "settings", "caps", "types", "rs", "values", "keys", "plugins", "ports", "body", "strings", "fields", "h", "padding", "names", "options", "dict"], "is": ["oss", "obs", "isol", "nis", "lis", "cs", "ris", "bas", "serv", "ui", "ori", "iss", "isl", "iris", "oris", "abs", "i", "es", "ais", "has", "ois", "ib", "http", "us", "iv", "its", "bs", "ics", "isa", "os", "iso", "in", "ins", "ls", "ms", "s", "bis", "IS", "mis", "ios", "ops", "tis", "as", "was", "or", "Is", "ros", "are", "js", "isi", "api", "osi", "ob", "out", "info", "fs", "sis"], "bos": ["obo", "bones", "osa", "obs", "pins", "bas", "bits", "bh", "uds", "oops", "ses", "beans", "aos", "lins", "home", "bi", "proxy", "es", "ais", "abs", "stats", "ois", "bc", "cos", "mos", "los", "oks", "ubs", "abi", "zos", "bs", "os", "ubis", "fits", "zo", "obos", "bps", "bot", "bis", "ko", "bes", "mis", "opus", "ios", "ws", "ops", "tis", "oses", "mobi", "was", "outs", "bott", "ros", "bo", "js", "osi", "so", "ob", "oos", "obi", "oes", "fs"]}}
{"id1": "22977189", "id2": "20924119", "code1": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"in": ["gin", "f", "re", "isin", "g", "inn", "source", "i", "ln", "con", "ic", "plus", "read", "is", "input", "init", "this", "kin", "min", "din", "url", "lin", "reader", "w", "ins", "bin", "err", "inner", "get", "image", "inside", "as", "l", "win", "In", "pass", "n", "inc", "cin", "IN", "nin", "ini", "r", "login", "again", "id"], "out": ["prefix", "flush", "server", "block", "raw", "w", "self", "outs", "n", "at", "inc", "pool", "ext", "f", "sync", "data", "lib", "file", "conn", "plain", "connection", "net", "io", "exec", "write", "log", "key", "word", "again", "OUT", "a", "no", "output", "option", "list", "writer", "this", "init", "Out", "part", "temp", "bin", "comment", "up", "client", "c", "outer", "cache", "ex", "copy", "default", "object", "user", "point", "strip", "app", "off", "editor", "parent", "window", "query", "page", "err", "call", "inner", "name", "obj", "o", "b", "null"], "line": ["cl", "f", "next", "column", "data", "content", "row", "lines", "string", "lc", "i", "source", "end", "feed", "rule", "LINE", "str", "entry", "character", "pe", "sl", "cell", "lf", "text", "block", "url", "page", "file", "lin", "inline", "style", "char", "letter", "header", "comment", "unit", "name", "Line", "code", "c", "write", "l", "link", "pass", "log", "key", "word", "object", "col", "message"]}}
{"id1": "15241397", "id2": "6403868", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"request": ["application", "queue", "data", "user", "uri", "received", "resource", "document", "xml", "web", "subject", "server", "http", "initial", "input", "context", "query", "req", "event", "url", "reader", "method", "er", "type", "connection", "buffer", "image", "QUEST", "client", "result", "instance", "parser", "report", "complete", "object", "info", "Request", "message"], "response": ["application", "queue", "version", "data", "content", "site", "other", "wave", "resource", "document", "output", "host", "server", "model", "generation", "writer", "onse", "Response", "json", "respond", "function", "parent", "reply", "error", "page", "connection", "results", "image", "collection", "client", "result", "resp", "cache", "view", "pool", "body", "report", "out", "object", "status", "message"], "rewrittenQueryString": ["rewrittenQueryLine", "rewrittenUrlService", "rewrittenPageString", "rewwrittenRequestString", "rewrittenPageLine", "rewrittenQuestionText", "rewrittenRequestArray", "rewwrittenQueryLine", "rewrittenPageService", "rewrittenRequestString", "rewwrittenQueryText", "rewrittenQuestionLine", "rewrittenHeaderLine", "rewrittenRequestText", "rewrittenqueryString", "rewrittenqueryStr", "rewrittenQuestionStr", "rewrittenRequestStr", "rewwrittenQueryStr", "rewwrittenRequestService", "rewrittenqueryText", "rewwrittenRequestArray", "rewrittenUrlLine", "rewrittenQueryService", "rewwrittenRequestText", "rewrittenQueryStr", "rewrittenQueryArray", "rewwrittenQueryService", "rewrittenPageArray", "rewwrittenQueryArray", "rewwrittenRequestLine", "rewrittenRequestService", "rewrittenQueryText", "rewrittenHeaderService", "rewrittenRequestLine", "rewrittenQuestionString", "rewrittenqueryService", "rewwrittenRequestStr", "rewrittenUrlText", "rewwrittenQueryString", "rewrittenHeaderArray", "rewrittenUrlString", "rewrittenqueryLine", "rewrittenHeaderString"], "rewrittenUrl": ["rewatchedText", "rewwrittenUr", "rewrittenFile", "rerittenJar", "RewwrittenUrl", "RewrittenText", "rewwrittenUrl", "rewedUrl", "RewwrittenServer", "RewrittenFile", "RewwrittenUr", "RewrittenUrl", "rewardedHost", "rewrapedUrl", "rewoldedURL", "rewrawnUrl", "rerittenUrl", "rewatchedServer", "rewreatedurl", "rewanedURL", "rewoldedFile", "rewedURL", "rewoldedUrl", "rewriteUr", "rewriteFile", "rewroteUrl", "rewrapedUr", "rewrawnurl", "RewrittenLocation", "rewrawnText", "rewrittenServer", "rewrawnURL", "rewardedLocation", "rewatchedURL", "rewedHost", "RewrittenURL", "rewrittenLocation", "rewrittenUr", "rewrittenJar", "rewriteServer", "rewroteURL", "rewrittenurl", "rewreatedUrl", "rewardedUrl", "RewwrittenHost", "rewanedHost", "rewardedURL", "Rewrittenurl", "rewrittenHost", "rewanedUrl", "RewwrittenURL", "RewrittenServer", "RewwrittenFile", "RewwrittenLocation", "RewrittenUr", "rewwrittenServer", "rewrapedFile", "rerittenFile", "rewrapedURL", "rewanedLocation", "rewatchedUrl", "rewriteUrl", "rewriteText", "rewrittenURL", "RewwrittenText", "rewwrittenURL", "rewedJar", "rewreatedText", "rewrittenText", "rewwrittenFile", "rewroteurl", "rewwrittenHost", "rerittenHost", "rewwrittenurl", "RewrittenHost", "rewreatedURL", "rewedFile", "rewwrittenText", "rewoldedHost", "rerittenURL", "rewriteURL", "Rewwrittenurl", "rewedurl", "rewwrittenLocation", "rerittenurl", "rewwrittenJar", "rewroteJar"], "httpURLConnection": ["httpMRconnection", "httpURLConstruction", "httpLLconnection", "httpURLOperation", "httpUrlInterface", " httpURLNode", "httpURIContext", "httpLLConnect", " httpRLConstruction", "facebookPathConnection", "cacheURLConnection", "httpURConnect", "httpURChannel", "facebookPathconnection", "cacheUrlConnect", "httpHTTPInterface", "httpPathConnect", "httpPathChannel", "httpURIConnect", "httpDBConnection", "httpUrlconnection", "httpURLApplication", " httpRLConnection", "facebookPathChannel", "httpURConstruction", " httpRLConnect", "httpUrlApplication", "httpStreamConn", "facebookURLconnection", "httpUrlConnection", "httpHTTPApplication", "httpRLConn", "httpMRConnect", "httpHTTPConn", "facebookPathConnect", "httpGETInterface", "httpRLConnect", "facebookURLChannel", "httpURConnection", "cacheURLOperation", "cacheUrlConn", "cacheUrlOperation", " httpURconnection", "cacheUrlConnection", " httpRLContext", " httpURLconnection", "httpRLconnection", "httpUrlConn", " httpURLConnect", "httpLLConn", "httpUrlOperation", "httpStreamConnect", "httpGETConn", "facebookURLConnection", "httpHTTPConnection", "httpStringConnect", "httpURLConnect", "httpStreamOperation", "facebookURLConnect", "httpLLConnection", " httpURLInterface", "httpURNode", "httpGETApplication", "httpURIConnection", "httpURContext", " httpURLConn", " httpRLConn", "cacheURLConnect", "httpPathConnection", " httpURLConstruction", "httpLLOperation", "httpUrlConnect", "httpPathconnection", " httpHTTPInterface", "httpGETConnection", "httpDBNode", "httpURLConn", " httpHTTPConnection", "httpURLContext", "httpURLChannel", "httpStreamConnection", "httpRLConnection", "httpRLConstruction", "httpURLInterface", " httpRLconnection", " httpURLApplication", " httpURNode", " httpHTTPApplication", "cacheURLConn", " httpURLContext", " httpHTTPConn", " httpURConnect", "httpStringconnection", "httpMRConn", "httpMRConnection", "httpRLContext", "httpStringChannel", " httpURConnection", "httpDBConnect", "httpDBconnection", "httpURLNode", "httpURconnection", "httpStringConnection", "httpURLconnection", "httpUrlNode", "httpURIConstruction"], "header": ["cover", "filter", "column", "version", "next", "dr", "data", "core", "string", "section", "document", "token", "rule", "handler", "director", "line", "layer", "server", "second", "entry", "character", "iter", "list", "writer", "member", "group", "block", "head", "event", "error", "part", "er", "single", "comment", "buffer", "hash", "pair", "later", "channel", "player", "her", "Header", "component", "outer", "feature", "over", "definition", "bridge", "item", "key", "driver", "consumer", "after", "headers", "index", "default", "back", "info", "field", "date", "attribute", "match", "message"], "value": ["hello", "expression", "version", "child", "Value", "data", "content", "format", "string", "end", "server", "valid", "model", "entry", "option", "VALUE", "label", "password", "member", "text", "json", "parent", "function", "v", "variable", "type", "now", "comment", "letter", "get", "element", "media", "name", "archive", "job", "set", "property", "description", "index", "values", "item", "current", "key", "val", "field", "default", "object", "info", "attribute", "message"], "inputStream": [" inputWriter", "inputstream", "outputWriter", "Inputstream", "inputWriter", "outputSteam", "inputResource", "outputstream", "inputSteam", "InputResource", "InputStream", " inputstream", " inputSteam", "InputSteam", "InputWriter", " inputResource", "outputResource"], "outputStream": ["OutputFile", "inputstream", "inputStreamer", "referencestream", "outputFile", "referenceSteam", "OutputStream", "outputSteam", "responseSteam", "responseStream", "outputstream", "inputSteam", "OutputChannel", "Outputstream", "referenceStream", "responseChannel", "OutputSteam", "OutputStreamer", "referenceStreamer", "outputStreamer", "outputChannel", "responseFile", " outputFile", " outputChannel", " outputSteam"]}}
{"id1": "22046596", "id2": "471804", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"s": ["S", "f", "x", "a", "ses", "src", "g", "ssl", "sb", "source", "i", "sf", "es", "sin", "sh", "ds", "is", "sl", "input", "p", "os", "v", "ns", "se", "gs", "ins", "ls", "files", "w", "u", "south", "m", "storage", "services", "xs", "o", "b", "c", "outs", "as", "ss", "l", "ps", "less", "ts", "sv", "si", "fs", "e"], "t": ["target", "f", "x", "it", "template", "g", " T", "i", "tr", "ot", "z", "tf", "p", "v", "file", "T", "temp", "down", "m", "tc", "tor", "to", "ta", "y", "o", "b", "c", "tty", "l", "ts", "n", "at", "pt", "tp", "r", "object", "ty", "e"], "in": ["f", "sync", "d", "pull", "socket", "g", "inn", "ssl", "source", "i", "sin", "is", "input", "init", "p", "min", "din", "conn", "file", "url", "reader", "rin", "ins", "bin", "m", "inner", "io", "up", "c", "b", "as", "l", "win", "In", "n", "inc", "IN", "nin", "r", "login", "h", "again", "pin", "e", "id"], "out": ["ext", "f", "sync", "OUT", "d", "x", "g", "user", "output", "off", "writer", "parent", "Out", "p", "v", "conn", "file", "plain", "temp", "w", "bin", "err", "connection", "net", "io", "call", "image", "client", "channel", "o", "c", "b", "outs", "obj", "not", "l", "n", "at", "inc", "ex", "copy", "again", "null"]}}
{"id1": "14820302", "id2": "22411381", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"curi": ["lurl", "piri", "cri", "curation", "fURI", "lri", "Cri", "Cunit", "cudi", " curation", "lciri", "cui", "cuid", "CURI", "ciri", "lcuid", " cuid", " cgui", "Curi", "lcri", "Cudi", "lcURI", "Curation", "cURI", " ciri", "cunit", "pURI", "Curl", "lcunit", "fri", "puid", "Cgui", " curl", "Cui", "curl", "lcgui", "puri", " cunit", "cgui", "lcui", "lURI", " cudi", " cURI", " cui", "furi", "lcudi", "luri", "lcuri", "furation", " cri"], "regexpr": ["regexer", "rerup", "rerepr", "renexpr", "regexper", "regnexper", "pregexer", "renexr", "renexp", "regexrt", "reasurert", "Regexpre", "reggexr", "rereper", "pregexpr", "Renexpre", "recepl", "recrepl", "recer", "prenexp", "reasurep", "Regexp", "Renexpr", "Renexp", "recrepre", "Renexrt", "pregexpl", "pregexp", "Regexpr", "regexpre", "prenexpr", "reggexpl", "reasurepr", "renexrt", "recreer", "reggexper", "receper", "regnexpr", "recrepr", "renexper", "regexpl", "prenexpl", "regexr", "renexer", "reggexpr", "rerupl", "recepr", "regnexpl", "regnexr", "rerer", "recrep", "renexpl", "regexp", "Regexrt", "recrert", "reruer", "renexpre", "rerupr", "prenexer", "rerepl", "reasurepre"], "cs": ["ca", "ctx", "cons", "cm", "Cs", "sync", "cf", "cers", "lc", "cases", "ci", "es", "acks", "cn", "cr", "bc", "ced", "cos", "cer", "ds", "pc", "acts", "cing", "ce", "cas", "cp", "bs", "ics", "CS", "os", "conn", "vs", "sc", "ns", "gs", "ins", "ls", "icks", "css", "ms", "tc", "spec", "qs", "cms", "cus", "cells", "ec", "ches", "ios", "c", "cc", "rs", "codes", "ss", "rc", "ps", "ces", "cache", "js", "acs", "ac", "cks", "ars", "coll", "wcs", "fs", "ks"], "digest": ["logester", "generested", " digesting", "hashester", "digcher", "igested", "hashger", "igcher", "digit", " digEST", "digEST", " digger", " digested", "digger", "diger", "hashesting", "logit", "digests", "igest", "Digested", "signest", "generest", "signger", "Digester", "signer", "digester", "signester", "igester", "signested", " digester", "digesting", " digests", "generEST", "signests", " diger", "digested", "Digesting", "Digger", "generests", " digcher", "logest", "Digit", "Diger", "signEST", " digit", "logger", "Digcher", "hashest", "Digest"], "s": ["states", "obs", "ans", "S", "address", "f", "sync", "data", "ses", "g", "string", "sb", "abs", "str", "ds", "t", "is", "sl", "groups", "binary", "p", "os", "v", "ns", "gs", "u", "ls", "ms", "sets", "services", "ws", "o", "c", "b", "su", "settings", "bytes", "rs", "ss", "l", "ps", "sum", "n", "js", "si", "sym", "strings", "r", "h", "e"], "m": ["gm", "man", "cm", "nm", "sm", "hm", "pm", "vm", "string", "mo", "e", "ym", "mm", "am", "p", "v", "bm", "M", "ms", "rm", "wm", "dm", "machine", "c", "om", "tm", "me", "sym", "imm", "mc", "r", "mi", "mr", "fm", "map", "match"], "newDigestValue": ["newDigestValues", "newDigestedKey", "newDigestKey", "newSignestedValue", "newSignestValues", "newSignestString", "newSignestedKey", "newDigesterArray", "newDigestedValue", "newDigenseValue", "newDigesterString", "newDigesterKey", "newDigestArray", "newDigenseArray", "newSignestValue", "newDigestString", "newSignestKey", "newDigESTValues", "newDigestedArray", "newDigESTValue", "newSignestedValues", "newDigestedString", "newDigenseKey", "newDigestedValues", "newDigESTString", "newSignestedString", "newDigenseString", "newDigesterValues", "newDigesterValue", "newDigESTKey"]}}
{"id1": "2668634", "id2": "10795866", "code1": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"inputName": ["imageName", "InputPath", "inputname", "Inputname", "inputAddress", "imageAddress", "InputFile", "imagename", "imageFile", "socketName", " inputFile", " inputname", " inputAddress", "inputPath", "socketname", "inputFile", "InputAddress", "imagePath", "socketPath", "InputName"], "outputName": ["applicationName", "OutputFile", "applicationDir", "OutputPath", "outputFile", "Outputname", "OutputDir", "applicationFile", "applicationname", " outputDir", " outputname", "inputDir", "outputname", "outputPath", "inputPath", "inputFile", "applicationPath", "outputDir", " outputFile", "OutputName"], "stripLoggers": ["stripSubging", " striploggers", "stripLogging", "striploggers", "stripDebugger", "stripDebuglers", " stripLogging", "stripSubger", "stripLoglers", " striplogging", " striplogger", " stripLogger", "striplogger", "stripSubgers", " stripLoglers", "stripDebugging", " striploglers", "striploglers", "stripDebuggers", "stripSublers", "striplogging", "stripLogger"], "tempFile": ["tempPlace", "tmpFiles", "poraryPlace", " tempPage", "TempDir", "tmpfile", "tmpMessage", "inputfile", "tempFiles", "poraryFiles", "inputPage", " tempPlace", "tmpDir", "poraryMessage", "tempDir", " tempfile", "tempPage", "inputDir", "TempFile", "TempFiles", "tempfile", "tmpPage", " tempFiles", "poraryDir", "Tempfile", "poraryfile", " tempDir", "tmpPlace", "inputFile", "tempMessage", "tmpFile", "TempMessage", "poraryFile"], "jin": ["NI", "jun", "nu", "inx", "pillar", "vin", "gin", "plugin", "Ru", "NJ", "ni", "ja", "thin", "ln", "sin", "icer", "zik", "cos", "Intern", "mu", "zip", "cli", "arin", " Jin", "Mos", "kin", "din", "lin", "in", "rin", "zin", "Js", "rio", "bin", "Mu", "jen", "Kit", "zon", "fen", "Ju", "unin", "lu", "nir", "gn", "jing", "skin", "util", "su", "sit", "jp", "cin", "hn", "nin", "ini", "ji", "hin", "tin", "spin", "LI", "zn", "pin", "raf"], "jout": ["nouts", "ujagain", "jobout", " jouts", "JOUT", "jobouts", "jagain", "jobOUT", "Jagain", "nout", "nOUT", "jobOut", "JOut", " jOut", "Jout", "jOUT", "jouts", " jagain", " jOUT", "ujOUT", "ujout", "nOut", "ujOut", "jOut"], "srcChannel": ["sourcechannel", "sourceChan", "rcChan", "srcchannel", " srcchannel", "rcchannel", " srcStream", "srcStream", "rcChannel", "rcStream", "srcChan", " srcChan", "sourceStream", "sourceChannel"], "dstChannel": ["dstChan", "ddestChan", "dstchannel", "dndchannel", "dndChannel", " ddestChan", "dndChan", "dspCh", " dstCh", " dstchannel", "dspchannel", "dndCh", " ddestCh", "ddestchannel", "dstCh", "ddestChannel", "ddestCh", "dspChannel", " ddestchannel", "dspChan", " ddestChannel", " dstChan"], "portletApplicationName": ["portletsAppPath", "portletAppInfo", "portletsApplicationName", "portelContainerPath", "portelApplicationPath", "portletContainerName", "portletAppName", "portletContainerPath", "portletApplicationsInfo", "portelContainerInfo", "portletAppCode", "portalApplicationPath", "portletPlatformPath", "portletsAppName", "portalPlatformPath", "portletApplicationsName", "portalApplicationName", "portelApplicationInfo", "portalPlatformName", "portletPlatformDir", "portalApplicationDir", "portelContainerKey", "portletsApplicationPath", "portletApplicationsPath", "portletAppDir", "portletsAppCode", "portletApplicationKey", "portelContainerName", "portletsAppInfo", "portletApplicationsCode", "portletApplicationInfo", "portletAppKey", "portletsApplicationInfo", "portletContainerInfo", "portalPlatformDir", "portletContainerUrl", "portletAppUrl", "portletPlatformUrl", "portletApplicationDir", "portletApplicationUrl", "portalPlatformUrl", "portletsApplicationCode", "portletPlatformName", "portelApplicationKey", "portletApplicationPath", "portletPlatformInfo", "portletApplicationCode", "portalApplicationUrl", "portletContainerKey", "portletPlatformCode", "portletContainerDir", "portletAppPath", "portelApplicationName"], "webXml": ["webJxml", "homeXml", "httpXPxml", "webAxaml", "webCrossxml", "projectXxml", "homeAxml", "homeXlf", "webWorklim", "webXmary", "webXlc", "httpXPla", "projectXml", "webTxML", "webXaml", "webAxxml", "webHxml", "httpXmary", "homeXlc", "webTexML", "projectAxxml", "webTxxml", "webXMxml", "httpXPml", "WebWorklim", "webHla", "webSaxml", "webCosla", "webAxlc", "webAxlf", "webXMML", "webWorkML", "projectXaml", "homeAxlf", "webCrossml", "webWorkml", "webTxaml", "webSaxlf", "WebWorkxml", "httpXml", "webHmary", "WebXml", "homeAxML", "WebWorkml", "projectAxML", "webJaml", "webXML", "WebXxml", "httpXla", "webXPml", "webTexlf", "homeXML", "webXlim", "webCosml", "webCosmary", "webCrossML", "webCrosslim", "webCosxml", "webHml", "homeAxlc", "webTxml", "WebXML", "webXMml", "WebXlim", "webXxml", "webXMlim", "httpXPmary", "projectAxml", "webAxML", "httpXxml", "webWorkxml", "webXPmary", "webTexml", "projectAxaml", "projectXML", "webXlf", "webTexlc", "webXla", "webJML", "webXPxml", "WebWorkML", "webSaxlc", "webJml", "webXPla", "webSaxML", "webAxml"], "portletXml": ["portletxsl", "portfileXML", "portletExml", "portableXpl", "portableXMtml", "portletJml", "portletYsl", "portfileJsl", "portfileJml", "portableXMaml", "portfileXxml", "portletsXML", "portletXMul", "portletSyaml", "portletExpl", "portletXaml", "portableXtml", "portletXML", "portletYul", "portletxML", "portfileXml", "portletExaml", "portletsYsl", "portletsXul", "portfileJML", "portletsXml", "portletxml", "portletsYml", "portletXMML", "portletCml", "portletJsl", "portletYxml", "portletCxml", "portableXMpl", "portletSytml", "portletCsl", "portletJML", "portletSypl", "portfileJxml", "portletXul", "portletXpl", "portfileXsl", "portletExtml", "portletXMaml", "portletXsl", "portletJxml", "portletCML", "portletXtml", "portletXMml", "portableXml", "portletxul", "portletSyml", "portletYML", "portableXMml", "portletsXsl", "portletXMtml", "portableXaml", "portletsYML", "portletXMpl", "portletsYul", "portletXMsl", "portletYml", "portletXxml"], "contextXml": ["contextUla", "contextUml", "contextHxml", "contextXaml", "contextXMla", "conceptHxml", "contextUML", "contextHml", "resourceXxml", "contextHla", "conceptXla", "contextXMxml", "resourcexla", "resourceXla", "contextHaml", "contextxml", "conceptHla", "resourceXml", "contextHML", "contextXML", "conceptXml", "contextxxml", "conceptXaml", "resourceXML", "resourcexxml", "conceptHaml", "contextPhxml", "contextxML", "conceptHml", "contextXMml", "contextPhla", "resourcexML", "conceptXxml", "contextUxml", "contextXxml", "contextPhml", "contextXMaml", "resourcexml", "contextPhaml", "contextXla", "contextxla"], "src": ["inst", "lit", "ctx", "gb", "sync", "st", "bh", "rb", "rel", "jar", "ie", "uri", "socket", "sb", "i", "resource", "ruby", "ssl", "sin", "sr", "ources", "SOURCE", "sub", "host", "http", "slice", "entry", "ur", "zip", "sl", "dist", "rec", "dest", "secure", "username", "kin", "cont", "req", "url", "conn", "in", "sc", "rin", "rss", "ins", "gz", "spec", "href", "s", "comp", "obj", "sit", "result", "ri", "sq", "sel", "rs", "rc", "lower", "cur", "Source", "loc", "rl", "r", "uc", "ource", "config", "ser", "sn"], "source": ["session", "wrapper", "loader", "data", "core", "uri", "service", "string", "i", "xml", "resource", "form", "token", "status", "sin", "sr", "ources", "resources", "slice", "handler", "plus", "reason", "SOURCE", "iter", "zip", "sl", "iterator", "input", "this", "text", "context", "parent", "secure", "function", "fp", "url", "in", "reader", "sp", "stack", "scope", "gen", "connection", "spec", "inner", "get", "unit", "comment", "comp", "style", "storage", "channel", "client", "result", "component", "size", "rc", "stream", "start", "view", "Source", "driver", "ource", "config", "use", "out", "proxy", "null", "e"], "zipEntries": ["ZipEntrys", "zipInstlines", "zipEnry", "zipEnries", "zipEntlines", "ziLenries", "ziEntues", "zipLenls", "zipInstrs", "zipentlines", "ZipEnties", "zipEntry", "zipLenlements", "ziEntls", "zipentrys", "zipEntrs", "ziEntlements", "zipExls", "zipentries", "zipElements", "zipEnrs", "zipInsties", " ZipInstrs", "zipentry", " ZipEnties", "zipExries", "zipentrs", "zipEntlements", "zipEntrys", "zipEnlines", "zipEls", "zipExlements", "ziLenues", "zipInstries", "ziLenlements", " ZipInsties", "zipEnies", "zipenties", "zipEntues", "zipLenues", " ZipInstlines", "zipEnrys", "zipEnties", " ZipEntlines", "ZipEntries", "ZipEntry", "zipEues", "ziLenls", "ziEntries", "zipEntls", "zipEries", " ZipEntries", " ZipInstries", "zipExues", " ZipEntrs", "zipLenries"], "target": ["address", "next", "filename", "prefix", "template", "bh", "content", "format", "platform", "it", "feat", "cat", "string", "site", "resource", "remote", "compatible", "path", "output", "host", "project", "top", "goal", "class", "context", "dest", "tag", "value", "base", "nt", "file", "url", "hop", "qt", "wrong", "type", "concept", "scope", "location", "tail", "style", "name", "route", "pattern", "result", "component", "feature", "arget", "flat", "external", "current", "test", "loc", "Target", "config", "theme", "match"], "webRewriter": ["webrewrite", "webCompriter", "webComporter", "webComprite", "webReworter", " webreworter", "webrewriter", "webComprites", "webEmbrite", "webRewrites", " webRewrite", " webRewrites", "webEmbriter", " webrewrites", " webrewriter", " webReworter", " webrewrite", "webEmborter", "webRewrite", "webreworter", "webrewrites", "webEmbrites"]}}
{"id1": "17158020", "id2": "8788371", "code1": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"passwordString": ["PasswordText", " passwordBytes", " passwordText", "PasswordString", "passwordText", " passwordStr", "passStr", "passBytes", " passwordPassword", "passwordPassword", "PasswordBytes", "passwordBytes", "passPassword", "passString", "passText", "passwordStr", "PasswordPassword", "PasswordStr"], "digest": ["hedested", "diggest", "digit", "Digse", "mainHash", " digEST", "digEST", "signse", "genergest", "hedest", "diger", " digested", "digHash", "compit", "Digested", "signest", "generest", "Digester", "signer", "hedester", "digester", "compested", "signester", "generester", "Diggest", " digester", " diggest", " digse", "mainit", "DigEST", " diger", "digested", "mainest", "heder", " digHash", "Diger", "signEST", "mainested", " digit", "generer", "compHash", "compest", "Digest", "digse"], "raw": ["aws", "unsigned", "wrapper", "RAW", "rew", "row", "wrap", "alpha", "hex", "empty", "pure", "feed", "dec", "initial", "input", "unknown", "binary", "ng", "random", "block", "array", "load", "full", "temp", "missing", "secret", "shared", "Raw", "buffer", "image", "serial", "original", "channel", "instance", "local", "clean", "enc", "out", "null", "none"], "hash": ["version", "Hash", "data", "row", "ruby", "hex", "sh", "id", "response", "sha", "input", "html", "base", "block", "utf", "array", "url", "ashes", "secret", "dig", "image", "header", "hed", "her", "ash", "sum", "index", "ha", "pass", "cache", "mac", "kh", "key", "h", "auth", "rh", "message"]}}
{"id1": "6341264", "id2": "9347451", "code1": "    public static byte[] getJarEntry(String jarName, String entry, int port) {\n        byte[] b = null;\n        try {\n            String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName());\n            String protocol = \"http://\";\n            int x = codebase.indexOf(protocol) + protocol.length();\n            String s2 = codebase.substring(x);\n            int x2 = s2.indexOf('/');\n            String downloadHost = s2.substring(0, x2);\n            if (downloadHost.indexOf(':') == -1) {\n                downloadHost += \":\" + port;\n            }\n            URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry);\n            JarURLConnection jurl = (JarURLConnection) url.openConnection();\n            JarEntry je = jurl.getJarEntry();\n            InputStream is = jurl.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            int size = (int) je.getSize();\n            b = new byte[size];\n            int rb = 0;\n            int chunk = 0;\n            while ((size - rb) > 0) {\n                chunk = bis.read(b, rb, size - rb);\n                if (chunk == -1) {\n                    break;\n                }\n                rb += chunk;\n            }\n            bis.close();\n            is.close();\n            bis = null;\n            is = null;\n            url = null;\n            jurl = null;\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return b;\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 0, "substitutes": {"jarName": ["JarName", "jobName", "jarPath", "zipFamily", "zipAlias", " jarPath", "JarPath", "reportAlias", "jobPath", "jarname", "jobVersion", " jarAlias", "JarVersion", "reportFamily", "jarFamily", " jarVersion", " jarFamily", "jobname", "Jarname", "zipName", " jarname", "reportName", "jarVersion", "jarAlias"], "entry": ["address", "next", "filename", "ry", "data", "jar", "uri", "ie", "service", "string", "source", "parse", "resource", "end", "path", "str", "server", "zip", "file", "type", "connection", "offset", "element", "image", "code", "archive", "name", "info", "route", "start", "key", "ticket", "Entry", "enter", "e", "id"], "port": ["target", "address", "length", "delay", "version", "patch", "point", "uri", "service", "time", "string", "path", "Port", "host", "server", "limit", "PORT", "pi", "file", "timeout", "type", "offset", "ip", "name", "pid", "pos", "ports", "position", "key", "count", "index", "ort"], "b": ["abb", "bar", "pb", "f", "xb", "d", "emb", "a", "nb", "bb", "gb", "eb", "sb", "i", "wb", "db", "ib", "zb", "erb", "fb", "usb", "buff", "buf", "binary", "bs", "base", "p", "bf", "orb", "obb", "v", "lb", "bp", "library", "bin", "boot", "cb", "ab", "bd", "s", "buffer", "mb", "bt", "beta", "br", "B", "c", "bytes", "l", "r", "ob", "e"], "codebase": [" codeb", "Codebase", "Codefile", "broadfull", "Codebas", "mapfile", "codebas", " codebas", " codefull", "mapbas", "geBase", "workfull", "workbase", "CodeBase", "gebase", "contentfile", "codeBase", "codefull", "codefile", "broadbase", "contentunit", "workb", "Codeb", "broadb", "geb", "contentbase", "codeb", "workBase", "mapbase", "gebas", "codeunit", "mapunit", "contentbas", "Codeunit", "broadBase", " codeBase"], "protocol": ["hypocol", "hypprot", "predocol", "protprot", "Proturl", "propometry", "proturl", "extocol", "protometry", "propology", "Prototype", "protology", "exturl", "Protocol", "hypology", "extology", "prototype", "extotype", "protose", " protose", "horometry", "Protose", "horology", "Protometry", "predprot", "propocol", "predose", "Protology", "horocol", "extprot", "horurl", "extose", " prototype", "propurl", " proturl", "hypose", "predology"], "x": ["lex", "rex", "ctx", "f", "xa", "d", "check", "xd", "fx", "ax", "xf", "pe", "cross", "z", "p", "wx", "v", "ix", "w", "X", "ww", "m", "exp", "xxx", "xes", "tx", "y", "xt", "xxxx", "xs", "pos", "en", "index", "max", "work", "rx", "xx", "dx", "val", "xc", "ex", "h", "xi", "xp", "xxxxxxxx", "id"], "s2": ["x4", "s14", "x1", " s96", "v5", "x14", " s14", "x96", "l1", "p1", "S4", "l2", "S256", "s256", "v1", "l5", "s5", "x256", "v2", "S1", "p5", " s1", "latter", "S2", "vatter", " s4", "s4", "s1", "p2", "patter", "s96", "satter", " s256"], "x2": ["ix1", "x1", "X2", " xtwo", "rx1", "ix6", "X1", "ixtwo", " x52", "rx52", "X52", "xtwo", "rx5", "x5", "xp6", "x52", "x6", "xp1", " x6", "X5", " x1", "xp2", " x5", "ix2", "xptwo", "rx2"], "downloadHost": ["transferPath", "urlhost", "writePort", "urlPort", "writehost", "DownloadPort", " downloadPath", "downloadAddress", "urlDomain", " downloadPort", "transferhost", "transferPort", "DownloadAddress", "downloadPort", "externalhost", " downloadForm", "downloadhost", "writeHost", "externalRoot", "externalPort", "DownloadDomain", "transferDomain", " downloadhost", " downloadRoot", "transferAddress", "downloadRoot", " downloadAddress", "externalHost", " downloadDomain", "urlHost", "downloadForm", "writePath", "DownloadForm", "transferHost", "DownloadHost", "transferRoot", "DownloadPath", "writeForm", "downloadPath", "downloadDomain", "writeDomain"], "url": ["rel", "jar", "uri", "bb", "user", "ssl", "abs", "source", "web", "il", "host", "server", "http", "ur", "sl", "zip", "org", "el", "URL", "blog", "base", "orb", "file", "page", "ls", "www", "gl", "connection", "image", "job", "obj", "build", "j", "l", "ll", "link", "Url", "loc", "li", "rl", "ob", "fl", "proxy", "ball", "ul"], "jurl": ["gcoll", "jjUrl", "jpfile", "jjcoll", "JUrl", "gURL", "jjurl", " jURL", "jpul", " jUrl", "gurl", " jweb", "JURL", "jfile", "Jcoll", "ajurl", "jpURL", "jpcoll", " jul", "jobfile", " jsl", "jul", "jweb", "joburl", "ajweb", "jURL", "jpurl", "jcoll", "jobsl", " jbb", "jobweb", "jsl", " jcoll", "jobbb", "jbb", "ajbb", "jpUrl", "jobUrl", "jjul", "jobURL", "gUrl", "ajsl", "Jfile", "Jurl", "jUrl"], "je": ["esi", "jar", "ie", "ni", "jj", "ja", "gi", "fr", "xe", "zip", "Obj", " ze", "jo", "ju", "se", "jen", "java", "pse", "elt", "ii", "ee", "py", "obj", "job", "su", "oe", "j", "jp", "ne", "jl", "js", "Je", "si", "isi", "ji", "be", "la"], "is": ["oss", "ir", "nis", "lis", "address", "ris", "ori", "isin", "jar", "iss", "isl", "ses", "oris", "ie", "bi", "i", "es", "ais", "src", "iris", "ci", "sin", "il", "ib", "http", "zip", "its", "uri", "bs", "isa", "os", "iso", "ai", "vs", "in", "ils", "ins", "state", "s", "ii", "bb", "IS", "mis", "ios", "tis", "ri", "as", "ice", "Is", "are", "isi", "si", "li", "ob", "info", "be", "id"], "bis": ["oss", "obs", "pins", "esi", "nis", "lis", "ris", "ori", "bos", "serv", "isin", "ses", "bb", "iss", "iris", "abs", "bi", "i", "sb", "ais", "sin", "slice", "cos", "http", "di", "bus", "fb", "buff", "usb", "zip", "uri", "binary", "abi", "init", "bs", "base", "lock", "obb", "os", "ubis", "ins", "ls", "bin", "bps", "cb", "boot", "connection", "inner", "IS", "mis", "bes", "ios", "obj", "ri", "Is", "download", "js", "ob"], "size": ["cm", "cl", "address", "sync", "length", "core", "content", "g", "time", "form", "ci", "end", "send", "cr", "capacity", "ize", "small", "speed", "z", "sized", "len", "when", "scale", "base", "large", "shape", "esc", "sc", "co", "se", "fee", "now", "Size", "err", "unit", "range", "code", "name", "c", "width", "en", "rc", "sum", "max", "mode", "close", "si", "iz", "loc", "body", "SIZE", "cel", "enc", "sec", "ner", "use", "e", "sn"], "rb": ["abb", "pb", "xb", "rub", "nb", "rr", "ru", "rw", "RF", "bb", "src", "gb", "eb", "sb", "rd", "ruby", "reb", "wb", "sr", "db", "cr", "erb", "fb", "buf", "rob", "lb", "orb", "bf", "obb", "rab", "cb", "RB", "rg", "rm", "adr", "rar", "mb", "vr", "rt", "rf", " rc", "ri", "lr", "rc", "nr", "loc", "rl", "r", "ob"], "chunk": ["copacket", "charone", "cunc", " Chunks", "unchink", "choy", " chunker", "unchunk", "poy", "cone", "chink", "cherunk", "chacket", " Chunk", "cunk", "bone", "chunker", "copink", "cherink", "jacket", "charunks", "packet", "unchunks", " chink", "chunks", "bink", "charunk", "chone", "cheracket", "cacket", "copunc", "cherunc", " Chunker", "chrow", "bunk", "copoy", "charink", "prow", "punk", "chunc", "cink", "coprow", " Chink", " chunks", "junk", "cunks", "copunk", "jrow", "unchunker", "bunks", "joy"]}}
{"id1": "6906419", "id2": "3187685", "code1": "    public static String encryptPassword(String password) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA1\");\n            digest.update(password.getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                int halfbyte = (hash[i] >>> 4) & 0x0F;\n                int two_halfs = 0;\n                do {\n                    if ((0 <= halfbyte) && (halfbyte <= 9)) {\n                        buf.append((char) ('0' + halfbyte));\n                    } else {\n                        buf.append((char) ('a' + (halfbyte - 10)));\n                    }\n                    halfbyte = hash[i] & 0x0F;\n                } while (two_halfs++ < 1);\n            }\n            return buf.toString();\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"password": ["sword", "address", "prefix", "data", "words", "content", "wd", "user", "string", "confirmed", "token", "path", "project", "input", " passwords", "text", "username", "p", "database", "array", "phrase", "secret", "buffer", "seed", "name", "pattern", "Password", "pass", "PASS", "key", "crypt", "padding", "word", "auth", "message"], "digest": ["initText", "hashester", "diffested", " digEST", "digEST", "DigText", "Digeter", " digText", "diffester", "diffest", " digested", "diger", "digests", "Digested", " digeter", "signest", "Digester", "signer", "digester", "signester", " digester", "initests", " digests", "Digests", "initEST", "DigEST", " diger", "hasheter", "digested", "Diger", "signEST", "diffEST", "digText", "digeter", "initest", "hasher", "hashest", "Digest"], "hash": ["number", "cover", "filter", "address", "f", "version", "Hash", "bug", "bh", "check", "mask", "hex", "wave", "diff", "sh", "id", "sha", "search", "value", "html", "block", "query", "array", "error", "url", "ashes", "handle", "history", "bin", "secret", "char", "buffer", "image", "header", "code", "hed", "batch", "build", "ash", "sum", "memory", "ha", "index", "cache", "kh", "log", "key", "body", "count", "h", "map", "auth", "match", "message"], "buf": ["abb", "queue", "ba", "ctx", "pb", "f", "bh", "rb", "data", "nb", "port", "runner", "bb", "src", "sb", "home", "builder", "wb", "pad", "bc", "db", "uber", "tmp", "buff", "fb", "bu", "cv", "cas", "pkg", "bf", "func", "fp", "v", "url", "vec", "img", "bin", "cb", "Buff", "box", "ab", "buffer", "vr", "abc", "Buffer", "coll", "conv", "b", "uf", "va", "af", "fw", "uv", "cur", "cmp", "aux", "cap", "append", "uc", "ob", "config", "out", "bag", "la"], "i": ["hi", "phi", "f", "length", "a", "x", "d", "ui", "it", "ti", "uri", "ie", "ci", "gi", "qi", "slice", "mu", "di", "h", "init", "abi", "pi", "p", "mini", "v", "ix", "ai", "u", "type", "iu", "io", "ip", "ii", "info", "o", "b", "c", "I", "multi", "fi", "ri", "j", "l", "n", "uni", "si", "key", "li", "ini", "count", "oi", "ji", "index", "xi", "e", "id"], "halfbyte": ["Halfbit", "halfbit", "superchar", "quarterbit", "Halfchar", " halfabyte", "thirdsecond", "postbit", "quarterurl", "wardurl", "quarterbyte", " halfByte", "sidebit", "littlebit", "halfnumber", " halfbit", "halfbytes", "littlebyte", "quarterabyte", " halfchar", "halfchar", "halfreference", "postabyte", "littleByte", "HalfByte", "quarterbytes", "quartersecond", "superbit", " halfbytes", "Halfbyte", "quarterByte", "superbyte", "halfabyte", "halfByte", "sidebyte", "quarternumber", " halfurl", "halfsecond", "littlereference", "halfurl", "sideByte", " halfreference", " halfnumber", "thirdnumber", "sidereference", "wardbyte", "wardbytes", "thirdbyte", "postbyte", " halfsecond"], "two_halfs": ["two_partis", "two_Halfbytes", "two_quarterrows", "two_Halfis", "two_partrows", "two_thirdrows", "two_commons", "two_quarterows", "two_hatows", "two_thirds", "two_halfions", "two_thirdis", "two_thirdbytes", "two_parts", "two_halfbytes", "two_commonows", "two_hatrows", "two_commonrows", "two_Halfrows", "two_commonions", "two_hats", "two_hations", "two_Halfs", "two_halfrows", "two_quarters", "two_partbytes", "two_halfis", "two_quarterions", "two_halfows"]}}
{"id1": "3683344", "id2": "12106167", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    public static void init(Locale lng) {\n        try {\n            Locale toLoad = lng != null ? lng : DEFAULT_LOCALE;\n            URL url = ClassLoader.getSystemResource(\"locales/\" + toLoad.getISO3Language() + \".properties\");\n            if (url == null) {\n                url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n            }\n            PROPS.clear();\n            PROPS.load(url.openStream());\n        } catch (IOException ioe) {\n            try {\n                URL url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n                PROPS.clear();\n                PROPS.load(url.openStream());\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.exit(99);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(99);\n        }\n    }\n", "label": 0, "substitutes": {"secure": ["session", "ssh", "Secure", "encrypted", "debug", "secondary", "allow", "sensitive", "fast", "ssl", "confirmed", "safe", "remote", "sec", "host", "require", "str", "server", "password", "sys", "zip", "deep", "ce", "stable", "random", "weak", "protect", "smart", "timeout", "security", "secret", "seed", "force", "forced", "client", "expensive", "exclusive", "close", "ctr", "https", "config", " insecure", "proxy", "active", "depth"], "md5": ["amd512", "mand5", "mand2", " MD5", "MD2", " md65", " MD65", "mandol", "amd4", "mdol", "cmd3", "MDkey", " MD2", "cmd512", "mdkey", "md512", " md2", "md65", "cmd5", " md3", "amdok", "mag512", "mag5", " MD3", "cmdok", "cmd4", "mdok", "MD3", "md3", "mand3", "mag4", "md2", "MD65", "cmdol", "mand53", "md4", "md53", "mandkey", " mdol", " md53", "cmd53", "magok", " mdkey", "amd5", "MD5"], "sbValueBeforeMD5": ["sbValueBeforeMP523", "sbValuebeforeMD3", "sbValueWithoutAMD3", "sbValueBeforeMT5", "sbValueWithoutAMD1", "sbValueBeforeM53", "sbValueBeforeMP25", "sbValueAfterMSKey", "sbValueBeforeMDKey", "sbValueAfterMP5", "sbValueBehindDD525", "sbValueBeforeMD50", "sbValueBeforeMC2", "sbValueWithoutMS25", "sbValueBeforeMT523", "sbValueAboveMT523", "sbValueWithoutMSBlock", "sbValueAfterMP50", "sbValueBeforeMDql", "sbValueBeforeMITBlock", "sbValueBehindMD5", "sbValueBehindMD25", "sbValueBeforeMS5", "sbValueBeforeDF3", "sbValueBeforeMC3", "sbValueBehindDD3", "sbValueBeforeMD3", "sbValueWithoutMD1", "sbValueAfterMD3", "sbValueBeforeDF523", "sbValueWithoutMD5", "sbValuebeforeMD2", "sbValueBeforeMT8", "sbValueBeforeAMD5", "sbValueBeforeMD53", "sbValueWithoutMDBlock", "sbValueBeforeDF8", "sbValueWithoutMS3", "sbValueBeforeDD525", "sbValueBeforeMD523", "sbValueBeforeMS3", "sbValueAfterMP3", "sbValueAfterMD2", "sbValueBeforeAMD1", "sbValueBeforeMS1", "sbValuebeforeMT3", "sbValueBeforeMD1", "sbValueAboveMT8", "sbValueBeforeDER5", "sbValueBeforeDD25", "sbValueBeforeMC25", "sbValueBeforeMD8", "sbValueBeforeMP5", "sbValueBeforeMIT5", "sbValueBeforeMD2", "sbValueWithoutMD3", "sbValueAfterMS5", "sbValueAboveMD3", "sbValueBeforeMC525", "sbValueBeforeDD3", "sbValueAboveMT3", "sbValueBeforeMT3", "sbValuebeforeMTql", "sbValueAboveMD8", "sbValueBeforeDF5", "sbValueBeforeMC5", "sbValueBeforeMP1", "sbValueBeforeMKey", "sbValueBeforeM3", "sbValueBeforeMSKey", "sbValueBeforeMS525", "sbValuebeforeMT5", "sbValueBeforeM2", "sbValueBehindDD5", "sbValueWithoutAMD5", "sbValueBeforeMSBlock", "sbValueBeforeMS2", "sbValueBehindMD3", "sbValueAfterMP2", "sbValueBeforeMP8", "sbValueBeforeM5", "sbValueBehindDD25", "sbValueAboveMD5", "sbValuebeforeMD5", "sbValueBeforeDER53", "sbValueWithoutMD25", "sbValueWithoutAMD2", "sbValueAboveMT5", "sbValueBeforeMIT3", "sbValueWithoutMS5", "sbValueAfterMD50", "sbValueWithoutMD2", "sbValueAfterMS3", "sbValueBeforeMP3", "sbValueBehindMD525", "sbValueAfterMD53", "sbValueBeforeMT2", "sbValuebeforeMT2", "sbValueAfterMD5", "sbValueBeforeMIT25", "sbValueBeforeMDBlock", "sbValueBeforeMP2", "sbValueBeforeAMD2", "sbValueBeforeMP50", "sbValueBeforeMD525", "sbValueBeforeDD5", "sbValueAfterMS53", "sbValueBeforeMS53", "sbValuebeforeMDql", "sbValueBeforeMCql", "sbValueBeforeMS50", "sbValueBeforeDER3", "sbValueBeforeMS25", "sbValueBeforeMTql", "sbValueBeforeDERKey", "sbValueBeforeMD25", "sbValueAfterMDKey", "sbValueBeforeAMD3", "sbValueBeforeMPBlock", "sbValueAboveMD523", "sbValueBeforeMql"], "valueBeforeMD5": ["valueAfterMP2", "valueBeforeMP5", "valueBeforeMT85", "valueBeforeMP1", "valueBeforeMD6", "valueAfterMD1", "valueBeforeMC3", "valueBeforeME2", "valueAfterMC5", "valueAfterMD6", "valueBeforeMP2", "valueBeforeMD2", "valueBeforeMC6", "valueBeforeMAC5", "valueBeforeMT3", "valueBeforeMT2", "valueAfterMD3", "valueBeforeMD85", "valueBeforeMP6", "valueBeforeME3", "valueBeforeMP3", "valueAfterMC2", "valueAfterMP3", "valueAfterMD2", "valueAfterMC1", "valueAfterMC3", "valueAfterMD85", "valueBeforeMD3", "valueAfterMC6", "valueBeforeMD1", "valueBeforeMC5", "valueBeforeMAC3", "valueBeforeMC35", "valueAfterMD35", "valueBeforeAMD2", "valueBeforeMC2", "valueBeforeMD35", "valueBeforeME35", "valueBeforeMAC1", "valueBeforeMT5", "valueBeforeAMD3", "valueBeforeMC1", "valueBeforeMAC6", "valueBeforeME5", "valueAfterMC35", "valueBeforeAMD5", "valueBeforeMP85", "valueAfterMP5"], "time": ["Time", "tz", "length", "delay", "version", "depth", "port", "counter", "times", "money", "host", "hour", "speed", "duration", "TIME", "value", "q", "random", "rate", "error", "ime", "sleep", "play", "timeout", "type", "seed", "ip", "name", "clock", "year", "ice", "size", "mode", "start", "work", "tim", "count", "rice", "date", "etime", "race", "id"], "rand": ["version", "delay", "bug", "rr", "pick", "depth", "dr", "ro", "alpha", "raid", "rule", "mid", "game", " random", "ng", "dist", "random", "root", "rate", "rage", "dd", "round", "error", "winner", "ring", "res", "type", "bit", "dev", "gen", "range", "seed", "rar", "serial", "right", "name", "year", "reg", "order", "pattern", "rc", "nd", "win", "rank", "risk", "max", "index", "rx", "loc", "clean", "r", "count", "Rand", "rh", "id"], "array": ["number", "expression", "address", "a", "row", "integer", "string", "section", "sample", "form", "angle", "app", "air", "list", "binary", "value", "function", "error", "Array", "range", "image", "arr", "pair", "hash", "module", "collection", "element", "archive", "batch", "multi", "result", "instance", "feature", "view", "audio", "ray", "our", "r", "area", "api", "record", "index", "object", "message"], "i": ["hi", "phi", "f", "x", "d", "ui", "ti", "ie", "uri", "bi", "ci", "gi", "qi", "slice", "ind", "mu", "di", "t", "z", "abi", "pi", "chi", "p", "v", "in", "ai", "u", "k", "yi", "io", "inner", "ip", "ii", "y", "info", "o", "b", "ri", "I", "c", "multi", "j", "l", "index", "n", "si", "key", "li", "oi", "field", "h", "xi", "eni", "e", "id"], "strTemp": ["arrTemp", "brtemp", "charTemplate", "StrTemp", "brKey", "prtemp", "StrBase", "strTemplate", "frTemp", "arrTab", "strKey", "frSalt", "StrTem", " strKey", "frtemp", "objTem", "strtemp", " strtemp", "intTem", " strTemplate", "charTemp", "Strtemp", "objTemp", " strTest", "brTab", "brTem", "prTem", "charKey", " strBase", "objSalt", "StrTest", "intTest", "charTem", "frTem", "intBase", "strBase", "brBase", "arrTem", "brTemplate", " strTem", "strTest", "brTemp", "objtemp", "prTab", "StrSalt", "arrtemp", "intTemp", "strSalt", "strTem", "strTab", "prTemp"], "valueAfterMD5": ["valueAfterMP2", "valueBeforeMP5", "valueBeforeMD75", "valueAfterMeta5", "valueAfterMD1", "valueBeforeMC3", "valueAfterSM1", "valueAfterMC20", "valueBeforeMD2", "valueBeforeAST55", "valueAfterSHA2", "valueBeforeMP20", "valueAfterMDql", "valueAfterMRDown", "valueAfterMC3", "valueAfterMF3", "valueBeforeMD1", "valueBeforeMC5", "valueAfterSM55", "valueAfterMF305", "valueBeforeMCFive", "valueAfterMOD3", "valueAfterSM3", "valueAfterSHA5", "valueBeforeMD305", "valueAfterAST5", "valueAfterSHA3", "valueAfterSM5", "valueAfterAMD512", "valueBeforeAST75", "valueAfterMP20", "valueBeforeMP2", "valueAfterMD20", "valueAfterMD3", "valueAfterMF5", "valueAfterMCDown", "valueAfterEMS3", "valueAfterMC2", "valueBeforeMDFive", "valueAfterMD305", "valueAfterMD55", "valueAfterSM305", "valueBeforeAST305", "valueAfterSMql", "valueBeforeMD512", "valueAfterAMD3", "valueAfterMP512", "valueAfterMP1", "valueAfterMDDown", "valueBeforeAST3", "valueBeforeMD55", "valueAfterMetaDown", "valueAfterSHA20", "valueAfterMDFive", "valueAfterAMD5", "valueAfterMR5", "valueAfterMD2", "valueAfterMRFive", "valueAfterMPql", "valueBeforeMD3", "valueBeforeMDql", "valueBeforeMP512", "valueAfterMR3", "valueBeforeMCDown", "valueAfterEMS75", "valueBeforeMP3", "valueAfterMOD512", "valueAfterAST3", "valueAfterMC5", "valueAfterAST305", "valueAfterMCFive", "valueAfterAMD75", "valueBeforeMDDown", "valueAfterEMS5", "valueAfterMP3", "valueAfterMD75", "valueBeforeMD20", "valueAfterAST55", "valueAfterMOD5", "valueAfterMetaFive", "valueBeforeAST5", "valueAfterAST75", "valueAfterMeta3", "valueAfterMD512", "valueAfterMF55", "valueAfterMP5"]}}
{"id1": "16511008", "id2": "9109613", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"configID": ["configIDE", "ConfigId", "ConfigID", "contractIP", "configUID", "configIP", "configRI", "ConfigUID", "configId", "projectId", "ConfigIP", "projectIP", " configRI", "projectIDE", "projectID", "contractID", " configUID", "contractIDE", "projectRI", "contractUID", "projectUID", " configId", "ConfigRI", "ConfigIDE"], "programMessageSymbolID": ["programMessageSyncmbID", "programMessageSymbid", "programMessageSyborI", "programMessageSymbIT", "programMessageSyncmbolID", "programMessageSymbolIDE", "programMessageSyplementationId", "programMessageEntaxid", "programMessageSyMBID", "programMessageSyncmbolIL", "programMessageSyplementationIDE", "programMessageSyMBIDE", "programMessageSymbolid", "programMessageSyntaxI", "programMessageSyncmbIT", "programMessageSyletterId", "programMessageSyletterIP", "programMessageEntaxID", "programMessageSyntaxid", "programMessageSymbI", "programMessageSyMBId", "programMessageSyletterID", "programMessageSyletterIT", "programMessageEmbolI", "programMessageSyntaxId", "programMessageSyborID", "programMessageSymbIL", "programMessageSyncmbIP", "programMessageSymbIV", "programMessageSymbID", "programMessageSyncmbIL", "programMessageSyncmbId", "programMessageSymbolIP", "programMessageSyntaxID", "programMessageSyectorId", "programMessageSyntaxIV", "programMessageSyborId", "programMessageSyncmbolIT", "programMessageSyncmbIDE", "programMessageSymbIP", "programMessageSymbolIL", "programMessageEmbolid", "programMessageSyncmbolIDE", "programMessageEntaxI", "programMessageSymbolI", "programMessageSyectorID", "programMessageEmbolId", "programMessageSymbolIT", "programMessageSyMBIL", "programMessageSymbolIV", "programMessageEmbolID", "programMessageSymbId", "programMessageSyncmbolId", "programMessageSyncmbolIP", "programMessageSyplementationIL", "programMessageSyborid", "programMessageSymbolId", "programMessageSyplementationID", "programMessageEntaxId", "programMessageSyncmbIV", "programMessageSyectorIV", "programMessageSymbIDE", "programMessageSyncmbolIV"], "profilingMessageSymbol": ["profilingMessageSynPart", "profilingApplicationSymbol", "profilingMessageYletter", "profilingApplicationSyletter", "profilingFileSymSy", "profilingMessageSymb", "profilingMessageSymmbol", "profilingMessageCyletter", "profilingMessageCymbol", "profilingMessagePolymbol", "profilingFileSymbol", "profilingUserYletter", "profilingFileSySy", "profilingApplicationSymmb", "profilingMessageSySy", "profilingMessageSymPart", "profilingUserYmbol", "profilingMessageSymletter", "profilingFileSymPart", "profilingMessageSynmbol", "profilingMessagePolyPart", "profilingUserSymb", "profilingUserYmb", "profilingApplicationSymmbol", "profilingUserSyletter", "profilingUserSymbol", "profilingMessageYmb", "profilingMessagePolySy", "profilingMessageYmbol", "profilingMessageSynSy", "profilingMessageSyPart", "profilingFileSyPart", "profilingMessageSyletter", "profilingApplicationSymb", "profilingMessageCymb", "profilingApplicationSymletter", "profilingMessageSymmb", "profilingFileSymmbol", "profilingMessageSymSy"], "connection": ["application", "session", "Connection", "ctx", "version", "condition", "port", "user", "socket", "section", "connect", "document", "container", "con", " Connection", "ongo", "db", "bc", "response", "password", "server", "context", "communication", "function", "database", "volume", "error", "conn", "directory", "environment", "manager", "state", "engine", "table", "management", "unit", "image", "sql", "connected", "collection", "client", "channel", "relation", "c", "machine", "result", "ion", "cache", "log", "pool", "position", "driver", "config", "index", "use"], "statement": ["joined", "session", "Connection", "expression", "next", "Statement", "Session", "condition", "parse", "string", "section", "connect", "study", "document", "Query", "rule", "db", "str", "response", "di", "command", "commit", "writer", "function", "lock", "database", "jo", "error", "conn", "volume", "se", "part", "library", "timeout", "mt", "directory", "state", "stat", "comment", "usage", "unit", "management", "sql", "table", "storage", "collection", "execute", "relation", "result", "instance", "journal", "ment", "ss", "pass", "si", "parser", "general", "report", "use", "out", "message"], "resultSet": ["ResultTime", "errorSource", "responseGroup", " resultChan", "resultLine", " resultList", "resultSource", "responseTime", "featureChan", "resultList", "ResultGen", "resultTime", "resultHit", "ResultList", "resourceSet", "featureSet", " resultS", "responseSource", "resourceS", "responseList", "resultGroup", "rowGroup", "rowSet", "errorHit", "responseGen", "ResultSet", "ResultHit", "resourceSource", " resultTime", " resultSource", "resultChan", "ResultLine", "featureList", " resultGen", "responseSet", "ResultS", " resultLine", "resultGen", "featureLine", "ResultChan", " resultHit", "rowList", "ResultSource", "resultS", "errorSet", "ResultGroup"], "query": ["join", "expression", "script", "condition", "uri", "request", "string", "parse", "resource", "qu", "Query", "go", "send", "rule", "reason", "str", "id", "command", "search", "question", "value", "q", "qq", "lock", "database", "scan", "error", "root", "function", " Query", "select", "timeout", "type", "call", "comment", "table", "sql", "module", "name", "update", "code", "o", "result", "sq", "ql", "description", "work", "cache", "general", "report", "eries", "record", "index", "info", "message"], "msg": ["gm", "fg", "cm", "nm", "tool", "gr", "dr", "cfg", "format", "rr", "g", "phrase", "gor", "mr", "reason", "str", "id", "model", "ug", "mu", "e", "game", "og", "text", "desc", "tag", "pkg", "html", "agg", "mn", "sg", "req", "op", "error", "ma", "gs", "var", "mt", "type", "m", "Msg", "err", "gen", "ge", "rg", "char", "ag", "exc", "module", "title", "mg", "name", "info", "cmd", "md", "printf", "set", "doc", "bg", "log", "def", "cap", "bag", "status", "map", "sim", "message"]}}
{"id1": "2676365", "id2": "7468819", "code1": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"currentPilot": ["currentpector", "currentpooter", "activePacket", "activePistor", "currentCPilot", "currentPortilot", "currentCPector", " currentCPacket", "currentPector", "currentpilot", "activePilot", "currentPointilot", "currentPiece", " currentCPooter", " currentCPector", "currentPortacket", "currentPooter", "currentPointistor", "currentPayilot", " currentCPilot", "currentPayiece", "currentPacket", "currentPayacket", "currentPistor", "currentpiece", "currentCPooter", "activepilot", " currentPector", "currentpacket", "activepistor", "activepacket", "currentpistor", " currentPooter", "activePiece", "currentCPacket", "currentPointiece", "currentPointacket", " currentPacket", "currentPayistor", "currentPortector", "currentPortooter", "activepiece"], "psta": ["psa", "Psa", "pda", "Pda", " pste", "pela", "Pasi", "paresta", "Pla", "peppa", "pppa", "jda", "pste", "Pppa", " psa", "jsta", "pla", " pla", "pesta", "jste", "parsta", "pesa", " pppa", "parsa", " pesta", "Pste", " pda", "parasi", "jsa", "pasi", "Psta", " pasi", "Pesta"]}}
{"id1": "9275622", "id2": "22264586", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"_file1": ["_zip1", "_fone", "_resource1", "_files01", "_fileOne", "_f1", "_mail2", "_zipOne", "_files0", "_mail0", "_fOne", "_File2", "_mail01", "_fileone", "_files1", "_resourceone", "_files2", "_file01", "_fileFirst", "_resourceFirst", "_file0", "_File01", "_File0", "_fFirst", "_File1", "_mail1", "_resourceOne", "_zipone", "_zipFirst"], "_file2": [" _files4", "_play2", "_Filesecond", "_playsecond", "_play3", "_model1", "_File5", "_filesTwo", " _file4", " _filesTwo", "_playTwo", " _fileTwo", "jmodelsecond", "jmodel2", "jmodel5", "_File2", "_play5", "jfile2", "_play1", " _files3", "jfile1", "_files2", "_file3", "_model5", "_filesecond", "_files4", "_play4", "_File1", "jfile5", "_modelsecond", "_file4", "jmodel1", "_fileTwo", "jfilesecond", "_files3", " _files2", "_file5", " _file3", "_model2"], "fis": ["Fos", "lfis", "fas", " fils", " fris", "lfais", " fas", "Fris", "fris", "cfas", " fais", "Fils", "cfris", "lfiss", "afis", "afi", "Fis", " fiss", "infils", " fi", "afiss", "cfis", "afais", "fais", "cfiss", "fiss", "infiss", "cfos", "fils", "Fas", "fi", "infos", "Fiss", "lfi", "infis"], "fos": ["Fos", "foes", "feoses", "Foos", "lis", "fOS", "lOS", "feis", "flOS", "infios", "gus", "faos", "poes", "floes", "fus", " fo", "infoos", "goses", "Fis", "los", "flos", "foos", "Fros", " fios", "fios", "infros", " fus", " faos", "Fus", "infaos", "flis", "Fios", "fo", " foos", " fros", "pos", "foses", "gos", "infos", "Fo", "Foses", "feos", "infus", "pis", "pOS", "fros", "Faos", "feus", "info", "loes", "gis"], "canalFuente": ["canalBuente", "canallBuente", "canallBuencia", "canalBuze", "canalsFuencia", "canalFUje", "canalsBuente", "canalCraento", "canaledBuje", "canalFUence", "canalBuento", "canaledFuje", "canalKuze", "canalsFuento", "canalsFuente", "canaledFuze", "canalBuestro", "canalFUze", "canalCraente", "canalBuencia", "canalSuze", "canalSuestro", "canalFUente", "canalsFuence", "canalCraencia", "canalBuje", "canalSuente", "canallFuence", "canalFuze", "canallFuze", "canalCraence", "canallBuence", "canalFUestro", "canalFuestro", "canalsBuento", "canaledBuze", "canalFuje", "canalKuence", "canallBuze", "canaledBuestro", "canalSuje", "canallFuente", "canalFuence", "canalKuente", "canalKuencia", "canalKuento", "canalFuento", "canalsBuencia", "canaledBuente", "canalFUencia", "canalsBuence", "canalBuence", "canallFuencia", "canaledFuente", "canalFuencia", "canaledFuestro"]}}
{"id1": "19147279", "id2": "2198730", "code1": "    public boolean actualizarDatosFinal(int idJugadorDiv, int idRonda, jugadorxDivxRonda unjxdxr) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET resultado = ?, puntajeRonda = ? \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatementActFinal(unjxdxr);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    public void importCSV(InputStream csvfile) throws Exception {\n        try {\n            String[] qmarks = new String[columns.length];\n            for (int i = 0; i < qmarks.length; i++) {\n                qmarks[i] = \"?\";\n            }\n            if (cleartable) {\n                String delsql = \"delete from \" + table;\n                Statement delstm = conn.createStatement();\n                delstm.executeUpdate(delsql);\n            }\n            String sql = \"insert into \" + table + \" (\" + StringUtils.join(columns, \", \") + \") values (\" + StringUtils.join(qmarks, \", \") + \")\";\n            log.debug(\"SQL: \" + sql);\n            PreparedStatement stm = conn.prepareStatement(sql);\n            int datatypes[] = new int[columns.length];\n            for (int i = 0; i < columns.length; i++) {\n                Table tbl = project.getTableByName(table);\n                if (tbl == null) throw new OntopiaRuntimeException(\"Unknown table: \" + table);\n                Column col = tbl.getColumnByName(columns[i]);\n                if (col == null) throw new OntopiaRuntimeException(\"Unknown table column: \" + columns[i]);\n                if (col.getType() == null) throw new OntopiaRuntimeException(\"Column type is null: \" + col.getType());\n                DataType datatype = project.getDataTypeByName(col.getType(), \"generic\");\n                if (datatype == null) throw new OntopiaRuntimeException(\"Unknown column type: \" + col.getType());\n                String dtype = datatype.getType();\n                if (\"varchar\".equals(dtype)) datatypes[i] = Types.VARCHAR; else if (\"integer\".equals(dtype)) datatypes[i] = Types.INTEGER; else throw new OntopiaRuntimeException(\"Unknown datatype: \" + dtype);\n            }\n            LineNumberReader reader = new LineNumberReader(new InputStreamReader(csvfile));\n            for (int i = 0; i < ignorelines; i++) {\n                String line = reader.readLine();\n                if (line == null) break;\n            }\n            log.debug(\"[\" + StringUtils.join(columns, \", \") + \"]\");\n            int lineno = 0;\n            while (true) {\n                lineno++;\n                String line = reader.readLine();\n                if (line == null) break;\n                try {\n                    String[] cols = StringUtils.split(line, separator);\n                    if (cols.length > columns.length && !ignorecolumns) log.debug(\"Ignoring columns: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    log.debug(\"CVALUES: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    String dmesg = \"(\";\n                    for (int i = 0; i < columns.length; i++) {\n                        String col = cols[i];\n                        if (stripquotes) {\n                            int len = col.length();\n                            if (len > 1 && ((col.charAt(0) == '\"' && col.charAt(len - 1) == '\"') || (col.charAt(0) == '\\'' && col.charAt(len - 1) == '\\''))) col = col.substring(1, len - 1);\n                        }\n                        if (col != null && col.equals(\"\")) col = null;\n                        dmesg = dmesg + col;\n                        if (i < columns.length - 1) dmesg = dmesg + \", \";\n                        stm.setObject(i + 1, col, datatypes[i]);\n                    }\n                    dmesg = dmesg + \")\";\n                    log.debug(dmesg);\n                    stm.execute();\n                } catch (Exception e) {\n                    conn.rollback();\n                    throw new OntopiaRuntimeException(\"Cannot read line \" + lineno + \": '\" + line + \"'\", e);\n                }\n            }\n            conn.commit();\n        } finally {\n            if (conn != null) conn.close();\n        }\n    }\n", "label": 1, "substitutes": {"idJugadorDiv": ["idJugordOrd", "idJugadorOrd", "idJubadorDec", "idJugaderDiv", "idJubordDiv", "idJugrarOrd", "idJugadorDoc", "idJubordDoc", "idJugordDoc", "idJudadorDiv", "idJugrarDiv", "idJugaderDec", "idJugrarDoc", "idJudadeDIV", "idJugadorDec", "idJugordDec", "idJugadeDiv", "idJugaderDoc", "idJugadeDec", "idJugrarDec", "idJubadorDoc", "idJudadeDec", "idJubadorOrd", "idJugadeDIV", "idJubadorDiv", "idJubordOrd", "idJugordDIV", "idJugaderOrd", "idJudadeDiv", "idJudadorDec", "idJugaderDIV", "idJubordDec", "idJudadorDIV", "idJugadorDIV", "idJugordDiv"], "idRonda": ["idGrona", " idRanna", " idranna", "pidRhonda", " idrona", "idRhanna", " idronda", " idrora", "idRona", "idRado", "idRhora", "idGrora", "idrora", "idRhona", "pidRora", "idrona", "idRhado", "idRanna", "idranna", "idRora", "idrado", " idRora", "pidRado", "idRhonda", "pidRhado", "idronda", "pidRhona", " idRona", "pidRhora", "pidRonda", "pidRona", "idGronda", "idGrado"], "unjxdxr": ["unjxdddr", "unjxdxxr", "unjxfxr", "unjddxxer", "unjxdxrs", "unjxdddrs", "unjxfexr", "unjddxxl", "unjddxer", "unjddxR", "unjxdxR", "unjxfexR", "unjxdxtl", "unjxdxtrs", "unjddxxr", "unjxfxrs", "unjxdxtr", "unjxfexrs", "unjxdxtR", "unjxdexr", "unjddxl", "unjxfxR", "unjxdxl", "unjxdxer", "unjxdexl", "unjxdexrs", "unjxdexer", "unjxdexR", "unjddxr", "unjxdxxl", "unjxdxter", "unjxdxxer", "unjxdddR", "unjddxxR", "unjxdxxR"], "intResult": ["IntRes", "longResponse", "longRes", " intOrder", "IntOrder", "IntCode", " intRest", "mintResult", " intRate", "mintReturn", "intReturn", "intRest", "ntResponse", "intCode", "IntReturn", "mintRate", "longResult", "intRate", " intRes", "INTResult", "ntResult", "IntResult", "IntRate", "INTRest", "mintOrder", "IntResponse", "longCode", "intOrder", "ntCode", "intResponse", "intRes", "INTReturn", "ntRes", " intReturn", "IntRest", "INTRes"], "sql": ["joined", "join", "sync", "msg", "plan", "pg", "socket", "ssl", "string", "section", "sb", "db", "str", "nl", "limit", "sl", "pr", "search", " SQL", "query", "database", "QL", "url", "conn", "params", "dd", "select", "SQL", "mt", "statement", "comment", "job", "cmd", "printf", "sq", "ql", "l", "log", "fn", "dl", "eps"], "connection": ["application", "session", "Connection", "ctx", "condition", "pg", "socket", "BC", "section", "connect", "document", "container", "con", "handler", "db", "bc", "server", "character", "writer", "context", "cp", "communication", "function", "database", "query", "conn", "reader", "statement", "environment", "manager", "engine", "table", "collection", "connected", "client", "relation", "c", "cc", "ion", "log", "position", "loc", "driver", "config", "index", "proxy"], "ps": ["pa", "cs", "pg", "changes", "pers", "PS", "ds", "hs", "pe", "pc", "pp", "pps", "pr", "cp", "bs", "p", "relations", "ping", "os", "conn", "params", "ns", "gs", "sp", "ins", "ls", "Ps", "ms", "qs", "pse", "ops", "details", "syn", "ips", "ups", "po", "rs", "ts", "ports", "mp", "ppa", "proxy", "posts", "eps", "ks"]}}
{"id1": "9796161", "id2": "4798332", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 1, "substitutes": {"s": ["styles", "ends", "S", "comments", "f", "cs", "a", "data", "g", "ses", "lines", "ssl", "string", "sb", "i", "es", "source", "abs", " returns", "str", "parts", "ds", "is", "input", "ings", "its", " fails", "scripts", "bs", "p", "os", "v", "tests", "in", "ns", "als", "gs", "ls", "ates", "ms", "self", "sets", "services", "ws", "bytes", "b", "c", "ips", "rs", "l", "ss", "ps", " signs", "ts", "n", "js", "si", "sym", "strings", "ows", "e"], "m": ["gm", "man", "cm", "nm", "f", "um", "d", "sm", "hm", "pm", "vm", "i", "em", "im", "mu", "e", "ym", "mm", "am", "p", "bm", "mand", "M", "mt", "manager", "ms", "rm", "arm", "module", "wm", "dm", "machine", "md", "c", "o", "om", "tm", "l", "me", "mac", "mi", "mc", "h", "mr", "fm"]}}
{"id1": "12236729", "id2": "11562173", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "label": 1, "substitutes": {"inputFile": ["outputFiles", "outputfile", "sourcePath", "inputfile", "currentDir", "currentFile", "inputFiles", " inputDir", "sourceFiles", "currentFiles", "inputDir", " inputfile", " inputPath", "outputPath", "inputPath", " inputFiles", "outputDir", "sourceFile", "sourcefile", "currentfile"], "outputFile": ["tempFile", "OutputFile", "referenceFilename", "outputfile", " outputFilename", "Outputfile", "OutputDirectory", "inputfile", "OutputDir", "referenceDir", " outputfile", "tempDirectory", "outputDirectory", " outputDir", "tempDir", "referencefile", "inputDir", "outputFilename", "tempfile", "outputDir", "inputFilename", "referenceFile", " outputDirectory"], "in": ["gin", "f", "a", "pull", "socket", "inn", "source", "i", "ln", "con", "sin", "read", "is", "input", "init", "kin", "lock", "min", "din", "conn", "lin", "file", "reader", "ins", "bin", "into", "err", "connection", "inner", "get", "s", "image", "up", "inside", "as", "l", "win", "In", "n", "cin", "inc", "IN", "nin", "ini", "r", "login", "again", "pin", "e", "id"], "out": ["sync", "OUT", "socket", "i", "output", "off", "plus", "line", "writer", "parent", "Out", "v", "file", "conn", "error", "plain", "w", "temp", "bin", "one", "err", "net", "io", "up", "obj", "o", "b", "outside", "outs", "write", "exec", "outer", "over", "n", "cache", "inc", "post", "at", "log", "ex", "copy", "extra", "again", "null"], "c": ["cm", "cl", "f", "d", "cu", "a", "x", "cf", "lc", "i", "ci", "C", "line", "cr", "pc", "character", "ce", "fc", "p", "cy", "v", "esc", "sc", "u", "ct", "m", "k", "char", "code", "ec", "cd", "o", "b", "cc", "l", "rc", "n", "ch", "xc", "count", "uc", "r", "pointer", "col", "e", "id"]}}
{"id1": "14783950", "id2": "22046596", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"fileList": ["FileStream", "filelist", " fileCollection", "modelEx", "modelCollection", "fileChain", "ziplist", " fileSet", "fileEx", "FileChain", "stringChain", "FileSet", "stringlist", "wordName", "inputStream", "FileName", "FileList", " fileStream", "Filelist", "fileStream", "fileSet", "fileCollection", "wordStream", "modelStream", "wordString", "inputList", "fileString", "zipList", "wordList", "FileString", "inputCollection", "stringList", " fileString", "zipName", " filelist", "modelList", "inputEx", "zipSet", " fileEx", "stringName", " fileChain"], "zipFileName": ["zipFilename", "archiveDirPath", "folderFilePath", "zipFileDir", "zipGlobalPath", "folderGlobalPath", "zipFullNames", "folderFileName", "zipGlobalNames", "zipFullDir", "zipPackageDir", "zipGlobalName", "folderGlobalNames", "zipFullName", "archiveFileDir", "zipFilePath", "zipDirDir", "folderGlobalname", "zipDirname", "archiveDirDir", "zipFullPath", "folderGlobalName", "zipGlobalname", "zipDirPath", "folderFileNames", "archiveFileName", "folderFilename", "archiveDirName", "zipFullname", "zipDirName", "zipPackageName", "zipFileNames", "archiveFilePath", "zipDirNames", "zipPackagePath"], "fos": ["Fos", "FoS", "faos", " fosh", "afis", "Fis", "flos", "fosh", "infoS", "afaos", "afos", "infaos", "flis", "foS", "Fosh", "afoS", "infos", "infis", "flosh", "Faos"], "zos": ["tz", "phi", "bos", "nz", "budget", "ses", "ozo", "lins", "LOS", "es", "zen", "inos", "zz", "zik", "zers", "cos", "zb", "zag", "ZA", "zip", "bag", "z", "zar", "abi", "zl", "onz", "zer", "zy", "zi", "jobs", "webkit", "os", "obb", "jas", "fits", "zo", "dos", "zzy", "closure", "zon", "css", "zx", "gz", "bis", "bes", "oses", "lol", "outs", "rez", "fi", "kos", "ros", "iframe", "zan", "uz", "chini", "seconds", "loop", "osi", "packs", "spin", "zes", "ZI"], "iter": ["walker", "ir", "itter", "f", "next", "it", "ener", "cher", "fer", "gener", "ie", "parse", "i", "former", "end", "slice", "http", "fr", "is", "iner", "iterator", "list", "ator", "el", "ite", "file", "chain", "keep", "er", "izer", "inter", "ter", "err", "sort", "inner", "finder", "ip", "liter", "Iterator", "inse", "set", "order", "Iter", "outer", "inc", "oper", "iz", "loc", "test", "upper", "ner", "ser", "index", "coll", "enter", "e"], "fileName": ["fullName", "FilePart", "filename", " fileInfo", "fullOpen", "FilePath", "fileInfo", "pageString", "Filename", "localPart", "filePath", "fLine", "filenamename", "fileFull", " fileType", "FileName", "filenameInfo", " fileUrl", "FileUrl", "simpleOpen", "pageName", "FileData", " fileData", "simplePath", "FileLine", " fileLine", "fPart", "filenameFull", "filePart", "currentname", "fileString", "fileOpen", " filePath", "localname", "fileData", "filenameName", "currentUrl", "FileFull", "FileString", "fname", " filePart", " fileString", "fileUrl", "currentData", "simpleName", "currentName", " fileOpen", "pageType", "fullPath", " fileFull", " filename", "fileType", "fileLine", "fName", "localName", "pagename", "localPath", "FileType", "FileInfo"], "ind": ["bind", "length", "x", "d", "pull", "cond", "ad", "inn", "i", "ci", "end", "div", "mid", "eff", "fr", "ord", "z", "len", "ded", "Ind", "vert", "ix", "in", "rib", "ii", "dir", "pos", "j", "pend", "nd", "start", "inc", "pt", "loc", "val", "count", "ld", "index", "wind", "IND", "mind", "id"], "shortName": ["fullName", "longPath", " shortString", "smallname", "longName", "shortString", "smallPath", "longPart", "fullString", " shortname", "Shortname", "shortPath", "longname", "fullname", "ShortName", "shortname", "ShortPath", " shortPath", " shortLine", "smallPart", "ShortString", "shortLine", "shortPart", "fullLine", "fullPath", "ShortPart", "longLine", "smallName"], "fis": ["Fos", " fisa", "gisa", " fris", " fs", "gios", "fris", "cfris", "afis", "Fis", " fiss", "pios", " fios", "afiss", "fios", "cfis", "pisa", "Fs", "afos", "pris", "fisa", "gris", "cfiss", "fiss", "cfos", "afris", "Fiss", "cfs", "pis", "fs", "gis"], "buf": ["queue", "ba", "pb", "bl", "bh", "rb", "data", "feat", "bb", "wb", "bc", "tmp", "buff", "fb", "bu", "grab", "cv", "seq", "ff", "lb", "bf", "v", "vec", "fd", "bp", "lim", "bin", "cb", "Buff", "box", "bd", "buffer", "br", "done", "batch", "b", "bytes", "rc", "uf", "cur", "loc", "uc", "bag", "la"], "bytesRead": ["bytesWrite", "secondsRead", "flowsLength", "wordsLength", "wordsWrite", "flowsRead", "tesRead", "wordsUse", "tesWrite", "secondsLength", "flowsNeed", "bytesSkip", " bytesLoad", "bitsLoad", " bytesWrite", "tesLoad", "secondsWrite", "bitsLength", "bytesLength", " bytesSkip", "bytesLoad", "bitsRead", "bitsSkip", "secondsNeed", "bitsWrite", "bytesUse", " bytesNeed", "bytesNeed", "tesSkip", " bytesLength", "wordsRead", "flowsWrite", " bytesUse", "bitsUse"]}}
{"id1": "12066447", "id2": "8150996", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"file": ["loader", "uri", "per", "path", "http", "class", "File", "url", "full", "type", "future", "open", "FILE", "body", "out", "model", "e", "queue", "address", "f", "data", "source", "lib", "binary", "folder", "base", "reader", "connection", "io", "archive", "stream", "log", "local", "info", "content", "string", "resource", "document", "handler", "db", "plus", "line", "layer", "zip", "writer", "this", "book", "function", "fp", "part", "directory", "single", "get", "letter", "dir", "job", "or", "ile", "work", "cache", "object", "filename", "it", "format", "feed", "parent", "page", "files", "one", "image", "name", "route", "phase", "l"], "backupRoot": ["Backdownroot", "backureDirectory", "backoutroot", "backupDir", "backdownDir", "BackdownSupport", "BackbackRoot", "backbackDirectory", "Backbackroot", "BackbackDir", "backflowRoot", "backupSupport", "backupsDirectory", "backdownRoot", "backoutDirectory", "backuproot", "backbackRoot", "workupHome", "workuproot", "backupsroot", "BackupRoot", "workdownHome", "backoutSupport", "backflowHome", "backupDirectory", "BackupSupport", "backbackDir", "backureHome", "backbackHome", "backflowroot", "workupDirectory", "backdownroot", "backupsRoot", "backoutRoot", "backureRoot", "BackupDir", "backupsHome", "backupsSupport", "backdownDirectory", "BackdownRoot", "workdownroot", "workupRoot", "BackdownDirectory", "backdownHome", "BackbackHome", "workdownDirectory", "backureroot", "Backuproot", "backupsDir", "backbackroot", "BackbackDirectory", "workdownRoot", "backflowDir", "backdownSupport", "BackupDirectory", "BackupHome", "backupHome"], "df": ["f", "pd", "DF", "d", " def", "data", "format", "dt", "cf", "form", "sf", "flow", "da", "dc", "db", "dat", "fr", "xf", "ds", "fb", "CF", "dp", "tf", "bf", "func", "fp", "dd", "fd", "pdf", "de", "der", "deb", "io", "dm", "md", "printf", "dict", "af", "dn", "dq", "def", "fn", "fe", "dl", "fs", "raf"], "date": ["custom", " Date", "updated", "version", "d", "x", "sync", "data", "format", "dt", "days", "time", "string", "form", "output", "rule", "diff", "Dat", "db", "str", "valid", "pe", "duration", "input", "Date", "tag", "value", "modified", "day", "atom", "min", "ate", "type", "D", "m", "style", "open", "code", "update", "name", "year", "md", "pre", "stage", "j", "doc", "work", "age", "log", "inc", "dates", "dose", "complete", "created", "use", "out", "back", "create", "dat", "message"], "zipFile": ["zipDir", "zFiles", "archiveDir", "ressFiles", " zipfile", "zfile", "archivefile", "ZipFile", "ressFile", "zipfile", "ZipDir", "zMessage", "archiveFile", "zipMessage", "zipFiles", " zipMessage", " zipFiles", "Zipfile", "ressMessage", "ressfile", "archiveFiles", "zFile", "ZipFiles", " zipDir"], "zos": ["tz", "hess", "phi", "address", "roth", "bos", "nz", "budget", "cash", "ses", "las", "ozo", "ssl", "hei", "zen", "inos", "dylib", " sands", "zero", "zik", "robe", "liquid", "han", "cos", "zb", "los", "ZA", "zip", "zag", "z", "zar", "forge", "zl", "zy", "zi", "zona", "os", "webkit", "obb", "jas", "fits", "zo", "dos", "zzy", "closure", "ls", "zin", "zon", "zx", "gz", "nox", "bes", "ops", "her", "bitcoin", "outs", "rez", "kos", "ros", "js", "zan", "chini", "zh", "uz", "osi", "packs", "zes", "zn", "asio", "zer"], "fis": [" fIs", "infisa", "fii", "lfis", " fisa", " fils", "sfis", " fris", "lfris", "feiss", "Fris", "infip", "fris", "feis", "Fils", "feires", " fos", "lfiss", "feris", " fires", "fIs", "Fis", " fiss", "flids", "flii", "sfiss", "flris", "fliss", "sfris", "fires", "Fires", "flis", "fos", " fids", " fii", "sfii", "fisa", "Fids", "affip", "fids", "fiss", "lfIs", "FIs", "fils", "infos", " fip", "Fiss", "affos", "infis", "affis", "fip", "flils", "affisa"], "entry": ["extra", "address", "next", "ry", "it", "data", "row", "ui", "ie", "the", " Entry", "lc", "uri", "per", "feed", "and", "pe", "see", "zip", "z", "event", "add", "array", "card", "reader", "zo", "de", "exp", "ge", "style", "comment", "element", "image", "offset", "letter", "io", "archive", "ries", "obj", "her", "term", "or", "ion", "index", "auto", "si", "key", "ticket", "r", "ace", "cel", "config", "Entry", "record", "attribute", "info", "e"], "buffer": ["number", "queue", "address", "length", "uffer", "data", "flush", "texture", "reference", "wave", "document", "FFER", "feed", "slice", "layer", "server", "iter", "buff", "buf", "writer", "binary", "available", "value", "window", "base", "array", "vector", "shape", "page", "transfer", "reader", "header", "seed", "beta", "Buffer", "batch", "channel", "b", "bytes", "result", "memory", "cache", "padding", "default", "null", "sequence"], "readed": ["Readned", "cedned", "loaden", "readen", "cededs", "lexed", "cedED", "runed", "runered", "lexen", " readled", "loadered", " readeds", "readned", "Readed", "keyned", " readED", "readeds", "Readen", "Readled", " readen", "keyeds", " readped", "loadped", "readped", "keyed", "lexled", "runped", "runen", "loaded", "keyED", "ceded", "readered", " readned", " readered", "readled", "readED", "lexned"]}}
{"id1": "18891988", "id2": "7425022", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"serviceName": ["ServiceName", "ServiceUrl", " servicePath", "servicename", "ServicePath", "servicePath", "packagename", "Servicename", "packagePath", "packageName", "serviceUrl", " servicename", " serviceUrl", "packageUrl"], "wsdlLocation": ["awsdlDirectory", "wsllFolder", "wslUrl", "wddlAddress", "wslpLocation", "wdlFolder", "wdlDirectory", "wssdFolder", "awsdlUrl", "wslFile", "wslpAddress", "wssdFile", "wslLocation", "wdlLocation", "wsdlDirectory", "wddlDirectory", "wdlAddress", "wsllDirectory", "wssdLocation", "wddlFile", "wsdlFolder", "wslAddress", "wsdlFile", "wslFolder", "wddlLocation", "wsDLDirectory", "wslDirectory", "awsdlLocation", "awslUrl", "wsllAddress", "wssdDirectory", "awsdlFile", "wslpDirectory", "wsdlUrl", "wsllLocation", "wdlFile", "wsdlAddress", "wddlFolder", "awslFile", "wsDLLocation", "wsllUrl", "wsDLFile", "awslDirectory", "wsllFile", "wslpFile", "wsDLUrl", "awslLocation"], "endpoint": ["enpoints", "ENDpoints", "enport", "gepoint", "ENDination", "enination", " endolution", "enPoint", " endPoint", " endport", "endaddress", "geport", "enpoint", "Endolution", "endsolution", " endaddress", "geaddress", "Endword", "endination", " endocol", "ENDpoint", " endword", "endocol", "Endpoint", "Endination", "endpoints", "endport", "endsocol", "gePoint", "endword", "endPoint", "endsword", "enaddress", "endspoint", "ENDPoint", "EndPoint", "Endocol", "Endpoints", "endolution"], "fileLocation": ["fileName", " fileName", "FileName", " filelocation", "Filelocation", "resourcelocation", "resourceLoc", "resourceLocation", "FileLoc", "resourceName", "fileLoc", "FileLocation", "filelocation", " fileLoc"], "tempDir": [" tempFile", "tempFile", "tempJar", "TempDir", "TempPath", "tmpPath", " tempDirectory", " tempJar", "tempDirectory", "tmpDir", "Tempdir", "tmpDirectory", "tempPath", "TempFile", " tempPath", "tmpJar", "tempdir", "TempJar", " tempdir", "TempDirectory", "tmpdir"], "url": ["plug", "address", "f", "bug", "socket", "uri", "bb", "service", "ssl", "string", "git", "source", "web", "path", "host", "server", "http", "ur", "zip", "sl", "URL", "base", "file", "conn", "ls", "www", "gl", "connection", "io", "image", "open", "client", "channel", "l", "ll", "link", "stream", "Url", "download", "log", "config", "fl", "coll", "pull"], "WSDLFile": ["WINDlFile", "WSDDLfile", "WSDLPath", "WINDLUrl", "WSDDLFiles", "WSDELFolder", "WSDLSourceFile", "WSDELFile", "WSDLLFolder", "WSDLFolder", "WDDLFolder", "WDDLFiles", "WDDlPath", "WSDlFile", "WSDELfile", "WINDlUrl", "WSDDLFile", "WSDlPath", "WSDELFiles", "WINDLFile", "WSDlUrl", "WINDLSourceFile", "WSDLLPath", "WDDLFile", "WDDDLPath", "WDDLPath", "WDDDLFolder", "WSDLUrl", "WSDDLSourceFile", "WSDELSourceFile", "WDDDLFile", "WSDELUrl", "WSDDLFolder", "WSDLLFile", "WSDlfile", "WINDlSourceFile", "WDDDLFiles", "WSDLLFiles", "WSDlFiles", "WINDlfile", "WSDlFolder", "WSDLFiles", "WDDlFile", "WSDlSourceFile", "WSDLfile", "WSDDLUrl", "WSDELPath", "WDDlFolder", "WINDLfile", "WDDlFiles", "WSDDLPath"], "tmpWSDLFile": ["tmpWSDSLFile", "tmpWDDELFiles", "tmpWSDLUrl", "tmpWDDLUrl", "tmpWSDLLDir", "tmpWSDELFiles", "tmpWSDLLFile", "tmpWSDSLPath", "tmpWDDLDir", "tmpWSDSLDir", "tmpWSDlDir", "tmpWSDLDir", "tmpWDDELPath", "tmpWSDLFolder", "tmpWSDLLFolder", "tmpWSDELPath", "tmpWDDELFolder", "tmpWDDLFolder", "tmpWDDlUrl", "tmpWDDLFile", "tmpWSDLLFiles", "tmpWSDLFiles", "tmpWDDlPath", "tmpWSDLLUrl", "tmpWSDlFiles", "tmpWSDlFolder", "tmpWDDlFile", "tmpWSDELFile", "tmpWSDSLUrl", "tmpWDDlDir", "tmpWDDLFiles", "tmpWSDLPath", "tmpWSDlFile", "tmpWSDELFolder", "tmpWSDLLPath", "tmpWDDELFile", "tmpWDDLPath", "tmpWSDlPath", "tmpWSDlUrl"], "inputFile": ["tempPlace", "tempFolder", "tempStream", "tempFile", "inputLine", "InputPlace", "outputFile", "outputFiles", "InputDir", "outputfile", "alphafile", "inputFactory", "inputSourceFile", "InputLine", "InputSourceFile", "inputfile", "InputFile", "inputStream", "inputFolder", "inputPage", " inputFilename", " inputLine", "inputFiles", "outputDirectory", " inputDirectory", "InputPage", "outputPage", "InputStream", "inputPlace", " inputDir", "alphaFile", "InputDirectory", "tempPage", "inputDir", "Inputfile", " inputfile", "alphaFilename", "tempLine", "InputFilename", " inputFolder", "tempfile", "outputStream", " inputFiles", "InputFolder", "outputDir", " inputFactory", "inputFilename", "alphaPlace", " inputSourceFile", " inputPlace", "InputFactory", "tempFactory", "InputFiles", "inputDirectory", "tempSourceFile"], "tmpFile": ["tempPlace", "tmpFiles", "tempFile", "tempStream", " tmpFiles", " tmpFilename", "tempFilename", "tmpSourceFile", "inputSourceFile", " tmpSourceFile", "tempFiles", "empFile", "empPlace", "inputFiles", " tmpStream", "tmpFilename", "tmpStream", "empStream", " tmpPlace", "tmpPlace", "inputFilename", "tempSourceFile", "empFiles"], "in": ["gin", "f", "data", "socket", "inn", "ssl", "source", "plus", "is", "input", "init", "p", "din", "file", "conn", "reader", "impl", "ins", "bin", "m", "connection", "inner", "io", "image", "up", "client", "c", "win", "In", "pass", "inc", "IN", "r", "login", "again", "pin", "id"], "out": ["sync", "OUT", "socket", "remote", "output", "on", "line", "server", "conf", "writer", "group", "parent", "Out", "lock", "can", "error", "file", "co", "conn", "part", "timeout", "bin", "connection", "err", "net", "io", "to", "inner", "image", "name", "up", "client", "channel", "conv", "exec", "outs", "outer", "cache", "inc", "log", "IN", "ch", "copy", "extra", "again"], "con": ["Connection", "cm", "un", "sync", "socket", "cf", "Con", "ssl", "connect", "cn", "conf", "input", "fc", "nc", "rec", "kin", "can", "conn", "file", "plain", "co", "ran", "ins", "connection", "inner", "open", "CON", "client", "channel", "conv", "c", "close", "en", "win", "Conn", "rc", "inc", "IN", "ch", "xc", "uc", "pin"], "fileLength": ["fileSize", "channelLength", "FileLength", "fileLen", "channelWidth", " fileLen", "fileNumber", "FileSize", "FileLen", "channelLen", "fileWidth", "FileWidth", " fileWidth", "channelNumber", "channelSize", " fileNumber", "FileNumber", " fileSize"], "channelIn": ["resourceIN", "resourceOut", "Channelin", " channelin", "containerOut", "ChannelIN", " channelInt", "streamInt", "containerIn", "ChannelOut", "streamOut", "resourceIn", "ChannelIn", "containerin", "containerIN", " channelIN", "resourcein", "ChannelInt", "channelin", "channelInt", "streamIn", "streamin", "channelIN"], "channelOut": ["connectionIn", " channelName", " channelOutput", " channelout", "chanIn", "connectionOut", "chanOut", "ChannelOutside", "ChannelOutput", "fileOut", "ChannelOut", "fileOutput", "chanOutside", "fileIn", "fileout", "Channelout", "ChannelIn", "connectionOutside", "channelName", "channelout", "channelOutside", "chanout", "channelOutput", "connectionout", "connectionName", "ChannelName"], "tmpDocument": ["tabdocument", "tempNode", "tempFile", "tmpDoc", "mpNode", "tmpClient", "mpDocument", "tmpNode", "inputContent", "tempClient", " tmpContent", "mpFile", " tmpdocument", " tmpNode", "tabDoc", "inputClient", "tabNode", "mpDoc", "tempContent", "tempDoc", "inputDocument", "tmpdocument", " tmpClient", "tempdocument", "tempDocument", "tmpContent", " tmpDoc", "tabDocument"], "nl1": ["wlOne", "dl3", "wl1", "ln1", "kl5", "nl2", "nl11", "NL3", "wl5", "dl2", "dl0", "nlOne", "nn11", "dl1", "nl6", "nl3", "jlOne", "nlFirst", "ln11", "nl0", "jl5", "NL0", "ln6", "NL6", "nn1", "ln2", "nn6", "jlFirst", "klOne", "nn0", "nn3", "NL1", "klFirst", "kl1", "wlFirst", "jl1", "nn2", "NL2", "NL11", "nl5"], "i": ["hi", "phi", "f", "d", "it", "ui", "ti", "uri", "ni", "bi", "ci", "gi", "qi", "slice", "mu", "di", "z", "pi", "chi", "v", "ix", "ai", "part", "m", "iu", "yi", "io", "inner", "ip", "ii", "y", "info", "o", "b", "ri", "I", "multi", "fi", "j", "l", "n", "si", "li", "ini", "mi", "oi", "ji", "index", "xi", "eni", "e", "id"], "node1": ["nOne", " nodeone", "shapeOne", "node7", "n0", "NodeOne", "n1", " node7", "node2", "entityFirst", "neOne", "sourceFirst", "shape7", "entityone", "nodeOne", "node0", "entityOne", "source1", " node0", "sourceone", "node81", "ne1", "Node2", " node2", "shape81", "entity1", "Node0", "shape1", " node81", " nodeFirst", "ne7", "nodeFirst", "Node1", "n2", " nodeOne", "nodeone", "sourceOne", "ne81"], "tmpOut": ["partout", "tempFile", "tempWriter", "tempOUT", "partOUT", "tmpout", "tmpOUT", "pmOut", "mpOut", "tmpIn", "mpIn", "tempIn", "pmOutput", "tempout", "mpFile", "bbOut", "tempOut", "pmOUT", "bbOutput", " tmpOUT", "partIn", "mpWriter", "pmWriter", "bbout", "tempOutput", "partOut", " tmpWriter", " tmpIn", " tmpOutput", " tmpout", "tmpWriter", "tmpOutput", "bbIn"], "retVal": ["New", "data", "xml", "path", "http", "Service", "this", "URL", "Socket", "s", "_", "HTTP", "Url", "Address"]}}
{"id1": "21488518", "id2": "9846843", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"name": ["prefix", "anc", "time", "alias", "path", "on", "class", "value", "large", "url", "full", "missing", "type", "self", "title", "code", "old", "ame", "not", "non", "n", "current", "config", "model", "names", "e", "address", "nm", "x", "data", "search", "folder", "base", "file", "connection", "NAME", "Name", "test", "key", "field", "word", "none", "id", "named", "content", "string", "no", "resource", "option", "office", "part", "comment", "client", "space", "ename", "default", "common", "filename", "child", "domain", "end", "member", "username", "parent", "one", "now", "call", "style", "image", "term", "size"], "in": ["data", "src", "source", "i", "resource", "thin", "con", "path", "plus", " IN", "slice", "read", "input", "len", "raw", "din", "file", "conn", "reader", "ins", "bin", "connection", "inner", "buffer", "image", "up", "exec", "size", "In", "pass", "work", "inc", "IN", "ini", "login", "config", "id"], "length": ["number", "filename", "content", "time", "string", "Length", "path", "limit", "duration", "len", "load", "url", "timeout", "type", "level", "offset", "buffer", "bytes", "width", "l", "size", "ength", "body", "count", "padding", "sequence", "id"], "contentType": ["resourceLength", "Contenttype", "contentPath", "contenttype", "resourcetype", "resourceType", " contentPath", "ContentLength", "resourcePath", "ContentType", " contenttype", "ContentPath", " contentLength", "contentLength"], "dest": ["target", "d", "src", "orig", "home", "source", "thin", "upload", "wb", "Dest", "output", "dc", "trip", "tif", "tmp", "comb", "zip", " destination", "dist", "folder", "store", "parent", "cont", "desc", "txt", "sup", "transfer", "destroy", "prop", "temp", "img", "de", "opt", "cdn", "gz", "tx", "done", " src", "later", "dir", "route", "trans", "flat", "transform", "fn", "config"], "out": ["ext", "session", "f", "filename", "OUT", "sync", "data", "flush", "socket", "point", "source", "resource", "thin", "output", "path", "line", "server", "password", "zip", "lib", "writer", "this", "again", "parent", "Out", "lock", "conn", "file", "url", "bin", "exp", "connection", "err", "gz", "io", "image", "up", "client", "obj", "o", "channel", "cmd", "outs", "result", "exec", "log", "view", "ex", "copy", "object", "null"], "request": ["hello", "ext", "re", "quest", "reference", "user", "xml", "upload", "resource", "path", "press", "id", "response", "server", "pe", "access", "input", "base", "req", "rate", "claim", "transfer", "url", "directory", "worker", "friend", "call", "get", "image", "buffer", "QUEST", "up", "client", "job", "instance", "respect", "external", "forward", "report", "complete", "config", "use", "object", "Request", "message"]}}
{"id1": "13233761", "id2": "23531898", "code1": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 1, "substitutes": {"queries": ["questires", "quires", "compests", "commires", "questands", "quips", "comperies", "commips", "quands", "bleries", "questeries", "commands", "squands", "quests", "compips", "blests", "squires", "squests", "commeries", "blips", "squips", "squeries", "compands", "blands", "questips"], "autoCommit": ["autoCompit", "autoCompits", "autoCompmit", "autoDebrit", "autoCommrit", "AutoCommit", "autoommit", "autoommits", "AutoDebmit", "AutoCommmit", "autoDebit", " autoCommmit", "AutoDebits", "autoCompitted", "autoComits", " autoCommitted", "autoCommitted", "autocommit", "autoComrit", "autoommmit", "autoCommits", "autoDebits", " autoComits", "AutoCommits", "autocommmit", "AutoDebit", "autoCommmit", "AutoDebrit", "autoommitted", "AutoCommrit", "autoComitted", " autoComit", " autoCommits", "autocommits", "autoDebmit", "autoComit", "autocommrit", " autoComitted"], "iterator": ["inst", "loader", "walker", "adder", "filter", "next", "data", "gener", "runner", "cher", "ie", "string", "section", "i", "former", "end", "division", "handler", "interstitial", "slice", "entry", "iter", "consider", "ator", "list", "init", "context", "internet", "creator", "database", "population", "vector", "reader", "ter", "inter", "finder", "connection", "inner", "runners", "done", "collection", "Iterator", "ski", "later", "set", "step", "encer", "instance", "size", "started", "start", "stream", "outer", "loop", "parser", "series", "index", "pointer", "info", "starter", "sequence", "metadata"], "query": ["join", "expression", "filter", "next", "data", "row", "script", "condition", "uri", "string", "qu", "Query", "rule", "press", "str", "entry", "command", "commit", "question", "search", "value", "q", "select", "connection", "call", "action", "comment", "table", "style", "sql", "name", "update", "result", "sq", "ql", "key", "record", "sequence", "message"], "statement": ["inst", "session", "join", "expression", "next", "Statement", "data", "script", "flush", "condition", "string", "section", "document", "response", "command", "commit", "function", "database", "conn", "mt", "connection", "stat", "state", "comment", "table", "s", "unit", "sql", "usage", "storage", "style", "element", "action", "execute", "result", "ment", "start", "si", "parser", "use", "sequence"]}}
{"id1": "12146394", "id2": "8164056", "code1": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "code2": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "label": 1, "substitutes": {"key": ["number", "length", "prefix", "core", "trust", "ssl", "time", "token", "server", "cer", "input", "ce", "value", "root", "cy", "full", "type", "ke", "k", "secret", "char", "element", "self", "hash", "y", "code", "link", "ask", "cookie", "magic", "cert", "x", "here", "sync", "data", "version", "service", "other", "source", "base", "connection", "pair", "ee", "ch", "word", "use", "KEY", "none", "id", "material", "any", "string", "no", "empty", "rule", "zip", "list", "this", "note", "ak", "power", "text", "Key", "my", "req", "state", "year", "order", "proof", "kh", "cache", "mac", "ace", "copy", "date", "message", "row", "user", "point", "blow", "wire", "sign", "password", "parent", "lock", "kid", "transfer", "fee", "scope", "phrase", "call", "image", "ip", "seed", "name", "size"], "salt": ["sALT", "ssecret", " sunt", "ssol", " sol", "sesalt", "absalt", "sesret", "sert", "secsecret", "statesALT", "secalt", "skey", "psert", "abssecret", "seskey", "absodium", " sass", "ssalt", " skey", "sift", "asALT", "sesift", "isalt", "Ssecret", "sol", "Salt", "sass", "secALT", "sesert", " sALT", "asalt", " sert", "sesALT", "sesass", "absALT", "psunt", "asift", "statesodium", "sret", "SALT", "secret", "statesalt", "seal", "issecret", "sunt", "sodium", "sesodium", "Sret", "ssass", "sessecret", "psALT", "iseal", "seseal", "ssALT", "Seal", "sesol", "Sodium", "asodium", "sesunt", "isALT", "statesift", " ssecret", "psalt", " sodium"], "_md": ["libcmd", "_magic", "_dm", "libmid", "longmd", "libmd", " _amd", "libMD", "placepub", "placedm", "\u00a0pub", "themd", " _dm", " _magic", "longm", "_MD", " _m", "_m", "longMD", "postcmd", "postmd", "placemd", "placekey", " _MD", "thecmd", " _mid", "_key", "\u00a0md", "\u00a0dm", " _cmd", "_mg", "longcmd", "_amd", "thekey", "_pub", " _mg", "_mid", "postkey", "themagic", "postamd", "_cmd", " _key"], "md2": ["m62", "cmd62", "md62", "mag2", " md4", "MD1", "material2", "MD62", "materialtwo", "MD2", "MDtwo", " md5", "mag62", "mc3", "cmd1", "cmd2", "MD02", "m2", "MD4", "cmd5", "mc62", "mc4", " md1", "mag5", "mc2", "cmd4", "md02", "material5", "material1", "md5", " mdtwo", "md4", "m4", " md02", "m3", "mdtwo", "mag1", "md1", "cmd02", "MD5", " md62"], "abyFinal": ["andyInitial", "abyLast", "aaaaInitial", "babyOriginal", "abySuccess", "andyOriginal", "babyLast", "lahfinal", "rayfinal", "BabySuccess", "aberInitial", "babyFinal", "aberFinal", "abyOriginal", "lahOriginal", "BabyInitial", "aberOriginal", "lahLast", "babyInitial", "andyFinal", "babyGlobal", "andyfinal", "abiesOriginal", "aaaaFinal", "abiesInitial", "babyfinal", "rayInitial", "abiesLast", "aaaaSuccess", "abyInitial", "abiesGlobal", "lahFinal", "abiesfinal", "lahInitial", "abyfinal", "babySuccess", "abyGlobal", "abiesFinal", "andyGlobal", "BabyFinal", "rayFinal"], "n": ["nil", "number", "d", "yn", "on", "ot", "adj", "mn", "k", "y", "nn", "syn", "np", "N", "nan", "not", "non", "dn", "sn", "nu", "un", "f", "x", "g", "ni", "cn", "nc", "ng", "nt", "v", "conn", "num", "net", "en", "nr", "norm", "pn", "r", "a", "nb", "no", "span", "z", "init", "len", "don", "m", "c", "node", "inn", "t", "p", "min", "ns", "network", "nor", "na", "name", "byn", "o", "b", "all", "l", "ne", "fn", "ner"], "j": ["x", "d", "aj", "ie", "ni", "section", "jj", "ij", "ja", "qi", "gi", "ind", "fr", "bj", "di", "adj", "z", "jc", "J", "q", "jo", "v", "in", "num", "u", "k", "io", "ii", "y", "o", "b", "c", "I", "dj", "l", "jp", "ne", "js", "si", "li", "ji", "index"], "i": ["phi", "ui", "ti", "ie", "ni", "bi", "gi", "ci", "qi", "ani", "mu", "di", "ki", "abi", "pi", "chi", "zi", "mini", "p", "v", "ai", "iu", "yi", "io", "ii", "o", "multi", "ri", "I", "c", "fi", "uni", "ali", "si", "li", "ini", "mi", "oi", "ji", "index", "xi", "eni", "e"], "sbPasswd": ["sbCrwords", "sbPushword", "bbParwd", "sbPasswt", "sfPassword", "sfPassWD", "sbPushwd", "sbPasspassword", "sbCrWD", "sfSecretwords", "sfSecretword", "sbpasswd", "bbParwt", "sbPassWD", "bbPassword", "sbParw", "sbSecretword", "sbBlockw", "sbFw", "bbPasspass", "bbPasswd", "bbPasspassword", "sbPushpass", "sbParword", "sbpassword", "bbPasswt", "sbFpassword", "sbCrwd", "sbCrw", "sbBlockwd", "sfPasswords", "sbSecretwd", "sbPushw", "sbParwt", "sbpassw", "sbParwd", "sbPassw", "sbParpassword", "sbParWD", "bbPassw", "sbParpass", "sbSecretWD", "sbBlockpassword", "bbParpass", "sbCrwt", "sfSecretWD", "sbCrword", "bbParpassword", "sbFwd", "sbpassWD", "sbPassword", "sbSecretwords", "sbpasswt", "bbParw", "sbBlockWD", "sfPasswd", "bbParWD", "sfSecretwd", "sbpasswords", "bbPassWD", "sbPasswords", "sbFWD", "sbPasspass", "bbParword"], "md3": ["cmd6", "mdthree", "mag53", "MD2", "cmd23", "metadatathree", "mc3", "dd1", "MD23", "cmd3", "cmd2", " md23", " md6", "md15", "mag83", "MD6", "md23", " md1", "MD3", "dd3", "MD53", "dd15", "mc1", "md83", "mag3", "cmdthree", "md53", "metadata83", " md15", " md53", "mc15", "md6", "metadata3", "cmd53", "cmd83", "md1", "magthree", "metadata53"]}}
{"id1": "18504192", "id2": "15797402", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"in": ["d", "data", "src", "inn", "i", "diff", "input", "parent", "base", "min", "file", "url", "reader", "part", "ins", "bin", "m", "inner", "io", "image", "buffer", "name", "c", "old", "b", "or", "In", "at", "inc", "ac", "IN", "ini", "copy", "index", "again", "info", "login", "id"], "out": ["target", "prefix", "OUT", "data", "point", "string", "output", "line", "password", "writer", "dest", "again", "Out", "base", "p", "file", "conn", "part", "w", "temp", "err", "connection", "call", "io", "name", "obj", "client", "o", "c", "b", "outs", "exec", "external", "n", "cache", "inc", "ex", "copy", "object"], "source": ["target", "sync", "core", "src", "ie", "service", "ssl", "from", "i", "origin", "sin", "ources", "SOURCE", "slice", "server", "iter", "sl", "project", "input", "writer", "dest", "parent", "secure", "se", "reader", "scope", "connection", "slave", "get", "unit", "self", "storage", "channel", "clone", "client", "settings", "component", "size", "stream", "start", "view", "Source", "ource", "copy", "use", "proxy", "null"], "destination": ["dependination", "contining", "Destinator", "Destinations", " destining", " destinations", "testinations", "destinations", "declination", "destinated", "Destination", "testinated", "dependinated", "Destinated", "declification", "testination", "dependinator", "declinator", "Destining", "continator", "dependification", "Destification", "declinated", "contination", "destification", "testinator", "destinator", " destinator", "destining", "continated", " destinated"]}}
{"id1": "7351534", "id2": "8770016", "code1": "    public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception {\n        InputSource source = null;\n        InputStream stream = null;\n        if (resolver != null) {\n            try {\n                source = resolver.resolveEntity(null, systemId);\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (source != null) {\n            try {\n                stream = source.getByteStream();\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (stream == null) {\n            URL url = new URL(systemId);\n            stream = url.openStream();\n        }\n        return stream;\n    }\n", "code2": "    public InputStream loadResource(String location) throws GenericConfigException {\n        URL url = getURL(location);\n        try {\n            return url.openStream();\n        } catch (java.io.IOException e) {\n            throw new GenericConfigException(\"Error opening URL resource at location [\" + url.toExternalForm() + \"]\", e);\n        }\n    }\n", "label": 0, "substitutes": {"systemId": ["systemPath", " systemID", "publicID", "sysid", "userid", "userId", "globalName", "SystemName", "globalID", "sysPath", "serverid", "sysId", "globalId", "machineId", "machinePath", "userID", "publicId", "Systemid", "sysID", " systemName", "globalid", "userName", "machineID", "machineid", " systemPath", "SystemId", "systemid", "serverID", " systemid", "systemID", "publicid", "serverId", "systemName", "SystemPath", "sysName"], "resolver": ["reol", "reistor", "resistor", "reolution", "persolver", " resolution", "Resistor", "resolve", "persistor", "resol", " resolving", " resol", "Resol", "persolve", "Resolving", "persolution", "reolving", " resolve", "resolving", "reolver", "Resolve", "Resolution", "resolution", "reolve", "Resolver"], "source": ["session", "target", "sync", "plugin", "reference", "src", "uri", "service", "from", "string", "i", "resource", "document", "remote", "site", "path", "status", "ources", "handler", "SOURCE", "slice", "response", "server", "model", "iter", "sl", "input", "ce", "text", "parent", "entity", "creator", "secure", "large", "reader", "method", "type", "scope", "object", "connection", "slave", "spec", "inner", "unit", "seed", "element", "image", "storage", "name", "info", "channel", "o", "client", "result", "instance", "component", "position", "Source", "driver", "ource", "use", "proxy", "null", "e", "id"], "stream": ["session", "wrapper", "f", "length", "child", "live", "sync", "row", "port", "content", "src", "service", "string", "form", "resource", "document", "flash", "ack", "feed", "output", "handler", "path", "host", "response", "server", "valid", "read", "zip", "sl", "speed", "input", "context", "dest", "parent", "cont", "load", "file", "reader", "Stream", "temp", "object", "connection", "steam", "buffer", "image", "client", "channel", "sw", "result", "instance", "trans", "log", "pool", "view", "wh", "body", "report", "null", "clean", "proxy", "model", "message"], "url": ["target", "address", "data", "user", "uri", "src", "service", "ssl", "string", "proxy", "resource", "web", "feed", "path", "host", "server", "http", "sl", "URL", "base", "large", "file", "page", "gl", "location", "image", "client", "channel", "link", "l", "Url", "control", "ource", "object", "id"]}}
{"id1": "350482", "id2": "742465", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"view": ["session", "gu", "ui", "row", "port", "pull", "check", "request", "form", "app", "VIEW", "div", "review", "im", "views", "server", "http", "see", "e", "layout", "out", "fail", "input", "el", "this", "window", "q", "lock", "html", "block", "event", "query", "gui", "page", "can", "full", "reader", "screen", "widget", "box", "comment", "View", "buffer", "image", "display", "style", "change", "self", "edit", "update", "client", "sel", "link", "cache", "body", "config", "GUI", "object", "model", "use", "vis", "show", "cell"], "url": ["loader", "address", "f", "bel", "socket", "uri", "bb", "user", "ssl", "string", "source", "service", "resource", "web", "path", "host", "server", "http", "hub", "zip", "sl", "input", "URL", "blog", "base", "file", "page", "connection", "buffer", "image", "open", "client", "channel", "build", "browser", "l", "stream", "Url", "log", "ob"], "in": ["gin", "data", "isin", "socket", "inn", "source", "i", "resource", "con", "sin", "is", "input", "binary", "init", "din", "file", "lin", "reader", "rin", "ins", "inner", "s", "buffer", "bis", "b", "as", "win", "In", "stream", "n", "cin", "inc", "ac", "IN", "nin", "ini", "login", "out", "again"], "bin": ["loader", "border", "gin", "data", "socket", "bb", "ruby", "inn", "bi", "con", "sin", "http", "input", "lib", "binary", "init", "abi", "lock", "din", "file", "lin", "reader", "inline", "part", "bot", "connection", "bn", "inner", "buffer", "b", "fin", "browser", "win", "cin", "run", "log", "IN", "body", "ini", "record", "spin", "out", "oin", "pin"], "line": ["cl", "plugin", "data", "row", "lines", "parse", "string", "source", "i", "no", "lc", "end", "home", "section", "rule", "site", "LINE", "str", "layer", "server", "nl", "message", "entry", "pe", "ine", "el", "sl", "lf", "text", "base", "day", "block", "load", "file", "page", "lin", "inline", "part", "shell", "ge", "comment", "style", "letter", "unit", "ip", "name", "Line", "code", "job", "up", "look", "b", "le", "l", "link", "band", "pass", "log", "key", "split", "word", "out", "status", "e", "cell"], "develBuild": ["deventInstall", "deestInstall", "deestBuilder", "deestBuild", "evenBuilder", "deventBuilt", "deVELBuilt", "develMake", "deVELBuild", "DEVELProject", "DEVELbuild", "evelBuilder", " deventBuild", "deeedMake", " deventBuilt", "evelMake", "devenInstall", "devenProject", "develBuilt", "deveBuild", "evenMake", "deVELbuild", "deeedBuilder", "develInstall", "Deploybuild", "develProject", "DEvelBuild", "evelInstall", "devebuild", "deployInstall", "deventBuild", "deVELProject", "deveBuilt", "deploybuild", "devenBuild", "DEvelBuilt", " deventbuild", "devenbuild", "deestMake", "devenBuilder", "deeedBuild", "DEvelbuild", "deployBuild", "evenInstall", "DevelBuilt", "develbuild", "DEVELBuilt", "evenBuild", "devenMake", "deventbuild", "DevelBuild", " develbuild", " develInstall", "develBuilder", "evelBuild", "DeployBuilt", "Develbuild", "devenBuilt", "DEvelProject", "DeployBuild", " develBuilt", " deventInstall", "deeedInstall", "DEVELBuild", "deployProject", "deployBuilt"], "stableBuild": ["expectedBuild", "severeBuild", "solidbuild", "stablebuild", " stablebuild", "stableRoll", "secureBuild", "weakBuild", "weakRoll", "stableBuilder", " stableBuilding", "validBuild", "stableVersion", "weakbuild", "stableRound", " stableVersion", "weakVersion", " stableRoll", " stableBuilder", "solidBuild", "expectedVersion", "latestBuilder", "validbuild", "solidBuilding", "latestBuild", "severebuild", "devbuild", "expectedRoll", "latestbuild", "expectedbuild", " stableRound", "stableBuilding", "securebuild", "severeRound", "validBuilder", "latestBuilding", "devBuilder", "solidBuilder", "secureRound", "devBuild"]}}
{"id1": "6271502", "id2": "18613870", "code1": "    @Override\n    public InputStream getResourceByClassName(String className) {\n        URL url = resourceFetcher.getResource(\"/fisce_scripts/\" + className + \".class\");\n        if (url == null) {\n            return null;\n        } else {\n            try {\n                return url.openStream();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"className": ["ClassName", "instanceName", "scriptname", "classPart", "ClassPart", "instancename", "CLASSNames", "CLASSname", "CLASSName", "scriptCode", "classCode", "instancePart", "ClassNames", " classNames", " classCode", "classNames", "CLASSCode", " classname", "classname", " classPart", "scriptNames", "Classname", "instanceNames", "scriptName"], "url": ["loader", "plug", "address", "f", "bel", "data", "ref", "rel", "uri", "bb", "service", "ssl", "string", "source", "resource", "xml", "web", "path", "feed", "resources", "server", "http", "zip", "sl", "org", "lib", "el", "URL", "class", "blog", "base", "orb", "event", "file", "page", "impl", "ls", "www", "location", "io", "element", "buffer", "name", "job", "b", "lr", "instance", "l", "Url", "log", "loc", "api", "r", "rl", "ob", "config", "object", "e"]}}
{"id1": "9826240", "id2": "14691829", "code1": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 1, "substitutes": {"facade": ["facce", "Facace", "humce", "factide", "facoke", "facale", "facace", " facades", "Facade", " facale", "foke", "facide", " facace", "facede", " facede", "factse", "factoke", "facase", "Facide", "factce", " facide", "factade", "face", " facoke", "Facse", "factase", "Facoke", "fale", "Facale", "humade", "fase", "Facce", "humase", "facades", "fade", "Facase", "fse", "Facede", " facase", "Facades", " facce", "fades", "humede", "facse"], "req": ["sem", "ctx", "pb", "f", "gr", "rr", "rb", "ru", "ref", "request", "form", "xml", "resource", "app", "require", "response", "http", "fr", "prof", "pr", "rec", "pro", "pkg", "q", "base", "qq", "query", "wx", "fp", "url", "w", "temp", "res", "cb", "err", "rt", "requ", "obj", "rf", "util", "exec", "sq", "required", "proc", "jp", "resp", "cmp", "cur", "cache", "view", "def", "r", "info", "Request", "pull", "crit"], "txtTransactionID": ["txtTaskID", "txtOrderName", "textTaskIP", "txtTaskId", "txtTransactionId", "textTaskId", "txtOperationType", "txtTaskType", "textTaskType", "txtJobInfo", "txtTaskName", "textTransactionId", "txtTransactionName", "txtTaskCode", "txtOrderCode", "textTaskCode", "textTaskName", "txtOperationIP", "txtTransactionType", "txtOrderType", "txtTransactionIP", "textTransactionID", "textTransactionName", "txtOrderID", "txtOperationID", "txtJobIP", "txtTransactionCode", "txtOperationName", "txtOperationInfo", "txtJobID", "textTransactionCode", "txtOrderId", "textTransactionIP", "textTaskID", "textTransactionInfo", "txtTaskIP", "txtJobId", "txtTransactionInfo", "txtOperationId", "textTaskInfo", "txtTaskInfo", "textTransactionType"], "txtOrderTotal": ["xtOrderLast", "txtAddresstotal", "txtAddressTotal", "txtRequestInfo", "xtAddressTotal", "xtOrderToken", "xtAddressID", "txtBlockToken", "xtBlockNum", "txtOrderToken", "txtBlockInfo", "xtRequestTotal", "txtRequestTotal", "xtBlockToken", "txtAddressType", "txtRequestLast", "xtRequestLast", "txtJobInfo", "txtJobTotal", "txtAddressID", "xtOrderTotal", "xtAddressType", "txtOrderType", "xtAddresstotal", "txtBlockTotal", "xtBlockInfo", "txtAfterType", "txtEventToken", "txtOrderInfo", "txtOrderID", "txtBlockNum", "txtJobtotal", "txtEventTotal", "txtJobNum", "xtOrdertotal", "txtAddressInfo", "txtAftertotal", "xtRequesttotal", "txtJobLast", "txtEventNum", "xtBlockTotal", "txtOrderNum", "txtOrdertotal", "txtRequesttotal", "xtOrderType", "xtOrderInfo", "txtAfterTotal", "txtEventInfo", "txtJobToken", "xtOrderID", "txtOrderLast", "xtOrderNum", "xtRequestInfo", "txtAfterID", "txtAddressLast"], "txtShopId": ["textShopInfo", "txtFactoryId", "txtSessionName", "txtFactoryName", "txtShopName", "txtOrderName", "textJobInfo", "txtSessionID", "textJobId", "txtJobInfo", "txtSessionInfo", "txtOrderInfo", "txtOrderID", "textShopName", "txtShopID", "txtJobName", "textJobID", "txtJobID", "txtOrderId", "textShopID", "txtShopInfo", "txtSessionId", "textJobName", "txtFactoryInfo", "textShopId", "txtJobId", "txtFactoryID"], "txtArtCurrency": ["txtartculture", "txtARTCcurrency", "txtArtSccurrency", "txtARTSculture", "txtArtAccurrency", "txtARTCurrencies", "txtArtAculture", "txtArtCustomurrency", "txtArtCulture", "txtartCulture", "txtArtcerc", "txtArtCustomerc", "txtArtScurrency", "txtArtAcurrency", "txtArtScurrencies", "txtArtLCurrency", "txtARTCulture", "txtartcurrency", "txtARTSccurrency", "txtArtCurrencies", "txtartCcurrency", "txtArtCerc", "txtArtCustomulture", "txtARTCurrency", "txtArtAcerc", "txtartCurrency", "txtArtculture", "txtArtLCulture", "txtARTScurrency", "txtArtccurrency", "txtartCerc", "txtArtSculture", "txtArtLCcurrency", "txtArtCcurrency", "txtArtLCurrencies", "txtartcerc", "txtArtcurrency", "txtARTScurrencies", "txtArtcurrencies", "txtArtCustomcurrency", "txtartccurrency"], "txtHashBack": ["txtHashback", "txtStyleBACK", "txtHandleRest", "txtHashRest", "txtMessageReturn", "txtMessageCode", "txtStyleBack", "txtCheckBack", "xtHashSave", "xtSumBACK", "txtSumBACK", "txtSumReturn", "txtCheckBACK", "txtSumFront", "txtSHABack", "xtMessageCode", "txtSumback", "txtHashReturn", "txtHandleReturn", "textSumReturn", "xtMessageRest", "xtSumback", "txtHashBACK", "txtSHAFront", "txtHandleback", "txtCheckback", "txtCheckSave", "xtHashBACK", "txtBlockReturn", "txtBlockFront", "textHashback", "txtMessageback", "txtBlockBack", "xtHashback", "txtHashCode", "txtSHAReturn", "txtStyleback", "txtStyleSave", "xtHashRest", "xtSumSave", "txtBlockback", "textHashReturn", "txtSHAback", "xtHashCode", "txtBlockCode", "textSumback", "textHashFront", "txtMessageBack", "xtMessageBack", "textSumBack", "xtSumBack", "xtMessageReturn", "txtCacheBack", "txtHashSave", "txtSumSave", "txtBlockRest", "txtMessageRest", "xtHashBack", "xtMessageback", "txtCacheReturn", "textSumFront", "txtCacheback", "txtCacheCode", "textHashBack", "txtSumBack", "xtHashReturn", "txtHandleBack", "txtHashFront"], "hashSeed": ["HashSleeds", "hashSql", "HashSeeds", "hashRead", " hashReeds", "hashPresql", "hashReed", " hashSeeds", "HashSlql", "hashSlees", "hashSerieseed", "hashSleeds", "HashSql", "hashReeds", " hashReed", "hashSerieseeds", "HashSleed", "hashPresees", " hashRee", " hashSee", "hashSleed", "HashSees", "hashRee", "hashSlql", "HashSlees", "hashSeriesees", " hashSead", "HashSeed", "hashSees", "hashSee", "hashPreseed", "hashPreseeds", "hashSead", "hashSlead", " hashRead", "hashSlee", "hashSeriesql", "hashSeeds"], "securityValue": [" securityString", "SecurityValue", "securityString", "SecurityFile", "secureKey", "SecurityKey", " securityFile", "SecurityValues", "securityFile", "securityKey", "securityValues", "secureFile", "secureValue", " securityValues", "SecurityString", " securityKey", "secureValues", "secureString"], "digest": ["logester", " digestro", "sended", "Digence", "digge", " digEST", "digEST", "digusher", "defge", "sendest", "digence", " Digestro", "logusher", "defested", "Digusher", " digested", "digHash", "diged", "Digested", " Digest", "DigHash", "signest", " Digester", "Digester", "Digge", "defest", "digester", "signester", "signested", " digester", "hashEST", "logence", "Digestro", " Digge", " Digested", "digestro", "DigEST", "sendHash", " digence", "digested", "sendEST", "defester", " digusher", " DigEST", "logest", "hashed", "Diged", "signEST", "hashHash", "hashest", "Digest"], "array": ["number", "address", "allow", "data", "row", "integer", "string", "section", "sample", "angle", "list", "binary", "value", "function", "database", "error", "Array", "environment", "range", "buffer", "arr", "image", "pair", "collection", "storage", "archive", "batch", "element", "order", "instance", "arrow", "feature", "cache", "audio", "ray", "our", "area", "record", "object", "message"], "sb": ["abb", "pb", "xb", "bh", "rb", "nb", "bb", "gb", "src", "ssl", "string", "eb", "sf", "wb", "bc", "db", "ib", "zb", "BB", "bj", "fb", "buf", "usb", "sl", "sa", "bs", "lb", "orb", "bf", "sg", "bsp", "sup", "bm", "obb", "SB", "cb", "s", "buffer", "mb", "bt", "nn", "su", "sq", "kb", "osc", "sv", "si", "ob", "bg", "sn"], "j": ["f", "length", "d", "x", "aj", "g", "section", "i", "ij", "jj", "ja", "ind", "bj", "dy", "z", "pr", "jc", "J", "p", "jo", "v", "ix", "part", "u", "k", "m", "ii", "y", "br", "obj", "o", "c", "dj", "l", "jp", "oj", "n", "js", "jl", "key", "li", "ch", "ji", "index", "uj", "e"], "b": ["bar", "ba", "f", "a", "d", "nb", "x", "rb", "bug", "bb", "eb", "bi", "i", "string", "wb", "db", "bc", "ib", "fb", "binary", "bs", "lb", "p", "bf", "orb", "bp", "bin", "cb", "k", "ab", "bd", "mb", "br", "B", "code", "job", "c", "l", "body", "ob", "be", "e"], "hash": ["number", "cover", "gh", "ssh", "address", "Hash", "dh", "ruby", "confirmed", "hex", "flash", "sh", "db", "sha", "password", "search", "json", "value", "html", "lock", "block", "error", "url", "handle", "history", "hh", "dash", "image", "header", "oh", "hed", "result", "build", "match", "ash", "sum", "memory", "ha", "kh", "cache", "ph", "mac", "math", "key", "report", "height", "h", "auth", "rh", "message"]}}
{"id1": "10385815", "id2": "6403868", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"fileFrom": ["FileTo", "ioTo", " fileStart", "fileAs", "mailFrom", "FileSource", "FileStart", "ioStart", "fileIn", "FileAs", " fileIn", "FileFrom", "ioSource", " fileAs", "mailAs", "mailIn", "FileIn", " fileSource", "mailTo", "fileStart", "fileSource", "ioFrom"], "fileTo": ["fpto", "FileTo", "FileTO", "fpTo", "fpFrom", "fpTO", "FileFrom", "fileTarget", "Fileto", "fileto", "fileTO", "resourceTarget", "resourceFile", "fileFile", "resourceFrom", " fileFile", "FileFile", "FileTarget", " fileTO", "resourceTo", " fileTarget", " fileto"], "inputStream": ["inputSync", "inputstream", "outputFile", " inputSync", "inputContext", "InputSync", "Inputstream", "outputSteam", "outputstream", "inputSteam", "InputFile", "InputContext", "InputStream", " inputstream", " inputFile", "outputSync", " inputSteam", "InputSteam", "inputFile", "outputContext", " inputContext", "InputChannel"], "outputStream": ["writeChannel", "OutputPath", "referenceSteam", "OutputChan", "writeSocket", "OutputStream", "outputSteam", "inputSteam", "OutputChannel", "referenceStream", " outputStreamer", "referenceSocket", "referenceChannel", "outputSocket", "OutputSteam", "OutputStreamer", "outputPath", "writeSteam", "outputStreamer", "inputPath", "inputChan", "fourStreamer", "fourChannel", " outputChan", "fourStream", "outputChan", "writeStream", " outputPath", " outputSteam", "fourSteam", "inputSocket"], "inputChannel": ["butChannel", "outputCam", "parentStream", "inputContext", "audioClient", "outputClient", "InputSocket", "InputContext", " inputPassword", "parentPassword", "inputCam", "InputStream", "butCommand", "audioCam", "inputClient", " inputSocket", "parentChan", "outputCommand", "outputSocket", " inputCommand", "inputPassword", "audioStream", "outputPassword", "inputChan", "audioChannel", " inputChan", "outputContext", " inputContext", "butChan", " inputClient", "outputChan", "InputChan", "parentChannel", " inputCam", "inputSocket", "InputChannel", "inputCommand", "butContext"], "outputChannel": [" outputQueue", "outStream", "outContext", "inputchannel", " outputchannel", " outputContext", "inputContext", "OutputChan", "OutputStream", "OutputContext", "outChan", "OutputChannel", "outChannel", "OutputQueue", "Outputchannel", "outputchannel", "inputChan", "outputQueue", "outputContext", " outputChan", "inputQueue", "outputChan"]}}
{"id1": "2642914", "id2": "8490297", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"taro": ["ttargo", "Targo", " too", "targo", "ttaco", "ttaron", "ptabo", "tro", "tato", "taron", "ptaco", "yaron", "theargo", "yaro", "theara", "Tro", "Taco", "thearo", " tro", "tabo", "Taron", "staro", "haro", "taaco", "taollo", " targo", "Tario", "hario", "yargo", "thearon", "Tabo", "tero", "yara", "fara", "hato", " tario", "stero", "too", "fargo", "follo", "Too", "Tero", "Tara", " tero", "tollo", "ptaron", "taaro", "ttaro", "ttara", "haco", " taron", "stro", "Toa", "taco", " tabo", "faco", " tato", "ttoa", "tara", " taco", "taargo", "tario", " tara", "stoo", "Tollo", "Tato", "ptaro", "faro", "Taro", " toa", "toa"], "path": ["ath", "PATH", "filename", "data", "ref", "uri", "from", "string", "source", "resource", "str", "text", "folder", "parent", "p", "txt", "root", "url", "file", "Path", "directory", "type", "object", "location", "image", "name", "dir", "route", "c", "pattern", "cache", "log", "key", "loc", "fn", "pointer", "id"], "base": ["extra", "address", "bas", "prefix", "relative", "core", "uri", "from", "home", "string", "resource", "alias", "server", "ase", "http", "store", "parent", "p", "bf", "root", "url", "file", "part", "Base", "type", "absolute", "buffer", "name", "dir", "b", "pre", "start", "cache", "key", "api", "area", "index", "default", "back", "id"], "f": ["inf", "d", "found", "ref", "g", "cf", "i", "sf", "form", "feed", "fx", "fr", "t", "fb", "fc", "this", "lf", "F", "fa", "tf", "p", "bf", "fp", "v", "file", "url", "fd", "w", "m", "of", "s", "self", "fo", "fac", "rf", "b", "c", "j", "aff", "l", "flat", "af", "n", "df", "fold", "fn", "fe", "r", "h", "framework", "fs", "e", "raf"], "entryName": ["sename", "sePath", "EntryTime", " entryPath", "resourceTime", "EntryName", "filePath", "EntryType", "entryTime", "entryPath", "entryType", "resourcename", "fileName", "EntryPath", " entryTime", " entryname", "seName", "resourceName", "seType", "fileType", "Entryname", "entryname", "resourcePath", "fileTime", " entryType"], "goIn": ["GOin", "GOEx", "goIns", "goin", "coIn", "GoIn", "GoEx", "loIN", "GoIN", "loin", "GOIns", "poEx", "loIn", "poin", "goEx", "poIn", "GOIn", "Goin", "goIN", "loIns", "poIns", "GOIN", "poIN", "coIns", "coIN", "coin"], "tarEntry": ["Tarentry", "TarElement", "zipEntry", "TarEntry", " Tarentry", "zipEnt", "rarInfo", " TarEntry", "zipInfo", " tarElement", " tarInfo", " tarentry", " tarFile", "rarEntry", "zipFile", " TarElement", "rarEnt", "tarFile", " tarEnt", "tarEnt", "tarentry", "tarInfo", "rarFile", "tarElement"], "children": ["parents", "data", "content", "words", "which", "other", "ales", "web", "output", "Children", "blocks", "sub", "balls", "pes", "packages", "feed", "ren", "many", "members", "each", "jobs", "opens", "parent", "when", "rows", "ins", "files", "bars", "roots", "open", "name", "pages", "kids", "well", "father", "all", "far", "values", "current", "ports", "scenes", "iblings", "plugins", "loc", "pool", "h", "ul", "ools"], "child": ["leaf", "data", "row", "i", "per", "feed", "and", "draft", "layer", "server", "entry", "cloud", "lib", "parent", "root", "kid", "file", "page", "in", "shell", "uncle", "connection", "slave", "name", "code", "client", "channel", "job", "c", "build", "or", "l", "pool", "key", "ch", "Child", "count", "hel", "cel", "pull", "id"]}}
{"id1": "22603577", "id2": "18989018", "code1": "    public static String getFileContentFromPlugin(String path) {\n        URL url = getURLFromPlugin(path);\n        StringBuffer sb = new StringBuffer();\n        try {\n            Scanner scanner = new Scanner(url.openStream());\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                sb.append(line + \"\\n\");\n            }\n            scanner.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n        return sb.toString();\n    }\n", "code2": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "label": 0, "substitutes": {"path": ["loader", "install", "ath", "PATH", "filename", "prefix", "platform", "plugin", "data", "content", "uri", "src", "string", "resource", "str", "input", "class", "text", "p", "root", "file", "full", "Path", "directory", "type", "location", "href", "image", "name", "code", "dir", "job", "pattern", "download", "stream", "work", "key", "config", "object", "id"], "url": ["loader", "plug", "f", "bel", "plugin", "socket", "bb", "user", "uri", "ssl", "string", "source", "service", "resource", "feed", "server", "http", "ur", "org", "sl", "URL", "this", "blog", "base", "file", "page", "reader", "impl", "ls", "er", "connection", "io", "image", "job", "channel", "b", "lr", "browser", "l", "ll", "download", "stream", "Url", "log", "fl"], "sb": ["pb", "nb", "rb", "bh", "bb", "vm", "gb", "ssl", "src", "eb", "sf", "lp", "wb", "web", "bc", "db", "ib", "BB", "erb", "fb", "sl", "binary", "sa", "lb", "bf", "sg", "bsp", "bm", "bp", "gs", "ls", "SB", "cb", "ab", "buffer", "bt", "job", "b", "lr", " SB", "sv", "si", "ob", "BP", "bag", "bg"], "scanner": ["scaninner", "verinner", "canener", "Scanning", "parseener", "parsening", "anning", "parsecher", "cancher", "verning", "scanter", "scanener", "Scancher", "Scaninner", "caninner", "scanger", "anler", "canning", "Scanger", "Scanter", "verner", "canner", "vercher", "scanler", "canger", "canter", "Scanner", "anner", "canler", "anter", "ancher", "scanning", "aninner", "scancher", " scaninner", " scanger", "parsener", " scanter", "Scanener", "Scanler"], "line": ["cl", "next", "column", "data", "row", "lines", "string", "source", "lc", "i", "section", "end", "feed", "LINE", "str", "id", "lined", "model", "entry", "pe", "character", "sl", " inline", "text", "base", "block", "file", "lin", "page", "inline", "style", "letter", "Line", "code", "job", "l", "link", "pass", "non", " Line", "object", "col", "e", "cell"]}}
{"id1": "7122523", "id2": "8778962", "code1": "    public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        InstanciaDelegate delegate = RegistroManager.recuperarInstancia(request);\n        if (delegate == null) {\n            ActionErrors errors = new ActionErrors();\n            errors.add(null, new ActionError(\"errors.session\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"fail\");\n        }\n        AyudaPantalla ayudaPantalla = delegate.obtenerAyudaPantalla();\n        TraAyudaPantalla traAyudaPantalla = (TraAyudaPantalla) ayudaPantalla.getTraduccion();\n        String urlSonido = traAyudaPantalla.getUrlSonido();\n        if (urlSonido == null) {\n            return null;\n        }\n        URL url = new URL(urlSonido);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.connect();\n        String tipoMime = urlConnection.getContentType();\n        log.debug(\"Tipo Mime: \" + tipoMime);\n        Map audioOptions = new HashMap();\n        if (tipoMime.indexOf(\"audio\") != -1 || tipoMime.indexOf(\"asf\") != -1 || tipoMime.equals(\"unknown/unknown\")) {\n            audioOptions.put(\"id\", \"MediaPlayer\");\n            audioOptions.put(\"codeBase\", \"http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,7,1112\");\n            audioOptions.put(\"classId\", \"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95\");\n            audioOptions.put(\"mimeType\", \"application/x-mplayer2\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/\");\n        } else if (tipoMime.indexOf(\"real\") != -1) {\n            audioOptions.put(\"id\", \"RVOCX\");\n            audioOptions.put(\"codeBase\", \"\");\n            audioOptions.put(\"classId\", \"clsid:CFCDAA03-8BE4-11cf-B84B-0020AFBBCCFA\");\n            audioOptions.put(\"mimeType\", \"audio/x-pn-realaudio-plugin\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"\");\n        }\n        request.setAttribute(\"audioOptions\", audioOptions);\n        log.debug(\"entra success\");\n        return mapping.findForward(\"success\");\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"mapping": ["Mappings", "rmapper", " matching", "pailing", "mmapping", "pording", "patching", "matching", " mapped", "mappings", " mording", " mapper", "mapper", "mording", "papping", "rmapped", "mapped", "mmailing", "Mapper", "mmording", " mailing", "rmapping", "Mapped", "mailing", "Mapping", "mmatching", "rmappings", " mappings"], "form": ["session", " forms", "template", "format", "flow", "upload", "app", "builder", "path", "former", "entry", "command", "input", "Form", "query", "page", "FORM", "submit", "forms", "route", "control", "view", "post", "transform", "field", "config", "object", "model"], "request": ["application", "session", "queue", "user", "xml", "resource", "web", "path", "handler", "subject", "server", "ware", "input", "context", "parent", "q", "query", "event", "req", "method", "type", "state", "image", "submit", "QUEST", "client", "route", "result", "instance", "current", "view", "enter", "frame", "report", "use", "object", "model", "create", "Request", "message"], "response": ["application", "session", "data", "resource", "output", "status", "server", "http", " Response", "Response", "req", "reply", "error", "page", "res", "manager", "results", "client", "result", "resp", "view", "report", "object", "model", " responses", "message"], "delegate": ["delegates", "reploy", "relegates", "deleg", "Delegates", "decleg", "rolelegate", " deplementation", "rolelegates", " delic", " deleg", "rolelic", "Delegate", "declegate", "roleplementation", " delegates", "Deplementation", "deploy", "Deider", "DElegate", "declegates", "delic", "decider", "deider", "releg", "deplementation", "DEleg", " deider", "relegate", "Deleg", "DElegates", "Deploy", "DEploy", "Delic"], "errors": ["comments", "data", "eps", "ages", "es", "xml", "rules", "items", "links", "ays", "blocks", "effects", "issues", "members", "reports", "orders", "failed", "ceptions", "array", "error", " exceptions", "rows", "relations", "maps", "params", "rss", "events", "ins", "uments", "err", "les", "s", "results", "management", "asts", " Errors", "ops", "objects", "details", "runs", " messages", "settings", " problems", "ations", "instance", "all", "rs", "ros", "values", "rors", "plugins", "parser", "ae", "null", " responses", "e"], "ayudaPantalla": ["ayudaPentala", "ayudaTantella", "ayudaPatantala", "ayudaPatantalla", "ayudaTantilla", "ayudaTentilla", "ayudaPentilla", "ayudaPantsilla", "ayudaPantsalla", "ayudaPandilla", "ayudaPandalla", "ayudaPataraala", "ayudaPentella", "ayudaTantala", "ayudaPandella", "ayudaParaala", "ayudaTentalla", "ayudaTentella", "ayudaPatantilla", "ayudaParailla", "ayudaParala", "ayudaTentala", "ayudaPataraalla", "ayudaTantalla", "ayudaPatarala", "ayudaPantsella", "ayudaPantsla", "ayudaPantla", "ayudaPantala", "ayudaParaalla", "ayudaPandla", "ayudaPentalla", "ayudaPantsala", "ayudaPantilla", "ayudaPatarailla", "ayudaPatantla", "ayudaPantella", "ayudaPandala"], "traAyudaPantalla": ["traAyudaPartlla", "traAyudaVantalla", "traAyudaPantilla", "traAyudaPartaya", "traAyudaPantella", "traAyudaParalla", "traAyudaPartala", "traAyudaPandilla", "traAyudaPlantala", "traAyudaPandaya", "traAyudaPartalla", "traAyudaPentilla", "traAyudaPantala", "traAyudaPlantilla", "traAyudaPantingella", "traAyudaPlantella", "traAyudaVantaya", "traAyudaPlantalla", "traAyudaPantingilla", "traAyudaPandala", "traAyudaVantala", "traAyudaPlantingalla", "traAyudaPantlla", "traAyudaPantingalla", "traAyudaPentella", "traAyudaParaaya", "traAyudaPandalla", "traAyudaParaala", "traAyudaVandala", "traAyudaVandaya", "traAyudaPentalla", "traAyudaPandella", "traAyudaPandlla", "traAyudaVandalla", "traAyudaPantingala", "traAyudaPentala", "traAyudaPantaya", "traAyudaPlantingala", "traAyudaParaalla", "traAyudaVantlla", "traAyudaVandlla", "traAyudaPlantingilla", "traAyudaPlantingella"], "urlSonido": ["urlSONri", " urlTonido", " urlTonigo", "urlMonuli", "UrlSenigo", " urlTonado", "UrlSonini", "urlTonini", "urlBonigo", "urlSonuli", "UrlSonuli", "urlBonidi", "urlSonri", "uriSonigma", "urlSONuli", "pathSoniao", "UrlSonida", "uriSonini", "UrlSenido", "urlsonini", "pathSeniao", "UrlSenini", "urlsonigo", "urlsonido", "urlBonuli", "urlSONigo", "UrlBonidi", "urlTonid", " urlSonado", "UrlSonido", "urlSonid", "UrlBonido", "urlSenri", "urlSONidi", "urlSONiao", "urlTonigo", "urlSONigma", "urlsonigma", "urlMonida", "pathSonido", "UrlSonigo", "UrlBonida", "urlsonado", "UrlBonuli", "urlSenigo", "urlMonido", "urlSoniao", "urlTonri", "urlSenini", " urlSonigo", "urlSonida", "urlSONini", "urlSONida", "uriSonido", "urlSONid", "urlSonidi", " urlTonini", "pathSenri", "UrlSonidi", "uriSONid", "UrlSonri", "urlTonido", "urlTonado", "UrlSenri", "uriSONigma", "pathSonigo", "urlTonigma", "urlSeniao", "urlBonida", "urlBonado", "pathSonri", "pathSenigo", "urlSonado", "uriSONido", "urlMonidi", "urlBonido", "urlSONido", "urlSenido", " urlSonini", "urlsonid", "uriSONini", "urlSonini", "urlSonigma", "pathSenido", "uriSonid", "urlsonri", "urlSonigo", "urlBonini"], "url": ["system", "f", "user", "uri", "service", "ssl", "string", "source", "resource", "web", "path", "str", "server", "http", "sl", "URL", "json", "base", "page", "full", "impl", "ls", "www", "gl", "location", "connection", "image", "client", "b", "l", "ll", "download", "Url", "control", "log", "config", "fl"], "urlConnection": ["URLFactory", "urlconnection", "URLClient", "URLConnection", " urlInfo", "UrlConnect", "webConn", "urlFactory", "httpFactory", "webConnection", "httpClient", "webConnect", "URLConn", "eventconnection", "eventConnection", "webConnector", "urlConn", "urlClient", "webFactory", "eventConnector", "UrlConnector", "userconnection", "urlConnector", "httpConn", "userConnection", "urlConnect", "webClient", "webconnection", "userInfo", "UrlInfo", "eventConnect", "httpConnection", "Urlconnection", "urlInfo", " urlconnection", "UrlConnection"], "tipoMime": ["tipoImale", " tiposTpe", "tipoPime", "tipoKnIME", "tiposMIME", "tiposTize", "tipoCIME", "tiposMorph", " tipoMIME", "tipoTIME", " tipoTIME", " tipoMile", "tiposMike", " tiposTile", "tiposText", "tipoTize", "tipoNext", "tipoPike", " tiposMIME", "tipoDemize", "tiposTile", "tiposMale", "tipoKnike", "tipoKnime", "tipoTike", "tipoImize", " tipoSmime", "tipoImime", " tipoMetIME", "tipoImIME", "tipoMile", "tiposManche", "tiposMime", "tiposTike", "tipoPanche", " tipoSmIME", "tipoDemIME", " tipoSmpe", "tipoTale", "tiposTorph", " tipoMetile", "tipoMike", "tipoMext", "tiposTanche", "tipoTorph", "tiposMize", "tipoNile", " tipoTime", " tipoTile", "tipoNime", " tipoTpe", "tiposMile", " tipoMetime", "tiposTIME", "tipoManche", " tiposMime", "tipoMIME", "tipoTile", "tiposTime", "tipoCime", "tipoDemale", "tiposTale", "tipoMize", "tipoCile", "tipoDemime", " tiposTIME", "tipoText", "tipoCext", " tipoSmile", "tipoCorph", "tipoKnanche", "tipoMorph", "tipoMale", "tipoPIME", " tipoMpe", " tiposMpe", " tiposTime", " tiposMile", "tipoTime", "tipoNIME", "tipoTanche", " tipoMetpe", "tiposMext"], "audioOptions": ["audioRules", " audioGames", " audioParts", "musicSettings", "archiveOptions", "AudioGames", " audioSettings", "AudioStyle", "AudioStream", "mediaSettings", "soundOption", "AudioColor", "soundContents", "archiveStyle", "audioVideo", "musicStream", "videooptions", "mediaOptions", " audioContents", "videoVideo", "videoParts", "oggOptions", "mediaGames", "audioGames", "AudioOptions", "oggOption", "soundRules", "mediaStyle", "audioOption", "videoOptions", "audioStyle", "videoStream", " audioVideo", " audiooptions", "archiveColor", "archiveStream", "oggContents", "soundOptions", "mediaParts", "audioParts", " audioStream", "audioStream", " audioStyle", "videoSettings", " audioColor", "audioSettings", "mediaVideo", "audioColor", "oggRules", "musicParts", "audioContents", " audioRules", " audioOption", "AudioSettings", "videoGames", "soundoptions", "soundSettings", "musicOptions", "audiooptions"]}}
{"id1": "14820302", "id2": "11968328", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"curi": ["lurl", "piri", "cri", "curation", "fURI", "lri", "Cri", "Cunit", "cudi", " curation", "lciri", "cui", "cuid", "CURI", "ciri", "lcuid", " cuid", " cgui", "Curi", "lcri", "Cudi", "lcURI", "Curation", "cURI", " ciri", "cunit", "pURI", "Curl", "lcunit", "fri", "puid", "Cgui", " curl", "Cui", "curl", "lcgui", "puri", " cunit", "cgui", "lcui", "lURI", " cudi", " cURI", " cui", "furi", "lcudi", "luri", "lcuri", "furation", " cri"], "regexpr": ["regexer", "rerup", "rerepr", "renexpr", "regexper", "regnexper", "pregexer", "renexr", "renexp", "regexrt", "reasurert", "Regexpre", "reggexr", "rereper", "pregexpr", "Renexpre", "recepl", "recrepl", "recer", "prenexp", "reasurep", "Regexp", "Renexpr", "Renexp", "recrepre", "Renexrt", "pregexpl", "pregexp", "Regexpr", "regexpre", "prenexpr", "reggexpl", "reasurepr", "renexrt", "recreer", "reggexper", "receper", "regnexpr", "recrepr", "renexper", "regexpl", "prenexpl", "regexr", "renexer", "reggexpr", "rerupl", "recepr", "regnexpl", "regnexr", "rerer", "recrep", "renexpl", "regexp", "Regexrt", "recrert", "reruer", "renexpre", "rerupr", "prenexer", "rerepl", "reasurepre"], "cs": ["ca", "ctx", "cons", "cm", "Cs", "sync", "cf", "cers", "lc", "cases", "ci", "es", "acks", "cn", "cr", "bc", "ced", "cos", "cer", "ds", "pc", "acts", "cing", "ce", "cas", "cp", "bs", "ics", "CS", "os", "conn", "vs", "sc", "ns", "gs", "ins", "ls", "icks", "css", "ms", "tc", "spec", "qs", "cms", "cus", "cells", "ec", "ches", "ios", "c", "cc", "rs", "codes", "ss", "rc", "ps", "ces", "cache", "js", "acs", "ac", "cks", "ars", "coll", "wcs", "fs", "ks"], "digest": ["logester", "generested", " digesting", "hashester", "digcher", "igested", "hashger", "igcher", "digit", " digEST", "digEST", " digger", " digested", "digger", "diger", "hashesting", "logit", "digests", "igest", "Digested", "signest", "generest", "signger", "Digester", "signer", "digester", "signester", "igester", "signested", " digester", "digesting", " digests", "generEST", "signests", " diger", "digested", "Digesting", "Digger", "generests", " digcher", "logest", "Digit", "Diger", "signEST", " digit", "logger", "Digcher", "hashest", "Digest"], "s": ["states", "obs", "ans", "S", "address", "f", "sync", "data", "ses", "g", "string", "sb", "abs", "str", "ds", "t", "is", "sl", "groups", "binary", "p", "os", "v", "ns", "gs", "u", "ls", "ms", "sets", "services", "ws", "o", "c", "b", "su", "settings", "bytes", "rs", "ss", "l", "ps", "sum", "n", "js", "si", "sym", "strings", "r", "h", "e"], "m": ["gm", "man", "cm", "nm", "sm", "hm", "pm", "vm", "string", "mo", "e", "ym", "mm", "am", "p", "v", "bm", "M", "ms", "rm", "wm", "dm", "machine", "c", "om", "tm", "me", "sym", "imm", "mc", "r", "mi", "mr", "fm", "map", "match"], "newDigestValue": ["newDigestValues", "newDigestedKey", "newDigestKey", "newSignestedValue", "newSignestValues", "newSignestString", "newSignestedKey", "newDigesterArray", "newDigestedValue", "newDigenseValue", "newDigesterString", "newDigesterKey", "newDigestArray", "newDigenseArray", "newSignestValue", "newDigestString", "newSignestKey", "newDigESTValues", "newDigestedArray", "newDigESTValue", "newSignestedValues", "newDigestedString", "newDigenseKey", "newDigestedValues", "newDigESTString", "newSignestedString", "newDigenseString", "newDigesterValues", "newDigesterValue", "newDigESTKey"]}}
{"id1": "13657103", "id2": "5951961", "code1": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"manip": ["menip", "MANi", "MANIP", "manapi", "Manip", "Manap", "navip", "navIP", "manpp", " manap", " manim", "manap", "emanib", " manpp", "MANip", "ManIP", "manIP", "navpp", "manim", "menib", "MANap", " manapi", "menapi", "navi", "menim", "emanapi", " mani", "mani", "emanip", "Manpp", "emanim", " manib", " manIP", "manib", "Mani"], "bout": ["tagain", " bflush", "tOut", "sbOUT", "zouts", "rbOUT", "zOut", "rbout", "Bindex", "bbflush", "BOUT", "sbout", "sbflush", "tindex", "zOUT", "bbOUT", "bbin", "bindex", "sbin", "lagain", " bOUT", "bagain", "bOut", "zin", "lout", "Bagain", "lOut", "bin", " bin", "bouts", "rbOut", " bouts", "bbout", "BOut", "lindex", "Bout", "tout", "rbouts", "bOUT", "bflush", "Bin", "Bouts"], "zout": ["ziOut", " zin", " zzip", "wio", "azfile", " zOut", "zOut", "gzagain", " zdump", "zeagain", "zipOut", " zup", "zfile", "wOut", "Zout", "zipin", "zOUT", " zOUT", "ziin", "zdump", "azin", "zipOUT", "zagain", "zipagain", "zipouter", "zeout", "zipzip", "ZOut", "azdump", "zipup", "Zin", "ziout", "gzOUT", "zipio", "azout", "zin", "azcache", " zagain", "zup", "zein", "zouter", "zenin", "zzip", " zouter", "zipcache", "ziouter", " zfile", "nzdump", "zcache", "win", "zenouter", "zezip", "zipout", "zenout", "nzout", "wout", "gzout", "nzOut", "nzfile", "zenup", "azOut", "gzOut", "zio", " zcache", "Zio"], "bundle": ["cixture", "buddy", "fuddy", " bider", " boodle", "bunch", "bixture", "bund", "bider", "brundle", "boodle", "cundle", "gbuddy", "foodle", "lundle", "abunch", "luddy", "broodle", "cunch", "bruddy", " buddy", "gunch", "abbl", "gbund", "brund", "bbl", "fundle", "lunch", "abixture", "abundle", "gbundle", "gundle", "brunch", "gixture", "lider", "fider", "loodle", "lund", "gbunch", "fund", "cbl", "gbl"], "files": ["ids", "obs", "f", "data", "features", "lines", "links", "xml", "web", "feed", "blocks", "resources", "balls", "http", "issues", "boxes", "classes", "groups", "reports", "iles", "thumbnails", "bs", "items", "flows", "errors", "file", "fires", "events", "books", "ls", "apps", "Files", "users", "pages", "objects", "bytes", "ips", "download", "keys", "plugins", "models", "images", "fl", "bugs", "fields", "headers", "workers", "names", "fs", "rules", "leases"], "url": ["address", "f", "filename", "data", "rel", "uri", "git", "string", "source", "resource", "path", "feed", "host", "layer", "server", "http", "entry", "sl", "el", "URL", "html", "file", "page", "full", "gl", "location", "connection", "image", "element", "job", "channel", "b", "email", "pattern", "browser", "link", "l", "download", "Url", "loc", "li", "ob", "fl", "out", "coll", "ball", "pull", "id"], "name": ["number", "common", "named", "address", "filename", "x", "child", "data", "uri", "time", "string", "source", "no", "resource", "alias", "end", "orig", "path", "host", "line", "str", "el", "member", "search", "parent", "value", "base", "large", "block", "error", "file", "full", "part", "type", "one", "wheel", "connection", "NAME", "action", "style", "comment", "image", "Name", "up", "job", "b", "old", "ame", "size", "work", "n", "pass", "definition", "key", "api", "word", "default", "object", "info", "names", "id"], "mf": ["Mfs", "Mcf", "smcf", "fmf", "smaf", "Mf", "mcf", " mcf", "fmfs", "smf", " maf", " mfs", "fmcf", "maf", "Maf", "mfs", "fmaf", "smfs"], "tmpFile": ["tmpFiles", "tempFile", "poraryPlace", "zipDir", " temporaryFiles", " tmpFiles", "TempDir", "tabFiles", "tmpfile", " temporaryFile", "tabFile", " tmpF", "zipContent", "tabPlace", "tempFiles", " tmpFILE", "poraryFiles", "poraryF", "zipfile", " temporaryFILE", "TempContent", "tmpDir", " temporaryDir", "tempDir", "tempFILE", "tempContent", "TempFile", "zipFile", " tmpDir", "tempfile", "tmpF", " tmpPlace", "tabF", "Tempfile", "tmpPlace", "tmpFILE", "tmpContent", "poraryFile"], "ref": ["ctx", " references", "eval", "f", "bind", "re", "reference", "rel", "service", "remote", "path", " config", "Reference", "ind", "conf", "col", "lib", "class", "lf", "fc", "context", " Ref", "base", "REF", "p", "bf", "req", "part", "type", " reference", "Ref", " href", "instance", "aff", "amp", " remote", "resp", "cmp", "ef", "af", "loc", "def", "val", "ob", "config", "proxy", "info", " pref", "id"]}}
{"id1": "18504192", "id2": "9033639", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"in": ["d", "data", "src", "inn", "i", "diff", "input", "parent", "base", "min", "file", "url", "reader", "part", "ins", "bin", "m", "inner", "io", "image", "buffer", "name", "c", "old", "b", "or", "In", "at", "inc", "ac", "IN", "ini", "copy", "index", "again", "info", "login", "id"], "out": ["target", "prefix", "OUT", "data", "point", "string", "output", "line", "password", "writer", "dest", "again", "Out", "base", "p", "file", "conn", "part", "w", "temp", "err", "connection", "call", "io", "name", "obj", "client", "o", "c", "b", "outs", "exec", "external", "n", "cache", "inc", "ex", "copy", "object"], "source": ["target", "sync", "core", "src", "ie", "service", "ssl", "from", "i", "origin", "sin", "ources", "SOURCE", "slice", "server", "iter", "sl", "project", "input", "writer", "dest", "parent", "secure", "se", "reader", "scope", "connection", "slave", "get", "unit", "self", "storage", "channel", "clone", "client", "settings", "component", "size", "stream", "start", "view", "Source", "ource", "copy", "use", "proxy", "null"], "destination": ["dependination", "contining", "Destinator", "Destinations", " destining", " destinations", "testinations", "destinations", "declination", "destinated", "Destination", "testinated", "dependinated", "Destinated", "declification", "testination", "dependinator", "declinator", "Destining", "continator", "dependification", "Destification", "declinated", "contination", "destification", "testinator", "destinator", " destinator", "destining", "continated", " destinated"]}}
{"id1": "364438", "id2": "536614", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"src": ["inst", "ctx", "filename", "st", "rb", "feat", "ref", "uri", "gb", "ssl", "sb", "source", "string", "resource", "upload", "prot", "Dest", "path", "sin", "RC", "slice", "tmp", "buf", "sth", "input", "sl", "supp", "dist", "username", "secure", "load", "req", "fp", "url", "file", "sc", "reader", "impl", "img", "cb", "gz", "spec", "href", "s", "cpp", "storage", "gn", "vr", "name", "code", "obj", "sit", "sel", "rc", "proc", "download", "stream", "component", "cmp", "dep", "Source", "loc", "fn", "rl", "SourceFile", "ource", "config", "sec", "back", "sn"], "dest": ["target", "orig", "home", "source", "wb", "Dest", "dc", "path", "di", "tmp", "lib", " destination", "class", "dist", "cont", "txt", "temp", "img", "bin", "std", "dir", "obj", "disk", "fn", " dst", "null", "dat"], "in": ["inf", "f", "d", "a", "data", "isin", "inn", "source", "i", "t", "is", "input", "inas", "din", "file", "reader", "ins", "bin", "err", "io", "up", "as", "doc", "win", "ps", "In", "stream", "n", "pass", "inc", "IN", "ini", "r", "ex", "val", "login", "pin"], "p": ["pa", "pb", "pd", "f", "d", "pg", "g", "lp", "pm", "i", "per", "pc", "pe", "t", "h", "pp", "pr", "cp", "pi", "op", "fp", "v", "wp", "bp", "part", "sp", "cop", "m", "s", "py", "o", "pre", "c", "np", "b", "po", "j", "l", "ps", "jp", "parser", "tp", "P", "e"], "ds": ["docs", "d", "uds", "dt", "lp", " db", "ays", "hs", "ads", " DS", "ded", "scripts", "des", "ils", "icks", "ants", "qs", "dm", "vals", "dates", "ld", "sys", "dat", "posts", "ks", "styles", "ans", "pd", "cs", "sync", "data", "words", "points", "dp", "bs", "dd", "gs", "cdn", "Ds", "ups", "rs", "ps", "js", " dd", "sts", "cons", "tools", "els", "lines", "db", "DS", "di", "dist", "amps", "os", "tests", "vs", "dos", "ins", "ls", " sd", "s", "ws", "xs", "ts", "plugins", " props", " ps", "eps", "obs", "gd", "da", "dc", "parts", "dds", "ys", "utils", "nas", "ns", "ss", "df", "models", "dl"], "format": ["filter", "f", "filename", "prefix", "template", "feat", "data", "Format", "plugin", "version", "string", "source", "form", "xml", "path", "handler", "host", "t", "layout", "atter", "class", "tag", "scale", "function", "sche", "fp", "file", "url", "fd", "part", "type", "act", "spec", "style", "letter", "unit", "table", "language", "name", "struct", "ant", "pattern", "nat", "at", "frame", "parser", "fn", "api", "config", "magic", "record", "object", "model", "match"], "hasPixelData": ["hasPictureData", "hasPicOps", "haspixelStyle", " hasPixeldata", "hasBytedata", "hasPicStyle", "hasPixelDATA", "hasPictureDATA", "haspixelData", " hasPixelOps", "hasPixeldata", "hasPixelStyle", "haspixelOps", "hasPicData", "hasByteData", " hasPixelSize", "haspixelSize", "hasPicturedata", "hasPixelSize", "haspixelDATA", "haspixeldata", "hasPixelOps", " hasPixelStyle", " hasPixelDATA", "hasByteSize"], "inflate": [" inflATE", "infloocate", "uninflocate", "infloase", "uninfloute", "uninfloate", "information", "informATE", "incollate", "infloATE", "inflation", "infolute", " information", "infolame", "incollame", "inFlase", "incollocate", "inFlate", "informate", "infloate", "influte", "inflase", "incollute", "uninfloame", "inFlation", "uninflute", "infolate", "informase", "inflame", "infolocate", "infloation", " informase", "uninfloocate", " informate", "infloame", "infloute", "inflocate", "uninflame", " inflation", "inFlATE", " inflase", "inflATE", " informATE", "uninflate"], "pxlen": ["nplin", "pyln", "pxlf", "fxlen", "pngden", "xyfin", "pyden", "pxden", "fxden", "rxfin", "xplength", "xplen", "fxval", "pglf", "xylen", "pyl", "xpval", "cpden", "fxlf", "pxlin", "pxLen", "rxlen", "pylen", "pngln", "pplen", "fxl", "cpln", "pngLen", "rxlin", "nplen", "npden", "xyden", "fxlength", "ppden", "pxval", "pxfin", "pxl", "ppln", "npfin", "rxden", "xyLen", "xylin", "fxln", "pxlength", "xplf", "pxln", "pglen", "cplen", "pnglen", "cpl", "xyln", "ppLen", "pglength", "pgval"], "out": ["session", "dump", "prefix", "OUT", "re", "user", "point", "output", "line", "server", "cli", "lib", "list", "group", "parent", "store", "lock", "Out", "base", "v", "conn", "error", "page", "gen", "err", "inter", "io", "code", "up", "obj", "step", "print", "outs", "work", "cache", "log", "post", "copy", "sys", "again"]}}
{"id1": "7044153", "id2": "19006212", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    public void Load(String fname) throws Exception {\n        File f = null;\n        try {\n            if (\"\".equals(fname) || fname == null) throw new Exception();\n            System.out.println(\"Loading mapfile \" + fname);\n        } catch (Exception e) {\n            throw new Exception(\"File not found\");\n        }\n        aType = null;\n        fieldtype.clear();\n        creatures.clear();\n        aElement = new String(\"\");\n        content = null;\n        Ax = -1;\n        Ay = -1;\n        aTemplate = -1;\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        data_read = 0;\n        URL url = this.game.mainClass.getClassLoader().getResource(fname);\n        if (url == null) {\n            throw new Exception(\"Can't load map from : \" + fname);\n        }\n        try {\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(url.openStream(), this);\n        } catch (Exception e) {\n            System.out.println(\"Can't open XML : \" + e);\n        }\n        for (int i = 0; i < fieldtype.size(); i++) {\n            System.out.println((MapField) fieldtype.get(i));\n        }\n        game.player.setpos(start_x, start_y);\n        System.out.println(\"Player starting position set\");\n        start_x = -1;\n        start_y = -1;\n        System.out.println(\"Map \\\"\" + fname + \"\\\" loaded\");\n    }\n", "label": 0, "substitutes": {"server": ["address", "prefix", "serv", "port", "service", "ssl", "domain", "host", "db", "http", "conf", " host", "json", "base", "root", "erver", "ip", "header", "client", "email", "addr", "test", "Server", "ser", "proxy", "null"], "ex": ["lex", "ext", "rex", "cl", "acer", "x", "re", "rupt", "nex", "EX", "sex", "hex", "ception", "con", "exit", "str", "ax", "fail", "e", "class", "Exc", " exc", "base", "event", "error", "Exception", "export", "full", "throw", "temp", "res", "pex", "exp", "err", "exc", "tx", "obj", "su", "exec", "except", "example", "log", "def", "ace", "aux", "status", "Ex", "none"], "config": ["ext", "Config", "address", "bug", "cfg", "service", "app", "Conf", "conf", "console", "text", "json", "base", "file", "cb", "connection", "Configuration", "client", "cmd", "settings", "rc", "proc", "log", "etc", "options"], "prob": ["proj", "pej", "probe", "probs", "pebs", "peb", " probs", " probe", "Probe", "Prob", "pebe", "Probs", " proj", "Proj"], "dataSB": ["ifSB", "ifsb", "controlLB", "strLB", " dataLB", "dataSL", "ifSL", "defaultLB", " dataBs", "offLB", "eventSL", "pLB", " dataPB", "postSL", "offSB", "pSB", "eventLB", "errorLB", " dataSL", "codeEB", "controlBB", "nosb", "uiEl", "execBL", "dataLB", "dataOB", "datLB", "postLB", "errorOB", "DataBB", "datOB", "fullLB", "DataSB", "loadSB", " datasb", "innerSB", "offsb", "strsb", "codeRB", "DataFB", "codeHL", "dataFB", "workBB", "uiLB", "controlBL", "controlsb", "uiSB", "postsb", "noSL", "dataBB", " dataBL", "DataSL", "responseSB", "workPB", "execLB", "dataRB", "errorsb", "errorSB", "DataMB", "errorPB", " dataRB", "filesb", "strSB", "workSB", "execsb", " dataEB", "responseBL", "dataBL", "cacheBL", " dataOB", "dataEB", "dataEl", "Datasb", "datasb", "dataHL", " dataMB", "errorEB", "pBs", "fullBB", "innerLB", "fullSB", "defaultsb", "offBB", "DataLB", "errorSL", "innersb", "defaultBB", "fileSB", "codeSB", "workSL", "execBB", "dataPB", "codesb", "innerSL", "codeBB", "controlSB", "postSB", "noLB", "ifLB", "codeFB", "responseLB", "contentsb", "fileSL", "defaultSB", "codeEl", "fullBL", "loadBB", " dataHL", "fileLB", "datBB", "psb", "contentOB", "codeBs", "cacheLB", "codeLB", "loadsb", "codeMB", "eventBB", " dataEl", "DataHL", "DataBL", "cacheSB", "execSB", "responseBB", "DataOB", "dataBs", " dataBB", "datSB", "DataRB", "strSL", "eventSB", "loadLB", "errorBB", "offSL", "cachesb", "contentSB", "dataMB", "noSB", " dataFB", "contentLB"], "trace": ["cover", "debug", "address", "bug", "data", "runner", "time", "string", "strip", "xml", "profile", "flow", "notice", "span", "tr", "trip", "t", "e", "ptr", "track", "atter", "context", "fake", "scale", "value", "array", "error", "file", "bean", "temp", "stack", "shadow", "type", "tc", " debug", "err", "call", "thread", "comment", "buffer", "tx", " tracing", " traced", "code", "details", " traces", "result", "tri", "trans", "cache", "ctr", "log", "test", "frame", "ray", "report", "ace", "r", "out", "info", "race", "message"]}}
{"id1": "20375440", "id2": "411595", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"srcFile": [" srcFiles", "sourcePath", "destFiles", "srcFiles", "srcfile", "rcFile", "sourceFiles", "sourceDir", "srcDir", " srcfile", "destfile", "rcPath", " srcPath", "srcPath", "sourceFile", "rcfile", "destDir", "sourcefile", " srcDir", "rcFiles"], "destFile": ["tempFile", "DestPath", "DestPlace", "destPath", "destFiles", "restFiles", "restPlace", "tempFiles", "targetPlace", "targetfile", "restFile", "destPlace", "restfile", "DestFile", "tempPath", "targetFiles", "DestFiles", "targetFile", "tempfile", "destfile", " destfile", " destPath", "Destfile", " destFiles"], "src": ["inst", "loader", "ctx", "sync", "construct", "rb", "gb", "ssl", "sb", "source", "upload", "sec", "sub", "ources", "RC", "slice", "sr", "sl", "input", "dist", "secure", "bs", "req", "func", "sup", "conn", "url", "in", "sc", "reader", "impl", "img", "cb", "stat", "self", "ws", "client", "conv", "sq", "sel", "rs", "rc", "proc", "stream", "start", "cmp", "cur", "loc", "ser", "config", "sys"], "dest": ["target", "rest", " Dest", "d", "ui", "ssl", "home", "source", "thin", "usr", "wb", "Dest", "dc", "end", "output", "path", "div", "ds", "tmp", "comb", "writer", "class", "this", "dist", "desc", "cp", "sup", "des", "destroy", "temp", "img", "de", "opt", "cdn", "dev", "slave", "std", "ws", "dir", "obj", "result", "proc", "trans", "stream", "wh", "test", "transform", "out", "null", "dat"], "buffer": ["number", "queue", "address", "length", "uffer", "data", "row", "flush", "reference", "request", "string", "source", "wave", "feed", "layer", "capacity", "slice", "limit", "iter", "buff", "buf", "input", "writer", "value", "base", "block", "raw", "transfer", "reader", "bin", "offset", "header", "Buffer", "batch", "channel", "b", "bytes", "result", "write", "size", "memory", "cache", "position", "key", "null", "copy", "info", "message"], "read": ["number", "next", "length", "x", "d", "sync", "data", "allow", "find", "pick", "check", "parse", "no", "i", "Read", "end", "send", "connect", "feed", "slice", "ind", "limit", "iter", "input", "wait", "text", "reading", "block", "load", "add", "raw", "sleep", "shape", "reader", "select", "play", "se", "fill", "seek", "k", "level", "get", "ip", "ride", "open", "READ", "b", "skip", "write", "exec", "build", "not", "create", "close", "size", "reads", "start", "work", "pass", "n", "run", "ok", "key", "count", "copy", "index", "default", "use", "show", "id"]}}
{"id1": "14794404", "id2": "9081749", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 1, "substitutes": {"password": ["address", "prefix", "data", "content", "words", "wd", "string", "resource", "path", "token", "input", " passwords", "text", "username", "p", "database", "array", "params", "phrase", "secret", "connection", "buffer", "name", "device", "channel", "email", "pattern", "Password", "description", "pass", "cache", "definition", "PASS", "crypt", "padding", "enc", "word", "attribute", "object", "sword", "message"], "encryptedPassword": ["encryptedCode", "encryptedpassword", "ryptedCode", "encryptedPass", " encryptedPass", "ryptedpassword", "ryptedPass", "ryptedString", " encryptedCode", "protectedpassword", " encryptedString", "protectedString", "ryptedPassword", "protectedPassword", "lockedString", "encryptedString", "protectedCode", "lockedPass", "lockedPassword", "protectedPass", "lockedpassword", " encryptedpassword"], "md5": [" md512", " md4", "dig5", "amd2", " MD5", "MD2", "mddown", "amd4", "MD45", "amd6", "digdown", " MD2", " md6", " md2", "md512", "dig4", "MD4", "dig2", "dig3", "MD6", "MD512", "MDdown", " md3", " MD3", "md45", "MD3", " mddown", "md3", "md2", " md45", "md4", "md6", " MD512", "amd5", "MD5", "dig45"], "digest": ["mdest", "mdenge", " digment", "encester", "Digher", "digace", " digash", "digash", "Digace", "mdash", "encest", "digests", " digace", "Digested", "signest", "Digester", "digester", "signester", "encash", "signested", " digester", "mdested", " digests", " digenge", "Digests", "signests", "digested", "digher", "mdests", "digenge", " digher", "mdher", "mdace", "digment", "mdment", "encment", "Digenge", "Digest", "mdester"], "i": ["hi", "phi", "f", "length", "x", "d", "it", "ui", "ti", "ie", "uri", "bi", "ci", "gi", "qi", "di", "t", "h", "pi", "zi", "p", "v", "ix", "ai", "u", "k", "io", "s", "ip", "ii", "o", "c", "b", "I", "multi", "ri", "j", "l", "si", "li", "r", "oi", "index", "xi", "e", "id"], "hex": ["ext", "lit", "rex", "length", "bits", "prefix", "digit", "data", "check", "alpha", "string", "sex", "none", "shift", "slice", "str", "sign", "di", "buff", "zip", "nexus", "binary", "text", "pixel", "utf", "ix", "mix", "num", "temp", "closure", "stick", "bin", "pex", "exp", "oct", "char", "letter", "ip", "hash", "comp", "serial", "coord", "pattern", "pack", "ctr", "ex", "enc", "bit", "null", "rh", "id"]}}
{"id1": "3558512", "id2": "17996547", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"out": ["loader", "dump", "filename", "OUT", "a", "data", "content", "string", "source", "i", "output", "server", "writer", "parent", "Out", "raw", "file", "conn", "page", "temp", "w", "bin", "gen", "err", "io", "buffer", "image", "name", "up", "archive", "obj", "client", "o", "outs", "exec", "cache", "pool", "report", "ex", "copy", "png"], "parser": ["loader", "system", "wrapper", "pillar", "plugin", "lp", "Parser", "parse", "xml", "builder", "upload", "per", "handler", "server", "pe", "pp", "writer", "class", "cp", "pkg", "parent", "base", "p", "txt", "processor", "file", "reader", "php", "er", "arser", "worker", "manager", "seed", "rar", "up", "as", "instance", "ss", "cache", "test", "tt", "copy", "master"], "on_disk": ["onnetdemand", "onbootlock", "on_demand", "on_storage", "onjspace", "onjdrive", "onnetdrive", "onJdisk", "off_delete", "onnetfile", "onnetdisk", "off_demand", "onbookdelete", "onJlock", "off_space", "off_drive", "off_file", "onjdisk", "onbootdisk", "off_storage", "on_space", "onjfile", "on_file", "off_disk", "on_lock", "on_delete", "onbookdisk", "onbootstorage", "onJdrive", "on_drive", "onbookdrive", "off_lock", "onnetspace", "onbootdrive", "onJdemand"], "in": ["f", "data", "socket", "inn", "source", "i", "thin", "con", "ax", "input", "inas", "kin", "min", "din", "file", "conn", "lin", "reader", "rin", "ins", "bin", "connection", "inner", "o", "c", "as", "win", "In", "stream", "pass", "inc", "ac", "IN", "ini", "r", "copy", "login", "again", "info", "pin"]}}
{"id1": "15797402", "id2": "822452", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"stream": ["loader", "video", "data", "content", "src", "source", "sample", "resource", "document", "form", "remote", "feed", "upload", "through", "server", "read", "http", "response", "iterator", "input", "writer", "load", "raw", "file", "url", "in", "reader", "Stream", "down", "handle", "stack", "temp", "draw", "inner", "image", "client", "channel", "download", "view", "message"], "handler": ["application", "Handler", "loader", "wrapper", "ctx", "data", "format", "service", "handled", "host", "layer", "response", "server", "di", "monitor", "writer", "parent", "function", "base", "event", "processor", "reader", "handle", "manager", "connection", "hand", "collection", "client", "channel", "phase", "parser", "controller", "driver", "h", "default", "pointer", "info"], "metadata": ["material", "ctx", "managed", "template", "plugin", "data", "content", "uri", "source", "resource", "document", "xml", "subject", "di", "monitor", "meta", "json", "runtime", "database", "processor", "properties", "params", "mt", "directory", "manager", "m", "connection", "state", "management", "header", "module", "storage", "collection", "met", "mx", "md", "mon", "property", "component", "metry", "parser", "adata", "mi", "config", "attribute", "info", "map", "message"], "context": ["system", "ctx", "Context", "data", "content", "request", "resource", "document", "xml", "subject", "kernel", "entry", "command", "text", "parent", "txt", "event", "processor", "reader", "translation", "method", "concept", "environment", "manager", "scope", "object", "connection", "element", "tx", "collection", "instance", "component", "cmp", " Context", "mc", "config", "proxy", " contexts", "message"], "name": ["common", "named", "address", "filename", "prefix", "sync", "child", "data", "version", "time", "string", "source", "no", "resource", "alias", "path", "on", "model", "message", "label", "class", "search", "base", "large", "url", "file", "in", "full", "active", "part", "missing", "type", "m", "call", "NAME", "connection", "comment", "action", "image", "Name", "code", "job", "route", "old", "ame", "size", "work", "n", "key", "api", "word", "default", "object", "null", "names", "none", "id"], "out": ["ext", "sync", "OUT", "child", "data", "flush", "socket", "user", "source", "resource", "builder", "output", "path", "line", "server", "cos", "lib", "writer", "again", "window", "Out", "file", "conn", "in", "url", "page", "plain", "temp", "bin", "manager", "exp", "err", "connection", "io", "image", "obj", "client", "o", "channel", "outs", "result", "instance", "pool", "ray", "ex", "copy", "extra", "object", "null"]}}
{"id1": "13563706", "id2": "17557289", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"request": ["application", "queue", "data", "user", "string", "resource", "remote", "document", "xml", "server", "input", "Response", "p", "query", "req", "event", "url", "method", "type", "connection", "buffer", "image", "QUEST", "info", "client", "result", "instance", "current", "view", "frame", "report", "complete", "attribute", "config", "object", "model", "create", "Request", "e", "message"], "response": ["application", "re", "service", "site", "resource", "document", "output", "status", "subject", "wa", "feed", "reason", "server", "http", "writer", " Response", "onse", "Response", "json", "respond", "query", "reply", "error", "res", "location", "connection", "results", "image", "header", "collection", "client", "result", "description", "resp", "view", "pool", "body", "report", "api", "index", "object", "model", "message"], "selectedPage": ["namedpage", "selectionpage", "selectedLine", " selectedSite", "electedButton", "selectionPage", "lectedFile", " selectedAction", "electedPage", "selectedpage", "lectedSite", "electedLine", "namedPage", "selectedAction", " selectedItem", "selectedFile", "namedLine", " selectedButton", "lectedPage", "selectionFile", "electedpage", "namedFile", " selectedLine", "selectionHour", "namedSite", "selectedSite", "lectedAction", "selectedButton", "lectedButton", " selectedpage", " selectedFile", " selectedHour", "lectedHour", "selectionButton", "selectedHour", "lectedpage", "selectionLine", "lectedItem", "selectionItem", "selectedItem", "lectedLine", "selectionAction"], "page": ["number", "peer", "per", "server", "pe", "project", "menu", "html", "block", "url", "sp", "type", "ge", "unit", "change", "view", "pool", "model", "e", "queue", "account", "address", "f", "plugin", "pg", " Page", "profile", "pp", "photo", "connection", "display", "po", "instance", "Page", "item", "me", "position", "fe", "record", "layout", "article", "je", "resource", "document", "rule", "handler", "office", "module", "language", "client", "cache", "node", "proxy", "message", "child", "row", "port", "user", "point", "site", "section", "parent", "p", "pl", "location", "image", "ip", "channel", "route", "result", "ice", "age", "phone"], "portalRequest": [" portalQuery", "portugalEvent", "PortortalRequest", "portelRequest", "portailResponse", "portbalRequest", "portortalUser", "portallRequest", "portugalResponse", "PortortalEvent", "PortortalAccess", "PortortalServer", "portalQuery", "portallingPage", "PortortalCommand", "portallingCommand", "portelQuery", "portortalRequest", "PortalResponse", "portALRequest", "portpalAccess", "portugalUser", "portailRequest", "portialRequest", " portalPage", "portalEvent", "portpalRequest", "PortalUser", "portugalOrder", "portugalServer", "portialResponse", "portortalServer", "portallingAccess", "portalServer", "portortalEvent", "portortalCommand", "portailUser", "portelPage", "portalUser", "PortortalResponse", " portalResponse", "portailOrder", " portialResponse", "portalResponse", "portelCommand", "PortalOrder", "PortalRequest", "portallingRequest", "portbalQuery", " portialRequest", "portallingResponse", "portortalAccess", "portpalPage", "portalOrder", "portialQuery", "PortalServer", "PortalAccess", "portALResponse", "PortortalPage", "PortalPage", "portalCommand", "portALUser", "portbalPage", "portortalPage", "portugalRequest", "PortortalOrder", "portbalResponse", "portortalResponse", "portortalOrder", "portialPage", "PortalCommand", "portallServer", " portialQuery", "portallUser", "PortalEvent", "PortortalUser", "portALEvent", "portpalResponse", "portallResponse", "portelResponse", "portalAccess", " portialPage", "portalPage"], "pageProp": ["pagePro", "projectprop", "projectProp", "resourceProp", "PagePro", "ageProp", "ageprop", " pageProperty", "PageProp", "ageProperty", "resourceProperty", " pageObj", "PageStr", "projectProperty", " pageStr", "parentPro", "pluginProp", "parentObj", "resourcePro", "pluginprop", "parentProperty", "peerProperty", "pageObj", "pluginPro", "pageprop", "pluginProperty", "Pageprop", "projectPro", "peerProp", "resourceprop", "parentProp", "peerPro", "agePro", "peerStr", " pagePro", "pageStr", "PageProperty", "PageObj", "pageProperty"], "possiblePage": ["puredGroup", "patchedOrder", "PossibilityLine", "patchingPage", "PossiblePages", "patchingpage", "pablepage", "PossibilityPages", "possibleGroup", "puredItem", "possiblyLine", "PossiblePage", "PossibleGroup", "patchedPage", "Possibilitypage", "PossiblyItem", "possiblepage", "possibleOrder", "PossiblyGroup", "permanentLine", "possibilitypage", "possibilityLine", "puredpage", "possiblyGroup", "permanentOrder", "PossiblyPage", "possiblePages", "possiblyPages", "PossibleItem", "patchingGroup", "patchingItem", "possiblyPage", "pableLine", "possiblyItem", "PossibilityPage", "pablePages", "PossibleLine", "pablePage", "Possiblypage", "possibleItem", "possibilityPage", "permanentPage", "possiblypage", "Possiblepage", "possibilityPages", "permanentpage", "possibleLine", "PossiblyLine", "patchedpage", "puredPage", "PossibleOrder", "possiblyOrder", "PossiblyOrder", "patchedLine"], "property": ["number", "maximum", "expression", "address", "f", "prefix", "data", "integer", "string", "section", "resource", "profile", "layer", "label", "uration", "character", "t", "perties", "project", "duration", "class", "binary", "Property", "value", "entity", "function", "p", " Property", "binding", "properties", "variable", "prop", "type", "future", "table", "header", "language", "name", "set", "result", "term", "notation", "feature", "key", "attribute", "config", "object", "operator"], "referer": ["defrer", "redrer", "defender", "afferer", "diffender", "Refender", "rederer", "differer", " refre", "reere", "refrer", " refber", "reiner", "Refere", "affrer", " refrer", "afferen", " referen", "refiner", "refere", "Referer", "affere", "Refeline", "ferer", "Refre", "refre", "rere", "deferer", "defere", "referers", " refere", "ferers", "Referers", "Referen", " refender", "diffiner", "Refrer", " refiner", "fere", "Refber", "reerer", "diffrer", " referers", "rerer", "defber", "redeline", "referen", "refender", "redber", "frer", "refber", "refeline", "Refiner", " refeline"]}}
{"id1": "9371421", "id2": "22752444", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 1, "substitutes": {"eventstr": ["errorstr", "EventStr", "exstring", "eventdict", "exStr", "Eventstr", "errorsource", "exdict", "exstr", "Eventstring", "errorstring", "eventStr", "Eventsource", "eventsource", "Eventdict", " eventStr", " eventdict", "errorStr", "eventstring", " eventstring", " eventsource"], "md": ["cm", "d", "dh", "dr", "sm", "data", "wd", "ad", "pm", "hm", "em", "amd", "rpm", "sha", "mu", "di", "mn", "meta", "ng", "mm", "MD", "dd", "od", "mand", "ma", "mt", "ke", "m", "ms", " MD", "bd", "dig", "hash", "mb", "mg", "vd", "dm", "cmd", "mod", "doc", "hd", "mac", "mag", "mp", "key", "metadata", "mc", "mem", "ld", "mo", "map", "id"], "theDigest": [" theSignest", "TheDigester", "theHashester", "thedighest", "theDigEST", " theDigester", "Thedigest", "theSignester", " theDighest", "TheDigEST", "theSignhest", " theSignEST", " theSignester", " theDigEST", "theDighest", "theDigester", "ThedigEST", "theSignest", "theHashEST", "thedigEST", "theHashest", "thedigest", "Thedigester", "theSignEST", "TheDigest", "thedigester", " theSignhest"]}}
{"id1": "18114701", "id2": "5744992", "code1": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "code2": "    public void dorequest(Map<String, String> ps, String method) throws IOException {\n        StringBuffer httpResponse = new StringBuffer();\n        URL ourl = new URL(url);\n        HttpURLConnection httpConnection = (HttpURLConnection) ourl.openConnection();\n        httpConnection.setRequestMethod(method);\n        httpConnection.setDoOutput(true);\n        this.setCookie(httpConnection);\n        OutputStream httpOutputStream = httpConnection.getOutputStream();\n        StringBuffer postParams = new StringBuffer(\"\");\n        for (Entry<String, String> entry : ps.entrySet()) {\n            postParams.append(entry.getKey());\n            postParams.append(\"=\");\n            postParams.append(entry.getValue());\n            postParams.append(\"&\");\n        }\n        httpOutputStream.write(postParams.toString().getBytes());\n        BufferedReader httpBufferedReader = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n        httpResponse.append(this.readBufferedContent(httpBufferedReader));\n        text = httpResponse.toString();\n        this.readCookie(httpConnection);\n    }\n", "label": 0, "substitutes": {"publicId": [" publicid", " publicUrl", "publicID", "packageLoc", "ublicLoc", " publicPath", "packageID", "openid", "publicPath", "clientID", "ublicid", "packageId", "ublicID", "classId", "classid", "systemUrl", " publicID", "packageid", "ublicId", "clientPath", "openID", "projectId", "classUrl", "publicUrl", "projectid", "classID", "projectID", "clientid", "openId", "clientId", "openPath", "systemid", "publicid", "systemID", "publicLoc", "projectLoc"], "systemId": ["systemPath", " systemID", "developmentID", "userPath", "userId", "SystemID", "serverid", "SystemUrl", "userUrl", "serverName", "userID", "systemUrl", " systemName", "developmentId", " systemPath", "SystemId", "systemid", "serverID", " systemid", "systemID", "serverId", "systemName", "SystemPath", "developmentid", "developmentName", " systemUrl"], "resolved": ["regolved", "regvable", "reolution", "revable", "reolved", "reerved", "presolution", " resolution", "presolving", "Resolved", "resolve", " resolver", "revolver", "presolved", "revolution", "presolve", "resolutionolution", "resolutionerved", "reolving", "resolutionolving", "presvable", "resolver", " resolve", "reolver", "Resolve", "regolution", "resolving", "revolved", "Resolution", "resvable", "resolution", "reserved", "reolve", "preserved", "resolutionolved", "presolver", "regolver", "Resolver", "revolving"], "iSource": ["dataSOURCE", "iInfo", "lSource", "iniSOURCE", "lStream", "ISource", "sSession", "iniSource", "iReader", "uiForce", "iniSourceFile", " iSOURCE", "uiStream", "siReader", "IStream", "dataInfo", "iProxy", "uiSource", " iSourceFile", "iConfig", "siForce", "lProxy", "siProxy", " iConfig", "ISession", "siSOURCE", "iSOURCE", " iReader", "IConfig", "uiSOURCE", "dataSourceFile", "iSourceFile", "sSource", "sStream", "iForce", "iSession", "dataSource", "siStream", " iForce", "sConfig", "lReader", " iSession", " iInfo", "iniInfo", " iProxy", "siSource"], "url": ["address", "f", "data", "jar", "uri", "user", "ssl", "string", "source", "resource", "web", "feed", "path", "server", "http", "fr", "org", "sl", "URL", "event", "file", "page", "www", "location", "connection", "image", "client", "channel", "b", "l", "ll", "stream", "Url", "rl", "fl", "ball", "id"], "iStream": ["istream", " iPath", " istream", "uFile", "piStream", " iFile", "uSource", "iniStream", "uiStream", "uiFile", "uiPath", "uiSource", "uStream", "iPath", " iFeed", "iFeed", "piFeed", "pistream", "piSteam", "iniFeed", "inistream", "iFile", "iSteam", " iSteam", "uPath", "iniSteam"]}}
{"id1": "20073619", "id2": "7499186", "code1": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 0, "substitutes": {"strurl": ["inthttp", "intUrl", "intaddress", "striurl", "arrUrl", "StrURL", "StrUrl", " straddress", "inturl", "arrurl", "strURL", "brurl", "strhttp", "striaddress", " strhttp", "straddress", "brUrl", "brURL", "striUrl", "strihttp", "arrURL", " strUrl", "Strurl", "strUrl"], "url": ["ir", "inf", "f", "bel", "socket", "uri", "user", "service", "ssl", "source", "resource", "web", "path", "server", "http", "ur", "org", "sl", "zip", "URL", "base", "file", "page", "ls", "gl", "connection", "io", "image", "buffer", "open", "job", "b", "en", "l", "ll", "stream", "Url", "log", "rl", "r", "ball"], "in": ["loader", "gin", "f", "d", "it", "data", "inn", "ssl", "source", "i", "con", "fr", "is", "input", "init", "rec", "din", "lin", "file", "reader", "impl", "ins", "bin", "into", "err", "ar", "inner", "s", "image", "b", "c", "inside", "as", "l", "win", "In", "stream", "inc", "IN", "ini", "r", "login", "out", "again", "e", "id"], "str": ["cl", "st", "rr", "data", "dr", "strip", "string", "lc", "i", "div", "sr", "line", "dec", "cr", "fr", "tr", "iter", "sl", "pr", "text", "rec", "p", "raw", "reader", "wr", "sp", "err", "char", "s", "arr", "br", "code", "STR", "obj", "c", "l", "doc", "Str", "cur", "key", "r", "enc", "stri", "e"], "resp": ["rest", "esi", "serv", "rr", "msg", "content", "ref", "rel", "lp", "remote", "conn", "exit", "host", "response", "reason", "news", "zip", "pp", "Resp", "Response", "rec", "json", "respond", "html", "dest", "req", "reply", "respons", "page", "esp", "wp", "part", "rss", "sp", "rev", "res", "www", "pretty", "exp", "err", "exc", "comp", "rep", "vp", "job", "obj", "result", "cmp", "ret", "report", "api", "default", "rh"]}}
{"id1": "8788371", "id2": "19134229", "code1": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"cmd": ["comm", "ctx", "cl", "cat", "cfg", "msg", "wd", "ck", "cycle", "host", "command", "buf", "cli", "seq", "grad", "cp", "pkg", "qq", "Cmd", "req", "prop", "method", "cb", "boot", "module", "code", "cd", "job", "md", "proc", "mode", "nd", "ctr", "cmp", "frame", "ok", "config", "dict"], "pos": ["address", "POS", "length", "x", "port", "point", "i", "Pos", "line", "limit", "pc", "param", "Position", "len", "seq", "p", "os", "neg", "num", "part", "prop", "pl", "type", " position", "s", "pri", "po", "ps", "start", "position", "pt", "loc", "val", "padding", "index", "pointer"], "c": ["ca", "cm", "f", "cs", "cu", "d", "g", "cf", "parse", "lc", "ci", "con", "cn", "dc", "cr", "pc", "t", "cli", "fc", "ce", "init", "cp", "p", "v", "sc", "u", "tc", "arc", "cd", "ec", "client", "b", "exec", "cc", "l", "ctrl", "ac", "unc", "xc", "mc", "uc", "enc", "h", "C", "e"], "src": ["inst", "lit", "rest", "filename", "prefix", "sync", "rb", "feat", "uri", "gb", "ssl", "string", "source", "sb", "resource", "prot", "RC", "host", "SOURCE", "str", "http", "attr", "sl", "project", "text", "dest", "username", "secure", "dist", "root", "sup", "url", "fp", "shell", "sc", "img", "location", "stat", "href", "storage", "name", "route", "result", "rc", "proc", "stream", "cmp", "cur", "loc", "fn", "uc", "ource", "config", "null", "sn"], "path": ["loader", "prefix", "length", "core", "ref", "uri", "time", "host", "root", "url", "sc", "full", "Path", "type", "link", "config", "pointer", "fs", "sync", "version", "home", "source", "context", "folder", "base", "txt", "chain", "conn", "file", "method", "near", "connection", "po", "log", "key", "info", "id", "ath", "ctx", "PATH", "content", "wd", "resource", "handler", "plus", "text", "cp", "prop", "temp", "directory", "stat", "dir", "client", "pattern", "or", "proc", "work", "api", "object", "rh", "system", "child", "cat", "port", "point", "app", "parent", "p", "location", "image", "name", "obj", "route", "rc", "size", "loc", "uc"], "parameters": ["equuments", " parameter", "pargs", "promuments", "prometers", " paramets", "promets", "paramatory", "paramsatory", " paramatory", "paramseter", "equargs", "peter", "puments", "paramsets", "parameter", "paramargs", "paramuments", "peters", "prometer", "promatory", "equeters", "paramets", "paramseters", "equeter", "promargs"], "foption": [" fopt", "Fopt", " Foption", "popt", "FOption", " Fopt", " fOption", "poption", " FOption", "fOption", "Foption", "Fsection", "pOption", "fsection", " fsection", "fopt", "psection"], "srcFs": ["srcFS", "rcfs", " srcFD", " srcFW", "sortfs", " srcOps", "sourceFS", "srcOs", " srcFS", "configFs", " srcfs", " srcOs", "sourceOps", "sourceOs", "srcfs", "configOs", "srcFW", "sortFW", "sourcefs", "rcFs", "sortFs", "rcFD", "rcOs", "sortFS", "sourceFs", "rcFW", "configFS", "srcFD", "rcOps", "configFD", "rcFS", "srcOps"], "fileSize": ["pageSize", "taskLength", "lineCopy", " fileSIZE", "logSize", " filesize", "functionSIZE", " fileInfo", "filesize", "fileInfo", "logLen", "fileLen", "functionSize", "bytesize", "FileVersion", " fileVersion", "Filesize", "wordSize", "lineInfo", "taskSIZE", "fileSIZE", "logLength", "taskLen", " fileLen", "byteInfo", "wordsize", "wordTime", "lineSize", "lineLength", "taskSize", "pagesize", "FileSize", "FileLen", "fileLength", " fileLength", "pageTime", " fileCopy", "byteVersion", "wordLen", "pageInfo", "logSIZE", "fileCopy", "FileCopy", "FileSIZE", "pageLen", " fileTime", "lineLen", "pageLength", "functionLen", "fileTime", "byteSize", "FileInfo", "fileVersion"], "offset": ["prefix", "length", "alias", "entry", "attr", "limit", "iterator", "align", "interrupted", "addr", "auto", "index", "out", "pointer", "address", "data", "left", "slice", "Offset", "base", "timeout", "connection", "action", "optional", "set", "item", "position", "online", "enabled", "info", "reset", "operation", "pad", "line", "option", "len", "array", "part", "absolute", "order", "exclusive", "start", "object", "point", "end", "shift", "off", "parent", "error", "page", "location", "image", "o", "skip", "size", "loc", "padding", "attribute", "extra"], "in": ["gin", "f", "a", "serv", "re", "data", "isin", "socket", "inn", "source", "i", "token", "diff", "read", "ax", "is", "input", "init", "inas", "binary", "min", "raw", "din", "file", "lin", "reader", "rin", "ins", "bin", "inner", "io", "s", "buffer", "b", "as", "ilo", "or", "win", "In", "stream", "n", "inc", "ac", "IN", "nin", "ini", "r", "ex", "login", "out", "again", "pin", "id"]}}
{"id1": "22046596", "id2": "21348951", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "label": 1, "substitutes": {"s": ["S", "f", "x", "a", "ses", "src", "g", "ssl", "sb", "source", "i", "sf", "es", "sin", "sh", "ds", "is", "sl", "input", "p", "os", "v", "ns", "se", "gs", "ins", "ls", "files", "w", "u", "south", "m", "storage", "services", "xs", "o", "b", "c", "outs", "as", "ss", "l", "ps", "less", "ts", "sv", "si", "fs", "e"], "t": ["target", "f", "x", "it", "template", "g", " T", "i", "tr", "ot", "z", "tf", "p", "v", "file", "T", "temp", "down", "m", "tc", "tor", "to", "ta", "y", "o", "b", "c", "tty", "l", "ts", "n", "at", "pt", "tp", "r", "object", "ty", "e"], "in": ["f", "sync", "d", "pull", "socket", "g", "inn", "ssl", "source", "i", "sin", "is", "input", "init", "p", "min", "din", "conn", "file", "url", "reader", "rin", "ins", "bin", "m", "inner", "io", "up", "c", "b", "as", "l", "win", "In", "n", "inc", "IN", "nin", "r", "login", "h", "again", "pin", "e", "id"], "out": ["ext", "f", "sync", "OUT", "d", "x", "g", "user", "output", "off", "writer", "parent", "Out", "p", "v", "conn", "file", "plain", "temp", "w", "bin", "err", "connection", "net", "io", "call", "image", "client", "channel", "o", "c", "b", "outs", "obj", "not", "l", "n", "at", "inc", "ex", "copy", "again", "null"]}}
{"id1": "14001795", "id2": "8047989", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"dir": ["ir", "d", "re", "dr", "data", "wd", "home", "container", "div", "dc", "director", "DIR", "handler", "db", "feed", "http", "draft", "di", "zip", "lib", "class", "group", "dist", "desc", "folder", "pkg", "store", "lock", "window", "parent", "url", "file", "fd", "handle", "keep", "directory", " directory", "manager", "io", "up", "cd", "md", "Dir", "build", "download", "direct", "doc", "df", "cache", "work", "log", "cur", "dn", "loc", "def", "clean", "r", "local", "config", "direction", "coll"], "ff": ["cl", "iff", "fed", "bb", "cf", "ck", "fox", "upp", "sf", "uff", "ffe", "flow", "feed", "eff", "ft", "fx", "off", "fb", "pp", "buff", "lf", "bf", "front", "fam", "fp", "dd", "fd", " buff", "cb", "now", "FF", "ffff", "rf", "fff", "aff", "uf", "ph", "df", "fw", "ef", "xff", "fold", "TF", "fe", "fl"], "files": ["data", "features", "lines", "blocks", "pes", "balls", "groups", "iles", "items", "flows", "rows", "file", "events", "ls", "pl", "apps", "Files", "qs", "results", "s", "users", "objects", "pages", "l", "ps", "keys", "models", "images", "split", "fl", "names", "fs", "locks"], "f": [" df", "inf", "d", "cf", "i", "sf", " file", "feed", " fa", "fr", " F", "t", "fb", " fe", "fc", "lf", "File", "F", "fa", "tf", "p", "bf", "fp", "file", "v", "fd", "full", "fen", "of", "name", "fac", "info", "rf", "o", "c", "aff", "l", "n", "fold", "fn", "fe", "r", "fl", " e", "fs", "e"], "newFile": ["createfile", "updateF", " newFiles", "oldfile", "againLine", "createFiles", "newLine", "oldFiles", " newFolder", "andFolder", "updateLine", "createFile", "createFolder", "againEntity", "oldFile", "NewFile", "andFiles", "updateFile", "oldFolder", "NewFiles", "NewFolder", "updateEntity", " newF", " newEntity", "newFiles", "andFile", "Newfile", " newLine", "newFolder", "againFile", "andfile", "newEntity", "newfile", " newfile", "againF", "newF"], "fi": ["cci", "afa", "afe", "ifi", "cf", "gif", "bi", "i", "sf", "ffe", "gi", "uci", "FI", "fr", "aci", "afi", "di", "fb", "ki", "fc", "abi", "fa", "pi", "xi", "zi", "ico", "ifa", "flo", "fp", "ilia", "Fi", "wi", "ii", "sci", "fw", "isi", "si", "vi", "ini", "fe", "fy", "info"], "fo": ["wo", "osa", "afe", "inf", "olo", "ato", "cf", "sf", "ofi", "xf", "di", "afi", "ki", "fa", "flo", "ico", "os", "jo", "fam", "shi", "fif", "zo", "io", "ho", "ko", "info", "o", "FO", "po", "uf", "bo", "ph", "fw", "si", "lo", "osi", "fe", "so", "obi", "mo"]}}
{"id1": "11475527", "id2": "13981689", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"theurl": ["thepublic", " thejob", "theUrl", "thatURL", "testURL", "THEURL", " theURL", " Thepublic", "THEpublic", "myurl", "testfile", "THEUrl", "thejob", "thatUrl", "thaturl", "thefile", "myUrl", " TheUrl", "testurl", "testUrl", " thepublic", " Theurl", " Thejob", "THEurl", " theUrl", "THEjob", "myURL", "myfile", "THEfile", "theURL"], "line": ["number", "cl", "f", "sync", "next", "row", "lines", "string", "source", "i", "no", "lc", "feed", "LINE", "str", "entry", "pe", "character", "ine", "el", "cell", "len", "text", "base", "block", "file", "url", "lin", "part", "reader", "inline", "connection", "char", "comment", "style", "buffer", "unit", "Line", "code", "name", "write", "le", "sel", "l", "link", "pass", "log", "key", "li", "out", "object", "e", "id"], "in": ["a", "it", "serv", "isin", "socket", "inn", "string", "source", "i", "ssl", "is", "input", "arin", "init", "fa", "din", "url", "lin", "file", "reader", "conn", "rin", "ins", "bin", "m", "into", "err", "inner", "io", "client", "b", "inside", "ilo", "or", "l", "win", "In", "pass", "stream", "cin", "inc", "IN", "include", "nin", "ini", "r", "record", "login", "out", "again", "pin"], "data": ["loader", "f", "next", "d", "lines", "source", "i", "da", "output", "handler", "valid", "read", "entry", "di", "iter", "input", "writer", "file", "url", "reader", "er", "one", "connection", "inner", "buffer", "open", "up", "client", "result", "l", "ata", "stream", "start", "DATA", "body", "r", "like", "out", "info", "la", "dat"]}}
{"id1": "10936821", "id2": "8417584", "code1": "    @Override\n    public void doIt() {\n        try {\n            Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\");\n            if (mode.equals(\"FTP\")) {\n                FTPClient client = new FTPClient();\n                client.connect(Constants.ftpHost);\n                client.login(Constants.ftpUser, Constants.ftpPass);\n                client.changeDirectory(Constants.ftpDir);\n                File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName);\n                client.download(\"GT99_A09.rar\", ff);\n                client.disconnect(false);\n                Shared.prepareMovements(ff);\n            } else if (mode.equals(\"File\")) {\n                JFileChooser jfc = new JFileChooser();\n                FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\");\n                jfc.setFileFilter(f);\n                int selection = jfc.showOpenDialog(Shared.getMyMainWindows());\n                if (selection == JFileChooser.APPROVE_OPTION) {\n                    Shared.prepareMovements(jfc.getSelectedFile());\n                } else {\n                    return;\n                }\n            }\n            Shared.updateMovements();\n            if (Shared.isHadMovements()) {\n                MessageBox msg = new MessageBox(MessageBox.SGN_SUCCESS, \"Fue cargado el nuevo inventario satisfactoriamente!\");\n                msg.show(Shared.getMyMainWindows());\n            } else {\n                MessageBox msg = new MessageBox(MessageBox.SGN_WARNING, \"La tienda no tuvo ningun movimiento asociado.\");\n                msg.show(Shared.getMyMainWindows());\n            }\n        } catch (Exception ex) {\n            MessageBox msg = new MessageBox(MessageBox.SGN_DANGER, \"Ha ocurrido un error.\", ex);\n            msg.show(Shared.getMyMainWindows());\n        }\n    }\n", "code2": "    private String getResultFromHttpUrl(String href) {\n        String result = null;\n        try {\n            URL url = new URL(href);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Object o = conn.getContent();\n            log.debug(\"Opened \" + href + \" and got class \" + o.getClass().getName());\n            StringBuffer version = new StringBuffer();\n            String inputLine;\n            DataInputStream dis = new DataInputStream(conn.getInputStream());\n            while ((inputLine = dis.readLine()) != null) {\n                version.append(inputLine + \"\\n\");\n            }\n            result = version.toString();\n            log.debug(\"Read from URL:\\n\" + result);\n            dis.close();\n        } catch (Exception e) {\n            log.debug(\"Caught exception \" + e + \" whilst attempting to query URL \" + href);\n            e.printStackTrace();\n        } finally {\n            return result;\n        }\n    }\n", "label": 0, "substitutes": {"client": ["bird", "ssl", "connect", "per", "host", "server", "http", "project", "class", "ce", "url", "open", "pool", "config", "API", "cell", "plugin", "pg", "socket", "contact", "console", "community", "file", "conn", "connection", "net", "close", "local", "help", "cl", "i", "web", "resource", "and", "grid", "cloud", "cp", "secure", "manager", "get", "util", "cache", "api", "clean", "simple", "default", "clip", "Client", "session", "cm", "port", "remote", "end", "app", "con", "cli", "parent", "p", "event", "co", "act", "call", "ip", "force", "conv", "https"], "ff": ["kk", "abb", "cl", "iff", "bb", "cf", "eb", "upp", "sf", "uff", "flow", "feed", "eff", "ft", "fx", "fb", "pp", "buf", "buff", "lf", "cp", "bf", "front", "fp", "url", "fd", "cb", "FF", "eph", "bd", "cpp", "cd", "fi", "fff", "aff", "nd", "uf", "ph", "af", "df", "ef", "fe", "ob", "fl", "back"], "jfc": ["jetfc", "jbc", "gpc", "vpc", "jsfe", " jxf", "Jxf", "Jcf", "vfe", "Jpc", "Jfe", "jspc", "vfc", "Jfc", "synbc", "jetFC", "Jbc", "jfe", "jetpc", "jpc", "gFC", " jfd", " jcf", "jcf", "jetxf", "gcf", " jbc", "synfc", "synfd", "synFC", "JFC", "jsdc", "jdc", "gfc", "Jfd", "jFC", "Jdc", "jsfc", "jfd", "jxf", "vdc", " jFC", " jpc"], "f": ["filter", "d", "ref", "g", "cf", "i", "sf", "handler", "xf", "t", "fb", "fc", "lf", "F", "p", "v", "fp", "file", "fd", "w", "m", "io", "fo", "self", "s", "fac", "rf", "c", "b", "j", "l", "df", "n", "fe", "r", "h", "info", "fs", "e", "raf"], "selection": ["delete", "expression", " selecting", "Se", "which", "ses", "ssl", "ling", "sb", " selected", "selected", "bc", "slice", "entry", "option", "slot", "sl", "edition", "desc", "choice", "qua", "random", "lection", "url", "shell", "sc", "select", "directory", "location", "connection", "management", "language", "sel", "election", " Selection", " selections", "position", "si", "loc", "SELECT", "index", "info", "match"], "msg": ["gm", "comm", "mess", "help", "cm", "mail", "live", "cat", "plugin", "bug", "g", "ck", "Message", "send", "app", "db", "arg", "kg", "mu", "conf", "lang", "list", "game", "og", "console", "ng", "pkg", "html", "sg", "req", "error", "file", "gui", "gs", "img", "gl", "m", "Msg", "err", "bot", "gen", "get", "exc", "s", "module", "mg", "generic", "title", "dm", "cmd", "md", "util", "doc", "link", "cmp", "log", "body", "enc", "out", "bg", "global", "e", "message"]}}
{"id1": "8747840", "id2": "5977352", "code1": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"src": ["inst", "inf", "filename", "rb", "ref", "uri", "gb", "sb", "source", "resource", "path", "sin", "sl", "input", "dist", "file", "url", "reader", "rin", "ins", "img", "files", "cb", "s", "archive", "obj", "b", "sit", "sel", "rc", "stream", "loc", "ource", "config", "back"], "dest": ["delete", "target", " Dest", "save", "orig", "home", "source", "thin", "usr", "wb", "Dest", "output", "exit", "tif", "tmp", "comb", "class", "dist", "desc", "folder", "txt", "sup", "file", "die", "destroy", "temp", "down", "opt", "de", "done", "later", "name", "obj", "b", "result", "flat", "test"], "in": ["gin", "f", "a", "isin", "socket", "inn", "source", "i", "thin", "ln", "con", "sub", "is", "input", "rec", "din", "conn", "url", "lin", "reader", "rin", "impl", "ins", "file", "bin", "m", "inner", "image", "inside", "as", "l", "win", "In", "stream", "n", "inc", "IN", "nin", "ini", "r", "login", "h", "again", "pull", "id"], "out": ["ext", "OUT", "socket", "home", "source", "i", "app", "exit", "output", "off", "line", "writer", "this", "Out", "ou", "v", "conn", "file", "part", "w", "temp", "img", "one", "exp", "err", "io", "self", "up", "obj", "client", "o", "b", "outs", "exec", "outer", "over", "n", "cache", "log", "post", "inc", "pool", "ex", "copy", "again"], "buf": ["queue", "ctx", "f", "length", "bl", "bh", "rb", "data", "bb", "cf", "orig", "wb", "bc", "cr", "tmp", "buff", "fb", "cv", "len", "seq", "cp", "ff", "base", "p", "bf", "raw", "v", "fp", "fd", "bp", "cb", "ab", "bd", "buffer", "br", "batch", "cmd", "bytes", "b", "rc", "uf", "cur", "cap", "count", "uc", "bag"], "c": ["cm", "cl", "f", "d", "a", "cu", "cf", "lc", "i", "ci", "dc", "cr", "pc", "col", "z", "fc", "ce", "nc", "cp", "p", "cy", "v", "pointer", "u", "ct", "cb", "m", "k", "code", "cd", "ec", " rc", "o", "b", " b", "cc", "rc", "l", "n", "ac", "unc", " n", "cur", "loc", "xc", "count", "uc", "enc", "r", "ch", " i", "C", "e"]}}
{"id1": "16931472", "id2": "12172485", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"result": ["session", "re", "data", "row", "source", "resource", "document", "output", "response", "message", "list", "group", "json", "event", "array", "page", "res", "manager", "table", "results", "buffer", "Result", "order", "feature", "cache", "view", "report", "complete", "record", "status", "map", "match", "dict"], "target": ["session", "next", "version", "template", "it", "data", "content", "reference", "the", "request", "site", "source", "proxy", "resource", "output", "token", "host", "response", "server", "http", "goal", "project", "this", "class", " Target", "favorite", "parent", "html", "base", "database", "event", "task", "that", "page", "environment", "type", "manager", "location", "connection", "owner", "tail", "style", "unit", "image", "about", "client", "route", "download", "link", "arget", "external", "current", "Target", "config", "theme", "object", "layout", "master"], "url": ["loader", "address", "user", "uri", "socket", "service", "ssl", "string", "source", "resource", "path", "feed", "str", "server", "http", "org", "sl", "URL", "blog", "base", "file", "page", "connection", "io", "buffer", "channel", "build", "browser", "l", "stream", "Url", "view"], "reader": ["loader", "bird", "f", "ry", "rr", "row", "i", "ler", "builder", "feed", "handler", "layer", "server", "read", "http", "editor", "e", "iter", "iterator", "input", "writer", "reading", "file", "in", "rer", "er", "worker", "err", "io", "buffer", "ri", "rc", "stream", "over", "rx", "parser", "driver", "report", "ner", "Reader"], "line": ["side", "lc", "pe", "limit", "sl", "block", "header", "buffer", "code", "link", "non", "view", "body", "e", "cell", "sync", "plugin", "data", "parse", "home", "source", "profile", "LINE", "lined", "liner", "base", "file", "Line", "log", "key", "li", "info", "id", "cl", "live", "lines", "string", "no", "rule", "str", "response", "zip", "el", "lf", "text", "lin", "comment", "le", "or", "status", "message", "row", "user", "point", "strip", "site", "end", "nl", "iter", "ine", "lock", "error", "page", "inline", "err", "style", "range", "name", "look", "email", "o", "l", "definition", "frame", "lo", "rl"], "entry": ["extra", "ry", "ener", "data", "row", "ie", "uri", "service", "counter", "string", "section", "source", "resource", "builder", "per", "feed", "exit", "ent", "layer", "editor", "writer", "member", "value", "entity", "page", "se", "part", "ge", "connection", "owner", "inner", "element", "archive", "her", "term", "match", "or", "link", "rc", "key", "ner", "Entry", "enter", "e", "cell"], "fromIndex": [" fromOffset", "fromLength", " fromPoint", "toOffset", " fromLength", "FromOffset", "FromSection", "FromPosition", "toPoint", "toIndex", "fromPosition", "startIndex", "FromLength", "sourceIndex", "FromPoint", " fromPosition", "startLength", "startPosition", " fromSection", "sourcePosition", "sourcePoint", "fromSection", "fromPoint", "toPosition", "FromIndex", "startOffset", "sourceSection", "fromOffset"], "r": ["f", "re", "d", "rr", "R", "rb", "ru", "sr", "cr", "fr", "attr", "pr", "q", "p", "array", "v", "w", "u", "res", "er", "m", "rg", "ar", "range", "vr", "b", "ri", "lr", "c", "rs", "l", "rc", "nr", "rl", "ner", "mr", "e"]}}
{"id1": "838844", "id2": "18211588", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"src": ["inst", "ctx", "filename", "st", "rb", "feat", "ref", "uri", "gb", "ssl", "sb", "source", "string", "resource", "upload", "prot", "Dest", "path", "sin", "RC", "slice", "tmp", "buf", "sth", "input", "sl", "supp", "dist", "username", "secure", "load", "req", "fp", "url", "file", "sc", "reader", "impl", "img", "cb", "gz", "spec", "href", "s", "cpp", "storage", "gn", "vr", "name", "code", "obj", "sit", "sel", "rc", "proc", "download", "stream", "component", "cmp", "dep", "Source", "loc", "fn", "rl", "SourceFile", "ource", "config", "sec", "back", "sn"], "dest": ["target", "orig", "home", "source", "wb", "Dest", "dc", "path", "di", "tmp", "lib", " destination", "class", "dist", "cont", "txt", "temp", "img", "bin", "std", "dir", "obj", "disk", "fn", " dst", "null", "dat"], "in": ["inf", "f", "d", "a", "data", "isin", "inn", "source", "i", "t", "is", "input", "inas", "din", "file", "reader", "ins", "bin", "err", "io", "up", "as", "doc", "win", "ps", "In", "stream", "n", "pass", "inc", "IN", "ini", "r", "ex", "val", "login", "pin"], "p": ["pa", "pb", "pd", "f", "d", "pg", "g", "lp", "pm", "i", "per", "pc", "pe", "t", "h", "pp", "pr", "cp", "pi", "op", "fp", "v", "wp", "bp", "part", "sp", "cop", "m", "s", "py", "o", "pre", "c", "np", "b", "po", "j", "l", "ps", "jp", "parser", "tp", "P", "e"], "ds": ["docs", "d", "uds", "dt", "lp", " db", "ays", "hs", "ads", " DS", "ded", "scripts", "des", "ils", "icks", "ants", "qs", "dm", "vals", "dates", "ld", "sys", "dat", "posts", "ks", "styles", "ans", "pd", "cs", "sync", "data", "words", "points", "dp", "bs", "dd", "gs", "cdn", "Ds", "ups", "rs", "ps", "js", " dd", "sts", "cons", "tools", "els", "lines", "db", "DS", "di", "dist", "amps", "os", "tests", "vs", "dos", "ins", "ls", " sd", "s", "ws", "xs", "ts", "plugins", " props", " ps", "eps", "obs", "gd", "da", "dc", "parts", "dds", "ys", "utils", "nas", "ns", "ss", "df", "models", "dl"], "format": ["filter", "f", "filename", "prefix", "template", "feat", "data", "Format", "plugin", "version", "string", "source", "form", "xml", "path", "handler", "host", "t", "layout", "atter", "class", "tag", "scale", "function", "sche", "fp", "file", "url", "fd", "part", "type", "act", "spec", "style", "letter", "unit", "table", "language", "name", "struct", "ant", "pattern", "nat", "at", "frame", "parser", "fn", "api", "config", "magic", "record", "object", "model", "match"], "hasPixelData": ["hasPictureData", "hasPicOps", "haspixelStyle", " hasPixeldata", "hasBytedata", "hasPicStyle", "hasPixelDATA", "hasPictureDATA", "haspixelData", " hasPixelOps", "hasPixeldata", "hasPixelStyle", "haspixelOps", "hasPicData", "hasByteData", " hasPixelSize", "haspixelSize", "hasPicturedata", "hasPixelSize", "haspixelDATA", "haspixeldata", "hasPixelOps", " hasPixelStyle", " hasPixelDATA", "hasByteSize"], "inflate": [" inflATE", "infloocate", "uninflocate", "infloase", "uninfloute", "uninfloate", "information", "informATE", "incollate", "infloATE", "inflation", "infolute", " information", "infolame", "incollame", "inFlase", "incollocate", "inFlate", "informate", "infloate", "influte", "inflase", "incollute", "uninfloame", "inFlation", "uninflute", "infolate", "informase", "inflame", "infolocate", "infloation", " informase", "uninfloocate", " informate", "infloame", "infloute", "inflocate", "uninflame", " inflation", "inFlATE", " inflase", "inflATE", " informATE", "uninflate"], "pxlen": ["nplin", "pyln", "pxlf", "fxlen", "pngden", "xyfin", "pyden", "pxden", "fxden", "rxfin", "xplength", "xplen", "fxval", "pglf", "xylen", "pyl", "xpval", "cpden", "fxlf", "pxlin", "pxLen", "rxlen", "pylen", "pngln", "pplen", "fxl", "cpln", "pngLen", "rxlin", "nplen", "npden", "xyden", "fxlength", "ppden", "pxval", "pxfin", "pxl", "ppln", "npfin", "rxden", "xyLen", "xylin", "fxln", "pxlength", "xplf", "pxln", "pglen", "cplen", "pnglen", "cpl", "xyln", "ppLen", "pglength", "pgval"], "out": ["session", "dump", "prefix", "OUT", "re", "user", "point", "output", "line", "server", "cli", "lib", "list", "group", "parent", "store", "lock", "Out", "base", "v", "conn", "error", "page", "gen", "err", "inter", "io", "code", "up", "obj", "step", "print", "outs", "work", "cache", "log", "post", "copy", "sys", "again"]}}
{"id1": "11475527", "id2": "9327525", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    @Test\n    public void test02_ok() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(chartURL);\n            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);\n            nameValuePairs.add(new BasicNameValuePair(\"ws\", \"getDomainEvolution\"));\n            nameValuePairs.add(new BasicNameValuePair(\"chartTitle\", \"test\"));\n            nameValuePairs.add(new BasicNameValuePair(\"type\", \"chart\"));\n            nameValuePairs.add(new BasicNameValuePair(\"firstDate\", \"20111124\"));\n            nameValuePairs.add(new BasicNameValuePair(\"lastDate\", \"20111125\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParams\", \"type,counting,protocol,unit,proxy,domain,timeScale,period\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParamsValues\", \"chart,volume,all,hits,all,google.com,day,360\"));\n            nameValuePairs.add(new BasicNameValuePair(\"serieTitle\", \"serie\"));\n            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            assertNotNull(entity);\n            InputStream instream = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream));\n            System.out.println(reader.readLine());\n            instream.close();\n            assertEquals(\"error :\" + response.getStatusLine(), 200, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"theurl": ["thepublic", " thejob", "theUrl", "thatURL", "testURL", "THEURL", " theURL", " Thepublic", "THEpublic", "myurl", "testfile", "THEUrl", "thejob", "thatUrl", "thaturl", "thefile", "myUrl", " TheUrl", "testurl", "testUrl", " thepublic", " Theurl", " Thejob", "THEurl", " theUrl", "THEjob", "myURL", "myfile", "THEfile", "theURL"], "line": ["number", "cl", "f", "sync", "next", "row", "lines", "string", "source", "i", "no", "lc", "feed", "LINE", "str", "entry", "pe", "character", "ine", "el", "cell", "len", "text", "base", "block", "file", "url", "lin", "part", "reader", "inline", "connection", "char", "comment", "style", "buffer", "unit", "Line", "code", "name", "write", "le", "sel", "l", "link", "pass", "log", "key", "li", "out", "object", "e", "id"], "in": ["a", "it", "serv", "isin", "socket", "inn", "string", "source", "i", "ssl", "is", "input", "arin", "init", "fa", "din", "url", "lin", "file", "reader", "conn", "rin", "ins", "bin", "m", "into", "err", "inner", "io", "client", "b", "inside", "ilo", "or", "l", "win", "In", "pass", "stream", "cin", "inc", "IN", "include", "nin", "ini", "r", "record", "login", "out", "again", "pin"], "data": ["loader", "f", "next", "d", "lines", "source", "i", "da", "output", "handler", "valid", "read", "entry", "di", "iter", "input", "writer", "file", "url", "reader", "er", "one", "connection", "inner", "buffer", "open", "up", "client", "result", "l", "ata", "stream", "start", "DATA", "body", "r", "like", "out", "info", "la", "dat"]}}
{"id1": "17791385", "id2": "5125848", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"src": ["inst", "inf", "filename", "st", "rb", "uri", "sb", "source", "resource", "upload", "sin", "http", "sl", "input", "dist", "dest", "txt", "sup", "file", "url", "sc", "ins", "img", "ls", "files", "s", "image", "obj", "b", "sit", "sel", "rc", "stream", "loc", "config", "ipl", "back"], "dst": ["dsts", "fdfd", "pdft", "pdst", "dfd", "Dsts", "ddfd", "ddsp", "stst", "stlt", "Dst", " dlt", "dft", "stdest", "fdst", "pdsp", "dlt", "fdsp", "Ddest", "fdft", "pdfd", "ddft", " ddest", "ddest", "ststs", "ddst", "dsp", " dsts", "Dlt"], "in": ["gin", "f", "data", "socket", "inn", "i", "ln", "con", "sin", "is", "input", "init", "kin", "din", "conn", "lin", "url", "rin", "reader", "file", "ins", "impl", "bin", "m", "err", "inner", "inside", "as", "win", "In", "n", "cin", "inc", "IN", "nin", "ini", "r", "login", "h", "again", "oin", "pin", "pull", "id"], "out": ["ext", "f", "sync", "x", "OUT", "other", "i", "output", "off", "line", "server", "writer", "parent", "Out", "raw", "conn", "file", "plain", "part", "w", "temp", "bin", "exp", "err", "net", "io", "s", "self", "up", "obj", "client", "o", "exec", "outs", "outer", "n", "at", "inc", "post", "cache", "ex", "copy", "again", "null"], "buf": ["queue", "ctx", "length", "bl", "cat", "rb", "data", "bh", "bb", "wb", "pad", "bc", "off", "buff", "fb", "seq", "ff", "base", "bf", "raw", "v", "vec", "fd", "lim", "bin", "cb", "bd", "buffer", "br", "batch", "cmd", "bytes", "b", "c", "rc", "uf", "cur", "loc", "cap", "val", "uc", "count", "fl", "bag"], "len": ["cl", "f", "length", "data", "no", "i", "lc", "end", "ln", "lt", "line", "ind", "sl", "el", "lf", "base", "nt", "lin", "fd", "part", "ix", "rev", "lim", "bin", "err", "name", "pos", "c", "le", "all", "en", "l", "size", "ll", "Len", "n", "fin", "split", "cap", "count", "val", "li", "fl"]}}
{"id1": "16550855", "id2": "3197876", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    public ArrayList<String> showTopLetters() {\n        int[] tempArray = new int[engCountLetters.length];\n        char[] tempArrayLetters = new char[abcEng.length];\n        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();\n        tempArray = engCountLetters.clone();\n        tempArrayLetters = abcEng.clone();\n        int tempCount;\n        char tempLetters;\n        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {\n            for (int i = 0; i < abcEng.length - 1; i++) {\n                if (tempArray[i] > tempArray[i + 1]) {\n                    tempCount = tempArray[i];\n                    tempLetters = tempArrayLetters[i];\n                    tempArray[i] = tempArray[i + 1];\n                    tempArrayLetters[i] = tempArrayLetters[i + 1];\n                    tempArray[i + 1] = tempCount;\n                    tempArrayLetters[i + 1] = tempLetters;\n                }\n            }\n        }\n        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {\n            resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]);\n        }\n        return resultTopFiveLetters;\n    }\n", "label": 0, "substitutes": {"ignoreComments": ["includecomments", "respectRules", "ignoreRules", " ignoreComment", "oreComments", " ignoreRules", "oreComment", "oreTags", "orecomments", " ignoreTags", "ignorecomments", " ignorecomments", "ignoreTags", "ignoreComment", "oreRules", "respectComments", "respectComment", "includeComments", "includeComment", "includeTags"], "in": ["loader", "gin", "f", "version", "re", "a", "serv", "data", "it", "isin", "socket", "inn", "ssl", "source", "i", "con", "t", "is", "input", "init", "rec", "min", "din", "url", "lin", "conn", "reader", "ins", "bin", "connection", "inner", "s", "buffer", "image", "client", "c", "b", "inside", "exec", "doc", "win", "index", "In", "stream", "inc", "ac", "IN", "nin", "ini", "r", "login", "h", "out", "again", "pin", "e", "id"], "inputLine": ["errorLink", "errorLine", "rawFile", "inputline", "formLine", "errorBlock", "outUrl", "inputName", " inputL", "outLine", "htmlline", "InputLine", "inputPass", "instanceLine", "inputUrl", "instancePass", "requestUrl", "InputLink", "inputLetter", "incLine", "formLink", "InputFile", " inputLink", "inputCode", "htmlLook", " inputBlock", "InputName", "InputLetter", "inputL", "inputLook", "errorPass", "rawline", "instanceLink", "outline", "incLetter", "htmlUrl", "requestL", "incName", "rawLink", "InputCode", " inputPass", " inputFile", "formL", "inputBlock", "rawLine", " inputLook", "htmlLine", " inputName", "requestLook", "errorL", "inputFile", "Inputline", " inputCode", "requestline", "incL", "instanceBlock", "formCode", " inputUrl", "requestLine", "outL", " inputLetter", "inputLink", "errorline", "InputL", " inputline"], "html": ["htm", "live", "template", "msg", "format", "data", "ui", "detail", "inline", "home", "web", "xml", "flash", "app", "links", "db", "str", "http", "war", "attr", "high", "text", "json", "tf", "atom", "bf", "blog", "url", "page", "plain", "part", "rss", "temp", "full", "img", "www", "dom", "css", "hard", "php", "strong", "sp", "header", "title", "up", "details", "ml", "browser", "doc", "link", "flat", "js", "frame", "tml", "body", "api", "tt", "summary", "https", "hot", "h", "fat", "HTML", "show", "message"]}}
{"id1": "5399593", "id2": "13414771", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"plaintext": ["aintext", "rainTEXT", " plainText", " plainform", "plaincontent", "raincontent", "plainform", "plainText", "foreTEXT", "singleText", "ainform", "singleTEXT", "foreText", "ainTEXT", " plainTEXT", "singleform", "singletext", "forecontent", "rainText", " plaincontent", "foretext", "plainTEXT", "raintext", "ainText"], "md": ["material", "nm", "d", "wd", "hm", "pm", "amd", "mad", "dc", "mage", "db", "sha", "mu", "mn", "meta", "mm", "am", "Cmd", "bf", "MD", "dd", "od", "mand", "ma", "mt", "m", "ms", " MD", "bd", "dig", "rm", "mb", "mg", "dm", "code", "cd", "cmd", "hed", "mod", "po", "sum", "hd", "me", "mac", "mag", "mp", "mc", "metadata", "mem", "mo", "map", "message"], "raw": ["aws", "unsigned", "RAW", "rew", "row", "wrap", "alpha", "hex", "empty", "flash", "ack", "micro", "blocks", "dec", "sign", "sha", "initial", "buf", "input", "unknown", "ng", "block", "array", "load", "full", "missing", "shared", "Raw", "buffer", "serial", "ghost", "original", "instance", "clean", "enc", "null", "message"], "hash": ["version", "Hash", "data", "ruby", "alpha", "string", "hex", "flash", "sh", "id", "sha", "password", "abi", "text", "html", "base", "block", "array", "url", "ashes", "hh", "secret", "shared", "image", "header", "code", "hed", "build", "ash", "sum", "ha", "kh", "cache", "mac", "log", "math", "key", "h", "auth", "rh", "message"]}}
{"id1": "18504192", "id2": "9550506", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    private String cookieString(String url, String ip) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update((url + \"&&\" + ip + \"&&\" + salt.toString()).getBytes());\n            java.math.BigInteger hash = new java.math.BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            filterConfig.getServletContext().log(this.getClass().getName() + \" error \" + e);\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"in": ["d", "data", "src", "inn", "i", "diff", "input", "parent", "base", "min", "file", "url", "reader", "part", "ins", "bin", "m", "inner", "io", "image", "buffer", "name", "c", "old", "b", "or", "In", "at", "inc", "ac", "IN", "ini", "copy", "index", "again", "info", "login", "id"], "out": ["target", "prefix", "OUT", "data", "point", "string", "output", "line", "password", "writer", "dest", "again", "Out", "base", "p", "file", "conn", "part", "w", "temp", "err", "connection", "call", "io", "name", "obj", "client", "o", "c", "b", "outs", "exec", "external", "n", "cache", "inc", "ex", "copy", "object"], "source": ["target", "sync", "core", "src", "ie", "service", "ssl", "from", "i", "origin", "sin", "ources", "SOURCE", "slice", "server", "iter", "sl", "project", "input", "writer", "dest", "parent", "secure", "se", "reader", "scope", "connection", "slave", "get", "unit", "self", "storage", "channel", "clone", "client", "settings", "component", "size", "stream", "start", "view", "Source", "ource", "copy", "use", "proxy", "null"], "destination": ["dependination", "contining", "Destinator", "Destinations", " destining", " destinations", "testinations", "destinations", "declination", "destinated", "Destination", "testinated", "dependinated", "Destinated", "declification", "testination", "dependinator", "declinator", "Destining", "continator", "dependification", "Destification", "declinated", "contination", "destification", "testinator", "destinator", " destinator", "destining", "continated", " destinated"]}}
{"id1": "22135199", "id2": "16215393", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"baos": ["baops", "paOS", "baoS", " baOS", " baops", "caos", "waos", "yaoS", "kaols", "paos", "aaaao", " baoS", "yaol", " baol", "baOs", "pao", "caOs", "kao", "baols", "kaos", "paols", " bao", "waOS", "waOs", "bao", "aaaaOs", "aaaaOS", "paol", "aaaaos", "paoS", " baols", "caOS", "yaops", "wao", "paops", "baol", "yaos", "baOS", "kaOS", "cao"], "channel": ["system", "queue", "video", "data", "socket", "service", "source", "flow", "container", "feed", "handler", "server", "console", "context", "window", "parent", "can", "conn", "url", "sc", "reader", "annels", "connection", "io", "cam", "chan", "self", "Channel", "client", "c", "camera", "cho", "en", "stream", "log", "pool", "ch", "config", "out", "sea", "bean"], "params": ["ctx", " parameters", "Parameters", "stats", "http", "param", "conf", " param", "par", "mm", "processor", "conn", "ams", "css", "tx", "cms", "ops", "settings", "proc", "size", "Param", "parser", "api", "config", "Par", "null", "options", "cpu"], "outbuf": ["outputrb", "Outbuffer", "outbuffer", " outcb", "outqueue", "outputbuff", "Outbuf", " outbuff", "Outcb", "iobuf", " outrb", "outputcb", "outputbuf", "outputqueue", " outbuffer", "outputbuffer", " outqueue", "outbuff", "Outbuff", "ioqueue", "iobuffer", "outcb", "outrb", "iorb"], "metrics": ["Metrates", "metrix", "matrics", "milstats", "matrates", "metstats", "matric", "matrix", "Metstats", "Metrics", "milric", " metstats", "metric", "milrics", "milrix", "Metric", "Metrix", " metrates", " metrix", "metrates", " metric"], "encoder": ["ecoded", "ecoder", "ecressor", "encressor", " encressor", "encler", "ecode", "eccode", "ecler", "Encipher", "encipher", "encode", "encoded", " encoded", "ecoser", "Encoding", "enoder", "enccode", "ecoding", "enressor", " encler", "Encoded", "enoser", " encode", " encoding", " encipher", "enoded", "Encler", " enccode", "encoser", "Encoder", "enode", "encoding", "ecipher", " encoser", "Encoser", "Encode"], "tmpFile": [" tmpfile", "zipFilename", "txtBase", "tmpFiles", "tempFile", "TempPage", "mpBase", "tmpFolder", "poFolder", " temporaryFiles", " tmpFiles", " tmpFilename", "tmpfile", " tmpFolder", " temporaryfile", " temporaryFile", " tmpTable", "txtfile", "tmpPath", "tempFiles", "txtFile", "mpFiles", "zipfile", "mpPage", "mpFile", "tmpTable", "tmpFilename", "mpPath", "poFile", "zipFolder", "pofile", "tempPath", "TempFile", "tmpBase", " temporaryTable", "zipFile", "txtPage", "poFilename", "tempfile", "tmpPage", "TempBase", "Tempfile", " tmpPath", "tempTable", "mpfile"], "fout": ["Fin", "sfout", "sfin", "filein", "Fout", "fdagain", "sfbase", "flsync", "fdsync", "fileout", "fileagain", "fbase", "Fbase", "wflush", "wsync", "fagain", "sfagain", "flout", "wagain", "fin", "Fagain", "fflush", "flflush", "fsync", "wout", "fdflush", "flagain", "filebase", "fdout"], "wrtout": ["wadrout", " wrcout", " wrcin", "Wrtio", "wadrin", " wrtagain", " wrcagain", "wrbwriter", "WRTouter", "wRTagain", "wrtwriter", "wntagain", "wRTouter", "wrcouter", "Wrtin", "wrtouter", "wrtOut", "wntouter", "WRTwriter", "wrxout", "wntin", "wrxin", "wrio", "wrtio", "WRTOut", " wrtouter", "wrout", "wrcin", "wrin", "WRTout", "wRTOut", "wadrOut", "WrtOut", "Wrtouter", "wrtagain", "wRTwriter", "wrbin", "Wrtwriter", "wrOut", " wrtin", " wrcouter", "wrcagain", "Wrtout", "wrcout", "wntout", "wrxouter", "wrbout", "wrbouter", "wRTout", "WRTin", "WRTio", "wrxwriter", "wadrio", "wrtin", "wRTin", "wRTio"], "fchannel": ["fqueue", "hqueue", "pqueue", "hchannel", "fchan", "lchannel", "cstream", "lstream", "cqueue", "pstream", "lcontainer", "pchannel", "cchan", "lqueue", "dchannel", "fstream", "hcontainer", "pchan", "hstream", "fcontainer", "cchannel", "dqueue", "dstream", "dchan", "dcontainer"], "s": ["states", "S", "f", "d", "g", "ses", "string", "abs", "i", "es", "sb", "t", "ings", "groups", "p", "os", "v", "ns", "gs", "u", "ls", "ins", "m", "ms", "qs", "services", "o", "b", "c", "su", "settings", "ss", "ps", "l", "ts", "n", "js", "strings", "r"]}}
{"id1": "14001795", "id2": "15799935", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "label": 1, "substitutes": {"dir": ["ir", "d", "re", "dr", "data", "wd", "home", "container", "div", "dc", "director", "DIR", "handler", "db", "feed", "http", "draft", "di", "zip", "lib", "class", "group", "dist", "desc", "folder", "pkg", "store", "lock", "window", "parent", "url", "file", "fd", "handle", "keep", "directory", " directory", "manager", "io", "up", "cd", "md", "Dir", "build", "download", "direct", "doc", "df", "cache", "work", "log", "cur", "dn", "loc", "def", "clean", "r", "local", "config", "direction", "coll"], "ff": ["cl", "iff", "fed", "bb", "cf", "ck", "fox", "upp", "sf", "uff", "ffe", "flow", "feed", "eff", "ft", "fx", "off", "fb", "pp", "buff", "lf", "bf", "front", "fam", "fp", "dd", "fd", " buff", "cb", "now", "FF", "ffff", "rf", "fff", "aff", "uf", "ph", "df", "fw", "ef", "xff", "fold", "TF", "fe", "fl"], "files": ["data", "features", "lines", "blocks", "pes", "balls", "groups", "iles", "items", "flows", "rows", "file", "events", "ls", "pl", "apps", "Files", "qs", "results", "s", "users", "objects", "pages", "l", "ps", "keys", "models", "images", "split", "fl", "names", "fs", "locks"], "f": [" df", "inf", "d", "cf", "i", "sf", " file", "feed", " fa", "fr", " F", "t", "fb", " fe", "fc", "lf", "File", "F", "fa", "tf", "p", "bf", "fp", "file", "v", "fd", "full", "fen", "of", "name", "fac", "info", "rf", "o", "c", "aff", "l", "n", "fold", "fn", "fe", "r", "fl", " e", "fs", "e"], "newFile": ["createfile", "updateF", " newFiles", "oldfile", "againLine", "createFiles", "newLine", "oldFiles", " newFolder", "andFolder", "updateLine", "createFile", "createFolder", "againEntity", "oldFile", "NewFile", "andFiles", "updateFile", "oldFolder", "NewFiles", "NewFolder", "updateEntity", " newF", " newEntity", "newFiles", "andFile", "Newfile", " newLine", "newFolder", "againFile", "andfile", "newEntity", "newfile", " newfile", "againF", "newF"], "fi": ["cci", "afa", "afe", "ifi", "cf", "gif", "bi", "i", "sf", "ffe", "gi", "uci", "FI", "fr", "aci", "afi", "di", "fb", "ki", "fc", "abi", "fa", "pi", "xi", "zi", "ico", "ifa", "flo", "fp", "ilia", "Fi", "wi", "ii", "sci", "fw", "isi", "si", "vi", "ini", "fe", "fy", "info"], "fo": ["wo", "osa", "afe", "inf", "olo", "ato", "cf", "sf", "ofi", "xf", "di", "afi", "ki", "fa", "flo", "ico", "os", "jo", "fam", "shi", "fif", "zo", "io", "ho", "ko", "info", "o", "FO", "po", "uf", "bo", "ph", "fw", "si", "lo", "osi", "fe", "so", "obi", "mo"]}}
{"id1": "3187685", "id2": "4750967", "code1": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"src": ["inst", "filename", "st", "rb", "core", "uri", "ssl", "sb", "source", "resource", "upload", "path", "sub", "host", "sl", "buf", "input", "dist", "dest", "url", "file", "sc", "img", "ls", "files", "s", "image", "storage", "archive", "obj", "b", "sit", "sq", "sel", "rs", "rc", "l", "download", "stream", "loc", "uc", "config"], "dst": ["dsts", "odsts", "fsts", "ldst", "edput", " ddr", "ddr", "edst", "odput", "ldsts", "dset", " dput", "edsts", "odset", "eddr", "odst", "ldput", " dset", "dput", "fst", "lddr", "fput", " dsts", "fset"], "srcChannel": ["instPage", "sourceChan", "srcConnection", "sslContext", "instChannel", " srcClient", " srcPage", " srcchannel", "rcContext", "instChan", "rcChannel", "sourceContext", "sourcePage", " srcChan", "rcConnection", "rcClient", "sourceConnection", "srcSocket", "rcSocket", "sslChannel", " srcConnection", "destClient", "sslSocket", "srcContext", "srcChan", "destChan", "sslChan", "destConnection", "sourcechannel", " srcContext", "srcPage", "rcChan", "instConnection", "destChannel", "srcchannel", "rcchannel", " srcSocket", "srcClient", "sourceChannel"], "dstChannel": ["dstChan", "ddestChan", "dstsConnection", "dostchannel", "DstChan", "DstConnection", "dstchannel", "DdestChannel", "drestChan", "DestChan", " dstchannel", "dspchannel", "Destchannel", "dstsStream", "dstsChannel", "dostChannel", "drdChan", " drdchannel", " drdChan", "dstsChan", " dstStream", "dstStream", "drestStream", "dstschannel", "ddestchannel", "DstChannel", "drestChannel", "drdStream", "dstConnection", "Ddestchannel", "destchannel", "ddestConnection", " drdStream", "destChan", "dspChannel", "ddestChannel", "dspChan", "destConnection", "DdestConnection", " drdChannel", "DestChannel", "DdestChan", "drdchannel", "DestConnection", "dspConnection", "Dstchannel", "drdChannel", "drestchannel", " dstChan", "destChannel", "dostChan"]}}
{"id1": "17683082", "id2": "22338097", "code1": "    HttpRepository(Path path) throws IOException {\n        super(path);\n        this.url = new URL(path.toURLString());\n        HttpURLConnection.setFollowRedirects(true);\n        this.connection = (HttpURLConnection) url.openConnection();\n        this.ns = Names.getNamespace(path);\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 0, "substitutes": {"IOException": ["IPception", "IPException", "IPError", "IOError", " URIError", " IOception", " URIception", " URIException", " IOError", "IOception"], "url": ["address", "bug", "ref", "socket", "uri", "user", "service", "ssl", "source", "resource", "web", "path", "feed", "host", "server", "http", "access", "sl", "URL", "this", "base", "file", "page", "conn", "impl", "manager", "location", "image", "client", "channel", "job", "build", "link", "l", "Url", "cache", "log", "loc", "config"], "connection": ["application", "loader", "Connection", "wrapper", "version", "socket", "uri", "service", "resource", "handler", "response", "server", "context", "function", "database", "file", "reader", "directory", "manager", "location", "collection", "client", "channel", "relation", "link", "position", "config", "index"], "ns": ["cs", "prefix", "lines", "domain", "cn", "db", "str", "ds", " namespace", "nc", "os", "conn", "params", "ls", "scope", "ms", "net", "ws", "obj", "space", "pos", "NS", "ss", "ps", "n", "object", "names", "fs"]}}
{"id1": "4686922", "id2": "20619879", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"resourcePath": [" resourceId", " resourceUrl", "stringpath", "sourcePath", "resourceFolder", " resourceFolder", "sourcepath", "servicepath", "ResourceUrl", "resourceUrl", "servicePath", "sourceId", "sourceUrl", "ResourcePath", "Resourcepath", "stringFolder", "resourceId", "ResourceId", " resourcepath", "stringPath", "resourcepath", "serviceFolder"], "dest": ["target", " Dest", "filename", "data", "content", "src", "home", "source", "resource", "sac", "wb", "Dest", "path", "output", "const", "resources", "tmp", "comb", "project", " destination", "class", "dist", "desc", "store", "folder", "txt", "sup", "file", "destroy", "transfer", "die", "prop", "temp", "img", "de", "contract", "default", "done", "later", "route", "result", "trans", "flat", "config"], "in": ["gin", "f", "re", "isin", "socket", "inn", "source", "i", "resource", "thin", "con", "sin", "plus", "is", "input", "arin", "init", "this", "rec", "kin", "din", "conn", "file", "lin", "reader", "rin", "url", "ins", "bin", "connection", "inner", "image", "up", "c", "b", "as", "inside", "win", "In", "pass", "n", "inc", "cin", "IN", "nin", "ini", "r", "like", "login", "again", "id"], "out": ["ext", "f", "sync", "OUT", "a", "user", "socket", "source", "i", "app", "output", "off", "server", "cos", "ax", "lib", "writer", "this", "parent", "Out", "conn", "file", "co", "w", "ins", "temp", "bin", "boot", "one", "err", "net", "io", "s", "image", "up", "client", "obj", "o", "b", "outside", "outs", "exec", "all", "outer", "In", "n", "at", "inc", "cache", "norm", "cookie", "auto", "ex", "copy", "again", "null"]}}
{"id1": "15051083", "id2": "23118425", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"digest": ["signesting", "greatested", " Diger", "Digiter", "greatester", " digEST", "digEST", "Digeter", " digger", " Digger", "Dighed", "digger", "diger", " Dighed", "sandested", " digested", "digests", "hexEST", "Digested", "Digex", " Digest", "signiter", "feedested", " digeter", "signest", " Digester", "Digester", "greatest", "sandest", "digester", " Digeter", "hexex", "signester", "signested", " digester", "digesting", "dighed", " digests", "greatiter", "Digests", "hexests", "DigEST", " diger", "digested", "hexest", "sandesting", "digex", "Digesting", "Digger", "sandester", "feedester", "Diger", "digeter", " dighed", "feedest", "digiter", " digex", "Digest"], "node": ["address", "internal", "child", "odes", "point", "uri", "source", "remote", "document", "resource", "path", " annotation", " parent", "server", " Node", " namespace", "parent", "entity", "root", " nodes", "event", " child", "network", "one", "location", "object", "connection", "element", "self", "module", "Node", "name", " source", "route", "instance", "component", "n", "local", "config", "index", "ode", "global"], "external": ["target", " External", "account", "secondary", "internal", "reference", "source", "remote", "resource", "ternal", "Intern", "tern", "intern", " global", "binary", "External", " foreign", "multiple", "export", "environment", "network", "element", "foreign", "name", "international", "client", "outside", "instance", "outer", " remote", "n", "local", "https", "ex", "out", "object", "global", "e"], "messageDigest": ["messageDesignested", "messageDigester", "MessageSignenge", "MessageSignester", "messageMarkester", "messageDested", "messagedigester", "messageDigenge", "messageDester", "messageHashested", "messageSignester", "messageMarkenge", "messageSignested", "messagedigger", "messageSignest", "messageMarkested", "messageHashesting", "messageModested", "messageModester", " messageDesignger", "messageSignenge", " messageHashester", " messageDigesting", " messageDesignested", " messageDesignest", "MessageDigenge", "messageHashest", "messageDenge", "messageMarkest", " messageHashested", " messageHashesting", "MessageSignest", "MessageDigest", "messageDesignesting", " messageHashest", " messageDigester", "messageDesignest", " messageDesignester", "messageModest", "messageDesignger", "messagedigest", " messageDigested", "MessageSignested", " messageDigger", "messageModesting", "messageDigesting", "messagedigested", "MessageDigested", "messageHashester", "messageDigested", "messageDigger", "messageDesignester", "messageDest", "MessageDigester"]}}
{"id1": "20091126", "id2": "6403868", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"in": ["f", "a", "data", "source", "i", "ic", "diff", "input", "base", "query", "min", "url", "file", "lin", "reader", "part", "ins", "bin", "m", "connection", "inner", "image", "buffer", "name", "b", "old", "or", "l", "In", "work", "inc", "ac", "IN", "config", "index", "again", "login", "id"], "out": ["ext", "target", "dot", "prefix", "OUT", "x", "a", "data", "content", "point", "string", "source", "i", "output", "off", "server", "parent", "Out", "base", "p", "value", "array", "v", "file", "page", "plain", "url", "temp", "object", "exp", "call", "err", "comment", "io", "image", "buffer", "default", "name", "channel", "o", "c", "outs", "exec", "write", "result", "external", "cache", "ex", "copy", "again"], "inChannel": ["outStream", "inputGate", " inClient", "inputchannel", "iniChannel", "inChan", "inClient", "inputChannel", "inButton", "INButton", "inputStream", " inChan", "iniGate", "iniStream", "outchannel", " inStream", "outChan", "INClient", "winChannel", "insStream", "winchannel", " inchannel", "insClient", "inchannel", "INGate", "INChannel", " inButton", "inputButton", "insChannel", "INChan", "inputChan", "inStream", "winChan", "outButton", "winStream", "INStream", "inGate", "iniChan", "INchannel", "insChan"], "outChannel": ["outStream", "OutClient", "outContext", "OutChan", "inChan", "inClient", "OutChannel", "OutContext", "OutStream", "outputClient", "inContext", "outchannel", "outChan", " outContext", "outConnection", " outchannel", " outChan", " outConnection", "inConnection", " outStream", "inchannel", "outsStream", "outputStream", "outputChannel", "outputchannel", "inStream", "outsChannel", "outsConnection", "outClient", "outsChan", "outputChan", "Outchannel"]}}
{"id1": "7761195", "id2": "12744653", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"plaintext": [" plainsource", "protecteddata", " plainstruct", "battext", " plainText", " plainletter", "batsource", "plainText", " plaindata", "prestruct", "protectedtext", "plainstruct", "protectedstruct", "predata", "foreText", "batText", "protectedText", "foresource", "batletter", "plainletter", "foreletter", "pretext", "preText", "foretext", "plaindata", "plainsource"], "sb": ["abb", "pb", "nb", "rb", "bh", "gb", "bb", "sf", "BG", "db", "BB", "erb", "bs", "bf", "sg", "bm", "sam", "bp", "SB", "cb", "mb", " SB", "sq", "gc", "ss", "sv", "si", "kB", "bg"], "md": ["cm", "nm", "pd", "d", "dh", "dr", "sm", "wd", "hm", "pm", "gd", "ad", "amd", "mad", "dc", "sha", "mu", "meta", "mm", "Cmd", "MD", "dd", "od", "mand", "M", "ma", "mt", "de", "cb", "m", "ms", " MD", "bd", "dig", "rm", "mb", "mg", "vd", "dm", "cd", "cmd", "mod", "hd", "df", "mac", "mag", "mp", "mc", "ld", "mo", "metadata"], "raw": ["unsigned", "RAW", "data", "row", "words", "hex", "wave", "empty", "ack", "output", "feed", "dec", "response", "valid", "initial", "buf", "input", "unknown", "text", "ng", "json", "load", "array", "block", "full", "missing", "shared", "Raw", "buffer", "image", "serial", "original", "bytes", "pack", "instance", "rc", "stream", "clean", "enc", "null", "message"], "hash": ["version", "Hash", "data", "ref", "hex", "flash", "sh", "sha", "message", "abi", "text", "html", "base", "block", "array", "url", "num", "ashes", "secret", "alt", "image", "dig", "buffer", "header", "code", "her", "pack", "ash", "sum", "ha", "kh", "cache", "mac", "log", "key", "h", "rh", "id"]}}
{"id1": "14783950", "id2": "9096314", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                log.warn(\"\\'\" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" ignored - table already  has an open record \");\n            } else {\n                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());\n                long outageID = -1;\n                ResultSet seqRS = getNextOutageIdStmt.executeQuery();\n                if (seqRS.next()) {\n                    outageID = seqRS.getLong(1);\n                }\n                seqRS.close();\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement newOutageWriter = null;\n                if (log.isDebugEnabled()) log.debug(\"handleNodeLostService: creating new outage entry...\");\n                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);\n                newOutageWriter.setLong(1, outageID);\n                newOutageWriter.setLong(2, eventID);\n                newOutageWriter.setLong(3, nodeID);\n                newOutageWriter.setString(4, ipAddr);\n                newOutageWriter.setLong(5, serviceID);\n                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));\n                newOutageWriter.executeUpdate();\n                newOutageWriter.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeLostService : \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" recorded in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            }\n        } catch (SQLException sqle) {\n            log.warn(\"SQL exception while handling \\'nodeLostService\\'\", sqle);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"fileList": ["FileStream", "filelist", " fileCollection", "modelEx", "modelCollection", "fileChain", "ziplist", " fileSet", "fileEx", "FileChain", "stringChain", "FileSet", "stringlist", "wordName", "inputStream", "FileName", "FileList", " fileStream", "Filelist", "fileStream", "fileSet", "fileCollection", "wordStream", "modelStream", "wordString", "inputList", "fileString", "zipList", "wordList", "FileString", "inputCollection", "stringList", " fileString", "zipName", " filelist", "modelList", "inputEx", "zipSet", " fileEx", "stringName", " fileChain"], "zipFileName": ["zipFilename", "archiveDirPath", "folderFilePath", "zipFileDir", "zipGlobalPath", "folderGlobalPath", "zipFullNames", "folderFileName", "zipGlobalNames", "zipFullDir", "zipPackageDir", "zipGlobalName", "folderGlobalNames", "zipFullName", "archiveFileDir", "zipFilePath", "zipDirDir", "folderGlobalname", "zipDirname", "archiveDirDir", "zipFullPath", "folderGlobalName", "zipGlobalname", "zipDirPath", "folderFileNames", "archiveFileName", "folderFilename", "archiveDirName", "zipFullname", "zipDirName", "zipPackageName", "zipFileNames", "archiveFilePath", "zipDirNames", "zipPackagePath"], "fos": ["Fos", "FoS", "faos", " fosh", "afis", "Fis", "flos", "fosh", "infoS", "afaos", "afos", "infaos", "flis", "foS", "Fosh", "afoS", "infos", "infis", "flosh", "Faos"], "zos": ["tz", "phi", "bos", "nz", "budget", "ses", "ozo", "lins", "LOS", "es", "zen", "inos", "zz", "zik", "zers", "cos", "zb", "zag", "ZA", "zip", "bag", "z", "zar", "abi", "zl", "onz", "zer", "zy", "zi", "jobs", "webkit", "os", "obb", "jas", "fits", "zo", "dos", "zzy", "closure", "zon", "css", "zx", "gz", "bis", "bes", "oses", "lol", "outs", "rez", "fi", "kos", "ros", "iframe", "zan", "uz", "chini", "seconds", "loop", "osi", "packs", "spin", "zes", "ZI"], "iter": ["walker", "ir", "itter", "f", "next", "it", "ener", "cher", "fer", "gener", "ie", "parse", "i", "former", "end", "slice", "http", "fr", "is", "iner", "iterator", "list", "ator", "el", "ite", "file", "chain", "keep", "er", "izer", "inter", "ter", "err", "sort", "inner", "finder", "ip", "liter", "Iterator", "inse", "set", "order", "Iter", "outer", "inc", "oper", "iz", "loc", "test", "upper", "ner", "ser", "index", "coll", "enter", "e"], "fileName": ["fullName", "FilePart", "filename", " fileInfo", "fullOpen", "FilePath", "fileInfo", "pageString", "Filename", "localPart", "filePath", "fLine", "filenamename", "fileFull", " fileType", "FileName", "filenameInfo", " fileUrl", "FileUrl", "simpleOpen", "pageName", "FileData", " fileData", "simplePath", "FileLine", " fileLine", "fPart", "filenameFull", "filePart", "currentname", "fileString", "fileOpen", " filePath", "localname", "fileData", "filenameName", "currentUrl", "FileFull", "FileString", "fname", " filePart", " fileString", "fileUrl", "currentData", "simpleName", "currentName", " fileOpen", "pageType", "fullPath", " fileFull", " filename", "fileType", "fileLine", "fName", "localName", "pagename", "localPath", "FileType", "FileInfo"], "ind": ["bind", "length", "x", "d", "pull", "cond", "ad", "inn", "i", "ci", "end", "div", "mid", "eff", "fr", "ord", "z", "len", "ded", "Ind", "vert", "ix", "in", "rib", "ii", "dir", "pos", "j", "pend", "nd", "start", "inc", "pt", "loc", "val", "count", "ld", "index", "wind", "IND", "mind", "id"], "shortName": ["fullName", "longPath", " shortString", "smallname", "longName", "shortString", "smallPath", "longPart", "fullString", " shortname", "Shortname", "shortPath", "longname", "fullname", "ShortName", "shortname", "ShortPath", " shortPath", " shortLine", "smallPart", "ShortString", "shortLine", "shortPart", "fullLine", "fullPath", "ShortPart", "longLine", "smallName"], "fis": ["Fos", " fisa", "gisa", " fris", " fs", "gios", "fris", "cfris", "afis", "Fis", " fiss", "pios", " fios", "afiss", "fios", "cfis", "pisa", "Fs", "afos", "pris", "fisa", "gris", "cfiss", "fiss", "cfos", "afris", "Fiss", "cfs", "pis", "fs", "gis"], "buf": ["queue", "ba", "pb", "bl", "bh", "rb", "data", "feat", "bb", "wb", "bc", "tmp", "buff", "fb", "bu", "grab", "cv", "seq", "ff", "lb", "bf", "v", "vec", "fd", "bp", "lim", "bin", "cb", "Buff", "box", "bd", "buffer", "br", "done", "batch", "b", "bytes", "rc", "uf", "cur", "loc", "uc", "bag", "la"], "bytesRead": ["bytesWrite", "secondsRead", "flowsLength", "wordsLength", "wordsWrite", "flowsRead", "tesRead", "wordsUse", "tesWrite", "secondsLength", "flowsNeed", "bytesSkip", " bytesLoad", "bitsLoad", " bytesWrite", "tesLoad", "secondsWrite", "bitsLength", "bytesLength", " bytesSkip", "bytesLoad", "bitsRead", "bitsSkip", "secondsNeed", "bitsWrite", "bytesUse", " bytesNeed", "bytesNeed", "tesSkip", " bytesLength", "wordsRead", "flowsWrite", " bytesUse", "bitsUse"]}}
{"id1": "3558512", "id2": "6988216", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "label": 1, "substitutes": {"out": ["loader", "dump", "filename", "OUT", "a", "data", "content", "string", "source", "i", "output", "server", "writer", "parent", "Out", "raw", "file", "conn", "page", "temp", "w", "bin", "gen", "err", "io", "buffer", "image", "name", "up", "archive", "obj", "client", "o", "outs", "exec", "cache", "pool", "report", "ex", "copy", "png"], "parser": ["loader", "system", "wrapper", "pillar", "plugin", "lp", "Parser", "parse", "xml", "builder", "upload", "per", "handler", "server", "pe", "pp", "writer", "class", "cp", "pkg", "parent", "base", "p", "txt", "processor", "file", "reader", "php", "er", "arser", "worker", "manager", "seed", "rar", "up", "as", "instance", "ss", "cache", "test", "tt", "copy", "master"], "on_disk": ["onnetdemand", "onbootlock", "on_demand", "on_storage", "onjspace", "onjdrive", "onnetdrive", "onJdisk", "off_delete", "onnetfile", "onnetdisk", "off_demand", "onbookdelete", "onJlock", "off_space", "off_drive", "off_file", "onjdisk", "onbootdisk", "off_storage", "on_space", "onjfile", "on_file", "off_disk", "on_lock", "on_delete", "onbookdisk", "onbootstorage", "onJdrive", "on_drive", "onbookdrive", "off_lock", "onnetspace", "onbootdrive", "onJdemand"], "in": ["f", "data", "socket", "inn", "source", "i", "thin", "con", "ax", "input", "inas", "kin", "min", "din", "file", "conn", "lin", "reader", "rin", "ins", "bin", "connection", "inner", "o", "c", "as", "win", "In", "stream", "pass", "inc", "ac", "IN", "ini", "r", "copy", "login", "again", "info", "pin"]}}
{"id1": "21182766", "id2": "3024992", "code1": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 0, "substitutes": {"propsName": ["pepertiesNames", "propertiesNames", "profsPath", "comppsName", "propertiesName", "proPSNames", "comppertiesDesc", "propertiesPath", "proPSName", "propsNames", "propsname", "proPSPath", "profsDesc", "pepertiesPath", "pepsname", "profsName", "propertiesDesc", "profsname", "pepsNames", "comppsDesc", "pepertiesname", "profsNames", "comppsPath", "comppertiesname", "propertiesname", "proPSDesc", "proPSname", "comppertiesName", "propsDesc", "propsPath", "comppertiesPath", "pepsPath", "pepsName", "pepertiesName", "comppsname"], "props": ["prots", "comppos", "compbs", "crops", "perbs", "prperties", "prets", "protpps", "pets", "cropr", "probs", "compds", "pripos", "prps", "protps", "cropps", "Prots", "Probs", "propps", "prids", "prips", "properties", "prpr", "prpps", "propos", "peps", "Props", "prods", "Procs", "protperties", "prebs", "compps", "perpos", "protpr", "precs", "pebs", "procs", "pecs", "perds", "perps", "croperties", "pribs", "preps", "propr"], "url": ["loader", "cl", "f", "bel", "data", "ref", "jar", "uri", "src", "service", "ssl", "user", "source", "i", "resource", "xml", "path", "feed", "server", "http", "sl", "URL", "base", "load", "event", "file", "page", "gl", "location", "buffer", "name", "channel", "b", "not", "browser", "l", "stream", "Url", "api", "r", "ob", "config", "fl", "e", "id"]}}
{"id1": "5551393", "id2": "1862616", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public static String fetch(String reference) throws IOException {\n        URL url = new URL(reference);\n        HttpURLConnection c = (HttpURLConnection) url.openConnection();\n        c.setRequestMethod(\"GET\");\n        c.setDoOutput(true);\n        c.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\");\n        return parseISToString(c.getInputStream());\n    }\n", "label": 0, "substitutes": {"source": ["target", "address", "length", "template", "data", "content", "sm", "src", "service", "string", "proxy", "resource", "output", "SOURCE", "slice", "input", "text", "dest", "secure", "base", "file", "url", "expected", "temp", "security", "style", "unit", "seed", "buffer", "code", "name", "bytes", "result", "size", "start", "Source", "ource", "config", "object", "info", "message"], "tmp": ["nm", "rb", "data", "src", "emp", "vm", "sb", "output", "ignore", "stuff", "zip", "buf", "binary", "dest", "meta", "html", "txt", "bf", "array", "fp", "params", "part", "foo", "temp", "var", "vt", "cb", "buffer", "cpp", "storage", "code", "py", "obj", "b", "result", "cache", "cmp", "test", "current", "mp", "body", "tt", "copy", "Temp", "default", "metadata"], "md": ["cm", "nm", "pd", "d", "wd", "ad", "pm", "gd", "amd", "mad", "rpm", "ind", "editor", "mu", "di", "zip", "mn", "meta", "mm", "bf", "od", "MD", "dd", "mand", "ma", "mt", "m", "ms", " MD", "bd", "rm", "mb", "mg", "vd", "dm", "cd", "sd", "cmd", "mod", "mmm", "nd", "hd", "mac", "oda", "mag", "mp", "mc", "mi", "ld", "mo"]}}
{"id1": "20091126", "id2": "5237257", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"in": ["f", "a", "data", "source", "i", "ic", "diff", "input", "base", "query", "min", "url", "file", "lin", "reader", "part", "ins", "bin", "m", "connection", "inner", "image", "buffer", "name", "b", "old", "or", "l", "In", "work", "inc", "ac", "IN", "config", "index", "again", "login", "id"], "out": ["ext", "target", "dot", "prefix", "OUT", "x", "a", "data", "content", "point", "string", "source", "i", "output", "off", "server", "parent", "Out", "base", "p", "value", "array", "v", "file", "page", "plain", "url", "temp", "object", "exp", "call", "err", "comment", "io", "image", "buffer", "default", "name", "channel", "o", "c", "outs", "exec", "write", "result", "external", "cache", "ex", "copy", "again"], "inChannel": ["outStream", "inputGate", " inClient", "inputchannel", "iniChannel", "inChan", "inClient", "inputChannel", "inButton", "INButton", "inputStream", " inChan", "iniGate", "iniStream", "outchannel", " inStream", "outChan", "INClient", "winChannel", "insStream", "winchannel", " inchannel", "insClient", "inchannel", "INGate", "INChannel", " inButton", "inputButton", "insChannel", "INChan", "inputChan", "inStream", "winChan", "outButton", "winStream", "INStream", "inGate", "iniChan", "INchannel", "insChan"], "outChannel": ["outStream", "OutClient", "outContext", "OutChan", "inChan", "inClient", "OutChannel", "OutContext", "OutStream", "outputClient", "inContext", "outchannel", "outChan", " outContext", "outConnection", " outchannel", " outChan", " outConnection", "inConnection", " outStream", "inchannel", "outsStream", "outputStream", "outputChannel", "outputchannel", "inStream", "outsChannel", "outsConnection", "outClient", "outsChan", "outputChan", "Outchannel"]}}
{"id1": "15797402", "id2": "11933797", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"stream": ["loader", "video", "data", "content", "src", "source", "sample", "resource", "document", "form", "remote", "feed", "upload", "through", "server", "read", "http", "response", "iterator", "input", "writer", "load", "raw", "file", "url", "in", "reader", "Stream", "down", "handle", "stack", "temp", "draw", "inner", "image", "client", "channel", "download", "view", "message"], "handler": ["application", "Handler", "loader", "wrapper", "ctx", "data", "format", "service", "handled", "host", "layer", "response", "server", "di", "monitor", "writer", "parent", "function", "base", "event", "processor", "reader", "handle", "manager", "connection", "hand", "collection", "client", "channel", "phase", "parser", "controller", "driver", "h", "default", "pointer", "info"], "metadata": ["material", "ctx", "managed", "template", "plugin", "data", "content", "uri", "source", "resource", "document", "xml", "subject", "di", "monitor", "meta", "json", "runtime", "database", "processor", "properties", "params", "mt", "directory", "manager", "m", "connection", "state", "management", "header", "module", "storage", "collection", "met", "mx", "md", "mon", "property", "component", "metry", "parser", "adata", "mi", "config", "attribute", "info", "map", "message"], "context": ["system", "ctx", "Context", "data", "content", "request", "resource", "document", "xml", "subject", "kernel", "entry", "command", "text", "parent", "txt", "event", "processor", "reader", "translation", "method", "concept", "environment", "manager", "scope", "object", "connection", "element", "tx", "collection", "instance", "component", "cmp", " Context", "mc", "config", "proxy", " contexts", "message"], "name": ["common", "named", "address", "filename", "prefix", "sync", "child", "data", "version", "time", "string", "source", "no", "resource", "alias", "path", "on", "model", "message", "label", "class", "search", "base", "large", "url", "file", "in", "full", "active", "part", "missing", "type", "m", "call", "NAME", "connection", "comment", "action", "image", "Name", "code", "job", "route", "old", "ame", "size", "work", "n", "key", "api", "word", "default", "object", "null", "names", "none", "id"], "out": ["ext", "sync", "OUT", "child", "data", "flush", "socket", "user", "source", "resource", "builder", "output", "path", "line", "server", "cos", "lib", "writer", "again", "window", "Out", "file", "conn", "in", "url", "page", "plain", "temp", "bin", "manager", "exp", "err", "connection", "io", "image", "obj", "client", "o", "channel", "outs", "result", "instance", "pool", "ray", "ex", "copy", "extra", "object", "null"]}}
{"id1": "18374478", "id2": "5836744", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 0, "substitutes": {"user": ["custom", "session", "system", "account", "author", "version", "bug", "plugin", "data", "content", "row", "ro", "you", "string", "resource", "profile", "app", "per", "rule", "person", "server", "character", "project", "member", "this", "group", "username", "parent", "creator", "p", "lock", "page", "User", "full", "manager", "one", "connection", "used", "self", "users", "module", "name", "update", "job", "client", "result", "instance", "USER", "current", "me", "view", "pool", "log", "consumer", "null", "config", "use", "record", "object", "model", "auth", "match", "ver"], "conn": ["session", "Connection", "oss", "ca", "ctx", "cm", "cs", "sync", "cat", "serv", "core", "pg", "socket", "cond", "cf", "connect", "ci", "con", "dc", "cn", "host", "db", "cr", "pc", "conf", "org", "sth", "cli", "nc", "pr", "cp", "cmp", "lock", "nt", "ou", "error", "url", "co", "part", "act", "ct", "cb", "connection", "err", "pub", "sql", "ec", "client", "c", "util", "cc", "exec", "reg", "close", "rc", "Conn", "n", "cache", "ac", "pool", "ann", "loc", "ch", "pt", "log", "mc", "enc", "config", "h", "uc", "coll", "col", "ob", "ks"], "autoCommit": ["autoDebet", "autoCommet", "autoommite", "autoModmit", "autoCommo", "autoModite", "AutoCommite", "autocommaction", "AutoCommit", "autoommit", " autoCommite", "AutoCommet", " autoCommo", "AutoDebmit", "autoCommaction", "AutoCommmit", "autoDebit", "autoComits", "autocommo", "autocommit", "autoCommite", " autoComaction", "autoommmit", "autoComite", "autoDebite", "autoCommits", "autoDebits", " autoComits", "AutoDebit", "autoModet", " autoCommaction", "autoCommmit", "autoommet", "AutoDebet", "autoDebaction", " autoComite", " autoComit", "autoModit", " autoCommits", " autoComo", "autocommits", "autoDebo", "autoDebmit", "autoComaction", "autoComit", "autocommite", "AutoDebite", "autoComo"], "updateUser": ["createRole", "UpdateUse", "deleteRole", "createUsers", "updateRole", "deletePost", "saveSoft", " updatePost", " updateGroup", "UpdateUser", "updateSoft", " updateUse", " updateRole", "deleteUsers", "Updateuser", "installUser", "updateGroup", "createUser", "updatePerson", "createSoft", "installPerson", "deleteuser", "installSoft", "createPerson", "deleteUser", "updateUse", "savePerson", "updateUsers", "installRole", "createuser", "saveUser", "deleteGroup", " updateUsers", "updatePost", "UpdateRole", "saveRole", "updateuser", "createUse", "UpdateUsers", "UpdateGroup", " updateuser", "UpdatePost"], "deleteRoles": ["deleteSloots", " deleteSlodes", " deleteRules", "deleteRole", "deleteCodes", " deleteSlows", "deleteRsoles", "deleteRodes", " deleteRole", "deleteRoots", "deleteRows", " deleteRows", " deleteRodes", "deleteSlows", "deleteColes", " deleteRles", "deleteRsows", "deleteSloles", " deleteSlole", " deleteSlles", "deleteSlodes", "deleteLoles", "deleteSlole", "deleteSeroots", "deleteRsole", "deleteSlules", "deleteCules", "deleteRsles", "deleteLoots", "deleteRules", "deleteCole", " deleteSloles", " deleteSlules", "deleteRles", "deleteLules", "deleteSerows", " deleteRoots", "deleteSlles", " deleteSloots", "deleteSeroles", "deleteCoots", "deleteRsoots", "deleteSerules", "deleteLodes", "deleteCles", "deleteRsules"], "insertRoles": ["insertLols", " insertRules", "deleteRodes", "insertLole", "insertRSoles", "insertSloles", "InsertRoles", "insertSlroups", " insertRols", "insertNols", "insertRsules", "InsertLols", "insertRsoles", "insertRules", "insertNodes", "InsertLodes", "insertNules", "insertRSanges", " insertRroups", "insertSlodes", "insertRole", "insertSodes", "insertSlanges", "insertRodes", "insertSanges", "insertSoles", "InsertRols", " insertLodes", " insertLols", "InsertRodes", "deleteRules", "deleteRanges", " insertLoles", "insertSlole", "insertLules", "insertSules", "insertLodes", "insertSole", " insertRodes", "insertLoles", "insertRanges", "InsertRole", "InsertLole", "insertNoles", "insertRsodes", "insertRsanges", "insertRSodes", "InsertLoles", " insertRanges", "insertRSroups", "insertRroups", "insertRols", "insertSols", "insertSlols", " insertLules"], "role": ["tool", "data", "row", "ro", "resource", "alias", "profile", "rule", "line", "guard", "entry", "label", "member", "group", "tag", "username", "base", "function", "type", "one", "ole", "slave", "to", "range", "module", "Role", "route", "rol", "relation", "le", "po", "or", "l", "link", "key", "rl", "r", "val", "use", "proxy", "id"]}}
{"id1": "21092340", "id2": "9109613", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"pod": ["loader", "plug", "child", "plugin", "peer", "ad", "per", "pad", "host", "Pod", "cer", "pc", "pe", "tmp", "zip", "project", "ce", "pi", "pkg", "p", "od", "part", "pl", "product", "table", "module", "pid", "po", "component", "proc", "cache", "pot", "post", "node", "ods", "object", "bean"], "podArchiveOutputStream": ["podArchivesFileSteam", "podArchivesFileResource", "podArchIVEOutputDirectory", "podArchIVEInputDirectory", "podArchivesFileFile", "podArchiveFileResource", "podArchiveByteFile", "podArchiveWritePath", "podArchivesOutputSteam", "podArchivingWritePath", "podArchiveIOSteam", "podArchiveInputDirectory", "podArchIVEOutputStream", "podArchiveIOResource", "podArchiveIODirectory", "podArchiveInputFile", "podArchivingWriteSteam", "podArchiveFileFile", "podArchivingWriteFile", "podArchiveWriteFile", "podArchiveFileStream", "podArchiveOutputPath", "podArchivingOutputPath", "podArchivesFileStream", "podArchiveOperationResource", "podArchIVEOutputFile", "podArchiveWriteStream", "podArchivingOutputSteam", "podArchiveInputStream", "podArchiveOperationFile", "podArchiveFileDirectory", "podArchiveOutputResource", "podArchiveFilePath", "podArchivingOutputFile", "podArchiveOperationStream", "podArchiveOutputDirectory", "podArchiveInputPath", "podArchivingOutputStream", "podArchiveWriteSteam", "podArchivesOutputFile", "podArchiveIOFile", "podArchiveOutputSteam", "podArchiveByteStream", "podArchIVEInputSteam", "podArchivesOutputResource", "podArchIVEOutputSteam", "podArchiveIOStream", "podArchiveByteDirectory", "podArchiveFileSteam", "podArchiveByteSteam", "podArchiveInputSteam", "podArchiveOperationSteam", "podArchivesOutputStream", "podArchIVEInputFile", "podArchiveOutputFile", "podArchivingWriteStream", "podArchIVEInputStream"], "filename": ["nil", "loader", "application", "named", "f", "prefix", "platform", "which", "uri", "string", "sf", "alias", "Filename", "path", "subject", "label", "kl", "binary", "username", "folder", "kn", "database", "fp", "url", "file", "fil", "dll", "directory", "files", "location", "module", "title", "name", "archive", "route", "property", "l", "download", "FILE", "ename", "fn", "ppa", "SourceFile", "word", "il", "sequence"], "source": ["loader", "target", "src", "uri", "service", "string", "resource", "document", "path", "output", "SOURCE", "slice", "zip", "sl", "input", "text", "parent", "url", "file", "reader", "stack", "connection", "slave", "unit", "image", "seed", "archive", "result", "stream", "Source", "driver", "ource", "copy", "config", "proxy", "use"], "entry": ["address", "child", "it", "data", "row", "ie", "string", "resource", "feed", "path", "line", "zip", "iterator", "this", "parent", "event", "add", "file", "pointer", "reader", "se", "ge", "connection", "letter", "element", "image", "archive", "obj", "result", "or", "stream", "index", "auto", "post", "r", "record", "Entry", "object", "article", "e"]}}
{"id1": "11616716", "id2": "12783713", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"rqlQuery": ["rSQLQuery", "riliQu", "rQLQuery", "rqlquery", "srqlquery", "rQLquery", "rSQLquery", "srqlQ", " rsqlquery", "rSQLQu", "rsqlquery", " rsqlQuery", "rsqlQ", "riliquery", " rqlquery", " rqlQu", "rSQLMethod", "rQLQu", "rsqlQu", "srQLQ", "rQLMethod", "srQLQu", "srQLquery", "rQLQ", "srQLQuery", "rqlMethod", "srqlQu", "riliQ", "rsqlQuery", "riliQuery", " rsqlQu", " rqlMethod", "rqlQu", "srqlQuery", " rsqlMethod", "rsqlMethod", "rqlQ"], "osr": ["usrt", "ossrs", " osrm", "yscr", "oswer", "ossrm", "losrr", "opsrar", "opswer", "bosr", "iosrs", "OSrr", " osfr", "ossrar", "osfr", "losrt", "OSerr", "osserr", "osrw", "usr", "ysrt", "ossrt", "otspr", "boswer", "otsr", "otssr", "iosr", "obsR", "oserr", " ossr", "osspr", "iospr", "osscr", " osrr", "cosfr", "uspr", " ospr", "obswer", "osR", "OSrt", "opsR", "ossrw", " osrt", "oscr", "ysrar", " oscr", "usrr", "iosrw", "osrar", "ossrr", "usrs", "bosR", "usrw", "osrm", "osrt", "ysr", "osrr", "cosrr", "osrs", "ospr", "osssr", "losr", "cosr", "bosrar", "obsr", "opsr", "ossr", "cosrt", "otsrm", "OSr", " osrar", "losfr", "userr", "obsrar"], "url": ["f", "socket", "uri", "ssl", "string", "lc", "source", "web", "resource", "path", "host", "server", "http", "nl", "org", "sl", "fb", "URL", "blog", "base", "file", "page", "ls", "www", "connection", "open", "client", "channel", "b", "l", "ll", "Url", "rl", "r", "ob", "config", "fl"], "conn": ["oss", "Connection", "wrapper", "ca", "ctx", "f", "sync", "ssl", "lc", "connect", "ci", "con", "cn", "dc", "db", "cr", "server", "http", "attr", "pc", "org", "nc", "pr", "cp", "p", "nt", "act", "ct", "cb", "connection", "err", "net", "rn", "open", "rt", "ec", "client", "conv", "c", "reg", "exec", "en", "l", "Conn", "rc", "n", "ann", "cur", "loc", "ch", "fn", "enc", "h", "coll", "col"]}}
{"id1": "18891988", "id2": "12055086", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"serviceName": ["ServiceName", "ServiceUrl", " servicePath", "servicename", "ServicePath", "servicePath", "packagename", "Servicename", "packagePath", "packageName", "serviceUrl", " servicename", " serviceUrl", "packageUrl"], "wsdlLocation": ["awsdlDirectory", "wsllFolder", "wslUrl", "wddlAddress", "wslpLocation", "wdlFolder", "wdlDirectory", "wssdFolder", "awsdlUrl", "wslFile", "wslpAddress", "wssdFile", "wslLocation", "wdlLocation", "wsdlDirectory", "wddlDirectory", "wdlAddress", "wsllDirectory", "wssdLocation", "wddlFile", "wsdlFolder", "wslAddress", "wsdlFile", "wslFolder", "wddlLocation", "wsDLDirectory", "wslDirectory", "awsdlLocation", "awslUrl", "wsllAddress", "wssdDirectory", "awsdlFile", "wslpDirectory", "wsdlUrl", "wsllLocation", "wdlFile", "wsdlAddress", "wddlFolder", "awslFile", "wsDLLocation", "wsllUrl", "wsDLFile", "awslDirectory", "wsllFile", "wslpFile", "wsDLUrl", "awslLocation"], "endpoint": ["enpoints", "ENDpoints", "enport", "gepoint", "ENDination", "enination", " endolution", "enPoint", " endPoint", " endport", "endaddress", "geport", "enpoint", "Endolution", "endsolution", " endaddress", "geaddress", "Endword", "endination", " endocol", "ENDpoint", " endword", "endocol", "Endpoint", "Endination", "endpoints", "endport", "endsocol", "gePoint", "endword", "endPoint", "endsword", "enaddress", "endspoint", "ENDPoint", "EndPoint", "Endocol", "Endpoints", "endolution"], "fileLocation": ["fileName", " fileName", "FileName", " filelocation", "Filelocation", "resourcelocation", "resourceLoc", "resourceLocation", "FileLoc", "resourceName", "fileLoc", "FileLocation", "filelocation", " fileLoc"], "tempDir": [" tempFile", "tempFile", "tempJar", "TempDir", "TempPath", "tmpPath", " tempDirectory", " tempJar", "tempDirectory", "tmpDir", "Tempdir", "tmpDirectory", "tempPath", "TempFile", " tempPath", "tmpJar", "tempdir", "TempJar", " tempdir", "TempDirectory", "tmpdir"], "url": ["plug", "address", "f", "bug", "socket", "uri", "bb", "service", "ssl", "string", "git", "source", "web", "path", "host", "server", "http", "ur", "zip", "sl", "URL", "base", "file", "conn", "ls", "www", "gl", "connection", "io", "image", "open", "client", "channel", "l", "ll", "link", "stream", "Url", "download", "log", "config", "fl", "coll", "pull"], "WSDLFile": ["WINDlFile", "WSDDLfile", "WSDLPath", "WINDLUrl", "WSDDLFiles", "WSDELFolder", "WSDLSourceFile", "WSDELFile", "WSDLLFolder", "WSDLFolder", "WDDLFolder", "WDDLFiles", "WDDlPath", "WSDlFile", "WSDELfile", "WINDlUrl", "WSDDLFile", "WSDlPath", "WSDELFiles", "WINDLFile", "WSDlUrl", "WINDLSourceFile", "WSDLLPath", "WDDLFile", "WDDDLPath", "WDDLPath", "WDDDLFolder", "WSDLUrl", "WSDDLSourceFile", "WSDELSourceFile", "WDDDLFile", "WSDELUrl", "WSDDLFolder", "WSDLLFile", "WSDlfile", "WINDlSourceFile", "WDDDLFiles", "WSDLLFiles", "WSDlFiles", "WINDlfile", "WSDlFolder", "WSDLFiles", "WDDlFile", "WSDlSourceFile", "WSDLfile", "WSDDLUrl", "WSDELPath", "WDDlFolder", "WINDLfile", "WDDlFiles", "WSDDLPath"], "tmpWSDLFile": ["tmpWSDSLFile", "tmpWDDELFiles", "tmpWSDLUrl", "tmpWDDLUrl", "tmpWSDLLDir", "tmpWSDELFiles", "tmpWSDLLFile", "tmpWSDSLPath", "tmpWDDLDir", "tmpWSDSLDir", "tmpWSDlDir", "tmpWSDLDir", "tmpWDDELPath", "tmpWSDLFolder", "tmpWSDLLFolder", "tmpWSDELPath", "tmpWDDELFolder", "tmpWDDLFolder", "tmpWDDlUrl", "tmpWDDLFile", "tmpWSDLLFiles", "tmpWSDLFiles", "tmpWDDlPath", "tmpWSDLLUrl", "tmpWSDlFiles", "tmpWSDlFolder", "tmpWDDlFile", "tmpWSDELFile", "tmpWSDSLUrl", "tmpWDDlDir", "tmpWDDLFiles", "tmpWSDLPath", "tmpWSDlFile", "tmpWSDELFolder", "tmpWSDLLPath", "tmpWDDELFile", "tmpWDDLPath", "tmpWSDlPath", "tmpWSDlUrl"], "inputFile": ["tempPlace", "tempFolder", "tempStream", "tempFile", "inputLine", "InputPlace", "outputFile", "outputFiles", "InputDir", "outputfile", "alphafile", "inputFactory", "inputSourceFile", "InputLine", "InputSourceFile", "inputfile", "InputFile", "inputStream", "inputFolder", "inputPage", " inputFilename", " inputLine", "inputFiles", "outputDirectory", " inputDirectory", "InputPage", "outputPage", "InputStream", "inputPlace", " inputDir", "alphaFile", "InputDirectory", "tempPage", "inputDir", "Inputfile", " inputfile", "alphaFilename", "tempLine", "InputFilename", " inputFolder", "tempfile", "outputStream", " inputFiles", "InputFolder", "outputDir", " inputFactory", "inputFilename", "alphaPlace", " inputSourceFile", " inputPlace", "InputFactory", "tempFactory", "InputFiles", "inputDirectory", "tempSourceFile"], "tmpFile": ["tempPlace", "tmpFiles", "tempFile", "tempStream", " tmpFiles", " tmpFilename", "tempFilename", "tmpSourceFile", "inputSourceFile", " tmpSourceFile", "tempFiles", "empFile", "empPlace", "inputFiles", " tmpStream", "tmpFilename", "tmpStream", "empStream", " tmpPlace", "tmpPlace", "inputFilename", "tempSourceFile", "empFiles"], "in": ["gin", "f", "data", "socket", "inn", "ssl", "source", "plus", "is", "input", "init", "p", "din", "file", "conn", "reader", "impl", "ins", "bin", "m", "connection", "inner", "io", "image", "up", "client", "c", "win", "In", "pass", "inc", "IN", "r", "login", "again", "pin", "id"], "out": ["sync", "OUT", "socket", "remote", "output", "on", "line", "server", "conf", "writer", "group", "parent", "Out", "lock", "can", "error", "file", "co", "conn", "part", "timeout", "bin", "connection", "err", "net", "io", "to", "inner", "image", "name", "up", "client", "channel", "conv", "exec", "outs", "outer", "cache", "inc", "log", "IN", "ch", "copy", "extra", "again"], "con": ["Connection", "cm", "un", "sync", "socket", "cf", "Con", "ssl", "connect", "cn", "conf", "input", "fc", "nc", "rec", "kin", "can", "conn", "file", "plain", "co", "ran", "ins", "connection", "inner", "open", "CON", "client", "channel", "conv", "c", "close", "en", "win", "Conn", "rc", "inc", "IN", "ch", "xc", "uc", "pin"], "fileLength": ["fileSize", "channelLength", "FileLength", "fileLen", "channelWidth", " fileLen", "fileNumber", "FileSize", "FileLen", "channelLen", "fileWidth", "FileWidth", " fileWidth", "channelNumber", "channelSize", " fileNumber", "FileNumber", " fileSize"], "channelIn": ["resourceIN", "resourceOut", "Channelin", " channelin", "containerOut", "ChannelIN", " channelInt", "streamInt", "containerIn", "ChannelOut", "streamOut", "resourceIn", "ChannelIn", "containerin", "containerIN", " channelIN", "resourcein", "ChannelInt", "channelin", "channelInt", "streamIn", "streamin", "channelIN"], "channelOut": ["connectionIn", " channelName", " channelOutput", " channelout", "chanIn", "connectionOut", "chanOut", "ChannelOutside", "ChannelOutput", "fileOut", "ChannelOut", "fileOutput", "chanOutside", "fileIn", "fileout", "Channelout", "ChannelIn", "connectionOutside", "channelName", "channelout", "channelOutside", "chanout", "channelOutput", "connectionout", "connectionName", "ChannelName"], "tmpDocument": ["tabdocument", "tempNode", "tempFile", "tmpDoc", "mpNode", "tmpClient", "mpDocument", "tmpNode", "inputContent", "tempClient", " tmpContent", "mpFile", " tmpdocument", " tmpNode", "tabDoc", "inputClient", "tabNode", "mpDoc", "tempContent", "tempDoc", "inputDocument", "tmpdocument", " tmpClient", "tempdocument", "tempDocument", "tmpContent", " tmpDoc", "tabDocument"], "nl1": ["wlOne", "dl3", "wl1", "ln1", "kl5", "nl2", "nl11", "NL3", "wl5", "dl2", "dl0", "nlOne", "nn11", "dl1", "nl6", "nl3", "jlOne", "nlFirst", "ln11", "nl0", "jl5", "NL0", "ln6", "NL6", "nn1", "ln2", "nn6", "jlFirst", "klOne", "nn0", "nn3", "NL1", "klFirst", "kl1", "wlFirst", "jl1", "nn2", "NL2", "NL11", "nl5"], "i": ["hi", "phi", "f", "d", "it", "ui", "ti", "uri", "ni", "bi", "ci", "gi", "qi", "slice", "mu", "di", "z", "pi", "chi", "v", "ix", "ai", "part", "m", "iu", "yi", "io", "inner", "ip", "ii", "y", "info", "o", "b", "ri", "I", "multi", "fi", "j", "l", "n", "si", "li", "ini", "mi", "oi", "ji", "index", "xi", "eni", "e", "id"], "node1": ["nOne", " nodeone", "shapeOne", "node7", "n0", "NodeOne", "n1", " node7", "node2", "entityFirst", "neOne", "sourceFirst", "shape7", "entityone", "nodeOne", "node0", "entityOne", "source1", " node0", "sourceone", "node81", "ne1", "Node2", " node2", "shape81", "entity1", "Node0", "shape1", " node81", " nodeFirst", "ne7", "nodeFirst", "Node1", "n2", " nodeOne", "nodeone", "sourceOne", "ne81"], "tmpOut": ["partout", "tempFile", "tempWriter", "tempOUT", "partOUT", "tmpout", "tmpOUT", "pmOut", "mpOut", "tmpIn", "mpIn", "tempIn", "pmOutput", "tempout", "mpFile", "bbOut", "tempOut", "pmOUT", "bbOutput", " tmpOUT", "partIn", "mpWriter", "pmWriter", "bbout", "tempOutput", "partOut", " tmpWriter", " tmpIn", " tmpOutput", " tmpout", "tmpWriter", "tmpOutput", "bbIn"], "retVal": ["New", "data", "xml", "path", "http", "Service", "this", "URL", "Socket", "s", "_", "HTTP", "Url", "Address"]}}
{"id1": "8119563", "id2": "21531069", "code1": "    protected boolean checkLink(URL url) {\n        try {\n            URLConnection connection = url.openConnection();\n            connection.connect();\n            return true;\n        } catch (IOException e) {\n            MsgLog.error(\"DapParser.checkLink(): IOException: \" + e.toString());\n            return false;\n        }\n    }\n", "code2": "    public int updateuser(User u) {\n        int i = 0;\n        Connection conn = null;\n        PreparedStatement pm = null;\n        try {\n            conn = Pool.getConnection();\n            conn.setAutoCommit(false);\n            pm = conn.prepareStatement(\"update user set username=?,passwd=?,existstate=?,management=? where userid=?\");\n            pm.setString(1, u.getUsername());\n            pm.setString(2, u.getPasswd());\n            pm.setInt(3, u.getExiststate());\n            pm.setInt(4, u.getManagement());\n            pm.setString(5, u.getUserid());\n            i = pm.executeUpdate();\n            conn.commit();\n            Pool.close(pm);\n            Pool.close(conn);\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            Pool.close(pm);\n            Pool.close(conn);\n        } finally {\n            Pool.close(pm);\n            Pool.close(conn);\n        }\n        return i;\n    }\n", "label": 0, "substitutes": {"url": ["address", " URL", "uri", "socket", "service", "ssl", "string", "source", "proxy", "resource", "host", "str", "server", "http", "entry", "sl", "URL", "class", "base", "file", "page", "conn", "location", "image", "element", "open", "name", "client", "route", "or", "instance", "l", "link", "Url", "loc", "config", "object", "null"], "connection": ["application", "Connection", "data", "socket", "uri", "i", "connect", "resource", "builder", " Connection", "handler", "response", "http", "server", "character", "writer", "communication", "function", "database", "conn", "timeout", "network", "io", "unit", "image", "open", "connected", "client", "channel", "relation", "c", "b", "link", "l", "ion", "position", "loc", "config", "object"]}}
{"id1": "19206412", "id2": "11005804", "code1": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"str": ["f", "kr", "st", "re", "dr", "data", "msg", "hr", "string", "sr", "fr", "tr", "this", "text", "txt", "url", "sp", "er", "exp", "err", "char", "s", "self", "star", "arr", "br", "name", "STR", "obj", "bytes", "result", "doc", "Str", "pass", "strings", "r", "enc", "out", "stri", "e", "dict"], "md": ["um", "pd", "mail", "d", "dh", "sm", "data", "wd", "hm", "ad", "pm", "amd", "rpm", "db", "mu", " Md", "mm", "am", "Cmd", "MD", "dd", "od", "mand", "ma", "mt", "m", "ms", " MD", "bd", "dig", "mb", "mg", "vd", "dm", "code", "cd", "cmd", "mod", "sum", "hd", "df", "me", "mac", "cmp", "mag", "mp", "mk", "mc", "ld", "mo", "map", "metadata"], "hash": ["number", "filter", "address", "f", "dot", "Hash", "check", "hex", "diff", "host", "sh", "id", "sha", "tr", "search", "value", "html", "base", "block", "array", "error", "url", "part", "bin", "chip", "char", "range", "image", "header", "arr", "code", "her", "print", "ash", "sum", "memory", "ha", "kh", "cache", "index", "key", "body", "count", "h", "rh", "ver"], "hexChars": ["hashchars", " hexchars", " hexChARS", "hexKhashes", " hexChats", "hexchacters", " hexchARS", "hashCHashes", "hexChashes", "hashCHash", "hashchases", "hexchARS", "hexCHats", "hexCHash", "hashChases", "hexChacters", "hashchacters", "hexKhash", "hexCharars", "hexCharashes", "hexCharases", "hexchases", "hexCashes", "hashChacters", "hexCHacters", "hexchats", "hexKhars", "hexChats", " hexchats", " hexChashes", "hashChashes", "hexCars", "hexCARS", "hexCash", "hashCHARS", "hexCHashes", "hashchARS", "hexCHases", "hexChases", "hashChars", "hashChARS", "hexChash", "hexCharats", "hexCharARS", "hashChash", "hexchars", "hexKhARS", "hashCHars", "hexChARS", " hexchashes", "hexCharacters", "hexCHars", "hexchashes", "hexCHARS"], "res": ["rex", "cons", "Res", "cs", "ris", "re", "data", "Rs", "pers", "string", "abs", "es", "pres", "response", "us", "bs", "RS", "req", "rows", "des", "Results", "vs", "rss", "ras", "rev", "css", "err", "rus", "results", "s", "arr", "ress", "Result", "vers", "bytes", "RES", "result", "vals", "reg", "details", "rs", "rez", "resolution", "ps", "ss", "ros", "resp", "cache", "ret", "r", "out", "rules"], "i": ["hi", "phi", "f", "length", "a", "x", "d", "it", "ui", "ti", "uri", "ie", "bi", "ci", "gi", "qi", "diff", "mu", "di", "abi", "pi", "base", "p", "v", "in", "ai", "part", "ix", "temp", "u", "k", "m", "iu", "io", "ip", "ii", "y", "code", "info", "o", "c", "b", "I", "multi", "ri", "j", "l", "index", "si", "li", "oi", "ji", "field", "h", "xi", "e", "id"]}}
{"id1": "4629990", "id2": "21555906", "code1": "    private String logonToServer(FTPClient ftpClient, String ftpAddress, int noRetries) {\n        String remoteHomeDir = null;\n        noRetriesSoFar = 0;\n        while (true) {\n            try {\n                ftpClient.connect(ftpAddress, ftpPort);\n                int reply = ftpClient.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftpClient.disconnect();\n                    throw new IOException();\n                }\n                if (!ftpClient.login(user, password)) {\n                    throw new IOException();\n                }\n                remoteHomeDir = ftpClient.printWorkingDirectory();\n                msgEntry.setAppContext(\"logonToServer()\");\n                msgEntry.setMessageText(\"Logged into FTP server \" + ftpAddress + \":\" + ftpPort + \" as user \" + user);\n                logger.logProcess(msgEntry);\n                break;\n            } catch (IOException e) {\n                logoutAndDisconnect(ftpClient);\n                if (noRetriesSoFar++ < noRetries) {\n                    waitBetweenRetry();\n                    notifyAndStartWaitingFlag = false;\n                } else {\n                    notifyAndStartWaitingFlag = true;\n                    errEntry.setThrowable(e);\n                    errEntry.setAppContext(\"logonToServer()\");\n                    errEntry.setAppMessage(\"Unable to login after \" + (noRetriesSoFar - 1) + \" retries. Max Retries.\\n\" + \"Address:\" + ftpAddress + \"\\n\" + \"User:\" + user);\n                    errEntry.setSubjectSendEmail(\"Unable to login to \" + ftpAddress + \" after \" + (noRetriesSoFar - 1) + \" retries.\");\n                    logger.logError(errEntry);\n                    break;\n                }\n            }\n        }\n        return remoteHomeDir;\n    }\n", "code2": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"ftpClient": [" ftpControl", "ftapiServer", "ftpiServer", "ctpContext", "ufspServer", "ftcpCloud", "ufspClient", "ftspServer", "ftcpAddress", "ftfServer", " ftfServer", "fttpClient", "ftapiPort", " ftpContact", "ufpclient", "ftprContact", "ctcpClient", " ftbContact", " ftpHost", "ftfPort", "ufpServer", " ftbclient", "ftspclient", "ftapiHost", "ctpAddress", "ftuControl", "ftpControl", " ftfClient", "ftdpCloud", "ftupclient", "ftdpClient", "ctcpAddress", "ftspContact", "fttpCase", "ftpcclient", "ufpClient", "ctpGuest", "ftcpHost", "fttpServer", "ftcpGuest", " ftpServer", "ftprControl", "ftpGuest", "ctpClient", "ftpPort", "ftpcServer", "ftpclient", "ftcpContext", "ftbServer", "ftbControl", " ftpcClient", "ftpContact", "ftfClient", "ftcServer", "ctcpCloud", "ftrContext", "ufpContact", "ftpHost", "ftcpConnect", "ftfHost", "ftupClient", "ftcClient", "ftdpAddress", "ctpServer", "ufspclient", "ftcclient", "ftuContact", "ftbContact", " ftfHost", "ftcpCase", "ftcContact", "ftbClient", " ftfPort", "ftapiClient", "ftuclient", "ctpCloud", "ftrServer", "ftrCase", "ftuClient", "ftpCase", " ftpcclient", "ftpConnect", "ftcpContact", "ctcpclient", "ftdpServer", "ftupServer", "ftpiClient", "ctpclient", "fttpContext", "ftpServer", "ftpcClient", "ftpcConnect", " ftbControl", "ftprclient", "ctcpCase", " ftpConnect", "ftrClient", "ufspContact", "ftpCloud", "ftprClient", "ftspClient", "ftbclient", "ftpContext", "ftupGuest", "ctpCase", " ftpcConnect", "ctcpContext", "ctcpGuest", " ftpPort", "ftpiCloud", " ftpclient", "ctcpServer", "ftcpServer", "ftcpclient", "ftbConnect", "ftcpPort", "ftcpClient", " ftbClient", " ftpcServer", "ftpiAddress", "ftbGuest"], "ftpAddress": ["ftfAddress", "ftcpAddress", "ftpaddress", "ftfServer", "aftapPath", "ftcpAdd", "ctapMaster", "ftPAddress", "ftfPort", "ftfPath", "ctpAddress", "aftpPath", "aftpHost", "aftpServer", "ftpcHost", "ctcpAddress", "ftpMaster", "ftraddress", "ftpointClient", "ftapHost", "ftcpHost", "fttpPath", "ftcpaddress", "ftpcAddress", "ftpAdd", "ftrPort", "ctpAdd", "aftapHost", "ctpClient", "ftpointMaster", "ftpPort", "ftpcServer", "ftpaPort", "ftrAdd", " ftpPath", "fttpAddress", "ftpHost", "ctpServer", "ftapPort", "aftpAddress", " ftcpAddress", "ftcpPath", "ftapPath", "ctapAddress", "ctapPort", "ctpMaster", "fttpaddress", "ftapMaster", "ftpcPath", "ftpaAddress", " ftcpPath", "ctapClient", "ftfaddress", "ftpaClient", "ftapAddress", "ftapClient", " ftcpPort", "ftPServer", "ctpaddress", " ftcpaddress", "fttpPort", "ctcpPort", "ftpServer", "ftPPort", "ftrAddress", "ftfAdd", "ftPaddress", "ftapServer", "ftpointPort", "ctcpAdd", "ctcpaddress", "ftpPath", "ctpPort", " ftpPort", "ftpaMaster", "aftapAddress", " ftpaddress", "ctcpServer", "ftcpServer", "ftcpPort", "ftpointAddress", "aftapServer"], "noRetries": ["noCountrying", "NoPatry", "noPatrys", "NoRetrys", "noRetrying", "NoRetries", "NoPatrys", "NoFortrys", "noCountry", "noCountries", "NoPatries", "noUntails", "noPatails", "noTries", "noRetails", "NoRetrying", "NoFortries", "noRetry", "noCountrys", "NoFortry", "noTrys", "noUntry", "noFortry", "noTry", "noUntrys", "noPatries", "noUntries", "NoFortails", "noRetrys", "noFortrys", "noFortries", "noFortails", "NoPatrying", "NoRetry", "noPatrying", "noTrying", "noPatry", "NoRetails"], "remoteHomeDir": ["remotehomeDir", "remotehomeUrl", "RemoteHomePath", "remoteHostFile", " remotehomeFile", "RemoteRootFile", "remotehomeDIR", "remoteRootDIR", " remoteHomeFile", "remoteHaDir", "remoteRootDir", "RemoteRootPath", "remoteHostPath", "RemoteHomeDirectory", "remotehomeDirectory", " remoteHomeDIR", "remoteHomeDIR", "remotehomePath", "remoteHomeFile", "remoteHaDIR", "remoteHostUrl", "remoteHaDirectory", "remoteRootFile", "remoteRootUrl", "RemoteRootDirectory", "remoteHaFile", "remoteHomeDirectory", "RemoteHomeFile", "remoteHostDir", " remoteRootDIR", "remotehomeFile", "remoteHostDirectory", " remoteHomeDirectory", "remoteRootPath", " remotehomeDirectory", "remoteHomePath", " remoteRootFile", " remotehomeDir", "remoteHomeUrl", "remoteRootDirectory", " remoteHomeUrl", " remoteRootDir", "RemoteHomeDir", " remotehomeUrl", " remoteRootDirectory", "RemoteRootDir"], "noRetriesSoFar": ["noRetriesSoLower", "noRetryssofar", "noRetriesYetLower", "noRetriesSincefar", "noRetriessoNear", "noRetryingsofar", "noRetriesSinceFar", "noRetryingSofar", "noRetriessofar", "noRetriesSOLower", "noRetrysSoFar", "noRetrysSoLower", "noRetriesSofar", "noRetriesYetfar", "noRetrySoFar", "noRetryssoFar", "noRetriessoLower", "noRetriesSOFar", "noRetrySONear", "noRetriessoFar", "noRetryssoLower", "noRetriesSONear", "noRetrySOFar", "noRetriesSoNear", "noRetrysSofar", "noRetryingsoFar", "noRetryingSoFar", "noRetriesYetFar", "noRetrySoNear", "noRetriesSOfar"], "reply": ["queue", "address", "next", "sync", " replied", "prefix", " replies", "service", "request", "send", "ply", "feed", "reason", "response", "server", "answer", " Reply", "dy", "repl", "respond", "base", "ping", "error", "fee", "bot", "connection", "state", "comment", "code", " answer", "info", "job", "py", "lie", "result", " response", "rc", "Reply", "link", "resp", "post", "ret", "count", "status", "message"]}}
{"id1": "8132219", "id2": "13852596", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "label": 1, "substitutes": {"inFile": ["inPlace", "infile", "InFilename", " infile", "outFiles", "binfile", "binFiles", "outPlace", "InSourceFile", "inputfile", "binPlace", "INFilename", " inFilename", "inputFiles", "inputPlace", "binFile", "INfile", "outfile", "Infile", "inSourceFile", "inFiles", "inFilename", "InFile", "inputFile", "INFile", " inSourceFile", "INSourceFile"], "outFile": ["infile", "outFilename", "outFiles", "outputFile", "outputFiles", "outputfile", "outPlace", " outPlace", "againPlace", " outFiles", "outfile", "outputFilename", "inFiles", "inFilename", " outFilename", " outfile", "againFilename", "outputPlace", "againFile", "againfile"], "in": ["f", "x", "a", "data", "inn", "source", "i", "ic", "is", "input", "base", "din", "file", "url", "reader", "part", "rin", "ins", "bin", "m", "connection", "inner", "io", "image", "name", "c", "as", "In", "work", "n", "inc", "IN", "ini", "like", "config", "index", "again", "pin", "id"], "out": ["ext", "dot", "version", "OUT", "x", "prefix", "data", "user", "string", "resource", "output", "line", "Output", "writer", "Out", "p", "v", "file", "conn", "plain", "part", "w", "bin", "call", "to", "io", "image", "buffer", "default", "name", "client", "obj", "o", "c", "b", "outs", "write", "exec", "external", "n", "cache", "log", "ex", "copy", "null"], "inChannel": ["outStream", "outLanguage", "inputchannel", "INConnection", "iniChannel", "inChan", "inputChannel", "INSocket", "INFlow", "sinSocket", "inputStream", " inChan", "iniStream", "inichannel", "outchannel", "outChan", "winLanguage", " inSocket", "outConnection", "winChannel", " inFlow", "winchannel", "inFlow", " inchannel", "sinChan", "inConnection", "inLanguage", "inchannel", " inConnection", "INChannel", "INChan", "inSocket", "inputChan", "inStream", "sinFlow", "iniLanguage", "winStream", "INStream", "sinChannel", "INchannel"], "outChannel": ["outStream", "outContext", "OutChan", " outPath", "newContext", "outPath", "inChan", "OutChannel", "OutContext", "OutStream", "newStream", "outchannel", "outChan", " outContext", "outConnection", " outchannel", " outChan", " outConnection", "againchannel", "inConnection", "OutConnection", "againChannel", "newChan", "againPath", " outStream", "inchannel", "newChannel", "outputChannel", "outputchannel", "againChan", "outputChan", "inPath", "Outchannel"]}}
{"id1": "14794404", "id2": "1097147", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"password": ["address", "prefix", "data", "content", "words", "wd", "string", "resource", "path", "token", "input", " passwords", "text", "username", "p", "database", "array", "params", "phrase", "secret", "connection", "buffer", "name", "device", "channel", "email", "pattern", "Password", "description", "pass", "cache", "definition", "PASS", "crypt", "padding", "enc", "word", "attribute", "object", "sword", "message"], "encryptedPassword": ["encryptedCode", "encryptedpassword", "ryptedCode", "encryptedPass", " encryptedPass", "ryptedpassword", "ryptedPass", "ryptedString", " encryptedCode", "protectedpassword", " encryptedString", "protectedString", "ryptedPassword", "protectedPassword", "lockedString", "encryptedString", "protectedCode", "lockedPass", "lockedPassword", "protectedPass", "lockedpassword", " encryptedpassword"], "md5": [" md512", " md4", "dig5", "amd2", " MD5", "MD2", "mddown", "amd4", "MD45", "amd6", "digdown", " MD2", " md6", " md2", "md512", "dig4", "MD4", "dig2", "dig3", "MD6", "MD512", "MDdown", " md3", " MD3", "md45", "MD3", " mddown", "md3", "md2", " md45", "md4", "md6", " MD512", "amd5", "MD5", "dig45"], "digest": ["mdest", "mdenge", " digment", "encester", "Digher", "digace", " digash", "digash", "Digace", "mdash", "encest", "digests", " digace", "Digested", "signest", "Digester", "digester", "signester", "encash", "signested", " digester", "mdested", " digests", " digenge", "Digests", "signests", "digested", "digher", "mdests", "digenge", " digher", "mdher", "mdace", "digment", "mdment", "encment", "Digenge", "Digest", "mdester"], "i": ["hi", "phi", "f", "length", "x", "d", "it", "ui", "ti", "ie", "uri", "bi", "ci", "gi", "qi", "di", "t", "h", "pi", "zi", "p", "v", "ix", "ai", "u", "k", "io", "s", "ip", "ii", "o", "c", "b", "I", "multi", "ri", "j", "l", "si", "li", "r", "oi", "index", "xi", "e", "id"], "hex": ["ext", "lit", "rex", "length", "bits", "prefix", "digit", "data", "check", "alpha", "string", "sex", "none", "shift", "slice", "str", "sign", "di", "buff", "zip", "nexus", "binary", "text", "pixel", "utf", "ix", "mix", "num", "temp", "closure", "stick", "bin", "pex", "exp", "oct", "char", "letter", "ip", "hash", "comp", "serial", "coord", "pattern", "pack", "ctr", "ex", "enc", "bit", "null", "rh", "id"]}}
{"id1": "3266833", "id2": "13063241", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"is": ["ir", "lis", "ris", "iss", "iris", "abs", "i", "es", "ais", "has", "ib", "us", "isu", "iv", "its", "init", "bs", "isa", "os", "iso", "fits", "in", "ins", "get", "ip", "image", "bis", "cms", "IS", "mis", "ws", "ios", "info", "as", "was", "or", "close", "Is", "isc", "im", "id"], "name": ["named", "address", "filename", "prefix", "version", "data", "format", "string", "no", "domain", "alias", "word", "source", "path", "label", "vision", "this", "search", "nice", "parent", "value", "base", "large", "database", "min", "file", "office", "url", "part", "directory", "type", "one", "connection", "NAME", "image", "module", "title", "Name", "code", "space", "ame", "term", "description", "size", "memory", "pass", "n", "key", "default", "null", "names", "id"], "contentType": ["mediaType", "messageName", "mediaPath", "messagetype", "Contenttype", "ContentTypes", "outputTypes", "ContentType", "contentInfo", "contentPoint", "documentInfo", "sourceInfo", "documenttype", "messageInfo", "sourceType", " contenttype", "ContentPath", "messageType", "ContentInfo", "contentPath", "mediaTypes", "contenttype", " contentInfo", "outputType", "contentTypes", "documentType", "outputPath", " contentPoint", "sourcetype", "sourcePoint", "contentName", "ContentName", "outputName", "documentPoint", " contentName", "mediaName"], "index": ["number", "expression", "address", "length", "x", "fix", "prefix", "data", "content", "alpha", "string", "i", "weight", "end", "none", "slice", "id", "input", "list", "search", "value", "error", "shape", "page", "in", "timeout", "type", "level", "offset", "image", "open", "update", "multi", "write", "width", "size", "axis", "include", "inc", "position", "Index", "key", "body", "height", "append", "default", "pointer", "pull", "depth"], "extension": ["configance", "variensions", "variension", "Extension", "configensions", "variuration", "Extance", "extance", "extensions", "Extensions", "configuration", "variance", "Exturation", "exturation", "configension"], "isImage": ["areImage", "areFile", "isimage", "ISFile", "IsVideo", "ISImage", "asImage", "IsPicture", " isInstance", "areMedia", "IsFile", " isPicture", "areImages", "isPicture", " isVideo", "isaImage", "ISPicture", "isImages", "ISVideo", "asInstance", " isFile", " isMedia", "isaImages", "IsImage", "areimage", "isaMedia", "isInstance", "isFile", "isVideo", "asimage", "isaFile", "areInstance", "asFile", " isimage", "isMedia", " isImages"], "isAux": ["isUux", "isAsx", "isOAUX", " isHax", "asAExcept", "isAsux", "isAAru", " isArrayUX", "isAxt", "isAAux", "isAcru", "isArrayxt", "isAlux", "isHaUX", "isHax", "isAslux", "isAnux", " isArrayux", "asAux", "isWalux", "isOAExcept", "asAlux", "isAcux", "isUExcept", "isAExcept", " isAxt", "asAsex", "isAcUX", " isHaUX", "isAex", " isAUX", " isArrayxt", " isHalux", "isAnex", "isHalux", "isAAUX", "isWaux", "asAUX", "isOAlux", "isOAux", "isAnUX", "isAsExcept", "isUex", "isAx", "isWaUX", "isWax", "asAsUX", "isAsex", "isHaux", "isArrayru", "isAUX", " isArrayru", "isAAxt", "isArrayux", "isAru", "isUUX", "isUlux", "asAslux", "isAsUX", " isHaux", "isAcxt", "asAsux", "isArrayUX", "asAsExcept", " isAlux", " isAru", " isAx", "asAex", "isAnlux"], "out": ["ext", "extra", "next", "sync", "OUT", "version", "a", "data", "prefix", "user", "socket", "source", "word", "output", "off", "project", "input", "this", "again", "parent", "Out", "base", "array", "error", "file", "page", "in", "conn", "part", "plain", "temp", "exp", "io", "inner", "table", "image", " in", "buffer", "up", "client", "obj", "o", "outs", "exec", "result", "size", "outer", "over", "cache", "auto", "post", "pool", "at", "work", "ex", "copy", "object", "null"], "bufferedImage": ["BufferedImage", "buffledimage", "bufferedimage", "Bufferedimage", "buffledImage", "bufferingImage", "BufferingImage", "buffendedImage", "Bufferingimage", "buffendedimage", "bufferingimage"], "inputStream": ["Inputstream", "InputSteam", " inputSteam", "outputSteam", "outputstream", "inputstream", "inputSteam", " inputstream", " inputBuffer", "outputBuffer", "InputBuffer", "inputBuffer", "InputStream", "outputStream"]}}
{"id1": "11082670", "id2": "22442270", "code1": "    @SuppressWarnings(\"unchecked\")\n    public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException {\n        StringBuilder json = new StringBuilder();\n        String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n        try {\n            URL url = new URL(requestUrl.toString());\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                json.append(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            throw new GtugsException(e);\n        }\n        List<Event> events = new ArrayList<Event>();\n        JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString());\n        JSONArray results = (JSONArray) jsonObj.get(\"results\");\n        for (int i = 0; i < results.size(); i++) {\n            JSONObject result = (JSONObject) results.get(i);\n            Event e = new Event();\n            e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\")));\n            e.setCity((String) result.get(\"venue_city\"));\n            e.setDescription((String) result.get(\"description\"));\n            e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\")));\n            e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\")));\n            e.setName((String) result.get(\"name\"));\n            Date myDate = null;\n            String time = (String) result.get(\"time\");\n            try {\n                myDate = meetupDateFormat.parse(time);\n                e.setStartTime(timeDateFormat.format(myDate));\n                e.setEndTime(timeDateFormat.format(myDate));\n                e.setStartDate(myDate);\n                e.setEndDate(myDate);\n                String tz = tzDateFormat.format(myDate);\n                if (tz != null && tz.startsWith(\"+\")) {\n                    tz = tz.substring(1);\n                }\n                e.setTimeZone(Integer.toString(Integer.parseInt(tz) / 100));\n            } catch (ParseException ex) {\n                ex.printStackTrace();\n                continue;\n            }\n            e.setState((String) result.get(\"venue_state\"));\n            StringBuilder addressBuilder = new StringBuilder();\n            if (result.get(\"venue_address1\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address1\") + \" \");\n            }\n            if (result.get(\"venue_address2\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address2\") + \" \");\n            }\n            if (result.get(\"venue_address3\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address3\") + \" \");\n            }\n            if (result.get(\"venue_address4\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address4\"));\n            }\n            e.setStreetAddress(addressBuilder.toString().trim());\n            e.setZipCode((String) result.get(\"venue_zip\"));\n            e.setUrl((String) result.get(\"event_url\"));\n            events.add(e);\n        }\n        return events;\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 1, "substitutes": {"groupIdentifier": ["groupidentification", "groupPurifier", "groupIdifier", "groupIdentifiers", "groupIdentcher", "groupIdcher", " groupIdentifiers", "groupIdifiers", " groupIdentifer", "groupidentifiers", " groupIdentification", "groupPurifiers", "groupidentcher", "groupidentifer", "groupidentifier", "groupIdifer", "groupPurifer", "groupIdentifer", "groupPurification", "groupIdentification", " groupIdentcher"], "json": ["data", "request", "string", "son", "ssl", "xml", "output", "token", "status", "feed", "id", "response", "http", "server", "zip", "input", "list", "text", "value", "html", "jack", "query", "txt", "array", "photo", "database", "rss", " JSON", "get", "io", "sql", "info", "obj", "struct", "build", "j", "journal", "description", "twitter", "js", "key", "body", "api", "JSON", "message"], "requestUrl": ["requestText", "RequestURI", " requestFeed", "RequestURL", "useURL", "useURI", " requestText", "RequestText", "requestString", "useString", " requestString", "useUrl", " requestURL", "requestFeed", " requestURI", "responseUrl", "requestURL", "RequestFeed", "RequestString", "RequestUrl", "requestURI", "responseText", "responseURL", "responseFeed"], "url": ["address", "f", "bel", "data", "socket", "uri", "user", "service", "ssl", "string", "source", "resource", "web", "path", "rule", "server", "http", "hub", "sl", "input", "URL", "base", "file", "gl", "connection", "io", "buffer", "image", "client", "channel", "job", "b", "l", "stream", "Url", "key", "api", "r", "out"], "in": ["gin", "f", "serv", "data", "inn", "ssl", "con", "line", "read", "fr", "is", "input", "init", "kin", "min", "din", "lin", "reader", "rin", "impl", "ins", "er", "bin", "into", "err", "io", "inner", "s", "buffer", "image", "b", "c", "l", "In", "stream", "inc", "IN", "ini", "r", "login", "out", "again", "pin", "id"], "inputLine": ["inputData", "outputBlock", "pullChar", "audioByte", "inputline", "outputReader", "inputEl", "eventChar", "pullUrl", "outputData", "InputLine", "eventLine", "inputUrl", "eventBlock", " inputByte", " inputChar", " inputBlock", "inputChar", "outputEl", "outputline", "outputByte", "outputLine", "inputByte", " inputReader", " inputData", "inputReader", "eventUrl", "InputBlock", "audioLine", "pullBlock", "inputBlock", "pullLine", "audioEl", "Inputline", " inputUrl", "audioReader", "InputData", " inputEl", " inputline"], "events": ["comments", "features", "lists", "ents", "actions", "times", "es", "Events", "effects", "issues", "views", "members", "reports", "groups", "alls", "items", "errors", "rows", "tests", "fires", "files", "services", "forms", "pages", "plugins", "scenes", "dates"], "jsonObj": ["responseObj", " jsonArray", "sonExt", "jsonObject", "responseVol", "jsonobj", "xmlObj", "jsonArray", "xmlobj", "sonObj", " jsonObject", "xmlVol", " jsonVol", "JSONObj", "jsonVol", "JSONobj", "JSONExt", "sonStr", "jsonExt", "responseArray", "xmlObject", "responseObject", "xmlExt", "jsonStr", "sonobj", "JSONStr", "xmlStr", "xmlArray"], "results": ["comments", "data", "features", "words", "changes", "times", "es", "rules", "successful", "ries", "Events", "stats", "ventures", "resources", "blocks", "response", "points", "ings", "reports", "groups", "its", "jobs", "items", "errors", "rows", "params", "Results", "res", "games", "shows", "qs", "s", "Result", "forms", "objects", " Results", "pages", "runs", "details", "vals", "versions", "places", "values", "js", "roads", "RESULTS", "dates", "r", "series", "projects", "terms"], "i": ["hi", "phi", "f", "x", "ori", "ui", "ti", "uri", "ie", "bi", "ci", "gi", "qi", "slice", "mu", "di", "pi", "chi", "p", "v", "ix", "ai", "u", "type", "iu", "io", "inner", "ip", "ii", "info", "c", "ri", "I", "multi", "fi", "j", "n", "uni", "si", "vi", "li", "ini", "oi", "ji", "index", "xi", "eni", "id"], "result": ["session", "found", "data", "row", "user", "request", "section", "resource", "profile", "successful", "success", "output", "rule", "role", "rh", "particip", "response", "status", "plus", "entry", "sr", "goal", "game", "function", "event", "error", "venture", "part", "res", "manager", "product", "err", "style", "comment", "Result", "job", "details", "order", "match", "term", "feature", "ver", "view", "report", "r", "complete", "record", "default", "back", "info", "date", "message"], "e": ["d", "ente", "ze", "ev", "ffe", "entry", "pe", "ce", "er", "de", "ge", "element", "y", "ye", "f", "g", "ite", "E", "v", "u", "exc", "ee", "en", "me", "fe", "ep", "r", "complete", "ane", "none", "ga", "esi", "eve", "re", "a", "je", "ception", "es", "ue", "line", "see", "eu", "el", "entity", "se", "m", "s", "ec", "c", "oe", "we", "or", "ele", "enter", "be", "it", "ie", "te", "t", "p", "event", "error", "eur", "one", "err", "ea", "ed", "o", "b", "l", "ne", "ae"], "myDate": ["MYTime", " myDay", "yourDay", "anyDate", " myDat", "anotherTime", "anotherdate", "MyTime", "yourDate", "anyGe", "anyTime", " myGe", "Mydate", " myYear", "hisGe", "anyYear", "anyDat", "myTime", "myDat", "hisTime", "hisDate", "anotherDate", "MyDate", "hisDat", "yourTime", " mydate", "myDay", "hisdate", "MYDat", "mydate", "MYYear", "anotherDay", "yourDat", "myGe", "MyDay", "myYear", "MyDat", "MYDate", " myTime"], "time": ["Time", "video", "length", "delay", "version", "live", "data", "depth", "format", "string", "times", "home", "end", "money", "host", "cost", "message", "hour", "duration", "TIME", "value", "am", "event", "rate", "volume", "ime", "timeout", "type", "price", "location", "image", "name", "code", "clock", "year", "timer", "size", "start", "work", "loc", "date", "etime", "id"], "tz": [" locale", " zone", "Delta", "Offset", "Local", " zones", "z", "Year", "fc", "zone", "Zone", "Timeout", "DT", "Clock", "offset", " clock", "clock", "ss", "at", " GMT", "loc", "GMT", "local", " offset", "def", " timestamp", "Z", "UTC"]}}
{"id1": "20623709", "id2": "4895903", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public List load(String sourceType, Object source, String param) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"load \" + source);\n        }\n        String location = null;\n        String type = null;\n        Object inputsource = null;\n        if (source instanceof DynamicMBean) {\n            sourceType = \"MbeansDescriptorsDynamicMBeanSource\";\n            inputsource = source;\n        } else if (source instanceof URL) {\n            URL url = (URL) source;\n            location = url.toString();\n            type = param;\n            inputsource = url.openStream();\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof File) {\n            location = ((File) source).getAbsolutePath();\n            inputsource = new FileInputStream((File) source);\n            type = param;\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof InputStream) {\n            type = param;\n            inputsource = source;\n        } else if (source instanceof Class) {\n            location = ((Class) source).getName();\n            type = param;\n            inputsource = source;\n            if (sourceType == null) {\n                sourceType = \"MbeansDescriptorsIntrospectionSource\";\n            }\n        }\n        if (sourceType == null) {\n            sourceType = \"MbeansDescriptorsDigesterSource\";\n        }\n        ModelerSource ds = getModelerSource(sourceType);\n        List mbeans = ds.loadDescriptors(this, location, type, inputsource);\n        return mbeans;\n    }\n", "label": 0, "substitutes": {"targetDirectory": [" targetRoot", "targetRoot", "TargetDirectory", "destDirectory", "outputFile", "currentPath", "outputFolder", "TargetCollection", " targetFolder", " targetPath", "destFile", "TargetPath", "TargetDir", "TargetRoot", "contentCollection", "basePath", "TargetFile", "currentDirectory", "currentDir", " targetFile", "baseFile", "baseFolder", "outputDirectory", "contentDir", "targetPath", "TargetFolder", "contentPath", "baseCollection", "targetFile", "baseDirectory", "destFolder", "targetDir", "contentDirectory", "targetFolder", "currentRoot", "targetCollection", "outputDir", "destDir", "baseDir", " targetDir", "currentFolder"], "prefix": ["number", "queue", "filename", "template", "patch", "format", " suffix", "uri", "string", "domain", "prot", "resource", "path", "username", "folder", "base", "root", "txt", "processor", "fp", "ix", "first", "temp", "timeout", "type", "directory", "FIX", "Pref", "offset", "unit", "name", "pre", "pattern", "resolution", "cache", "append", "padding", "config", "index", "fix", "sequence"], "maxUnitBases": ["maxunitBasks", "maxUnitPlaches", "maxUnitPlase", "maxunitAliasing", "maxUnitMaches", "maxUnitMases", "maxunitBases", "maxUnitChase", "maxUnitBasing", "maxunitAliasks", "maxUnitAliaches", "maxunitAliases", "maxunitBasing", "maxUnitMase", "maxUnitChasing", "maxunitBaches", "maxUnitBase", "maxunitAliase", "maxUnitPlases", "maxUnitAliases", "maxunitBase", "maxunitAliaches", "maxUnitPlasing", "maxUnitMasing", "maxUnitAliasing", "maxUnitChases", "maxUnitAliasks", "maxUnitAliase", "maxUnitChasks", "maxUnitBasks", "maxUnitBaches"], "maxUnitEntries": ["maxunitEntrys", "maxUnitEntryrs", "maxUnitEntents", "maxUnitIntrys", "maxunitEntryrys", "maxUnitEntryry", "maxUnitCountrs", "maxUnitEntrs", "maxUnitCountries", "maxUnitEntry", "maxunitEntryries", "maxunitCountry", "maxunitEntrs", "maxunitCountries", "maxUnitSequrys", "maxUnitCountrys", "maxunitCountrys", "maxunitEntry", "maxUnitEntrys", "maxUnitentries", "maxUnitEntryures", "maxunitEntryies", "maxUnitentrs", "maxUnitEntryies", "maxUnitEntryrys", "maxunitEnties", "maxUnitCountures", "maxUnitEntryries", "maxUnitSequies", "maxUnitSequents", "maxUnitCountry", "maxUnitIntries", "maxUnitEntryents", "maxUnitEnties", "maxUnitentrys", "maxUnitSequries", "maxunitCountrs", "maxUnitInties", "maxunitEntents", "maxUnitentry", "maxUnitEntures", "maxunitEntryents", "maxunitEntries", "maxUnitIntents"], "fis": ["affai", "cci", "fii", " fai", " fisa", "bos", " fris", "fai", "Fris", "fris", "cisa", "bai", "Fis", "cris", " fii", "fisa", "bis", "affii", "bii", "affos", "cis", "affis", "Fisa", "Fci"], "fci": ["ofco", "Foci", "fii", "frco", "sfcy", "fai", "ofcf", "lfco", "lcy", "sfai", "sfci", "Fco", "fcf", "frni", "lci", "ofci", "ofni", "Fai", "lfii", "lai", " fii", "lco", " foci", " fni", "foci", "frci", "sfco", "lfoci", "lfci", "frcf", "fcy", "Fii", "fni", "Fcy", "Fci", " fcf"], "fos": ["Fos", "fOS", "infoss", "infOS", "xos", " fo", "xOS", "Fis", " fcos", " foss", "Foss", "foss", "eo", "fo", "ecos", "eos", "infos", "xo", "infis", "fcos", " fOS", "xcos", "eOS", "FOS"], "fco": ["cci", "lcos", "gcos", "fcon", "fscon", " foc", "fico", "foc", "fsco", "lro", " fcon", "fsci", "fro", " fcos", "lci", "hco", "gci", "gco", "hico", "coc", "lco", "fscos", " fro", "hci", "cro", " fico", "cco", "hcos", "fcos", "lico", "loc", "gcon"], "buffer": ["number", "loader", "queue", "border", "bar", "expression", "length", "uffer", "data", "port", "reference", "flush", "texture", "counter", "request", "wave", "resource", "document", "feed", "zero", "layer", "capacity", "response", "server", "bc", "entry", "holder", "iter", "buff", "buf", "pause", "input", "writer", "binary", "scale", "base", "rate", "vector", "transfer", "reader", "translation", "timeout", "bin", "comment", "offset", "header", "image", "device", "Buffer", "batch", "channel", "callback", "result", "cube", "size", "memory", "cache", "view", "position", "null", "copy", "info", "message"], "currentBasesCount": ["currentBasingCounter", "currentBasingcount", "currentChaseCounter", "currentBancesCount", "currentBasescount", "currentBancesCounter", "currentBaseCount", "currentBasingCount", "currentBasesCounter", "currentBancescount", "currentChaseCount", "currentChasecount", "currentBasecount", "currentBaseCounter", "currentChasescount", "currentChasesCounter", "currentChasesCount"], "currentEntriesCount": ["currentEntriesSize", "currentAddoriesSize", "currentAddriesLimit", "currentAddriesCount", "currentEntirsSize", "currentEntmissionsSize", "currentEntoriesAmount", "currentEntriesAmount", "currentEntmissionsAmount", "currentEntriesLimit", "currentAddoriesCount", "currentAddriesSize", "currentEntirsAmount", "currentEntoriesSize", "currentEntirsLimit", "currentEntmissionsCount", "currentAddoriesLimit", "currentEntirsCount", "currentAddoriesAmount", "currentEntoriesCount", "currentEntmissionsLimit", "currentEntoriesLimit", "currentAddriesAmount"], "targetCount": ["argetcount", "parentCount", "Targetcount", "TargetCount", "parentSize", "TargetSize", "parentcount", "targetcount", "targetSize", "argetSize", "argetCount"], "fastaChannel": ["fastasConnection", "fastaChan", "fastanaTexture", " fastAConnection", " fastaChan", "fastaTexture", "fastAChan", "fastATexture", " fastaContainer", "fastABuffer", "fastasContainer", " fastATexture", " fastAContainer", "fastasChannel", "fastanaContainer", " fastaConnection", " fastAChan", "fastasChan", "fastasBuffer", "fastanaBuffer", "fastaConnection", "fastAConnection", "fastaiConnection", "fastaContainer", "fastaiChan", "fastasTexture", "fastanaChannel", "fastAContainer", "fastAChannel", "fastaiBuffer", " fastAChannel", "fastaiChannel", " fastaTexture", " fastABuffer"], "totalSeqCount": ["totalSeqsSize", "totalSeqSize", "totalSequeNum", "totalSeqNum", "totalSequeCounter", "totalSeQCount", "totalSeqsNum", "totalSeQNum", "totalSequeCount", "totalSeqCounter", "totalSeQSize", "totalSeqsCount", "totalSeqsCounter", "totalSeQCounter", "totalSequeSize"], "totalResiduesCount": ["totalResinuesCount", "totalResiduescount", "totalResinuesCounter", "totalResiduecount", "totalResiduingCount", "totalResiduesCode", "totalResiduingCode", "totalResinuescount", "totalResiduumcount", "totalResidueCode", "totalResinuecount", "totalResinueCounter", "totalResinueCode", "totalResiduingcount", "totalResiduumCode", "totalResidueCounter", "totalResiduumCount", "totalResiduesCounter", "totalResinuesCode", "totalResiduingCounter", "totalResidueCount", "totalResiduumCounter", "totalResinueCount"], "prevTime": ["viousCount", "trainTIME", "viousTime", "prevCounter", "viousCounter", "trainCount", "prevTIME", "trainCounter", " prevCount", " prevTIME", " prevCounter", "trainTime", "viousTIME", "prevCount"], "fastaFileSize": ["fastaHeaderName", "fastAFileLength", "fastaBufferSize", "fastAFileStore", "fastasFileAddress", "fastaFilesLength", "fastasHeaderName", "fastasFileName", "fastaBufferCount", "fastABufferCount", "fastaFilesAddress", "fastasFileSize", "fastaHeaderLength", "fastaFileName", "fastABufferStore", "fastaStreamName", "fastasHeaderLength", "fastaFilesName", "fastABufferSize", "fastaFileLength", "fastaFileStore", "fastAFileSize", "fastaBodyLength", "fastasHeaderSize", "fastaLineLength", "fastaHeaderSize", "fastaStreamAddress", "fastaStreamLength", "fastAFileCount", "fastaBodyStore", "fastasHeaderAddress", "fastaStreamSize", "fastaFileCount", "fastaFilesSize", "fastABufferLength", "fastaBodySize", "fastaFileAddress", "fastasFileLength", "fastaLineCount", "fastaLineStore", "fastaBufferStore", "fastaBodyCount", "fastaBufferLength", "fastaHeaderAddress", "fastaLineSize"], "fastaFileReadOffset": ["fastaBufferWriteoffset", "fastaFileReadLocation", "fastaFileWritePosition", "fastaFilereadOffset", "fastaFilereadPosition", "fastaFileReadLength", "fastaFileReadOff", "fastaBufferWriteLength", "fastaFilesWriteLength", "fastaFileLoadPosition", "fastaFilesReadLength", "fastaFileReadPosition", "fastaFileWriteStart", "fastaFilereadLocation", "fastaFileWriteoffset", "fastaFileLengthoffset", "fastaFileWriteLength", "fastaBufferReadoffset", "fastaFileReaderoffset", "fastaFileLengthStart", "fastaBufferWriteStart", "fastaFilesReadOffset", "fastaBufferReadPosition", "fastaFileReaderStart", "fastaFilesWriteLocation", "fastaFilesReadLocation", "fastaFileReadoffset", "fastaFileLengthLength", "fastaBufferReadOffset", "fastaBufferreadoffset", "fastaFileLoadOffset", "fastaFileReadStart", "fastaFilesWriteOffset", "fastaFileWriteOffset", "fastaFileLengthOff", "fastaBufferreadOffset", "fastaFilereadOff", "fastaFileReaderLength", "fastaBufferreadOff", "fastaBufferReadStart", "fastaFilereadoffset", "fastaBufferWriteOffset", "fastaFileWriteLocation", "fastaFileWriteOff", "fastaFileLengthLocation", "fastaBufferreadPosition", "fastaFileLoadOff", "fastaFileLoadoffset", "fastaFileLengthOffset", "fastaFilereadLength", "fastaBufferReadOff", "fastaFileReaderOffset", "fastaBufferReadLength", "fastaFilesWriteOff", "fastaFilesReadOff"], "partitionStartOffset": ["partitionStartOff", "partitionsEndAlias", "partitionsStartSlot", "partitionsStartOffset", "partitionStartSlot", "partitionRunAlias", "partitionParamOff", "partitionStartAlias", "partitionsEndOffset", "partitionParamAlias", "partitionParamOffset", "partitionEndAlias", "partitionsStartAlias", "partitionsEndSlot", "partitionEndSlot", "partitionsStartOff", "partitionRunOff", "partitionEndOff", "partitionParamSlot", "partitionsEndOff", "partitionRunOffset", "partitionRunSlot"], "bufferSize": ["queueSize", " bufferMode", " buffersize", "bufferSIZE", "queueCount", " bufferLen", "BufferCount", "bufsize", "queueLength", "buffersize", "bufferLen", "sourceMode", " bufferLength", "BufferSize", "sourceSize", "sourceSIZE", "bufSize", "bufferMode", " bufferSIZE", "bufMode", "BufferLen", "bufferCount", " bufferCount", "BufferLength", "queueLen", "sourcesize", "bufferLength", "bufSIZE"], "fastaBuffer": [" fastABuff", "FastaBuffer", " fastasStream", "fastfBuff", "fastasQueue", "fastABuff", "Fastasbuffer", " fastaStream", "fastyBuff", "fastanQueue", "fastAPtr", "fastAbuffer", " fastasChannel", "fastABuffer", "FastanQueue", "fastasStream", "Fastabuffer", "fastaBuff", "fastaFile", " fastasBuffer", " fastaFile", "FastaQueue", "fastasbuffer", "FastanFile", "fastasChannel", "FastanChannel", "FastasChannel", "FastanBuffer", "FastaFile", "fastyChannel", "fastanFile", "fastasFile", "fastasBuffer", "fastanBuffer", "fastaPtr", "FastaChannel", "fastasPtr", "fastAStream", "fastybuffer", "fastasBuff", "fastanStream", "fastfPtr", "fastaStream", "fastAChannel", "FastasBuff", "FastasPtr", " fastaBuff", " fastAFile", "fastfChannel", " fastAChannel", "fastfBuffer", "fastAQueue", "fastanChannel", "fastyBuffer", "fastaQueue", "fastabuffer", "fastanBuff", "FastaBuff", " fastasFile", "FastasBuffer", "fastAFile", "FastaPtr", " fastABuffer"], "fastaReadState": ["fastaFileState", "fastaReaderState", "fastaReaderMode", "fastasReadType", "fastaReadingstate", "fastaReadMode", "fastasReadMode", "fastaFileMode", "fastaFileType", "fastasReaderState", "fastaReaderType", "fastaReadType", "fastasReaderType", "fastaFilestate", "fastasReadState", "fastaReadingState", "fastaReadingType", "fastaReadstate", "fastasReaderstate", "fastaReadingMode", "fastaReaderstate", "fastasReadstate", "fastasReaderMode"], "nBytes": ["NParts", "ninBytes", "iBytes", "NBytes", "nFiles", "Nbytes", "nBlocks", "nPages", "ibytes", "ninByte", " nByte", "NBlocks", " nPages", "numBytes", "cParts", "cPages", "numbytes", " nBlocks", "cbytes", " nbytes", " nParts", "nbytes", "numFiles", "ninBlocks", " nFiles", "NByte", "ninParts", "iBlocks", "iFiles", "numBlocks", "nByte", "cBytes", "nParts", "NPages"]}}
{"id1": "13152325", "id2": "293167", "code1": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"classLoader": [" classLoad", "classesLoad", " classloader", "CLASSLoading", "classPath", "Classloader", "CLASSloader", "classLoad", "resourceLoading", "classloader", "ClassLoad", "classParser", " classPath", "ClassLoader", "classesLoading", "CLASSLoader", "ClassPath", "resourceLoader", " classLoading", "ClassParser", "CLASSParser", "ClassLoading", "classesLoader", "resourceloader", "classLoading", " classParser", "resourcePath", "classesloader"], "antlibUrl": ["antlabAddress", "artlibUr", "artlibraryJar", "antlrStr", "antlibraryJar", "ntlibJar", "antLibUrl", "antlibraryUrl", "artlibraryUrl", "antlibraryUr", "antlibAddress", "antribURL", "antlibJar", "ntLibURL", "antribJar", "antlibraryAddress", "ntlibUrl", "antlibStr", "ntlibURL", "ntlibStr", "artlibUrl", "antlabJar", "antlabUr", "artlibraryAddress", "antlibUr", "antlibFile", "antlrURL", "antLibUr", "antLibAddress", "ntLibUrl", "ntLibStr", "antlibraryStr", "artlibJar", "antLibStr", "ntlibFile", "antlrUrl", "antlabUrl", "antLibJar", "artlibraryUr", "antlibraryURL", "artlibAddress", "antlrFile", "antlibraryFile", "antLibFile", "antLibURL", "ntLibJar", "antlibURL", "ntLibFile", "antribUrl", "antribFile"], "antlibUri": ["antlibAri", "antlibCini", "antLibUni", "antLibUsrio", "antlibraryAri", "antlibUni", "antlibUtRI", "antlibUtifier", "antlibAo", "antlibraryURI", "antlibUris", "antlibUtri", "antlibraryUro", "antLibUsURI", "antlibUsris", "antlibraryAris", "antLibUsri", "antlibUsni", "antlibraryUri", "antlibCurURI", "antlibUini", "antlibBaseo", "antlibURI", "antlibCRI", "antlibCurri", "antlibUtrio", "antlibraryAro", "antlibUsri", "antLibUURI", "antlibraryUo", "antlibraryAo", "antlibBaseris", "antlibUsini", "antlibBaseri", "antlibPatri", "antlibUsrio", "antlibCurrio", "antLibUsRI", "antlibAro", "antLibUsifier", "antlibraryUris", "antlibPatRI", "antlibCurRI", "antlibOris", "antlibUrrio", "antlibOni", "antlibPatris", "antLibUsro", "antlibIri", "antLibUro", "antlibIURI", "antlibCri", "antLibUrio", "antlibAris", "antLibUifier", "antlibUrRI", "antlibUso", "antlibUsURI", "antlibraryCRI", "antlibUtro", "antlibUrri", "antlibraryCini", "antlibCris", "antlibUURI", "antLibUri", "antlibIRI", "antlibUifier", "antlibUtris", "antlibUrio", "antlibPatini", "antlibUo", "antlibOro", "antLibUsni", "antlibraryCri", "antlibUro", "antLibURI", "antlibBasero", "antlibUrifier", "antlibUsro", "antlibUsifier", "antlibOri", "antlibraryCris", "antlibraryUini", "antlibIrio", "antLibUris", "antLibUsris", "antlibUtni", "antlibUsRI"], "resources": ["ids", "loader", "parents", "features", "lines", "ruby", "times", "source", "resource", "ources", "blocks", "server", "packages", "http", "classes", "groups", "reports", "thumbnails", "items", "errors", "relations", "multiple", "rows", "maps", "archives", "events", "res", "files", "Resources", "apps", "roots", "results", "users", "collection", "ries", "pages", "objects", "details", "bytes", "types", "rs", "plugins", "models", "linux", "rules"], "url": ["loader", "ir", "address", "f", "plugin", "jar", "user", "service", "ssl", "string", "source", "i", "resource", "src", "xml", "path", "feed", "host", "layer", "str", "server", "http", "ur", "zip", "sl", "cli", "URL", "base", "root", "file", "page", "location", "connection", "io", "element", "image", "buffer", "name", "route", "b", "ri", "lr", "email", "l", "link", "download", "Url", "addr", "loc", "li", "key", "r", "ource", "config", "e", "id"], "stream": ["loader", "system", "video", "filter", "f", "data", "port", "user", "socket", "ssl", "source", "form", "resource", "document", "per", "path", "feed", "handler", "host", "slice", "response", "read", "http", "server", "zip", "sl", "input", "writer", "context", "raw", "v", "file", "in", "Stream", "er", "io", "buffer", "open", "client", "channel", "view", "pool", "driver", "body", "clean", "r", "out", "coll", "model", "e"], "reader": ["loader", "bird", "f", "rr", "row", "parse", "source", "i", "resource", "Reader", "ler", "per", "feed", "xml", "handler", "server", "read", "editor", "entry", "http", "iter", "iterator", "input", "writer", "reading", "file", "in", "rer", "library", "er", "worker", "err", "connection", "io", "buffer", "rar", "client", "ri", "or", "rc", "parser", "rx", "driver", "r", "upper", "ner", "e", "oder"], "line": ["f", "sync", "plugin", "data", "row", "lines", "user", "parse", "string", "source", "lc", "resource", "end", "xml", "rule", "LINE", "str", "nl", "read", "entry", "pe", "sl", "el", "lf", "liner", "text", "base", "block", "raw", "file", "page", "lin", "inline", "err", "style", "letter", "range", "header", "Line", "name", "code", "job", "o", "write", "le", "l", "pass", "log", "key", "li", "val", "word", "info", "e", "cell"], "pkg": ["install", "filename", "prefix", "plugin", "patch", "rel", "jar", "gp", "wd", "src", "string", "git", "i", "resource", "prot", "alias", "source", "path", "packages", "kg", "lang", "zip", "pp", "lib", "class", "cp", "base", "p", "root", "req", "fp", "file", "library", "type", "ip", "comp", "module", "name", "dir", "cmd", "Package", "po", "pack", "link", "dep", "ph", "qa", "cmp", "loc", "ppa", "info"], "uri": ["address", "plugin", "ui", "service", "string", "source", "i", "resource", "path", "server", "http", "response", "entry", "cli", "URI", "lib", "URL", "olver", "pi", "base", "root", "database", "file", " URI", "io", "collection", "client", "ri", "iri", "uni", "parser", "li", "api", "proxy"], "resource2antlib": ["resource1ntlib", "resource1ntlibrary", "resource2etloc", "resource4antlib", "resource2Antlibrary", "resource4antLib", "resource2entlib", "resource2ntlr", "resource2ntrib", "resource4ntLib", "resource2ntib", "resource4ntlib", "resource1ntLib", "resource2artloc", "resource2etli", "resource2gentlib", "resource1antlibrary", "resource2antlibrary", "resource1antlib", "resource2antloc", "resource2artli", "resource2ntlib", "resource2rtlibrary", "resource4antli", "resource2gentLib", "resource2etlib", "resource2entlibrary", "resource2antlr", "resource4ntloc", "resource2Antlib", "resource2entrib", "resource2gentib", "resource1antib", "resource1antLib", "resource2AntLib", "resource2ntloc", "resource4ntli", "resource2rtlib", "resource2ntLib", "resource2antib", "resource2Antib", "resource2antrib", "resource2artLib", "resource2gentlibrary", "resource2antLib", "resource2etLib", "resource2ntli", "resource1ntib", "resource2rtlr", "resource2rtrib", "resource2entlr", "resource2ntlibrary", "resource2antli", "resource4antloc", "resource2artlib"]}}
{"id1": "8452134", "id2": "310182", "code1": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"fileToCheck": [" fileToWork", "filetoWork", " fileWillCheck", " fileWillcheck", "fileWillWork", "filetoCheck", "entryToCheck", "entryTOcheck", "fileToWork", "fileTOcheck", "fileTOWork", "entryTocheck", "filetoTest", "fileWillCheck", "entryTOTest", "fileTOCheck", "fileToTest", "fileWillTest", "fileTOTest", "entryToTest", "fileTocheck", " fileWillTest", " fileWillWork", "entryTOCheck", "filetocheck", "fileWillcheck", " fileTocheck", " fileToTest"], "ftp": ["pttp", " ftpr", "ctp", " ftr", "ttP", "ntip", "lfpi", "lfp", " ftpy", "ptp", "iftpatch", "oftping", "aftcp", "fttp", "ftop", "oftpc", "fxtp", "fxsp", " ftop", "aftsp", "ptb", "oftop", "fundp", "nowpi", "ftr", "ntp", " ftcp", "etp", "etip", " ftps", "iftpy", "etr", " ftb", " ftP", "lfps", "ftpoint", "ctpoint", "ttp", "ftpi", " fttp", "ttping", "ttcp", "ttpoint", "ctP", "oftp", "fundtp", "iftp", "ufpr", "fxp", "handp", "ftpr", " ftpoint", "lfpr", "aftpi", "ftip", " ftpatch", "ttpc", "ftps", "ftP", "fpi", "ftpc", "fp", "ftpy", "etcp", "ntcp", "afpi", "ptpatch", "ifttp", "iftpo", "fxpi", " ftping", "nowcp", " ftip", "ftping", " ftpc", "ttop", "afcp", "fcp", "ftcp", "ufpi", "ftpatch", "ctcp", "ufps", "handtp", "ftpo", "fpo", "fundpi", "ftsp", "ftb", "handsp", "afp", "aftp", "afttp", "nowp", "ntr", "iftb", " ftpi", "handpi", "fundcp", " ftpo", "ufp", "fpy", "nowtp"], "found": ["defined", "sent", "f", "x", "find", "left", "received", "from", "checked", "successful", "success", "path", "built", "valid", "response", "read", "iter", "Found", "len", "search", "failed", "nt", "error", "only", "file", "first", "expected", "finding", "missing", "installed", "owned", "finder", "err", "used", "given", "ed", "done", "pos", "old", "result", "loaded", "good", "all", "flat", "ret", "val", "count", "index", "default", "active"], "reply": ["sent", "address", "next", "length", "sync", "prefix", "rr", "data", " replies", "service", "request", "from", "send", "status", "ply", "zero", "reason", "response", "server", "read", "answer", "dy", "repl", "cause", "len", "text", "respond", "lying", "base", "query", "error", "ix", "part", "bot", "err", "connection", "call", "comment", "buffer", "force", "code", "info", "echo", "result", "write", "link", "Reply", "article", "resp", "post", "continue", "index", " response", "message"]}}
{"id1": "8588992", "id2": "823074", "code1": "    public ActionForward perform(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String status = null;\n        HttpSession session = request.getSession();\n        ReportingBean reportingBean = null;\n        NewConceptBean conceptBean = null;\n        String conceptName = null;\n        String primitive = null;\n        MessageResources errorMessages = MessageResources.getMessageResources(\"com.apelon.apps.dts.treebrowser.resources.error_messages\");\n        LogonUtilities logonUtilities = new LogonUtilities();\n        if (logonUtilities.checkSession(session, status, reportingBean, errorMessages)) {\n            reportingBean = (ReportingBean) session.getAttribute(\"reportingBean\");\n            if ((reportingBean.getMessageHtml().indexOf(\"Classify\")) == -1) {\n                reportingBean.setReportingHtml(\"\");\n            }\n            conceptBean = (NewConceptBean) session.getAttribute(\"newConceptEntity\");\n            conceptName = request.getParameter(\"conceptName\");\n            primitive = request.getParameter(\"primitive\");\n            if (primitive == null) {\n                primitive = \"false\";\n            }\n            conceptBean.setConceptName(conceptName);\n            conceptBean.setPrimitive(primitive);\n            String namespace = conceptBean.getConceptNamespace();\n            if (namespace == null) {\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_3\"));\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n                return (mapping.findForward(status));\n            }\n            String[] roleMods = request.getParameterValues(\"some_or_all\");\n            String[] roleGrps = request.getParameterValues(\"role_group\");\n            Vector roles = conceptBean.getRoles();\n            RoleBean[] roleCons = new RoleBean[roles.size()];\n            roles.copyInto(roleCons);\n            if (roleMods != null && roleGrps != null && roleCons != null) {\n                if (roleCons.length == roleMods.length && roleCons.length == roleGrps.length) {\n                    for (int i = 0; i < roleCons.length; i++) {\n                        roleCons[i].setSomeOrAll(roleMods[i]);\n                        roleCons[i].setRoleGroup(roleGrps[i]);\n                    }\n                }\n            }\n            session.setAttribute(\"newConceptEntity\", conceptBean);\n            NewConceptXMLDisplayBean xmlBean = new NewConceptXMLDisplayBean();\n            xmlBean.setNewConceptXml(conceptBean);\n            String data = BrowserUtilities.encodeUrl(\"conceptXml\") + \"=\" + BrowserUtilities.encodeUrl(xmlBean.getNewConceptXml()) + \"&\" + BrowserUtilities.encodeUrl(\"nameSpace\") + \"=\" + BrowserUtilities.encodeUrl(namespace);\n            XMLPropertyHandler configPh = new XMLPropertyHandler(\"dtsbrowserclassify.xml\");\n            Properties configProps = configPh.getProps();\n            String urlString = configProps.getProperty(\"url\");\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuffer buf = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                buf.append(line);\n            }\n            String resultXml = buf.toString();\n            wr.close();\n            rd.close();\n            ClassifiedConceptBean ccBean = new ClassifiedConceptBean();\n            ClassifyResultParser parser = new ClassifyResultParser(resultXml);\n            ResultBuilder rbuilder = new ResultBuilder();\n            rbuilder.setConceptBean(ccBean);\n            rbuilder.setParser(parser);\n            rbuilder.setNamespace(namespace);\n            try {\n                rbuilder.buildResult();\n                ccBean = rbuilder.getConceptBean();\n                ClassifiedConceptDisplayBean displayBean = new ClassifiedConceptDisplayBean();\n                displayBean.setNewConceptHtml(ccBean);\n                session.setAttribute(\"classifyResult\", ccBean);\n                session.setAttribute(\"classifyDisplayResult\", displayBean);\n                status = \"success\";\n            } catch (Exception e) {\n                Categories.dataServer().error(StackTracePrinter.getStackTrace(e));\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_1\") + e.getMessage());\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n            }\n        }\n        return (mapping.findForward(status));\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"mapping": ["maming", "Mappings", "fapping", "fappings", "inatching", "inapping", "mmapping", "mashing", "matching", "mmigration", "mappings", " mapper", "mapper", "Mashing", "inaming", "fapper", "inigration", " mashing", "tmatching", "Mapper", "tmaming", "tmapping", "migration", "Mapping", "mmaming", "fashing", "tmigration", "mmatching", " mappings"], "form": ["f", " forms", "template", "format", " submission", "flow", "app", "path", "command", "Form", "page", "method", "change", "submit", "process", "update", "forms", "route", "instance", "stream", "control", "view", "controller", "transform", "report", "config", "object", "model"], "request": ["application", "queue", "join", "version", "child", "re", "condition", "user", "xml", "document", "resource", "remote", "path", "subject", "press", "server", "initial", "project", "input", "context", "q", "query", "req", "event", "page", "method", "image", "submit", "QUEST", "name", "client", "route", "result", "instance", "current", "view", "frame", "position", "enter", "post", "report", "complete", "record", "use", "object", "model", "create", "Request", "message"], "response": ["application", "re", "resource", "xml", "output", "server", "model", " Response", "Response", "json", "reply", "page", "method", "res", "client", "result", "resp", "view", "report", "r", "object", "message"], "status": ["version", "sync", "prefix", "msg", "service", "ssl", "string", "site", "source", "xml", "notice", "output", "success", "stats", "subject", "host", "reason", "server", "id", "str", "model", "sign", "speed", "wait", "json", "html", "exit", "score", "error", "STAT", "uses", "temp", "method", "type", "sort", "security", "state", "stat", "spec", "edit", "warning", "Status", "code", "name", "stage", "update", " Status", "result", "settings", "step", "description", "ss", "current", "complete", "login", "index", "date", "message"], "session": ["application", "account", "child", "Session", "port", "condition", "user", "socket", "service", "sb", "site", "connect", "resource", "document", "container", "source", "ESSION", "token", "subject", "host", "http", "server", "ess", "input", "sa", "context", "search", "entity", "lock", "query", " Session", "gui", "shell", "se", "sp", "temp", "statement", "environment", "manager", "scope", "security", "connection", "state", "thread", "s", "image", "process", "language", "batch", "client", "set", "su", "result", "settings", "ession", "cache", "view", "local", "cookie", "api", "use", "mission", "message"], "reportingBean": ["reportingBoean", "reportingBann", "reportingChean", "reportingMixanc", "reportingGuane", "reportingBehan", "trainingBeann", "trainingBEam", "reportingBEa", "reportBEan", "trainingBeanc", "reportBeean", "reportingBehanc", "reportingRoanc", "reportingBoanc", "reportingBlanc", "reportingRoean", "sharingBEank", "reportingBanc", "reportingMixane", "reportingBEane", "sharingBEan", "ReportingBean", "reportingBeank", "reportingTeen", "sharingBean", "reportingBeon", "trainingBEon", "reportingChanc", "trainingBEanc", "sharingBeank", "ReportingBen", "reportingGuean", "trainingBEa", "ReportingBane", "reportBEean", "reportingTeean", "reportingBehann", "reportingChan", "reportingMixan", "reportingBoanned", "ReportingBeean", "sharingBEean", "ReportingBeen", "reportingGuanned", "reportingChen", "trainingBEean", "reportingBlann", "reportingBeham", "reportingBeanc", "trainingBEann", "reportingBeann", "reportBean", "reportingBeanned", "reportingTea", "reportingBeane", "reportBEam", "reportingBlean", "ReportingBeans", "trainingBeon", "trainingBeen", "reportingMixon", "trainingBeean", "reportingBoan", "reportingBoane", "reportingBeam", "reportingRoam", "reportingBEean", "reportingBEon", "reportingBehean", "reportingBoon", "reportBEanc", "reportingTean", "reportingBehen", "reportingBEann", "sharingBeane", "ReportingBeane", "reportingBen", "reportingBEam", "reportingBoam", "reportingBane", "ReportingBanned", "sharingBeean", "trainingBEan", "trainingBEen", "reportingMixank", "reportingBanned", "reportingBea", "trainingBean", "reportingBan", "reportingBans", "reportingMixann", "reportBeanc", "reportingRoan", "trainingBeam", "reportingBEans", "reportingGuan", "reportingMixam", "reportingBoann", "sharingBEane", "reportingBlan", "reportingBEen", "reportingBeans", "sharingBeann", "ReportingBeanned", "reportingBEanc", "reportingBa", "reportingBeen", "ReportingBans", "reportingBehank", "reportingBeean", "trainingBea", "reportingBehane", "reportingBEank", "reportingBEan", "ReportingBan", "reportBeam", "sharingBEann"], "conceptBean": ["conceptBeane", "conceptEa", "contactBEa", "conceptFean", "conceptBEans", "reportBeean", "conceptPla", "contactBEanch", "conceptFea", "conceptPea", "conceptBEann", "conceptbeean", "conceptEanc", "conceptPean", "contractBEa", "contactBEann", " conceptBehan", "conceptBlean", "contactBean", "reportTeom", "contractBeean", "conceptBehan", "conceptBla", " conceptBeans", "conceptEans", "conceptBeans", "contractBEbean", "conceptBebean", "contractBEean", "conceptTeane", "contractBEanc", "conceptBEan", "contractBeanc", "conceptPeean", "contactBeanch", "conceptBeanch", " conceptBeann", "conceptPebean", "conceptBea", "contractBea", "reportingBeann", "reportBean", "conceptBeean", "contractBEan", "conceptEann", "contractBEans", "conceptPlanc", "conceptBann", "conceptbeom", " conceptBehann", "contactBEan", "conceptBEanc", "reportTeean", "conceptBehane", "contactBeann", "conceptBlbean", "conceptEanch", "conceptBlann", "conceptTean", "contractBean", "conceptBEanch", "reportingBEean", "conceptBehann", "conceptbean", "conceptBEom", "conceptEean", "reportingBEann", "conceptEbean", "conceptFeann", "conceptFeanch", " conceptBehans", "conceptBEane", "conceptBane", "conceptBEa", "reportingBEbean", "conceptEan", "reportTeane", "conceptBeann", "conceptBeom", "conceptBan", " conceptBehane", " conceptBeane", "contractBebean", "conceptBeanc", "conceptBEean", "reportTean", "reportBeom", "reportBeane", "conceptPlans", "conceptBans", "reportingBebean", "conceptBEbean", "contractBeans", "conceptPlan", "conceptTeean", "conceptTeom", "contactBea", "conceptbeane", "reportingBeean", "reportingBEan", "conceptBehans", "conceptBlan"], "conceptName": ["contextFamily", "configNames", "contextAlias", "configName", "contextNames", "businessname", "featureId", "ceptNames", "featureNames", "ceptname", "conceptFamily", "conceptAlias", "ceptName", "businessName", "ceptType", "conceptType", " conceptAlias", "conceptNAME", "contextname", "contextName", " conceptNames", " conceptType", "conceptId", "conceptname", "configname", "conceptNames", "configFamily", "ceptId", " conceptFamily", "businessNAME", " conceptId", "contextType", "ceptAlias", " conceptname", "contextNAME", " conceptNAME", "featureName"], "primitive": ["Primity", "primression", "Primue", "Primicle", "quantue", "primical", "quantitive", "posity", "penative", "perative", "quantression", "Primression", "percer", "pencer", "Primitives", "promical", "posative", "zenitive", " primue", "zenition", "perity", "perical", "penitives", "Primition", "zenity", " primition", " primicle", "primicle", "primitives", " primression", "penitive", "primcer", "Primical", "penity", "posue", "promitives", "peritive", "penical", "promue", "penue", "peritives", "primity", "zenicle", " primity", "positives", "poscer", "promitive", "promity", "positive", "primative", "Primitive", "quantity", "primition", "primue"], "errorMessages": ["errormessules", "errorMules", "errorMessules", " errorBags", "errorChages", "errormessages", "errorMessings", "errorChags", " errormessags", "errorMessagers", "errorMags", " errorMessaging", "errorChings", " errorChaging", "errorMages", "errorMessodes", " errorBings", "errorChodes", " errormessules", "errorMessaging", "errormessags", " errorMessags", " errorBodes", "errorBaging", "errorModules", " errorMessodes", "errorModages", " errorChings", "errormessodes", "errorBages", " errorMessules", "errorMessags", "errorBings", " errorMessings", "errormessaging", "errorBags", " errorChages", "errorModagers", "errormessagers", "errorMagers", " errorBages", " errormessagers", " errorChags", "errorBodes", "errorModags", "errormessings", "errorChaging", " errorMessagers", " errormessages"], "logonUtilities": [" logonsutility", "logonutility", "logonUtiles", " logonMutilities", "logronUtility", " logonUtility", "logonFacils", " logonTility", "logonUtils", " logonutilities", "logonFacility", " logonsUtility", "logonIntils", "logronUtils", " logonsutil", " logonsutils", "logonFaciles", " logonsUtils", "logonutilities", "logronUtilities", " logonMutil", " logonTilities", " logonutil", "logonutils", " logonsutilities", " logonUtils", "logonutiles", " logonutils", " logonUtil", " logonTils", " logonsUtilities", " logonutility", "logonIntilities", "logronutility", "logonIntility", "logronutilities", " logonMutils", "logronutils", "logronUtiles", "logronutiles", " logonMutility", " logonTil", " logonsUtil", "logonFacilities", "logonIntiles", "logonUtility"], "namespace": ["Namesource", "inship", "namesource", "Namespace", "insource", "relationset", "inspaces", "namespaces", "memberspaces", "inset", "relationspaces", "memberset", "inspaced", "nameset", "inspace", " namespaces", "nameship", "namespaced", " nameship", "Namespaces", "relationspace", "relationspaced", "memberspaced", " namesource", "memberspace", "Nameship"], "roleMods": ["ruleOps", " roleUsers", " roleOps", "resourceMod", "RoleMOD", "RoleOps", "RoleMods", "RoleUsers", "ruleUsers", " roleMod", "roleMod", "roleOps", "roleMOD", "resourceMods", "ruleMod", " roleMOD", "roleUsers", "ruleMods", "resourceMOD", "RoleMod"], "roleGrps": ["roleGrPs", "roleGp", " roleGrPS", " roleGps", " roleGpe", "roleGrases", "roleGrpe", "rolegrPS", "rolegrps", "roleGases", "rolegrPs", "roleGRPs", " rolegrps", " rolegrases", "roleGRps", " roleGrases", "roleArpe", "roleArPs", " rolegrPS", " roleGp", "roleGrp", " roleGrPs", " roleGPs", "roleArps", "roleGRpe", "roleGRPS", "roleGPS", " roleGrpe", "rolegrases", "roleGps", " roleGrp", "roleGpe", "roleGPs", " rolegrPs", "roleGRases", "roleGRp", "roleGrPS", "roleArp"], "roles": ["rolvers", "rages", "roleges", "rolevers", "riels", "rowels", "rolges", "rovers", "rile", "roels", "grovers", "role", "rowoles", "rooles", "rolele", "roges", "rolles", "roleoles", "grole", "grooles", "rololes", "rolels", "rowle", "rowles", "rolle", "raels", "groles", "rioles", "raoles", "roleles", "riles", "rales", "roleels"], "roleCons": ["ruleCs", "roleCs", "oleConfig", "ruleCons", "routeCons", "resourceCons", "oleCons", "olecons", "oleValues", "rolecons", "roleValues", " roleValues", "resourcecons", " rolePres", "ruleValues", "roleMembers", "olePres", "ruleMembers", "roleConfig", "ruleConfig", "roleIns", "routeCs", " roleConfig", "rulecons", "oleIns", " roleCs", "resourcePres", "routeMembers", " rolecons", " roleMembers", "resourceIns", "rolePres", " roleIns"]}}
{"id1": "16466743", "id2": "9826240", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"password": ["number", "account", "sword", "encrypted", "address", "f", "prefix", "data", "words", "wd", "string", "token", "path", " Password", "input", " passwords", "text", "username", "p", "array", "phrase", "secret", "buffer", "hash", "name", "email", "pattern", "Password", "pass", "PASS", "key", "crypt", "padding", "enc", "word", "attribute", "config", "login", "auth", "message"], "md": ["material", "cm", "nm", "pd", "um", "d", "sm", "ad", "pm", "hm", "amd", "dc", "db", "sha", "mu", "meta", "mm", "am", "p", "Cmd", "bf", "MD", "dd", "od", "bm", "mand", "ma", "mt", "cb", "m", "ms", " MD", "bd", "rm", "dig", "mb", "hash", "mg", "dm", "cd", "cmd", "mod", "ph", "mac", "mag", "mp", "mc", "mem", "mo", "metadata"], "b": ["bar", "ba", "f", "a", "nb", "rb", "d", "emb", "gb", "bb", "eb", "sb", "bi", "reb", "wb", "db", "ib", "fb", "buf", "buff", "binary", "bs", "base", "p", "orb", "lb", "u", "cb", "ab", "bd", "buffer", "mb", "br", "y", "B", "batch", "bytes", "l", "r", "ob", "be", "e"], "i": ["hi", "phi", "f", "x", "a", "d", "it", "data", "ui", "ti", "uri", "ni", "bi", "end", "ci", "qi", "gi", "slice", "mu", "di", "t", "z", "abi", "pi", "xi", "base", "p", "block", "zi", "v", "ai", "u", "io", "s", "ii", "o", "c", "I", "multi", "ri", "j", "l", "index", "start", "n", "si", "vi", "li", "r", "oi", "ji", "h", "info", "eni", "e", "id"], "pwHash": ["PwStr", " pwdSecret", "pwaSecret", " pwaHash", "pwrSalt", "pWSum", "pwrHash", " pwahash", "pwsSecret", "pWhash", "pwhhash", "pwSalt", " pwSalt", "pwaSalt", "pwaStr", "pwrSum", "PWStr", "pWSalt", "pwsSalt", "pwKey", "pwhSum", "pwStr", " pwdSalt", "pwsHash", "pwdSalt", " pwaKey", "pWHash", "PWSalt", "pwahash", "PwSum", "pwhHash", "pwhKey", " pwhash", "PWSum", "pWStr", "pwSum", "pwdSum", "PwSalt", " pwdHash", " pwKey", "PWHash", " pwSum", "pwaKey", " pwaSum", "pwaSum", "pwdHash", " pwdSum", "pwhash", "pWKey", "PwHash", " pwSecret", "pwaHash", "pwSecret", "pwrStr", "pwdSecret", "pwsSum"]}}
{"id1": "14001795", "id2": "4618237", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"dir": ["ir", "d", "re", "dr", "data", "wd", "home", "container", "div", "dc", "director", "DIR", "handler", "db", "feed", "http", "draft", "di", "zip", "lib", "class", "group", "dist", "desc", "folder", "pkg", "store", "lock", "window", "parent", "url", "file", "fd", "handle", "keep", "directory", " directory", "manager", "io", "up", "cd", "md", "Dir", "build", "download", "direct", "doc", "df", "cache", "work", "log", "cur", "dn", "loc", "def", "clean", "r", "local", "config", "direction", "coll"], "ff": ["cl", "iff", "fed", "bb", "cf", "ck", "fox", "upp", "sf", "uff", "ffe", "flow", "feed", "eff", "ft", "fx", "off", "fb", "pp", "buff", "lf", "bf", "front", "fam", "fp", "dd", "fd", " buff", "cb", "now", "FF", "ffff", "rf", "fff", "aff", "uf", "ph", "df", "fw", "ef", "xff", "fold", "TF", "fe", "fl"], "files": ["data", "features", "lines", "blocks", "pes", "balls", "groups", "iles", "items", "flows", "rows", "file", "events", "ls", "pl", "apps", "Files", "qs", "results", "s", "users", "objects", "pages", "l", "ps", "keys", "models", "images", "split", "fl", "names", "fs", "locks"], "f": [" df", "inf", "d", "cf", "i", "sf", " file", "feed", " fa", "fr", " F", "t", "fb", " fe", "fc", "lf", "File", "F", "fa", "tf", "p", "bf", "fp", "file", "v", "fd", "full", "fen", "of", "name", "fac", "info", "rf", "o", "c", "aff", "l", "n", "fold", "fn", "fe", "r", "fl", " e", "fs", "e"], "newFile": ["createfile", "updateF", " newFiles", "oldfile", "againLine", "createFiles", "newLine", "oldFiles", " newFolder", "andFolder", "updateLine", "createFile", "createFolder", "againEntity", "oldFile", "NewFile", "andFiles", "updateFile", "oldFolder", "NewFiles", "NewFolder", "updateEntity", " newF", " newEntity", "newFiles", "andFile", "Newfile", " newLine", "newFolder", "againFile", "andfile", "newEntity", "newfile", " newfile", "againF", "newF"], "fi": ["cci", "afa", "afe", "ifi", "cf", "gif", "bi", "i", "sf", "ffe", "gi", "uci", "FI", "fr", "aci", "afi", "di", "fb", "ki", "fc", "abi", "fa", "pi", "xi", "zi", "ico", "ifa", "flo", "fp", "ilia", "Fi", "wi", "ii", "sci", "fw", "isi", "si", "vi", "ini", "fe", "fy", "info"], "fo": ["wo", "osa", "afe", "inf", "olo", "ato", "cf", "sf", "ofi", "xf", "di", "afi", "ki", "fa", "flo", "ico", "os", "jo", "fam", "shi", "fif", "zo", "io", "ho", "ko", "info", "o", "FO", "po", "uf", "bo", "ph", "fw", "si", "lo", "osi", "fe", "so", "obi", "mo"]}}
{"id1": "5414088", "id2": "9846843", "code1": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"file": ["queue", "f", "filename", "it", "data", "content", "service", "parse", "source", "resource", "document", "profile", "per", "path", "handler", "db", "line", "http", "model", "input", "lib", "class", "binary", "File", "folder", "parent", "base", "function", "load", "database", "large", "fp", "page", "pic", "full", "part", "single", "type", "connection", "to", "letter", "get", "image", "force", "style", "figure", "future", "module", "name", "code", "info", "space", "FILE", "work", "cache", "current", "log", "picture", "auto", "local", "fe", "config", "use", "object", "null", "create", "global", "show"], "destination": ["constination", "Destinator", "scheation", "constinations", "distination", "boundinated", "configination", "Destinations", "Destinate", "boundinator", "Destribution", " destinations", "destinations", " destinate", "destinated", "Destination", "distined", "scheinations", "boundribution", "restinations", "destined", "scheination", "boundination", "Destinated", "constation", "destation", "targetinated", "restinate", "constinator", "configinated", "configined", "destribution", "scheinator", "destinate", "configinator", "distinator", "distinated", "restination", "targetinator", "destinator", "Destation", "restinator", "Destined", "targetribution", " destinator", "targetination"], "newDataFile": ["newAssetFile", "newVersionFiles", "newStorageFile", "largeDatChannel", "newNewDirectory", "newDatChannel", "newNewFile", "newStorageBase", "newVersionTable", "NewDataDir", "newNewDir", "newDatBase", " newAssetFile", "largeDatBase", " newDataDirectory", "NewVersionFiles", "newDataTable", " newAssetTable", "newVersionLine", "newInfoFile", "newDataLine", "newDataDir", "newDatModule", " newDataFiles", "largeDatFile", "newNewTable", "newContentChannel", "newContentFile", "NewDataFiles", "newStorageModule", "newVersionDir", "newDataBase", "newNewFiles", "NewVersionFile", " newAssetDirectory", "NewDataFile", "largeDataBase", " newDataTable", "newDataDirectory", "largeDataFile", "largeDataChannel", "newStorageChannel", "newAssetTable", "NewVersionLine", "newAssetFiles", "largeDataModule", "newDataChannel", "newAssetDirectory", "NewVersionDir", "newDatFile", "newInfoDir", "newDataModule", "newContentBase", "largeDatModule", "newVersionDirectory", "newDataFiles", "newInfoFiles", "newNewLine", "newContentModule", "NewDataLine", "newInfoLine", " newAssetFiles"], "fileName": [" fileNAME", "fileNAME", "filename", "FileNAME", "serviceName", "FilePath", "Filename", "filePath", " fileType", "FileName", "servicePath", "resourcename", " filePath", "resourceName", "serviceNAME", " filename", "fileType", "resourceType", "resourcePath", "FileType"], "assetsPath": ["imagesFile", "toolsCase", "assetsFile", "antsCase", "assetsTree", "assetsDir", "antsPath", " assetspath", "absoluteFile", "toolsPath", "toolsTree", "toolsDir", "assetspath", "imagesDir", " assetsFile", "antsDir", " assetsDir", "absolutePath", "imagesPath", "absoluteDir", "imagespath", "assetsCase", " assetsTree", "absolutepath", "antsTree", " assetsCase"], "workingFile": ["startingSourceFile", "learningFILE", "lockingFilename", "workingFILE", "movingFilename", "gradingFILE", "pingSourceFile", "writingFilename", "WorkingFile", "workDirectory", "learningFile", "learningFilename", "pingFILE", "pingFile", "workingfile", "learningSourceFile", "trainingSourceFile", "workingFiles", "movingFile", "gradingfile", "WorkingFilename", "movingfile", "workSourceFile", " workingFILE", "workingSourceFile", " workingSourceFile", "movingSourceFile", "trainingStream", " workingDirectory", "WorkingFiles", "processingFILE", "workFiles", "lockingFile", "writingFILE", "trainingFile", "processingFilename", "workingStream", "writingFile", " workingfile", "gradingFilename", "startingStream", "movingFILE", "trainingFILE", "workingFilename", "WorkingFILE", "lockingSourceFile", "processingSourceFile", "processingFile", " workingFiles", "pingStream", "processingfile", "startingFILE", "gradingFile", "WorkingDirectory", "writingSourceFile", " workingFilename", "WorkingSourceFile", "lockingFILE", "startingFile", "writingfile", "workingDirectory", "workFile"], "vc": ["cs", "cu", " c", " db", "cf", "lc", "ci", "CV", "ic", "dc", "RC", "db", " cd", " VC", "pc", "fc", "VC", " cache", "cv", " vm", "GC", "cy", " cf", "cow", " util", "vt", " cc", "hw", "acl", "DC", "vd", " dc", " rc", "ant", "c", "util", "cc", " cs", "CC", "rc", "Controller", "ctrl", "cache", "fw", "ac", "xc", "mc", "vg", "coll", "C"], "is": ["ir", "lis", "address", "ris", "ui", "iss", "isl", "iris", "abs", "i", "does", "ci", "app", "ais", "has", "ois", "us", "iv", "its", "init", "isa", "os", "vs", "in", "iso", "ins", "ls", "ip", "bis", "IS", "ios", "info", "ri", "as", "or", "Is", "are", "js", "isi", "api", "isol", "sis", "id"], "channelFrom": ["imageFrom", "queueTo", "imageTo", "ChannelOrigin", "queuefrom", "Channelfrom", "pageOf", " channelOf", "channelOf", "channelOrigin", "pagefrom", "ChannelFrom", "ChannelOf", "pageFrom", "queueFrom", " channelfrom", "pageTo", "imageOrigin", " channelOrigin", "imageOf", "channelfrom", "queueOf", "ChannelTo"], "newVersionFile": ["NEWVersionDir", "newVersionFiles", "NewDataFunction", "newversionFiles", "newNewFile", "NEWVersioned", "newNewDir", "NewDataDir", "NewVersionFunction", "newTargetDir", "newChannelDir", "newTargetFunction", "newChannelFormat", "newDataFormat", "newversioned", "newDataDir", "newversionFile", "newVersionDir", "newNewFiles", "NEWversioned", "NewVersionFile", "newversionDir", "newDataed", "NewDataFormat", "newDataFunction", "newVersioned", "NewDataFile", "NEWversionDir", "newVersionFunction", "newChannelFile", "newChannelFunction", "NEWVersionFile", "newNewed", "NEWversionFile", "NewVersionDir", "newVersionFormat", "newDataFiles", "NewVersionFormat", "NEWversionFiles", "NEWVersionFiles", "newTargetFile", "newTargetFormat"], "channelTo": ["userFrom", "ChannelTO", "channelFor", "queueTo", "routeFlo", "Channel2", "channel2", "flowOf", "queueTO", "userTo", "channelTO", "Channelto", "flowFrom", " channelFor", "routeFor", "flowto", "userTO", "flow2", " channelTO", "channelFlo", " channelOf", "ChannelFor", "userto", "channelOf", "channelto", "queueto", "ChannelFlo", "ChannelFrom", "flowTo", "ChannelOf", "queueFrom", "routeTo", " channelto", " channel2", "flowTO", "routeFrom", "ChannelTo", " channelFlo"], "writeCurrentChannel": ["writePreviousStream", "changeNewUser", "valuecurrentChannel", "writeNewMessage", " writeStreamStream", " writeThisConnection", "writeThisQueue", "writeThisConnection", " writeStreamChannel", "writeCompleteSquare", " writeStreamChan", "writeCurChannel", "writeStreamChan", " writeStreamUser", "changeCurrentchannel", "writeCurrentSquare", "writeCorrectConnection", "writeCenterChan", "writeCurrentQueue", "writeCurStream", "writeNewchannel", "writeCurPlayer", "changeCurrentMessage", "writeNewChannel", " writeCurrentUser", "writePreviousChannel", "writeCurChan", " writeThisQueue", " writeNewChannel", " writeCurrentSquare", " writeCurrentConnection", "writeNewChan", "writecurrentConnection", " writeNewConnection", "writeCurrentchannel", "changeCurrentUser", "writeCompleteChannel", "writeCurConnection", "writeCurrentMessage", "writeRightMessage", "valueCurrentPlayer", "writeStreamUser", "writeCorrectChannel", " writeThisStream", "writeRightChannel", "writeCorrectStream", "writeThisStream", "writeCenterChannel", "writePreviousChan", " writeCurrentQueue", "writeCurrentStream", "writeNewUser", "writeNewConnection", "valuecurrentPlayer", "writeCurrentUser", "writeCorrectQueue", " writeNewChan", "writeOriginalchannel", "changeNewchannel", "writeCompleteConnection", "writeRightUser", "writeStreamChannel", "changeCurrentChannel", " writeNewSquare", "valuecurrentChan", "writeNewSquare", "writeActiveChannel", " writeThisChannel", "writeCurQueue", "writeCompleteChan", "writeOriginalChannel", " writeCurrentChan", "writecurrentChan", " writeCurrentStream", "writeCurrentChan", "writeActiveChan", "writecurrentPlayer", "writeActiveStream", "writeCurrentConnection", "writeOriginalUser", "writePreviousUser", "changeNewChannel", "valueCurrentChan", "writeRightchannel", "writecurrentSquare", "valueCurrentChannel", "writeCenterPlayer", "writeCurrentPlayer", "writecurrentChannel", "writeStreamStream", "writeOriginalMessage", "writeActiveUser", "changeNewMessage", "writeThisChannel"], "fromChannel": ["toChannel", "fromFile", "newServer", "FromPage", "fromSocket", " fromClient", "fromConnection", "fromButton", " fromPlayer", " fromchannel", "fromClient", "FromServer", " fromPage", "fromchannel", "FromChannel", "newStream", "Fromchannel", "FromConnection", "FromButton", "formStream", "toChan", "formConnection", "toClient", "FromChan", "fromPage", " fromConnection", " fromStream", " fromSocket", "tochannel", " fromChan", "FromPlayer", "formChannel", "toPage", " fromFile", "FromSocket", "FromClient", "fromServer", "newChannel", "FromStream", "FromFile", " fromServer", "fromChan", "toSocket", "newButton", "formPlayer", "toFile", " fromButton", "fromStream", "fromPlayer"], "img": ["f", "data", "Image", "g", " images", "src", "gif", "ie", "gb", "jpg", "i", "hr", "au", "app", "gd", "div", "NG", "ani", "attr", "tmp", "fb", "buf", "iv", "input", "lib", "ng", "p", "v", " image", "pic", "url", "imp", "m", "icon", "io", "agi", "image", "ii", "br", "info", "dir", "obj", "aff", "bg", "cache", "imag", "picture", "auto", "Images", "images", "api", "coll", "im", "map", "png"], "height": ["hi", "gh", "length", "d", "data", "row", "alpha", "flow", "id", "capacity", "h", "input", "thumbnails", "window", "volume", "head", "rows", "shape", "inches", "style", "image", "ip", "header", "pages", "ops", "Height", "resolution", "size", "hd", "crop", "age", "view", "images", "def", "area", "padding", "ensions", "upper", "png", "depth"], "width": ["number", "border", "length", "platform", "data", "core", "port", "left", "weight", "flow", "Width", "path", "wa", "output", "capacity", "layout", "duration", "sl", "writer", "value", "window", "large", "page", "full", "lon", "down", "amount", "widget", "style", "image", "sw", "write", "settings", "size", "crop", "age", "area", "fe", "depth"], "folderPath": ["directoryLocation", "dirLocation", "FolderName", "directoryHalf", "fileDir", "filePath", "FolderDir", "filePoint", "directoryDir", "dirName", "directoryPath", " folderLocation", "directoryPoint", "dirPath", "directoryName", "folderLocation", " folderName", "folderHalf", "dirHalf", " folderHalf", "folderPoint", "FolderPoint", "folderName", "folderDir", "FolderPath"], "directory": ["system", "f", "filename", "d", "relative", "tree", "home", " repository", " Directory", "container", "director", "handler", "server", "project", "list", "folder", "parent", "root", "Folder", "Manager", "database", "volume", "manager", "location", "widget", "connection", "storage", "collection", "archive", "Directory", "dir", "machine", "Dir", " dir", " manager", "l", "direct", "cache", " directories", "area", "direction", "object"], "files": ["f", "parents", "data", "lines", "blocks", "sections", "classes", "iles", "jobs", "items", "fil", "apps", "writers", "Files", "results", "s", "children", "users", "pages", "objects", "places", "images", "split", "packs", "projects", "names", "fs"]}}
{"id1": "812803", "id2": "8490297", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"src": ["inst", "ctx", "filename", "st", "rb", "feat", "ref", "uri", "gb", "ssl", "sb", "source", "string", "resource", "upload", "prot", "Dest", "path", "sin", "RC", "slice", "tmp", "buf", "sth", "input", "sl", "supp", "dist", "username", "secure", "load", "req", "fp", "url", "file", "sc", "reader", "impl", "img", "cb", "gz", "spec", "href", "s", "cpp", "storage", "gn", "vr", "name", "code", "obj", "sit", "sel", "rc", "proc", "download", "stream", "component", "cmp", "dep", "Source", "loc", "fn", "rl", "SourceFile", "ource", "config", "sec", "back", "sn"], "dest": ["target", "orig", "home", "source", "wb", "Dest", "dc", "path", "di", "tmp", "lib", " destination", "class", "dist", "cont", "txt", "temp", "img", "bin", "std", "dir", "obj", "disk", "fn", " dst", "null", "dat"], "in": ["inf", "f", "d", "a", "data", "isin", "inn", "source", "i", "t", "is", "input", "inas", "din", "file", "reader", "ins", "bin", "err", "io", "up", "as", "doc", "win", "ps", "In", "stream", "n", "pass", "inc", "IN", "ini", "r", "ex", "val", "login", "pin"], "p": ["pa", "pb", "pd", "f", "d", "pg", "g", "lp", "pm", "i", "per", "pc", "pe", "t", "h", "pp", "pr", "cp", "pi", "op", "fp", "v", "wp", "bp", "part", "sp", "cop", "m", "s", "py", "o", "pre", "c", "np", "b", "po", "j", "l", "ps", "jp", "parser", "tp", "P", "e"], "ds": ["docs", "d", "uds", "dt", "lp", " db", "ays", "hs", "ads", " DS", "ded", "scripts", "des", "ils", "icks", "ants", "qs", "dm", "vals", "dates", "ld", "sys", "dat", "posts", "ks", "styles", "ans", "pd", "cs", "sync", "data", "words", "points", "dp", "bs", "dd", "gs", "cdn", "Ds", "ups", "rs", "ps", "js", " dd", "sts", "cons", "tools", "els", "lines", "db", "DS", "di", "dist", "amps", "os", "tests", "vs", "dos", "ins", "ls", " sd", "s", "ws", "xs", "ts", "plugins", " props", " ps", "eps", "obs", "gd", "da", "dc", "parts", "dds", "ys", "utils", "nas", "ns", "ss", "df", "models", "dl"], "format": ["filter", "f", "filename", "prefix", "template", "feat", "data", "Format", "plugin", "version", "string", "source", "form", "xml", "path", "handler", "host", "t", "layout", "atter", "class", "tag", "scale", "function", "sche", "fp", "file", "url", "fd", "part", "type", "act", "spec", "style", "letter", "unit", "table", "language", "name", "struct", "ant", "pattern", "nat", "at", "frame", "parser", "fn", "api", "config", "magic", "record", "object", "model", "match"], "hasPixelData": ["hasPictureData", "hasPicOps", "haspixelStyle", " hasPixeldata", "hasBytedata", "hasPicStyle", "hasPixelDATA", "hasPictureDATA", "haspixelData", " hasPixelOps", "hasPixeldata", "hasPixelStyle", "haspixelOps", "hasPicData", "hasByteData", " hasPixelSize", "haspixelSize", "hasPicturedata", "hasPixelSize", "haspixelDATA", "haspixeldata", "hasPixelOps", " hasPixelStyle", " hasPixelDATA", "hasByteSize"], "inflate": [" inflATE", "infloocate", "uninflocate", "infloase", "uninfloute", "uninfloate", "information", "informATE", "incollate", "infloATE", "inflation", "infolute", " information", "infolame", "incollame", "inFlase", "incollocate", "inFlate", "informate", "infloate", "influte", "inflase", "incollute", "uninfloame", "inFlation", "uninflute", "infolate", "informase", "inflame", "infolocate", "infloation", " informase", "uninfloocate", " informate", "infloame", "infloute", "inflocate", "uninflame", " inflation", "inFlATE", " inflase", "inflATE", " informATE", "uninflate"], "pxlen": ["nplin", "pyln", "pxlf", "fxlen", "pngden", "xyfin", "pyden", "pxden", "fxden", "rxfin", "xplength", "xplen", "fxval", "pglf", "xylen", "pyl", "xpval", "cpden", "fxlf", "pxlin", "pxLen", "rxlen", "pylen", "pngln", "pplen", "fxl", "cpln", "pngLen", "rxlin", "nplen", "npden", "xyden", "fxlength", "ppden", "pxval", "pxfin", "pxl", "ppln", "npfin", "rxden", "xyLen", "xylin", "fxln", "pxlength", "xplf", "pxln", "pglen", "cplen", "pnglen", "cpl", "xyln", "ppLen", "pglength", "pgval"], "out": ["session", "dump", "prefix", "OUT", "re", "user", "point", "output", "line", "server", "cli", "lib", "list", "group", "parent", "store", "lock", "Out", "base", "v", "conn", "error", "page", "gen", "err", "inter", "io", "code", "up", "obj", "step", "print", "outs", "work", "cache", "log", "post", "copy", "sys", "again"]}}
{"id1": "9371421", "id2": "9081749", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 1, "substitutes": {"eventstr": ["errorstr", "EventStr", "exstring", "eventdict", "exStr", "Eventstr", "errorsource", "exdict", "exstr", "Eventstring", "errorstring", "eventStr", "Eventsource", "eventsource", "Eventdict", " eventStr", " eventdict", "errorStr", "eventstring", " eventstring", " eventsource"], "md": ["cm", "d", "dh", "dr", "sm", "data", "wd", "ad", "pm", "hm", "em", "amd", "rpm", "sha", "mu", "di", "mn", "meta", "ng", "mm", "MD", "dd", "od", "mand", "ma", "mt", "ke", "m", "ms", " MD", "bd", "dig", "hash", "mb", "mg", "vd", "dm", "cmd", "mod", "doc", "hd", "mac", "mag", "mp", "key", "metadata", "mc", "mem", "ld", "mo", "map", "id"], "theDigest": [" theSignest", "TheDigester", "theHashester", "thedighest", "theDigEST", " theDigester", "Thedigest", "theSignester", " theDighest", "TheDigEST", "theSignhest", " theSignEST", " theSignester", " theDigEST", "theDighest", "theDigester", "ThedigEST", "theSignest", "theHashEST", "thedigEST", "theHashest", "thedigest", "Thedigester", "theSignEST", "TheDigest", "thedigester", " theSignhest"]}}
{"id1": "4168534", "id2": "7425022", "code1": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 0, "substitutes": {"sms": ["smos", "osras", " smos", "osmas", "salras", "jsmb", "smes", "sras", " smt", "resms", "sdb", "smt", " sdb", "smm", "pMS", "isbm", "isms", "pmes", "jsmes", "hesms", " sMS", " smas", "salms", "hesmt", "resmm", " sras", "resmb", "sco", "smb", "smas", "pmos", "osms", "isco", "pmm", "osMS", "osmos", "pdb", "resmes", "sMS", " sco", " sbm", "hesbm", "osdb", "sbm", "ismt", "hesco", "jsms", "pms", "pmb", "salmas", "jsmm", "salMS"], "smsId": ["ospsID", "spsid", "sssId", "osmsid", "spsName", "sssJs", "ospsName", "osmsID", "pmsid", "snsAnd", "sMSid", "smsID", "esnsID", "pnsID", "esmsId", "smsInfo", "sarmsAnd", "osmsId", "sssID", " snsID", "sssAnd", "esmsID", "pmsID", "pnsId", "esnsKey", "sinesId", "sinesInfo", "sarmsId", "pnsAnd", "sssInfo", "esmsid", "esnsid", "sssid", "smsName", "snsid", "scsid", "snsKey", "scsID", "spsId", "osmsName", "pmsAnd", "snsID", "snsJs", "sinesJs", "smsid", "smesId", "spsID", "smsKey", "esmsKey", "smesid", "smesID", "sarmsid", "ospsid", "sMSID", "sinesID", " smsID", "pmsId", "esnsId", "smsAnd", "smesName", "smsJs", "sarmsID", " snsInfo", "pnsid", " smsJs", "sMSKey", "snsInfo", "snsId", "scsId", "sMSId", "ospsId", "scsKey", " snsJs", "sMSName", " smsInfo", " snsId"], "conn": ["session", "Connection", "ca", "ctx", "cm", "sync", "cat", "core", "pg", "oci", "cf", "lc", "connect", "ci", "con", "dc", "cn", "cr", "db", "server", "pc", "conf", "org", "cli", "nc", "cp", "lock", "nt", "ou", "error", "ai", "co", "act", "cb", "ct", "connection", "io", "sql", "cms", "ec", "client", "conv", "c", "reg", "cc", "po", "exec", "close", "rc", "Conn", "cache", "n", "ann", "pool", "ok", "loc", "ch", "mc", "uc", "enc", "config", "h", "coll", "col"], "pstmt": [" postmt", "pshmt", "Pctmr", "pstsmb", "pstrmd", "pstmd", "pmtmt", " pstnt", " pstrt", " postrt", " pftmi", "pstgt", "pndmb", "pftm", "pcttor", "psthmi", "pctdb", " pstsmb", " pstmd", "Pctmb", " pstms", "psthMT", "psthct", "pndmt", " psthdb", "pctmd", "pconsttor", "pctms", "pctgt", " psthnt", "pststor", " postmd", " pstsmt", " pstsmd", "pndm", "postm", "pndMT", "pustmp", "pstrmt", "Pstwd", "pconstmt", "pstrt", "pstmb", "pctnt", " postm", " psttor", "postmr", "pstdb", "pstMT", " pstmb", "pstmp", "PctMT", "postmt", "pstatmp", "psthmt", "PstMT", " pstmp", "psthgt", "pctmr", "pmtnt", "pctwd", "pmtdb", "psthwd", " pstm", "pftct", " pftct", "pstrrt", "pstsmd", "Pctmt", " pstmi", "postmd", "Pcttor", "Pstm", "postrt", "psttor", "pustmb", " psthmt", "Pstmr", "posttor", "pndwd", "pftmi", "pstatmb", "pctct", "pstms", "pconstmd", "pctmb", "pshmb", "psthnt", "pstnt", "pstwd", "pconstmb", " pstdb", "Pctwd", "pctmp", " pustmp", "pstsmt", "Pctm", "pctmt", " pftm", "pctrt", " psthgt", "pustms", "pstm", "pstct", "postmb", "psthdb", "pstmr", "pstatmt", "Psttor", "pmtgt", "pstrm", " pstgt", "pshtor", " pftmt", "psthmb", " pustmt", " pustmb", "pshmr", "Pstmb", "pustmt", "pctMT", "pstatms", " pstct", "pstmi", " pststor", "pctm", " pustms", "psthm", "Pstmt", "pftmt", "pctmi"], "buffer": ["loader", "queue", "bar", "pb", "re", "uffer", "template", "bb", "counter", "BU", "sb", "string", "flash", "builder", "document", "FFER", "feed", "bc", "str", "server", "http", "layer", "BB", "iter", "buff", "buf", "fb", "writer", "binary", "text", "book", "window", "base", "function", "block", "array", "fp", "url", "page", "file", "full", "comment", "header", "seed", "code", "Buffer", "batch", "b", "print", "result", "build", "program", "memory", "uf", "cache", "view", "key", "api", "append", "copy", "use", "null", "message"], "index": ["number", "join", "address", "length", "x", "version", "prefix", "find", "condition", "point", "alpha", "section", "weight", "connect", "end", "path", "diff", "slice", "ind", "input", "insert", "list", "len", "search", "value", "base", "block", "error", "num", "active", "type", "connection", "level", "style", "action", "offset", "unit", "change", "open", "update", "batch", "step", "pos", "width", "instance", "size", "start", "include", "cache", "inc", "position", "view", "Index", "loc", "key", "append", "config", "default", "info", "match", "id"]}}
{"id1": "12380475", "id2": "18974466", "code1": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"file": ["queue", "f", "filename", "data", "content", "user", "socket", "service", "string", "source", "resource", "document", "path", "handler", "db", "server", "http", "line", "entry", "project", "class", "File", "folder", "parent", "base", "fp", "url", "page", "full", "reader", "handle", "directory", "type", "single", "connection", "io", "comment", "image", "change", "name", "info", "dir", "channel", "route", "ile", "FILE", "stream", "cache", "log", "auto", "local", "use", "out", "object", "model", "e"], "files": ["f", "features", "lines", "phones", "blocks", "pes", "balls", "views", "issues", "boxes", "classes", "iles", "thumbnails", "bs", "items", "flows", "events", "ins", "ls", "books", "Files", "s", "results", "users", "ums", "cells", "facts", "ions", "dir", "objects", "pages", "ups", "sites", "keys", "models", "images", "headers", "names", "fs"], "i": ["hi", "f", "x", "it", "d", "ui", "ti", "uri", "ni", "ci", "end", "slice", "di", "h", "abi", "pi", "chi", "xi", "p", "v", "ai", "u", "k", "m", "io", "ip", "ii", "info", "o", "c", "b", "I", "ri", "multi", "j", "n", "si", "vi", "key", "li", "ini", "mi", "oi", "index", "col", "e", "id"], "inChannel": ["outStream", "inChan", "inputChannel", "InChan", "Inchannel", "inMessage", "inputStream", " inChan", "outchannel", " inStream", "inFile", "inCh", " inchannel", "InStream", " inMessage", "inchannel", "inputCh", "inputChan", "inStream", "InFile", "outMessage", "InChannel", "InCh", "InMessage", "outFile", " inCh", " inFile"], "outChannel": ["outStream", "OutChan", "ioChannel", "inChan", "ioHandler", "inHandler", "OutChannel", "OutStream", "ioChan", "outHandler", "outchannel", "outChan", "outConnection", " outHandler", " outchannel", " outChan", " outConnection", "inConnection", " outStream", "inchannel", "inStream", "ioConnection", "Outchannel"]}}
{"id1": "7044685", "id2": "2910383", "code1": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "code2": "    public String downloadAndOpen(JProgressBar bar) {\n        long size = 0;\n        try {\n            size = photo.getSize();\n        } catch (ServiceException ex) {\n            ex.printStackTrace();\n        }\n        try {\n            bar.setMaximum((int) size);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        bar.setValue(0);\n        image = new File(\"TMP/\" + photo.getTitle().getPlainText());\n        try {\n            if (!image.exists()) {\n                image.createNewFile();\n                image.deleteOnExit();\n                URL url = null;\n                BufferedOutputStream fOut = null;\n                try {\n                    url = new URL(photo.getMediaContents().get(0).getUrl());\n                    InputStream html = null;\n                    html = url.openStream();\n                    fOut = new BufferedOutputStream(new FileOutputStream(image));\n                    byte[] buffer = new byte[32 * 1024];\n                    int bytesRead = 0;\n                    int in = 0;\n                    while ((bytesRead = html.read(buffer)) != -1) {\n                        in += bytesRead;\n                        bar.setValue(in);\n                        fOut.write(buffer, 0, bytesRead);\n                    }\n                    html.close();\n                    fOut.close();\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return image.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"plaintext": [" plainsource", "flatText", "fccontent", "flatsource", " Plainbinary", " plainText", "plaincontent", " plainbinary", "broadText", "plainText", "plainbinary", "flattext", " Plaincontent", "broadtext", " plainTEXT", " PlainText", "broadTEXT", "flatTEXT", "fcbinary", "broadsource", " Plaintext", " plaincontent", "fcText", "plainTEXT", "fctext", "plainsource"], "d": ["pd", "f", "dh", "dr", "data", "dt", "did", "g", "ad", "gd", "rd", "da", "dc", "mad", "db", "id", "ds", "di", "dl", "t", "ded", "p", "od", "dd", "fd", "mand", "de", "D", "m", "bd", "dig", "ed", "sd", "cd", "md", "o", "c", "b", "mod", "l", "nd", "n", "dn", "dad", "r", "ld", "h", " dd", "dat", "e", "dict"]}}
{"id1": "23510383", "id2": "8788371", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"file": ["filename", "data", "content", "resource", "document", "path", "handler", "db", "line", "plus", "zip", "project", "File", "folder", "parent", "base", "lock", "fp", "full", "part", "directory", "files", "single", "connection", "table", "image", "dir", "ile", "FILE", "work", "log", "picture", "local", "complete", "use", "out", "object", "model"], "types": ["ids", "styles", "tools", "stores", "features", "words", "lists", "uploads", "times", "links", "blocks", "resources", "pes", "ames", "ypes", "packages", "parts", "boxes", "classes", "photos", "its", "reports", "groups", "opens", "jobs", "thumbnails", "Types", "relations", "tests", "properties", "archives", "params", "products", "files", "shows", "roots", "arts", "users", "services", "forms", "versions", "pages", "ions", "xs", "objects", "settings", "cats", "sites", "ts", "plugins", "models", "ports", "tags", "keys", "Images", "strings", "packs", "fields", "projects", "eps", "names", "options", "locks"], "images": ["ids", "styles", "features", "uploads", "actions", "blocks", "views", "photos", "reports", "rooms", "scripts", "thumbnails", "events", "files", "image", "assets", "media", "users", "services", "versions", "ips", "plugins", "modules", "tags", "Images", "videos", "png"], "trajectories": ["traventories", "traventions", "traventory", "trajectors", "trajections", "tracessions", "traveyory", "transjectors", "transjections", "traveyions", "trajectory", "traventors", "transcessions", "tracessories", "tracessors", "transjectory", "transcessories", "traveyors", "tracessory", "transcessors", "transcessory", "transjectories", "traveyories"], "databasesIncluded": ["daturesInclusion", "databytesInscluded", "databytesInclusive", "databasesInsferred", "databasesINferred", "daturesInferred", "daturesInscluded", "databytesInsclusion", "databasesInclusion", "databasesINclusion", "databasesInferred", "databasesExferred", "daturesInclusive", "databytesInclusion", "databytesInferred", "databasesINclusive", "daturesIncluded", "databasesInclusive", "databasesINcluded", "databasesincluded", "databasesExclusive", "databasesinclusion", "databasesExcluded", "databasesExclusion", "daturesInsclusion", "databasesInsclusive", "daturesInsferred", "databasesinclusive", "databasesInscluded", "databytesInsferred", "databasesInsclusion", "daturesInsclusive", "databytesInsclusive", "databasesinferred", "databytesIncluded"], "onlyLinks": ["onlyLink", "allLinks", "alllinks", "justlinks", "onlylinks", " onlyLink", "justLink", "justLinks", "withlinks", "allLink", "withLinks", " onlylinks", "withLink"], "index": ["number", "address", "length", "x", "point", "i", "weight", "end", "slice", "ind", " Index", "initial", "input", "search", "value", "head", "page", "in", "num", "part", "xxx", "level", "tail", "offset", "old", "pattern", "instance", "size", "inc", "position", "Index", "key", "ini", "default", "match", "id"], "name": ["ext", "named", "filename", "data", "home", "string", "section", "domain", "path", "host", "id", "vision", "base", "root", "large", "url", "full", "part", "temp", "connection", "NAME", "image", "title", "Name", "up", "stage", "size", "memory", "key", "default", "names", "none", "message"], "format": ["filename", "template", "data", "Format", "string", "form", "feed", "handler", "layout", "init", "text", "scale", "value", "function", "base", "array", "v", "pretty", "export", "temp", "style", "letter", "unit", "header", "language", "struct", "pattern", "term", "external", "current", "at", "parser", "transform", "config", "status", "date"], "count": ["length", "child", "found", "content", "counter", "weight", "path", "id", "limit", "list", "parent", "base", "error", "page", "num", "call", "level", "force", "Count", "code", "build", "sum", "cache", "match", "depth"], "version": ["application", "cover", "install", "video", "latest", "platform", "plugin", "data", "content", "string", "xml", "output", "draft", "server", "vision", "project", "vert", "root", "database", "v", "environment", "manager", "directory", "unit", "image", "header", "Version", "update", "versions", "channel", "dir", "VERSION", "release", "journal", "download", "description", "feature", "python", "view", "config", "default", "model", "master", "ver"], "writer": ["wrapper", "master", "walker", "author", "data", "wave", "xml", "builder", "document", "former", "output", "director", "handler", "wire", "riter", "editor", "war", "book", "creator", "page", "W", "export", "reader", "wr", "Writer", "w", "temp", "manager", "er", "writers", "engine", "worker", "widget", "letter", "buffer", "later", "written", "player", "write", "journal", "log", "parser", "driver", "writ", "word", "out", "writing"], "xmlDir": ["xmlDIR", "phpFile", "imageDir", "mainArea", "databaseDir", "xmlJar", "phpFolder", "databaseDirectory", "databaseJar", "databaseArea", " xmlArea", " xmlDIR", "xmlFolder", " xmlJar", "imageFile", "imageFolder", "phpDIR", " xmlDirectory", " xmlFolder", " xmlFile", "xmlDirectory", "mainDir", "xmlArea", "phpDir", "imageDIR", "mainDirectory", "mainJar", "xmlFile"], "databases": ["Databases", "mutabytes", "validabytes", " databytes", "dups", "muturation", "Datumbers", " datumbers", "Daturation", "datories", "dabases", "validographies", "duration", "validabases", "databytes", "mutups", "datographies", " dataxies", "Dataxies", "dabytes", "Databytes", "Datups", "datups", " datographies", "mutaxies", "dataxies", "mutories", " datories", "Datories", "datumbers", "Datographies", "daturation", "validumbers", "mutabases"], "t": ["target", "cat", "g", "te", " T", "string", "Type", "i", "token", "none", "h", "class", "p", "task", "v", "T", "w", "m", "y", "title", "Name", "att", "ant", "o", "c", "tm", "j", "ts", "n", "at", "test", "object", "ty", "e"], "type": ["target", "plugin", "data", "other", "string", "Type", "resource", "role", "rule", "handler", "token", "slice", "http", "option", "pe", "e", "ty", "class", "value", "parent", "function", "p", "block", "base", "database", "error", "op", "part", "single", "state", "to", "style", "action", "y", "right", "language", "set", "o", "result", "ype", "TYPE", "definition", "test", "key", "null", "like", "config", "field", "info", "match", "id"], "currentName": [" currentPath", "recentKey", " currentData", "recentName", "reportedName", "currentCopy", "currentType", " currentNames", " currentTime", "currentAddress", "currentPath", " currentInstance", "CurrentPath", " currentAddress", "CurrentCopy", "CurrentNames", "currentNames", "CurrentAddress", "reportedType", "recentInstance", "reportedAddress", "reportedCopy", "currentKey", "CurrentData", "singleCopy", " currentKey", "singleName", " currentType", "reportedData", "currentlyKey", "currentTime", "currentlyTime", "CurrentType", "currentData", "currentlyInstance", "reportedPath", "reportedNames", "CurrentName", "singlePath", "recentTime", "currentlyName", "currentInstance"], "baseCopy": ["baseShare", " baseUpload", "asecopy", " basecopy", "BaseShare", "baseName", "bodycopy", "basecopy", "bodyCop", " baseName", "baseCop", "BaseCop", "aseUpload", "aseCopy", "basedcopy", "BaseCopy", " baseCop", "BaseName", "baseUpload", "bodyCopy", " baseShare", "BaseUpload", "basedCopy", "basedShare", "Basecopy", "aseName"], "source": ["target", "reference", "src", "uri", "from", "service", "site", "section", "resource", "remote", "ources", "SOURCE", "slice", "server", "plus", "option", "project", "input", "text", "dest", "parent", "base", "rate", "reader", "manager", "scope", "connection", "slave", "table", "inner", "unit", "image", "storage", "channel", "client", "clone", "result", "component", "size", "stream", "cache", "current", "view", "Source", "driver", "ource", "config", "use", "proxy", "null", "master"], "destination": ["destension", "declinations", "Destinator", "distination", "distinate", "destruction", "Destinations", "Destension", "Destinate", " destinations", "declination", "destinations", "destinated", "Destination", "coordinator", "coordination", " destruction", "Destruction", "coordinate", "Destinated", "coordension", "declruction", "declinator", "destinate", "distinator", "distinated", "destinator", " destinator", " destinated", "distension", " destension"], "clefs": ["ceFs", "CLEf", "cef", " clef", "cefs", "CleFs", "CLEFs", "CleFS", "CLEFS", " cleFS", "CLEfiles", "CLEfs", " clefiles", "cleFS", "ceFS", "Clef", "clef", "Clefs", "Clefiles", "cleFs", "clefiles"], "st": ["ST", "inst", "ost", "rest", "ust", "sts", "bl", "td", "sm", "src", "ast", "sb", "rd", "lt", "sh", "str", "db", "ds", "sta", "sl", "sa", "est", "sc", "sp", "mt", "statement", "ct", "ist", "bt", "std", "St", "struct", "sw", "ss", "nd", " ST", "ts", "start", "pt", "tt", "ld", "ste"], "rs": [" matches", " Rs", "Res", "R", " re", "Rs", " changes", "rd", "RC", " rm", " ans", " arr", "Row", " repl", " obj", "RS", "res", " success", " sr", " src", " rc", "rc", " ra", " instances", " hits", " ps", " RS"]}}
{"id1": "11865906", "id2": "7948308", "code1": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"username": ["staff", "hello", "nil", "account", "address", "filename", "prefix", "plugin", "ui", "uri", "mobile", "company", "home", "string", "usr", "ername", "profile", "rue", "token", "subject", "host", "person", "ug", "character", "month", "creator", "database", "utf", "url", "uno", "uin", "whatever", "uu", "verb", "uid", "users", "name", "purpose", "nick", "job", "email", "ame", "property", "USER", "consumer", "driver", "login", "word", "your", "sword", "sudo"], "password": ["session", "account", "address", "filename", "prefix", "patch", "words", "Pass", "wd", "string", "profile", "token", "pad", "diff", " passwords", "text", "value", "database", "p", "params", "auth", "fax", "w", "phrase", "security", "secret", "wallet", "seed", "hash", "name", "email", "Password", "description", "pass", "cache", "mac", "picture", "PASS", "key", "driver", "crypt", "padding", "login", "word", "attribute", "null", "sword", "sudo"], "md5": [" md512", " md4", " md75", "MD1", " mdob", "MD2", "mdob", "sha512", "md75", "md512", " md2", "MD4", "MD512", "MDob", " md3", "sha1", "MD75", "dd2", " md1", "MD3", "dd5", "md3", "md2", "md4", "sha4", "sha3", "ddob", "dd512", "sha75", "sha5", "md1", "MD5"], "logServiceMock": ["logServicemocks", "logServicemock", "logServiceVOCK", "logModuleManock", "logServiceMck", "logServicePOCK", "logModuleMocker", "logServiceBocks", "logServiceVocker", "logServiceFck", "logModulePick", "logServicePocks", "logServiceManagerock", "logModuleMick", "logServiceManagerocker", "logClientMck", "logClientBck", "logClientBock", "logServicemOCK", "logServicePick", "logServicePock", "logModuleManOCK", "logServiceFocks", "logServiceManocks", "logServiceManagerOCK", "logServiceAMocked", "logClientBocker", "logServiceManagerocks", "logServiceMick", "logServiceFocked", "logServiceManocker", "logModuleMock", "logServiceFocker", "logClientMocker", "logServicemick", "logServiceFOCK", "logServiceAMOCK", "logServiceMocker", "logServiceAMock", "logServiceVock", "logClientBOCK", "logServiceManock", "logServiceAMocker", "logModuleManocks", "logModuleManocker", "logClientMOCK", "logServiceBck", "logServiceVocks", "logServiceMOCK", "logServiceFock", "logModulePock", "logServiceBocker", "logClientMock", "logServiceVck", "logModulePOCK", "logServiceManocked", "logModuleMocks", "logServiceBOCK", "logServiceManOCK", "logModulePocks", "logServiceMocked", "logModuleMOCK", "logServiceBick", "logServiceMocks", "logServiceBock"], "dbServiceMock": ["dbservicemox", "dbServicemock", "dbServicemOCK", "dbServiceVOCK", "dbServiceManagerocker", "dbserviceMocker", "dbServicemox", "dbServiceCMocker", "dbserviceMox", "dbServiceDock", "dbClientFOCK", "dbServicesManocker", "dbServiceManick", "dbClientMocker", "dbServicemocker", "dbservicemOCK", "dbserviceMock", "dbServiceManagerOCK", "dbServicesManox", "dbServiceFocker", "dbServiceFOCK", "dbServiceDocker", "dbServiceBocker", "dbServiceVick", "dbServiceDick", "dbClientFocked", "dbServiceCMocked", "dbServiceMOCK", "dbClientFick", "dbservicemocker", "dbServiceVocker", "dbServiceBox", "dbServiceFock", "dbServiceManagerock", "dbServiceManagerick", "dbServicesMock", "dbServiceVock", "dbClientFock", "dbClientMocked", "dbServiceVox", "dbClientFocker", "dbServiceDOCK", "dbClientMock", "dbServiceFick", "dbServiceFocked", "dbservicemock", "dbServiceMick", "dbServicesManock", "dbServiceMocker", "dbClientMick", "dbServiceFox", "dbServiceManox", "dbServiceCMick", "dbServicesMox", "dbServicemick", "dbServiceMox", "dbServicesMocker", "dbserviceMOCK", "dbServicesManick", "dbClientMOCK", "dbServiceBOCK", "dbServiceManocker", "dbServiceMocked", "dbServiceBock", "dbServiceCMock", "dbServicemocked", "dbServiceManock", "dbServicesMick"], "user": ["account", "real", "author", "bug", "plugin", "data", "follow", "row", "you", "other", "proxy", "resource", "usr", "profile", "per", "token", "rule", "role", "db", "person", "server", "model", "usa", "project", "by", "class", "member", "blog", "creator", "lock", "page", "User", "type", "connection", "ee", "name", "up", "client", "job", "result", "or", "instance", "USER", "pass", "current", "me", "log", "key", "api", "login", "use", "config", "object", "info", "record", "auth", "match"]}}
{"id1": "6009527", "id2": "11546108", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"attachmentId": ["attplementationID", "attlementId", "attentionPath", "attimageInfo", "attlementid", "attociationPath", "adachmentPath", "attimageID", "adachmentID", "ttachmentId", "adachmentId", "attlementID", "attociationId", "attentionid", "attachmentID", "attentionInfo", "attociationInfo", "attimageId", "attociationid", "ttociationid", "attentionType", "attentionID", "attachmentid", "Attachmentid", "ttachmentID", "adociationInfo", "adociationId", "attachmentPath", "attachmentType", "adachmentInfo", "AttachmentID", "AttachmentType", "adociationPath", "ttociationId", "ttociationID", "attachmentInfo", "attociationID", "attplementationId", "ttachmentid", "attlementType", "AttachmentId", "attplementationid", "attentionId", "attimagePath", "adociationID"], "attachment": ["attached", "instment", "assment", "adment", "attociation", "attachached", "assachment", "assached", "instachment", "attachruction", "association", "adention", "appachment", "attruction", "adachment", " adaptachment", " attment", "adached", "attention", "attachachment", " adaptention", "appment", "attachention", " adaptment", " attociation", "instruction", " adaptociation", "appention", "instention", "assention", "appruction", " attention", "attment"], "attachmentUri": ["attachmentSuRI", "attachedARI", "attachmentUuri", "attachmentAuri", "attachmentAri", "attachmentIuri", "attachmentCuri", "attachedURI", "attachmentEuri", "attmentIris", "attachmentUti", "attachmentUURI", "attachmentSuti", "attachmentURI", "attachmentIURI", "attmentUri", "attachmentSuuri", "attachmentCuris", "attmentIri", "attachmentEti", "attachedAuri", "attachmentEri", "attachmentCuURI", "attachmentUris", "attachmentSuURI", "attachmentAti", "attachmentIris", "attachedAri", "attachmentARI", "attmentIURI", "attmentUris", "attmentUURI", "attachedUuri", "attachmentERI", "attachmentSuri", "attmentIuri", "attmentUuri", "attachedUri", "attachedUti", "attachedAti", "attachmentCuuri", "attachmentIri", "attachmentSuris"], "contentUri": ["contentIri", "contentFileuri", " contentUris", "resourceURI", "contentIi", "contentFileris", "contentIris", "contentUuri", "contentURri", "contentCi", "contentCris", " contentSuri", "contentURI", "contentSuri", "resourceUris", " contentUdi", "contentSuRI", "contentSuris", "contentUdi", "contentFileRI", "resourceUri", "contentFileri", "contentUsuri", "contentIuri", "contentCuri", "contentSudi", "contentIRI", "contentUsri", "contentUsRI", "resourceIi", "contentURris", "contentUsdi", "resourceUuri", "resourceIris", "contentURi", "contentCdi", "contentUsris", " contentURI", " contentSuris", "contentUi", " contentSudi", "contentCri", " contentSuRI", "resourceUi", "resourceIri", "contentURuri", "contentCRI", "resourceIRI", "resourceIuri", "contentUris"], "file": ["f", "filename", "child", "data", "content", "socket", "uri", "source", "resource", "upload", "path", "able", "output", "line", "handler", "pe", "zip", "input", "this", "binary", "File", "book", "folder", "entity", "base", "load", "fp", "url", "reader", "files", "single", "connection", "to", "letter", "io", "unit", "image", "get", "buffer", "name", "up", "b", "le", "FILE", "stream", "work", "ger", "cache", "log", "auto", "picture", "local", "view", "via", "copy", "use", "object", "model", "create"], "in": ["gin", "f", "sync", "a", "data", "pull", "socket", "inn", "source", "i", "con", "cli", "input", "this", "init", "binary", "din", "url", "conn", "reader", "ins", "bin", "m", "err", "connection", "io", "inner", "s", "image", "up", "o", "c", "b", "as", "or", "win", "In", "inc", "ac", "IN", "nin", "ini", "r", "copy", "login", "again", "pin", "e", "id"], "out": ["ext", "sync", "OUT", "data", "socket", "source", "i", "resource", "output", "on", "line", "cli", "by", "this", "writer", "init", "Out", "base", "lock", "page", "conn", "bin", "one", "err", "connection", "net", "io", "to", "s", "inner", "image", "up", "client", "o", "b", "outs", "exec", "outer", "In", "cache", "inc", "log", "view", "IN", "nin", "ex", "copy", "again", "null"], "intent": ["inst", "android", "ctx", "anc", "it", "feat", "content", "ents", " Intent", "request", "xml", "document", "contact", "anim", "ent", "response", "impact", "ani", "entry", "intention", "this", "init", "text", "context", "entity", "advert", "event", "Activity", "activate", "effect", "concept", "act", "vent", "action", "focus", "element", "animate", "language", "ant", "activation", "category", "term", "spirit", "acc", "feature", "ink", "activity", "eng", "enc", "object", "agent"]}}
{"id1": "2521141", "id2": "18489832", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "label": 1, "substitutes": {"from_name": ["fromFname", " from_names", "to_filename", "from_Name", "fromMnames", " from_Name", "from_names", " from_key", "source_name", "from_key", "from_filename", "source_path", "from__memory", "from__name", "from_memory", "to_path", "from__path", "from__filename", "fromMname", "fromMfile", "source_memory", "fromFpath", "fromFmemory", "from_path", "fromFfilename", "source_filename"], "to_name": ["toamfile", " to_home", "to_filename", "to_path", "toampath", "toamname", "to_home", "from_filename", "from_path", " to_Name", "to_Name", "toamhome", " to_path"], "from_file": ["from_lane", "from__directory", "from_auto", "from___name", "fromappfile", "fromapplog", "fromCfile", " from__file", " from__filename", " from_files", "source_name", "source_resource", "from_source", "fromCfilename", "fromCbrain", "fromapplane", "from_filename", " from_folder", "source_brain", "from_files", "source_file", "from__files", " from__auto", "source_directory", "from__resource", "from__name", "from_folder", "from___file", " from__name", "from___auto", "remote_lane", "from_directory", "from__filename", " from_filename", "from_log", " from_directory", "from_resource", "from__auto", "remote_function", "from_function", " from_auto", " from_source", "fromappfunction", "from___filename", "from_brain", "fromCname", "remote_file", "remote_log", "source_files", "from__file", "source_filename"], "to_file": ["eto___remote", "to__file", "to_files", "to___remote", "to_filename", "to_model", "into_function", "to_server", "tojfile", "source_filename", "from_binary", " to_filename", "intojname", "to_dir", "to_remote", "to67file", "from_load", "into_use", "to67dir", "from_stream", "tojname", "to64use", "from_dir", "from_files", "to67load", "from_model", "source_file", "toJbar", "to64name", "to64function", "to_function", "intojfunction", "toJstream", " to_model", "to___file", "eto_remote", "to__name", "to_class", "tojuse", "to_bar", "source_server", "to_use", "toJfile", "to__dir", "into_name", "into_file", "intojuse", "tojfunction", " to_queue", "to_queue", " to_class", "to64file", "to_binary", "intojfile", " to_files", "to_stream", "from_bar", "eto_name", "to_load", "to67name", "to___name", "eto___file", "eto___name", "to__load", "toJname", "source_files", "eto_file"], "parent": ["pa", "uri", "per", "path", "host", "server", "root", "url", "full", "type", "unit", "old", "current", "inc", "pool", "ppa", "out", "target", "address", "parents", "home", "source", "mother", "search", "par", "folder", "am", "file", "connection", "owner", "po", "test", "complete", "id", "author", "any", "patch", "content", "string", "resource", "div", "rule", "handler", "function", "Parent", "part", "temp", "directory", "manager", "client", "or", "cache", "ac", "api", "fat", "session", "child", "port", "tree", "point", "user", "remote", "container", "p", "page", "location", "ip", "name", "term", "memory", "size", "loc", "null", "global"], "dir": ["ir", "f", "d", "cat", "dr", "data", "wd", "rel", "user", "nav", "home", "container", "per", "path", "dc", "director", "div", "db", "dec", "tr", "entry", "di", "dis", "iter", "class", "group", "folder", "lock", "root", "block", "file", "url", "in", "die", "part", "keep", "directory", " directory", "manager", "exp", "dev", "io", "module", "name", "coll", "md", "Dir", "build", "or", "doc", "dep", "dict", "ver", "cache", "cur", "loc", "def", "r", "out", "object", "global", "id"], "from": ["cm", "address", "who", "find", "left", "low", "parse", "cf", "source", "form", "empty", "per", "feed", "con", "cr", "server", "with", "fr", "http", "pe", "entry", "without", "two", "by", "ce", "this", "ra", "context", "when", "flo", "base", "can", "add", "ou", "file", "url", "conn", "bean", "se", "part", "normal", "one", "connection", "From", "io", "range", "self", "get", "name", "vol", "client", "or", "component", "link", "stream", "start", "cache", "cor", "auto", "view", "ch", "api", "fe", "so", "e"], "to": ["session", "target", "To", "sync", "socket", "per", "token", "output", "on", "db", "server", "http", "with", "see", "t", "fb", "two", "top", "by", "dest", "flo", "store", "pi", "base", "thro", "op", "value", "that", "conn", "file", "too", "co", "office", "type", "one", "connection", "io", "storage", "client", "about", "o", "until", "write", "po", "or", "su", "as", "not", "size", "auto", "tto", "api", "fat", "so", "via", "copy", "out", "proxy", "TO", "will", "ver"], "buffer": ["number", "queue", "border", "address", "length", "uffer", "data", "flush", "reference", "row", "bb", "texture", "source", "wave", "resource", "document", "feed", "layer", "slice", "server", "read", "character", "iter", "buff", "buf", "duration", "writer", "binary", "total", "window", "block", "shape", "page", "variable", "transfer", "reader", "url", "comment", "header", "seed", "Buffer", "batch", "channel", "b", "memory", "position", "padding", "default", "null", "message"], "bytes_read": ["byte_before", "bytes_pass", " bytes_found", "bytes_reads", "gets_read", " bytes_en", "gets___allow", "byteslexread", "gets_reads", "gets___pass", "byteslexload", "bytes_before", "byteslexcurrent", "bytes_current", "bytesXload", "gets_pass", "bytes_found", "byte_load", "byteslexbefore", "bytes_write", " bytes_write", "bytesXcurrent", "gets___reads", "bytes_load", "gets_allow", "bytes___reads", "bytes_en", "bytes_allow", "byte_read", "bytes___read", "bytes___pass", "bytesXread", "bytesXbefore", "bytes___allow", "byte_current", "gets___read"]}}
{"id1": "13362846", "id2": "19549577", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "label": 0, "substitutes": {"contenuFichier": ["contenuFicheer", "contenuFrenchiers", "contenuPhichiere", "contenuFicheery", "contenuFaffique", "contenuPhactoryiere", "contenuTicherer", "contenuFrenchie", "contenuPrefichiere", "contenuFichique", "contenuMaffieri", "contenuPFocher", "contenuMichique", "contenuFicie", "contenuFchery", "contenuFrenchoyer", "contenuMichie", "contenuMichiers", "contenuFicher", "contenuFactoryoyer", "contenuPhichie", "contenuMaffiere", "contenuFichiere", "contenuFichtie", "contenuFocher", "contenuPFichier", "contenuFochie", "contenuTichiere", "contenuFicheieri", "contenuPFichique", "contenuFicheiere", "contenuMaffier", "contenuMichiere", "contenuMrenchiere", "contenuFcherer", "contenuFichtier", "contenuMaffiers", "contenuFactoryier", "contenuPFochier", "contenuPrefichier", "contenuFichiers", "contenuFaffiers", "contenuFochique", "contenuFrenchery", "contenuPhichier", "contenuFichtique", "contenuFochiers", "contenuMrenchie", "contenuPFochique", "contenuPhactoryie", "contenuTicheiere", "contenuMaffie", "contenuPFochiere", "contenuTicheier", "contenuPrefaffier", "contenuFichoyer", "contenuFaffieri", "contenuFichieri", "contenuFrenchique", "contenuPrefaffiere", "contenuFochiere", "contenuFicheier", "contenuPFichiere", "contenuFicheerer", "contenuPrefaffiers", "contenuPrefichie", "contenuTicheerer", "contenuFiciere", "contenuTichery", "contenuFicherer", "contenuFicheique", "contenuFactoryiere", "contenuPrefaffie", "contenuFichtieri", "contenuFichie", "contenuPhactoryier", "contenuTicheery", "contenuFchier", "contenuMrenchique", "contenuPFicher", "contenuFicier", "contenuFaffer", "contenuMrenchier", "contenuFrenchier", "contenuFicheie", "contenuMichieri", "contenuFochier", "contenuFaffier", "contenuFaffiere", "contenuMichier", "contenuFichery", "contenuFichtiere", "contenuPhichoyer", "contenuFchiere", "contenuFactoryie", "contenuFicoyer", "contenuTichier", "contenuFrenchiere", "contenuFaffie", "contenuPhactoryoyer", "contenuFrencherer", "contenuPrefichiers"], "fichierElectronique": ["fichierElectronelique", "fichierCentronier", "fichierElectaronier", "fichierAdministronique", "fichierAustroniques", "fichierAustrolique", "fichierAdministronsier", "fichierElectronsica", "fichierAdministronistic", "fichierElectornier", "fichierElectronistic", "fichierElectroliques", "fichierElectrons\u00e9e", "fichierElectroneique", "fichierAustrolier", "fichierElectonlique", "fichierElectpronistic", "fichierElectaronique", "fichierElectroneiere", "fichierAdministronie", "fichierAustronier", "fichierElectronsique", "fichierElectronsistic", "fichierAdministroniques", "fichierAdministronier", "fichierAdministronsistic", "fichierCentorniques", "fichierAdministronsical", "fichierAustroliere", "fichierElectronsiques", "fichierAdministronslique", "fichierElectronsiere", "fichierElectonier", "fichierElectroniques", "fichierElectpronique", "fichierCentornier", "fichierElectproniques", "fichierElectronsical", "fichierAustronique", "fichierCentornlique", "fichierElectroneier", "fichierElectronslique", "fichierAdministronsiques", "fichierElectronlique", "fichierElectonique", "fichierElectornique", "fichierElectroniere", "fichierElectpronical", "fichierElectolonique", "fichierElectromique", "fichierAdministrons\u00e9e", "fichierElectrol\u00e9e", "fichierElectaronie", "fichierElectromiques", "fichierElectornlique", "fichierElectrolie", "fichierElectronica", "fichierAustroniere", "fichierAdministronsie", "fichierElectoloniere", "fichierElectorniques", "fichierElectroneiques", "fichierElectromistic", "fichierAdministronical", "fichierElectromical", "fichierElectronier", "fichierElectrolique", "fichierElectronie", "fichierAdministron\u00e9e", "fichierElectroneie", "fichierElectronical", "fichierElectolonica", "fichierElectron\u00e9e", "fichierElectonie", "fichierElectronsier", "fichierCentornique", "fichierElectrolier", "fichierCentroniques", "fichierElectronsie", "fichierCentronlique", "fichierAdministronsique", "fichierElectaron\u00e9e", "fichierElectoloniques", "fichierAustroliques", "fichierAdministronlique", "fichierCentronique", "fichierElectrolica", "fichierElectroliere"], "utilisateurCourant": ["utilisateurCourateur", "utilisateurApplicants", "utilisateurParticipateur", "utilisateurCourants", "utilisationCourants", "utilisateurCourante", "utilisationApplicateur", "utilisateurParticipant", "utilisateurGovernateur", "utilisationCourateur", "utilisationApplicant", "utilisateurApplicant", "utilisateurGovernante", "utilisateurApplicante", "utilisateurParticipante", "utilisateurApplicateur", "utilisateurGovernants", "utilisationApplicante", "utilisationCourante", "utilisateurParticipants", "utilisationApplicants", "utilisateurGovernant", "utilisationCourant"], "support": ["cover", "system", "help", "pport", "allow", "push", "plugin", "protection", "format", "pull", "service", "compatible", "document", "contact", "review", "know", "accept", "facebook", "Support", "supp", "utils", "share", "supported", "library", "concept", "friend", "Library", "force", "best", "storage", "media", "services", "client", "util", "settings", "respect", "feature", "ann", "control", "knowledge", "summary", "config", " Support", "proxy", "info", "evidence", "bank"], "ficheDocument": ["fcheMatrix", "FcheDoc", "Fchedocument", "fielDocument", "friqueDoc", "fraudDirectory", "fagueMatrix", "frauddocument", "facheDocuments", "fagueDocument", "enfoiceCatalog", "financedocument", "FicheDocument", "finedocument", "fichedocument", "ficheCompany", "fchaDocument", "Fichedocument", "inficheDoc", "financeDocument", "ficheDocuments", "afficheFeature", "fetchDocument", "affineFeature", "inficheNumber", "facheMatrix", "financeDoc", "fetchFeature", "fetchdocument", "fielCompany", "fruitDocument", "foineDoc", "enficheCompany", "infichedocument", "afficheDocument", "fcheContent", "infraudNumber", "enficheDirectory", "financeNumber", "fraudCatalog", "fineDoc", "fagueDocuments", "fcheDirectory", "fraudCompany", "FcheContent", "foiceCatalog", "enficheDocument", "fchaDoc", "foiceDirectory", "friquedocument", "facheDocument", "fcheDocument", "ficheNumber", "fcheDocuments", " fcheDirectory", " ficheMatrix", "enficheCatalog", "foiceCompany", "fchedocument", "FcheDocument", "ficheCatalog", "fcheDoc", " ficheDirectory", "fetchDoc", "foineDocument", "ficheDirectory", " fcheDocuments", "ficheDoc", "FicheContent", "fineDocument", "infraudDoc", " ficheDocuments", "fielCatalog", "enfoiceDocument", "facheDirectory", "friqueContent", "fraudDocument", "fineFeature", "foinedocument", "ficheContent", " fcheDocument", "affineDoc", "fruitNumber", " fcheMatrix", "foineFeature", "affinedocument", "fielDirectory", "fchadocument", "inficheDocument", "foiceDocument", "enfoiceDirectory", "infraudDocument", "FicheDoc", "enfoiceCompany", "affichedocument", "ficheFeature", "fraudNumber", "afficheDoc", "fruitdocument", "fruitDoc", "friqueDocument", "fraudDoc", "infrauddocument", "fagueDirectory", "affineDocument", "ficheMatrix", "fchaContent"], "nomFichier": ["nomFiquieri", "nomFach\u00e8re", "nomWchire", "nomFochery", "nomFachire", "nomFiscer", "nomPrefchrier", "nomPchy", "nomFichterer", "nomFicherer", "nomFachiner", "nomWchery", "nomFitherer", "nomFisciner", "nomFchien", "nomFicher", "nomFacherer", "nomPrefchier", "nomPhichiere", "nomNichtier", "nomWichery", "nomFrenchier", "nomFachrier", "nomFochiere", "nomFichtiller", "nomFichy", "nomFiscien", "nomPichier", "nomVicher", "nomFchier", "nomFrenchieri", "nomWichiere", "nomFcher", "nomVcher", "nomNichiller", "nomFchery", "nomPrefchire", "nomFiscery", "nomF\u00e9tery", "nomPhacherer", "nomFichtiere", "nomPichery", "nomF\u00e9tier", "nomFichieri", "nomFichtire", "nomF\u00e9tien", "nomF\u00e9ty", "nomFchire", "nomNichier", "nomPchien", "nomNicher", "nomFchieri", "nomNichtiller", "nomFichire", "nomFichiner", "nomFiquier", "nomFiscy", "nomFich\u00e8re", "nomWchier", "nomPhachiere", "nomVichieri", "nomPichy", "nomFichtery", "nomNichter", "nomFithiere", "nomFochier", "nomFichiere", "nomVchier", "nomFichtier", "nomFiscier", "nomFichtieri", "nomFch\u00e8re", "nomPrefichier", "nomFachiller", "nomNichiner", "nomFrencher", "nomPchier", "nomFchy", "nomPrefchieri", "nomPhachier", "nomFachieri", "nomPchery", "nomVchieri", "nomVich\u00e8re", "nomVichier", "nomFachier", "nomFichter", "nomPhachieri", "nomPhichier", "nomFacher", "nomFithier", "nomFiquire", "nomFchiere", "nomFichtiner", "nomPrefichieri", "nomFchrier", "nomVch\u00e8re", "nomPichien", "nomFochire", "nomPrefichrier", "nomNichtiner", "nomFachiere", "nomFrench\u00e8re", "nomWchiere", "nomFichrier", "nomPhichieri", "nomFithieri", "nomWichire", "nomFiqurier", "nomFichien", "nomWichier", "nomPhicherer", "nomPrefichire", "nomFisciller", "nomFichiller", "nomFichery"], "extension": ["exression", "extion", "exion", "exception", "extensions", "Extensions", "EXTime", "encression", "Extime", "Extception", "anchension", "EXTension", "extression", "anchime", "extception", "anchensions", "encension", "Extression", "extime", "encion", "Extension", "Extion", "EXTensions", "encception", "exension"], "fichierElectroniqueExistant": ["fichierElectroniqueXistance", "fichierElectroniquesXclusive", "fichierElectroniqueExplists", "fichierElectroniqueXists", "fichierElectroniquesExivist", "fichierElectroniqueSistent", "fichierElectroniquesExists", "fichierElectroniqueexclusive", "fichierElectroniquesXilingual", "fichierElectroniqueexistant", "fichierElectroniquesExistant", "fichierElectroniqueSilingual", "fichierElectroniqueExivist", "fichierElectroniquesXistent", "fichierElectroniquesXivist", "fichierElectroniqueXclusive", "fichierElectroniqueExists", "fichierElectroniqueXivist", "fichierElectroniqueexistent", "fichierElectroniqueSistant", "fichierElectroniquesExist", "fichierElectroniqueexivist", "fichierElectroniqueExplistant", "fichierElectroniqueSistance", "fichierElectroniquesXists", "fichierElectroniquesExistance", "fichierElectroniqueExplistance", "fichierElectroniqueExclusive", "fichierElectroniquesXistant", "fichierElectroniquesExclusive", "fichierElectroniqueexilingual", "fichierElectroniqueexistance", "fichierElectroniqueexist", "fichierElectroniquesXist", "fichierElectroniqueExplist", "fichierElectroniquesXistance", "fichierElectroniqueXist", "fichierElectroniqueXistant", "fichierElectroniqueExistent", "fichierElectroniqueXistent", "fichierElectroniquesExilingual", "fichierElectroniquesExistent", "fichierElectroniqueExplivist", "fichierElectroniqueXilingual", "fichierElectroniqueExist", "fichierElectroniqueExilingual", "fichierElectroniqueExistance", "fichierElectroniqueExplclusive", "fichierElectroniqueexists"], "idIgid": ["idUguname", "idEGbit", "idIgenID", "idIgdid", "idEGid", "idIogbit", "idEgids", "idIgID", "idIguod", "idIGids", "idIguname", "idEgbit", "idIgudid", "idUgid", "idIguID", "idIogdid", "idIgids", "idIgnid", "idIggod", "idIgenids", "idUguids", "idIgubit", "idUgids", "idIogids", "idIGbit", "idIgmids", "idUguid", "idIgnID", "idUgID", "idIgnod", "idUguID", "idIgmid", "idIggID", "idIGid", "idIggid", "idIgenname", "idIgod", "idIogid", "idIgbit", "idIGdid", "idIguid", "idEGids", "idIguids", "idUgname", "idEgdid", "idIgenid", "idIgmID", "idIgname", "idIggids", "idEgid", "idEGdid", "idIgmname", "idIgnids"], "inputStream": ["InputLength", "inputstream", "inputStreamer", "outputLength", "outputThread", "InputThread", "Inputstream", "outputSteam", "outputstream", "inputSteam", " inputThread", "eventStream", "InputStream", "inputLength", "InputStreamer", " inputLength", " inputstream", "outputStreamer", "eventstream", " inputSteam", "InputSteam", "eventSteam", "inputThread", "eventStreamer"], "outputStream": ["entitystream", "inputstream", "inputStreamer", " outputContext", "entitySteam", "inputContext", " outputstream", "officeStream", "OutputStream", "outputSteam", "outputstream", "inputSteam", "OutputContext", "Outputstream", "entityStreamer", "officeSteam", "officestream", "OutputSteam", "OutputStreamer", "outputStreamer", "entityStream", "outputContext", "officeStreamer", " outputSteam"], "typeMime": ["TypeSmide", "typeMetangle", "TypeMide", "typeMatime", "typeSmide", "TypeSmimes", "typeMatangle", "TypeMime", "typeMetime", "TypeMimes", "typeSmangle", "typeMimes", "typeMatide", "TypeMangle", "typeMangle", "typeMatimes", "TypeSmime", "typeMetide", "TypeSmangle", "typeMide", "typeSmime", "typeMetimes", "typeSmimes"], "tailleFichier": [" tailleFichie", " taillefochier", " tailleFicher", " tailleFigner", " taillefocher", " taillefichiers", " tailleFicheier", " tailleFicheer", " taillefochiers", " taillefichier", " tailleFochiers", " tailleFignie", " tailleFochier", " tailleFichiers", " tailleFochie", " tailleFigniers", " taillefochie", " taillefichie", " tailleFocher", " tailleFicheie", " tailleFicheiers", " tailleficher", " tailleFignier"]}}
{"id1": "17791385", "id2": "3187685", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"src": ["inst", "inf", "filename", "st", "rb", "uri", "sb", "source", "resource", "upload", "sin", "http", "sl", "input", "dist", "dest", "txt", "sup", "file", "url", "sc", "ins", "img", "ls", "files", "s", "image", "obj", "b", "sit", "sel", "rc", "stream", "loc", "config", "ipl", "back"], "dst": ["dsts", "fdfd", "pdft", "pdst", "dfd", "Dsts", "ddfd", "ddsp", "stst", "stlt", "Dst", " dlt", "dft", "stdest", "fdst", "pdsp", "dlt", "fdsp", "Ddest", "fdft", "pdfd", "ddft", " ddest", "ddest", "ststs", "ddst", "dsp", " dsts", "Dlt"], "in": ["gin", "f", "data", "socket", "inn", "i", "ln", "con", "sin", "is", "input", "init", "kin", "din", "conn", "lin", "url", "rin", "reader", "file", "ins", "impl", "bin", "m", "err", "inner", "inside", "as", "win", "In", "n", "cin", "inc", "IN", "nin", "ini", "r", "login", "h", "again", "oin", "pin", "pull", "id"], "out": ["ext", "f", "sync", "x", "OUT", "other", "i", "output", "off", "line", "server", "writer", "parent", "Out", "raw", "conn", "file", "plain", "part", "w", "temp", "bin", "exp", "err", "net", "io", "s", "self", "up", "obj", "client", "o", "exec", "outs", "outer", "n", "at", "inc", "post", "cache", "ex", "copy", "again", "null"], "buf": ["queue", "ctx", "length", "bl", "cat", "rb", "data", "bh", "bb", "wb", "pad", "bc", "off", "buff", "fb", "seq", "ff", "base", "bf", "raw", "v", "vec", "fd", "lim", "bin", "cb", "bd", "buffer", "br", "batch", "cmd", "bytes", "b", "c", "rc", "uf", "cur", "loc", "cap", "val", "uc", "count", "fl", "bag"], "len": ["cl", "f", "length", "data", "no", "i", "lc", "end", "ln", "lt", "line", "ind", "sl", "el", "lf", "base", "nt", "lin", "fd", "part", "ix", "rev", "lim", "bin", "err", "name", "pos", "c", "le", "all", "en", "l", "size", "ll", "Len", "n", "fin", "split", "cap", "count", "val", "li", "fl"]}}
{"id1": "18046717", "id2": "20210699", "code1": "    private String getFullClassName(URL url, String className) throws Exception {\n        JarInputStream jis = new JarInputStream(url.openStream());\n        ZipEntry zentry = null;\n        while ((zentry = jis.getNextEntry()) != null) {\n            String name = zentry.getName();\n            int lastPos = name.lastIndexOf(\".class\");\n            if (lastPos < 0) {\n                continue;\n            }\n            name = name.replace('/', '.');\n            int pos = -1;\n            if (className != null) {\n                pos = name.indexOf(className);\n                if (pos >= 0 && name.length() == pos + className.length() + 6) {\n                    jis.close();\n                    return (name.substring(0, lastPos));\n                }\n            }\n        }\n        jis.close();\n        return (null);\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"url": ["loader", "address", "re", "jar", "uri", "src", "service", "ssl", "string", "source", "user", "resource", "path", "rule", "host", "server", "http", "entry", "ur", "org", "sl", "URL", "html", "base", "file", "page", "gl", "location", "connection", "io", "image", "job", "or", "l", "Url", "loc", "ob", "date"], "className": ["ClassName", "classValue", "objectName", " classNAME", "methodPath", "classClass", "shortString", "ClassValue", "objectname", "objectString", "classPath", "methodValue", "classType", "shortName", " classType", "onNAME", "shortNAME", "shortType", "classCode", "shortname", " classPath", " classString", "objectCode", " classCode", "onName", "ClassPath", "shortClass", "methodName", "classNAME", "objectType", " classValue", "classString", " classname", "methodname", "classname", "objectPath", "Classname", "ClassCode", " classClass", "onClass", "onname"], "jis": [" jiss", "lbis", "lris", "lis", "zbis", "jiss", "ajais", "ziss", "zris", "jamhas", "ajbis", "jris", " jris", "liss", "lais", "zhas", " jhas", "jhas", "ajis", "ajris", "ajiss", "zis", "jamais", "jamiss", "zais", " jais", "jais", "jamis", "jbis"], "zentry": [" zzip", "zientry", "tzentry", "zipester", "zester", "zozip", "czentry", "zfile", "zipEntry", " zester", "zie", "ziie", "lentry", "zenter", "zsource", "zoentry", "zoenter", "lzip", "tzzip", "lfile", "zipentry", "zEntry", "tzfile", "czenter", " zEntry", "tzenter", "zofile", "zipie", "jentry", "ziester", " zsource", "jenter", "zzip", "ziEntry", "czzip", "jzip", "czsource", "lenter", "jsource", " zie", " zenter"], "name": ["common", "number", "named", "address", "f", "filename", "x", "prefix", "data", "string", "no", "home", "alias", "end", "path", "none", "str", "entry", "class", "search", "value", "base", "error", "file", "in", "ix", "part", "type", "one", "now", "connection", "NAME", "comment", "style", "inner", "self", "image", "Name", "up", "code", "space", "old", "ame", "l", "size", "start", "pass", "n", "work", "key", "clean", "api", "word", "default", "info", "names", "e", "id"], "lastPos": ["lastPosition", "prevpos", "prevLen", "firstPos", "estPOS", "estPosition", "firstPart", "firstpos", " lastRes", "nextPos", " lastPOS", "lastPart", "lastLen", "prevPosition", "lastpos", "nextpos", "estRes", " lastLen", " lastPart", " lastpos", "lastPOS", "estPos", "firstRes", "firstLen", "firstPOS", "lastRes", " lastPosition", "nextPart", "firstPosition", "prevPos", "nextLen"], "pos": ["lit", "POS", "x", "push", "length", "cond", "fun", " len", "no", "i", "end", "Pos", "diff", "eff", "off", "line", "cos", "nos", "limit", "pose", "is", "z", "len", "seq", "cas", "pro", "p", "os", "min", "ix", "neg", "part", "prop", "rev", "act", " position", "spec", "style", "offset", "unit", "obj", "po", "j", "doc", "ps", "size", "start", "pass", "position", "pt", "loc", "post", "val", "count", "index", "pointer", "col", "none"]}}
{"id1": "1188100", "id2": "16092702", "code1": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"s": ["session", "states", "ans", "S", "f", "cs", "d", "sync", "ses", "g", "lines", "ssl", "sb", "abs", "i", "es", "source", "service", "stats", "server", "parts", "ds", "is", "sl", "its", "opens", "bs", "p", "os", "ils", "ns", "w", "gs", "ls", "ms", "m", "south", "state", "sets", "bis", "storage", "services", "ws", "ops", "o", "b", "as", "settings", "outs", "rs", "ss", "ps", "l", "less", "ts", "n", "js", "si", "sym", "h", "out", "fs", "e", "ks"], "input": ["a", "data", "source", "i", "xml", "flow", "output", "feed", "response", "read", "server", "this", "reading", "raw", "in", "Input", "reader", "temp", "w", "rss", "type", "io", "buffer", "image", "storage", "up", "o", "instance", "stream", "qa", "audio", "api", "r", "copy", "out", "null"], "writer": ["wan", "wrapper", "walker", "a", "data", "rw", "string", "source", "xml", "ler", "wb", "per", "output", "wa", "builder", "str", "riter", "editor", "book", "raw", "office", "reader", "wr", "Writer", "w", "temp", "er", "worker", "writers", "io", "letter", "inner", "buffer", "storage", "keeper", "written", "o", "write", "outer", "WR", "key", "r", "writ", "copy", "word", "out", "null", "writing"]}}
{"id1": "23672408", "id2": "8135072", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 1, "substitutes": {"clazz": ["sloss", "clod", "closs", "elaz", "loser", " clobe", "classe", "chou", "Clott", "slod", " clclass", "Clone", "CLod", "elazz", "laone", "Clclass", "lasse", "sllass", " claz", "ploser", "Cllass", "CLazz", "flance", "chaz", "Claz", "Classe", "plazz", "Closs", "slaz", "CLobe", "chazz", "slazz", "closer", "lazz", "sloser", "plclass", "CLaz", "laoss", "Clou", "chott", "laz", "clobe", "CLosing", "CLlass", "closing", "llass", "slone", "clott", "clou", "klaz", "klod", "klazz", "fllass", "elott", "Clazz", "CLoser", "lance", " cllass", "laazz", "slosing", "Closer", "clance", "flazz", "floser", "cllass", " closer", "klosing", "claz", "clclass", "laclass", "pllass", "clone", " clance", "Clance", " classe", "slobe", "slclass", "elou"], "i16": ["ini33", "id2016", "ii14", "idi1600", "i14", "ini14", "si1600", "ii20", "ii1600", "idi64", "isi14", "i33", "id15", "si33", "si16", "id16", "si15", "ii160", "i160", "ini16", "i15", "si14", "isi16", "ii16", "I15", "ii33", "isi1600", "ini2016", "i2016", "si160", "i20", "i1600", "I1600", "si20", "i64", "si2016", "ini160", "I16", "ii15", "idi16", "ini15", "I14", "ini20", "idi15", "si64", "isi15", "ii64", "id14"], "fileType": [" fileTyp", "featureTyp", "eventTy", "ileType", "playTyp", "imageTime", "fileTyp", "messageTy", "lineType", "fileTy", "fileTypes", "iconType", "channeltype", "eventTyp", "eventSize", "functionSpread", "iconSize", "pathType", "functionType", "filetype", " fileTime", "fileLike", "FILEBlock", "filePatch", "messagetype", "imageName", "lineTyp", "featureType", "fileRel", " filetype", "filePath", "iletype", "FILESize", "FILEType", "fileForce", " fileTy", "imageType", "fileClass", "pathtype", "featureBlock", "channelForce", "fileTime", "channelType", "playPath", "FileBlock", "eventPatch", "fileSpread", "ileTypes", " fileClass", "iconPatch", "channelClass", "pathName", "alLike", "lineSize", "messageType", "featureSize", " fileName", "featureRel", " filePath", " fileSpread", "linePath", "channelTyp", "channelTy", " fileBlock", "FileRel", "FILEPatch", "channelSpread", "eventType", "featureTy", "functionForce", " fileInfo", "fileSize", "featureInfo", "functionTyp", "imageLike", "ileLike", "fileInfo", " fileForce", "imageTypes", "eventBlock", " fileRel", "fileBlock", "altype", "messageClass", "fileName", "alTypes", "alType", "pathTime", "playSize", "playType", "imagetype", "iconBlock", " fileSize", "FileType", "FileInfo"], "desti16": ["deleteI16", "deleteI160", "deletei1600", "deletei116", "destu66", "desci16", "destii15", "destidi160", "destabi16", "destidi1600", "destii66", "destii16", "destabi160", "descu16", "descu166", "deste166", "desci15", "desti15", "destii166", "destu15", "desti1600", "deste16", "desti116", "destI16", "descu66", "destidi16", "deleteI116", "destI1600", "destu166", "deleteI1600", "deletei16", "deletei160", "destI116", "desci166", "desti66", "destabi116", "desti160", "deste15", "destu16", "descu15", "destI160", "destidi116", "desti166", "deste66", "destabi1600", "desci66"], "src": ["uri", "ssl", "sb", "usr", "http", "sl", "input", "url", "sc", "rss", "bot", "sel", "download", "crop", "uv", "view", "config", "sys", "kk", "target", "rest", "inf", "sync", "data", "source", "upload", "tmp", "iv", "lib", "console", "rob", "dest", "desc", "thumbnails", "img", "cdn", "gz", "archive", "stream", "ctr", "r", "pull", "video", "ctx", "st", "rb", "content", "gb", "resource", "output", "buf", "dist", "secure", "load", "front", "req", "func", "gl", "cb", "sq", "proc", "start", "ource", "scene", "default", "coll", "back", "inst", "filename", "remote", "sr", "impl", "image", "acl", "obj", "b", "rc", "cmp", "scenes", "cur", "loc", "rl", "https", "null"], "dst": ["dsts", "sdput", "dind", "sdbl", "dtd", "dibl", "hdst", "edost", " dbl", "DST", "edst", "edST", "Dsts", "madST", "dost", "madstore", "dedput", "fsp", " dtd", "edstore", "madost", " dput", "dedsc", "dsc", "dedst", "dnt", "fbl", "pput", "sddest", " dsc", "Dost", "idbl", "dest", "sdst", "sdsc", "hdnt", "Dst", "hdest", " dnt", "dist", "idsp", "Dbl", "pst", "dST", "Dstore", "sdnt", "idst", "ditd", "dnd", "dedbl", "hddest", "Dnd", " dost", "dstore", " dest", "idost", "dput", "fst", " dnd", "dbl", "Dput", "Dsp", "Dtd", " ddest", "psts", "ddest", "post", "madst", "dsp", "sdest", " dsts", "fost"], "i32": ["in34", "l34", "iu32", "in32", "pi34", "i36", "e33", "ui34", "l32", "e52", "pi33", "ui31", "in31", "i33", "u32", "l33", "u31", "i35", "ui32", "iu34", "e40", "int35", "i31", "int40", "pi52", "e32", "i52", " i35", "iu31", "in16", " i31", " i36", "int36", "e34", "ui16", "l52", " i34", "int32", "e35", " i40", "pi32", "e36", "pi31", "i34", "u33", "iu33", "i40", "u34"], "desti32": ["destii29", "sourcei15", "sourcei30", " Destin34", "destin34", " Destin32", "destidi34", "destidi30", "destin32", " Desti29", "sourceiu32", "deste34", "desti31", " Destin31", "desti15", "desti34", "deste32", "destii32", "destiu34", "deste30", "destiu32", "sourceiu34", " Desti34", "destii31", "desti30", "destidi15", "deste15", "destiu30", " Desti31", "destin29", " Destin29", "sourcei32", "destin31", "sourcei34", "sourceiu15", "destidi32", "destiu31", "destiu29", "desti29", "sourceiu30", " Desti32", "destiu15", "destii34"]}}
{"id1": "11716816", "id2": "1097147", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"file": ["queue", "f", "filename", "data", "content", "socket", "source", "resource", "path", "handler", "line", "http", "pe", "zip", "input", "class", "this", "File", "folder", "parent", "base", "lock", "load", "fp", "url", "full", "part", "files", "type", "single", "connection", "future", "image", "name", "up", "info", "dir", "b", "l", "ile", "FILE", "cache", "log", "local", "object", "model", "e"], "destFile": ["destF", "srcFolder", "destDirectory", "DestDir", " destinationFile", " destinationDir", "DestDirectory", " destDir", "foreignF", "destFiles", "DestClass", "srcLine", "DestFolder", "foreignLine", "srcFiles", "DestLine", "destClass", "destLine", " destinationFiles", "targetF", "DestFile", "sourceFiles", "destFunction", " destF", "sourceDir", "targetFile", "targetFiles", "DestFiles", "foreignFile", "destFolder", "targetClass", " destDirectory", "foreignDir", "targetDir", "DestFunction", "sourceFile", "sourceDirectory", "destDir", " destinationFunction", " destFolder", "srcFile", " destFunction", " destLine", " destClass", "targetLine", " destFiles"], "in": ["gin", "f", "sync", "a", "x", "cl", "isin", "socket", "inn", "source", "i", "con", "token", "on", "ax", "el", "input", "arin", "this", "init", "lock", "p", "min", "din", "conn", "reader", "rin", "ins", "bin", "connection", "err", "inner", "io", "s", "up", "client", "c", "b", "as", "inside", "l", "win", "In", "work", "pass", "cin", "inc", "ac", "IN", "nin", "ini", "r", "login", "again", "info", "pin", "pull", "id"], "out": ["ext", "f", "sync", "OUT", "socket", "source", "i", "resource", "output", "on", "off", "server", "password", "option", "t", "lib", "writer", "this", "group", "parent", "Out", "p", "v", "conn", "destroy", "url", "co", "w", "temp", "timeout", "bin", "exp", "err", "connection", "net", "io", "to", "call", "default", "name", "up", "client", "channel", "o", "b", "c", "outs", "outside", "outer", "In", "pass", "n", "at", "inc", "cache", "ex", "login", "extra", "again"]}}
{"id1": "8093133", "id2": "4016687", "code1": "    public static Object loadXmlFromUrl(URL url, int timeout, XML_TYPE xmlType) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        BufferedInputStream buffInputStream = new BufferedInputStream(connection.getInputStream());\n        return loadXml(buffInputStream, xmlType);\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        String sFTP = \"ftp.miservidor.com\";\n        String sUser = \"usuario\";\n        String sPassword = \"password\";\n        try {\n            System.out.println(\"Conectandose a \" + sFTP);\n            client.connect(sFTP);\n            boolean login = client.login(sUser, sPassword);\n            if (login) {\n                System.out.println(\"Login correcto\");\n                boolean logout = client.logout();\n                if (logout) {\n                    System.out.println(\"Logout del servidor FTP\");\n                }\n            } else {\n                System.out.println(\"Error en el login.\");\n            }\n            System.out.println(\"Desconectando.\");\n            client.disconnect();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"url": ["loader", "address", "user", "uri", "service", "ssl", "string", "source", "resource", "path", "feed", "host", "str", "server", "http", "org", "sl", "URL", "base", "file", "page", "conn", "location", "io", "image", "buffer", "open", "obj", "client", "l", "link", "Url", "loc", "config", "object", "id"], "timeout": ["scroll", "length", "delay", "sync", "data", "port", "socket", "time", "ssl", "resource", "token", "capacity", "server", "limit", "duration", "wait", "window", "lock", "period", "Timeout", "sleep", "type", "network", "io", "offset", "buffer", "unit", "client", "until", "resolution", "size", "cache", "seconds", "key", "config", "out"], "xmlType": ["writerType", "phpFile", "writerStyle", "mlFile", "phpClass", " xmlTypes", " xmlStyle", "elementtype", "phpTypes", "xmltype", "mlType", "elementStyle", " xmltype", " xmlModel", "writertype", "mlClass", "mlTypes", "elementModel", "xmlModel", " xmlClass", "xmlFile", " xmlFile", "xmlStyle", "elementType", "xmlTypes", "xmlClass", "phpType", "writerModel"], "connection": ["application", "Connection", "wrapper", "version", "union", "condition", "socket", "which", "uri", "lc", "connect", "resource", "section", "builder", "con", "container", " Connection", "handler", "bc", "response", "http", "server", "entry", "character", "writer", "context", "communication", "function", "database", "event", "conn", "reader", "directory", "network", "closed", "io", "unit", "open", "connected", "collection", "client", "channel", "relation", "c", "b", "l", "ion", "position", "loc", "config", "index", "proxy", "use"], "buffInputStream": ["BuffOutputstream", "buffOutputSteam", "buffinputStream", "buffinputSteam", "BuffReadSteam", "BuffOutputStream", "BuffReadstream", "buffReadStream", "buffInstream", "buffInSteam", "buffinputstream", "buffOutputStream", "buffReadstream", "BuffInputStream", "BuffOutputSteam", "buffOutputstream", "buffInStream", "buffInputSteam", "buffInputstream", "buffReadSteam", "BuffInputSteam", "BuffReadStream", "BuffInputstream"]}}
{"id1": "7891509", "id2": "10547671", "code1": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 1, "substitutes": {"pageAddress": [" pageName", "siteName", "urlUrl", "urlNumber", "pageName", "urlLocation", " pageUrl", "PageName", "siteUrl", "pageUrl", "PageAddress", "PageNumber", "siteLocation", " pageLocation", " pageNumber", "pageNumber", "urlAddress", "siteAddress", "PageUrl", "pageLocation", "PageLocation"], "url": ["loader", "address", "f", "plugin", "data", "socket", "uri", "user", "service", "ssl", "string", "source", "i", "resource", "web", "feed", "host", "server", "http", "sl", "URL", "this", "base", "file", "page", "reader", "ls", "connection", "image", "open", "client", "channel", "b", "browser", "l", "stream", "Url", "r", "out", "object"], "in": ["gin", "f", "data", "isin", "socket", "inn", "ssl", "source", "i", "ln", "con", "token", "line", "read", "input", "init", "rec", "kin", "min", "din", "file", "conn", "reader", "impl", "ins", "bin", "into", "err", "inner", "s", "buffer", "image", "client", "b", "c", "inside", "as", "l", "win", "In", "stream", "inc", "IN", "nin", "ini", "r", "login", "out", "again", "id"], "inputLine": ["outputBlock", "outputText", "outputFile", "inputline", " inputPage", "InputLine", "InputFile", " inputBlock", "inputPage", "rawBlock", " inputString", "outputline", "rawline", "outputLine", "InputPage", "outputPage", "InputBlock", "outputString", " inputFile", "inputText", "inputBlock", "rawLine", " inputText", "rawString", "inputFile", "Inputline", "InputText", "inputString", " inputline"]}}
{"id1": "2465747", "id2": "4798332", "code1": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"urlString": ["URLstring", "resourceString", " urlStr", "shortString", "resourcestring", " urlLine", "httpLine", "urlService", "httpstring", "URLString", "shortStr", "shortstring", "urlLine", " urlstring", "urlstring", "shortLine", "httpString", "resourceStr", "URLService", "URLStr", "urlStr", "resourceService", "httpStr", " urlService"], "data": ["session", "operation", "address", "next", "ui", "format", "uri", "request", "parse", "string", "resource", "output", "response", "parts", "server", "message", "entry", "input", "this", "json", "value", "base", "function", "query", "database", "part", "manager", "state", "to", "results", "module", "media", "done", "batch", "multi", "result", "settings", "as", "keys", "DATA", "key", "body", "metadata", "config", "object", "info", "map", "dat", "dict"], "url": ["session", "system", "address", "f", "user", "uri", "ssl", "string", "connect", "resource", "proxy", "server", "http", "zip", "sl", "org", "URL", "base", "database", "conn", "file", "page", "www", "image", "open", "update", "client", "channel", "build", "l", "link", "Url", "log", "position", "loc", "config", "object"], "connection": ["application", "session", "Connection", "version", "condition", "union", "socket", "uri", "user", "service", "section", "connect", "resource", "document", "proxy", "con", "output", "remote", "handler", "director", "response", "http", "server", "password", "character", "URL", "context", "communication", "function", "database", "conn", "directory", "timeout", "io", "image", "open", "connected", "later", "client", "channel", "relation", "c", "l", "link", "index", "log", "position", "loc", "driver", "config", "use", "object"], "out": ["ext", "dump", "prefix", "OUT", "user", "socket", "ssl", "string", "no", "builder", "con", "output", "line", "server", "editor", "cli", "writer", "init", "group", "again", "Out", "conn", "file", "part", "page", "w", "temp", "plain", "full", "office", "co", "err", "net", "io", "inner", "comment", "name", "up", "client", "o", "print", "outs", "exec", "outer", "cache", "log", "inc", "stop", "key", "report", "copy", "extra", "object", "login"], "keySet": ["characterHash", " keyString", "KeyLine", "keyType", " keySetting", "elementLine", "keyLine", " keyPoint", "typeType", "elementString", "keyString", "featureString", "featureHash", " keyInfo", "featureSet", "keyPoint", "keyHash", "characterSet", "KeyString", "fieldSet", "queryString", " keyLine", "KeyInfo", "typeKey", "KeySetting", "querySet", "queryInfo", "characterString", "keySetting", "KeyPoint", "fieldSize", "keySize", "characterKey", "typeSet", "keyKey", "KeySet", " keyList", "featureList", " keyType", "elementSet", "fieldString", " keySize", "keyList", " keyKey", "KeySize", "keyInfo", "elementSetting", "characterList", " keyHash", "characterType", "queryLine", "fieldPoint", "typeString"], "values": ["stores", "names", "words", "lists", "lines", "changes", "UES", "limits", "pes", "views", "parts", "boxes", "points", "groups", "value", "items", "ints", "tests", "maps", "Values", "vs", "properties", "params", "events", "als", "uments", "measures", "marks", "results", "ums", "services", "versions", "frames", "vers", "objects", "details", "vals", "settings", " Values", "types", "ones", "ues", "keys", "ports", "vi", "fields", "verts", "options", "rules"], "count": ["number", "length", "core", "time", "weight", "path", "limit", "class", "value", "first", "type", "code", "old", "n", "current", "index", "e", "depth", "address", "f", "next", "other", "group", "base", "num", "Count", "test", "key", "field", "use", "col", "id", "patch", "content", "check", "counter", "cycle", "i", "ind", "list", "len", "repeat", "part", "level", "c", "order", "sum", "start", "coll", "child", "found", "low", "label", "parent", "page", "now", "call", "force", "name", "batch", "multi", "all", "size", "loop"], "in": ["gin", "isin", "socket", "inn", "i", "con", "ic", "fr", "is", "input", "arin", "init", "rec", "kin", "din", "conn", "lin", "reader", "rin", "ins", "bin", "into", "err", "inner", "c", "b", "as", "l", "win", "In", "cin", "inc", "IN", "nin", "body", "r", "ex", "ini", "login", "again", "pin", "e"], "inputLine": ["inputData", "inputline", "InputLine", "instanceLine", " inputByte", "inputStream", "intLine", " inputString", "outputline", "rawData", "instanceStream", "rawline", "outputLine", "inputByte", "instanceline", " inputData", "InputByte", "intline", "outputString", " inputStream", "rawLine", "outputStream", "Inputline", "intByte", "InputData", "instanceString", "intData", "inputString", " inputline"], "returnData": ["loadResult", "ReturnInfo", " returnResult", "resultLine", "resultInfo", "returnPart", "ReturnDat", "outputData", "outputBody", " returnString", "getData", "ReturnResult", "retBu", " returnLine", "returnValue", "outputBu", "getDat", "returnBu", " returnBody", "ReturnString", "retString", "newBody", "loadDat", "returnLine", "loadString", "newValue", " returnPart", " returnInfo", "loadData", " returnDat", "returnResult", "newData", "getString", "outputString", "retData", "returnString", "ReturnData", "outputValue", "getBu", "retDat", "returnDat", "outputDat", "ReturnPart", "newString", "returnInfo", "resultPart", "ReturnLine", "resultData", " returnValue", "returnBody"]}}
{"id1": "17786231", "id2": "12783713", "code1": "        private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException {\n            HttpClient client = new DefaultHttpClient();\n            HttpGet httpGet = new HttpGet(downloadUrl);\n            final File outputFile = new File(destinationFile);\n            createParentDirectories(outputFile);\n            FileOutputStream outputStream;\n            outputStream = new FileOutputStream(outputFile);\n            final HttpResponse response = client.execute(httpGet);\n            if (isInterrupted()) {\n                outputStream.close();\n                return;\n            }\n            final HttpEntity entity = response.getEntity();\n            InputStream inputStream = null;\n            try {\n                if (entity != null) {\n                    inputStream = entity.getContent();\n                    CopyStreamStatusCallback callback = new CopyStreamStatusCallback() {\n\n                        @Override\n                        public long getSkipBetweenUpdates() {\n                            return entity.getContentLength() * 2 / PERCENTAGE_BASE;\n                        }\n\n                        @Override\n                        public void onUpdate(final long copiedLength) {\n                            int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength());\n                            handleUpdate(STATUS_DOWNLOADING, percentage);\n                        }\n                    };\n                    copyStreams(inputStream, outputStream, callback);\n                }\n            } finally {\n                try {\n                    outputStream.close();\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                } catch (IOException e) {\n                    Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e);\n                }\n            }\n        }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"downloadUrl": ["downloadurl", "outputUrl", "outputurl", "transferFile", "transferurl", "transferUrl", "downloadFile", "updateLine", "transferURL", " downloadurl", "downloadLine", "outputLine", "downloadURL", "updateFile", "updateUrl", "outputURL", " downloadLine", "updateURL", "updateurl", " downloadURL"], "destinationFile": ["destoutputImage", "destigrationFiles", "destoutputFile", "destinatingFilename", "destinatedFILE", "DestinationImage", "destoutputFiles", "destinationString", "destigrationFilename", "DestinatingFILE", "destinationFiles", "destinatingFILE", "destinatingString", "destinatingFile", "destinationFilename", "destigrationFILE", "DestinatingFile", "destporaryString", "destinationFILE", "DestinatingFiles", "DestinationFILE", "DestinatingImage", "destoutputString", "destporaryFile", "DestinationString", "destinatingFiles", "DestinatingFilename", "destinatedFile", "DestinationFile", "destporaryFiles", "destporaryImage", "DestinatingString", "DestinationFiles", "DestinationFilename", "destinatedFilename", "destinationImage", "destinatingImage", "destigrationFile", "destinatedFiles"], "client": ["application", "session", "queue", "bird", "cl", "plugin", "cher", "uri", "service", "request", "connect", "remote", "resource", "app", "per", "con", "contact", "handler", "http", "server", "cli", "project", "ce", "parent", "query", "conn", "url", "method", "connection", "call", "get", "self", "force", "channel", "c", "cache", "api", "https", "config", "proxy", "Client"], "httpGet": ["ttpCall", "HttpGet", " httpPut", "ttpGet", "resourcePut", "HttpCreate", "httpCall", " httpSend", "ttpCreate", "Httpget", " httpCall", "HttpCall", " httpCreate", "resourceCall", "httpSend", "resourceGet", "httpCreate", "resourceget", "ttpSend", " httpget", "HttpSend", "httpget", "httpPut", "HttpPut"], "outputFile": ["outStream", "outPath", "outputFiles", "outputfile", "writefile", " outputfile", "inputFiles", "outputDirectory", " outputDir", "referenceStream", "writeFile", "referencePath", "referencefile", "outfile", "targetFile", "targetFiles", "inputDir", "targetDir", "outputPath", "inputFile", "targetDirectory", "writePath", "outputDir", " outputFiles", "outFile", "referenceFile", "writeStream", " outputPath", " outputDirectory", "inputDirectory"], "outputStream": ["OutputFile", "inputStreamer", "outputWriter", "OutputWriter", "inputWriter", "responseSteam", "OutputStream", "outputSteam", "inputSteam", "responseStream", "inputForm", "logStreamer", "logStream", " outputForm", " outputStreamer", "logSteam", " outputWriter", "responseWriter", "logWriter", "OutputSteam", "outputStreamer", "responseFile", "OutputForm", "inputFile", " outputSteam", "outputForm"], "response": ["application", "session", "queue", "version", "data", "received", "request", "ception", "resource", "document", "success", "output", "feed", "handler", "http", "server", "generation", "Response", "json", "respond", "query", "reply", "error", "event", "connection", "image", "collection", "relation", "result", "resp", "body", "report", "api", "object", "status", "message"], "entity": ["application", "issue", "data", "content", "ie", "service", "ity", "source", "resource", "document", "xml", "output", "status", "ent", "id", "server", "entry", "pe", "message", "el", " identity", "ce", "json", "event", "volume", "file", "url", "translation", "environment", "connection", "state", "comment", "agent", "unit", "image", "element", "media", "collection", "coll", "channel", "email", "machine", "result", "instance", "component", "Entity", "cache", "item", "body", "node", "api", "attribute", "object", "model", "e", "metadata"], "inputStream": ["downloadstream", "audioStreamer", "selectStream", "inputstream", "InputLength", "inputStreamer", "inputChannel", "selectStreamer", "downloadLength", "Inputstream", "InputFile", "outputstream", "outputSteam", "inputSteam", " inputStreamer", "InputBuffer", "childChannel", " inputChannel", "InputStream", "inputLength", "InputStreamer", " inputLength", "selectFile", " inputstream", " inputBuffer", "outputBuffer", " inputFile", "childStreamer", "audiostream", "childSteam", "downloadStream", "selectSteam", "inputBuffer", "outputStreamer", "outputChannel", " inputSteam", "inputFile", "InputSteam", "downloadSteam", "audioSteam", "InputChannel", "childStream", "audioStream"], "callback": ["loader", "wrapper", "sync", "plugin", "data", "back", "resource", "handler", "message", "fb", "cell", "ff", "function", "event", "processor", "func", "CB", "url", "closure", "cb", "backs", "call", "connection", "state", "future", "buffer", "Callback", "code", "collection", "batch", "clone", "result", "cc", "cache", "behavior", "consumer", "config", "proxy", "band"], "copiedLength": ["copyiedSize", "copippedlength", "copedBytes", "copyiedWidth", "copyedCount", "copyiedLength", "copixedLength", "copyiedCount", "copyippedSize", "copyippedlength", "copiedBytes", "copiedlength", "copyingSize", "copippedWidth", "copixedBytes", "copyingLength", "copyingCount", "copiedCount", "copodedlength", "copiedWidth", "copyiedBytes", "copyedBytes", "copyippedLength", "copyedSize", "copedCount", "copodedLength", "copyingBytes", "copyedLength", "copiedSize", "copodedWidth", "copyiedlength", "copippedLength", "copodedSize", "copixedSize", "copixedCount", "copyingWidth", "copedSize", "copyinglength", "copyippedWidth", "copippedSize", "copedLength"], "percentage": [" percentile", " Percentages", "percentade", "milade", " Percentage", "Percentade", " percentance", " percentade", " Percentile", "Percentile", "Percentance", " percentages", " percentaged", "milance", "percentages", "Percentages", "percentance", "Percentaged", "percentile", "Percentage", "milage", "percentaged", "milaged", " Percentance"]}}
{"id1": "1371265", "id2": "20210699", "code1": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"channelPath": ["filePath", "downloadPath", "filePattern", "filepath", "downloadPattern", "downloadNode", "cachePath", "fileNode", "cachePattern", "downloadpath", "resourcePattern", "resourcepath", "resourcePath", "cachepath", "cacheNode", "resourceNode"], "dataField": [" dataStr", "resourceField", "resourceCondition", "DataStr", "actionField", "DataField", "actionCondition", " dataCondition", "DataTable", "actionTable", "dataTable", "dataStr", "inputFIELD", "inputfield", "datafield", "resourcefield", "actionStr", "resourceFIELD", "inputField", "DataCondition", "dataCondition", " dataTable", " dataFIELD", "inputCondition", " datafield", "dataFIELD"], "fatherDocId": ["fatherDocumentid", " fatherDocBack", "motherDocPath", "fatherdocName", "fatherDocumentID", "fatherDocBack", " fatherDocID", "fatherDOCID", "fatherPoBack", "fatherdocId", "fatherdocPath", "fatherWriterId", "fatherFileInfo", "fatherDocID", "fatherDocName", "fatherdocInfo", "motherDocid", "fatherDOCLength", " fatherPoid", "fatherDocumentId", "motherDocumentId", "fatherDocumentLength", "fatherWriterBack", "fatherDocLength", "fatherFileName", "fatherPoLength", "fatherWriterid", "motherDocInfo", "fatherDocumentName", " fatherPoID", "motherDocId", " fatherPoBack", "fatherPoid", "fatherFilePath", "motherDocumentName", "motherDocumentLength", "motherDocumentID", "fatherDOCBack", "fatherDOCid", "fatherWriterID", " fatherPoId", "fatherPoID", "motherDocumentInfo", "motherDocumentPath", "fatherDocumentPath", "fatherDocInfo", "fatherPoId", "motherDocLength", "motherDocID", "fatherDocPath", "motherDocName", "motherDocumentid", "fatherDocumentInfo", "fatherFileId", "fatherDocid", "fatherDOCId", " fatherDocid"], "sqlInitial": ["qlinitial", "detailsOriginal", "sqlinitial", " sqlInitialized", "SQLInit", "detailsInitial", " sqlinitial", "qlInitial", "SQLinitial", "SQLInitialized", "sqlInitialized", "detailsinitial", "sqlInit", " sqlInit", "SQLInitial", "sqlOriginal", "qlInit", "qlInitialized", "qlOriginal", "detailsInit", "SQLOriginal"], "sqlsortURL": ["sqlsaltUrl", "sqlsendUrl", "sqlsORTUrl", "sqLSaltURL", "sqLSortSSL", "sqlsaltURI", "sqlsortSSL", "sqlsORTURL", "sqLSortUR", "sqLSaltUR", "sqlsORTURI", "sqlsaltURL", "sqLSortURI", "sqlssortSSL", "sqlsendURL", "sqlsortURI", "sqlsORTSSL", "sqlsortUrl", "sqLSaltURI", "sqLSaltSSL", "sqLSortUrl", "sqlsendURI", "sqlssortUR", "sqLSaltUrl", "sqlsendUR", "sqlssortUrl", "sqlsendSSL", "sqlsaltSSL", "sqlssortURL", "sqlsaltUR", "sqLSortURL", "sqlsortUR"], "conn": ["session", "Connection", "oss", "ca", "ctx", "cm", "cs", "sync", "cat", "core", "pg", "oci", "Con", "connect", "ci", "con", "dc", "cn", "db", "cr", "ds", "pc", "conf", "apt", "pr", "nc", "cp", "p", "nt", "ens", "ns", "co", "res", "act", "ct", "connection", "pub", "sql", "rt", "client", "c", "reg", "cc", "po", "orp", "en", "rc", "Conn", "ann", "dn", "n", "Connect", "pool", "ch", "mc", "enc", "coll", "ks"], "rs": ["rys", "obs", "ans", "cs", "ris", "rr", "rb", "dr", "Rs", "lines", "hr", "pers", "rd", "acks", "sr", "cr", "ds", "hs", "sl", "repl", "its", "ra", "pr", "bs", "ys", "RS", "rows", "maps", "vs", "rss", "ras", "ins", "res", "icks", "ges", "rg", "qs", "results", "arr", "ums", "rt", "asts", "xs", "vers", "runs", "ues", "rc", "ros", "ts", "js", "rx", "rl", "r", "ars", "ows", "sels", "mr", "ks"], "ps": ["pa", "cs", "pg", "lines", "Rs", "pers", "PS", "posts", "per", "pres", "ds", "pe", "pc", "pp", "pps", "pr", "bs", "ys", "p", "amps", "ons", "os", "vs", "ens", "ns", "sp", "ras", "res", "gs", "pex", "pl", "Ps", "ms", "files", "qs", "pse", "s", "tx", "na", "ws", "xs", "LS", "ips", "pos", "pre", "ups", "po", "jp", "ros", "pass", "aps", "js", "ports", "pt", "ts", "mp", "ars", "fs", "eps", "ks"], "dbo": ["ldbo", "delpo", " dba", "Dba", "DBo", "dba", "delbo", "Dpo", "ldBo", " dBo", "dBo", "ldba", "Dbo", " dpo", "dbos", "delBo", "Dbos", " dbos", "dpo", "delbos"], "st": ["ST", "ost", "rest", "inst", "ust", "sts", "cl", "bl", "d", "src", "stand", "ast", "sb", "rd", "string", "lt", "const", "cr", "str", "ft", "sh", "fr", "pe", "t", "sta", "sl", "sth", "pr", "sa", "ut", "nt", "est", "sc", "se", "sp", "stack", "ct", "ist", "s", "rt", "std", "St", "sw", "l", "nd", "ts", "pt", "stop", "r", "ld", "ste", "la", "stri", "sn"], "url": ["address", "allow", "hl", "data", "format", "rel", "user", "uri", "service", "ssl", "string", "source", "request", "resource", "path", "feed", "host", "layer", "server", "http", "sl", "URL", "text", "secure", "html", "base", "file", "page", "type", "www", "gl", "location", "secret", "href", "image", "force", "language", "name", "route", "email", "result", "l", "download", "ll", "Url", "view", "loc", "key", "rl", "r", "field", "coll", "date", "id"], "flag": ["ext", "kind", "leaf", "debug", "f", "sync", "standard", "bug", "child", "Flag", "fun", "sub", "and", "ind", "arg", "cloud", "wait", "group", "tag", "store", "blog", "func", "file", "inline", "part", "prop", "type", "bit", "style", "char", "alt", "warning", "force", "ag", "star", "offset", "info", "lag", "flags", "start", "log", "key", "count", "like", "field", "FLAG", "status", "id"], "sortDocId": [" sortDocumentID", "SortDocId", "sortdocid", "sortDocumentid", "sortDOCRef", "sortdocId", "sortDocid", "sortdocInfo", " sortDocInfo", " sortDocid", " sortFileId", "sortdocById", "sortDocInfo", "sortdocID", " sortDocumentid", "SortDocById", "sortMatInfo", " sortFileInfo", " sortFileID", " sortDocumentName", " sortDocumentInfo", "sortDocName", "sortDocumentType", "sortMatId", "sortDOCInfo", "SortDocID", "sortdocRef", "sortDocumentInfo", " sortDocumentId", " sortDocumentRef", "sortDOCID", " sortDocID", "sortDocID", "sortDocById", "SortDOCID", " sortDocRef", "SortDOCById", "sortDocumentName", "sortDOCId", " sortDocName", "sortdocType", "sortDocumentById", "sortDocumentID", "sortMatid", "sortDOCById", "sortFileid", "sortDOCName", "SortDocType", "sortDocumentId", "sortMatID", "sortFileID", "sortDOCType", "sortDocType", "sortdocName", " sortFileid", "sortDOCid", "sortDocumentRef", "sortFileId", "sortFileInfo", "SortDOCId", "sortDocRef", "SortDOCType"], "sqlsort": ["sqlsorted", "sqrsort", "sqlesORT", "sqLSorted", " sqLSorts", "sqlersORT", "sqlersort", "sqrsorts", " sqlsorter", " sqLSorter", "sqlesort", "sqlesorter", "sqLSorter", " sqLSORT", " sqlesort", " sqlsorts", "sqLSort", "sqrsORT", "sqlersorn", "sqlesorn", "sqlsorter", "sqlsorts", "sqrsorter", " sqlesorn", "sqlersorted", "sqlsORT", "sqlesorted", " sqlesORT", " sqlsORT", "sqLSORT", "sqlesorts", " sqlsorted", "sqLSorts", " sqlesorted", "sqLSorn", " sqlsorn", "sqlsorn", " sqLSort"], "sortflag": ["sortFLAG", "updateflags", "ortFlag", "updateFLAG", "ortcount", "searchFLAG", " sortcount", "ortflags", "searchflag", "updatebit", "ortFLAG", "sortcount", "ortbit", "sortflags", "searchflags", "updateflag", " sortflags", "searchFlag", "searchcount", " sortFlag", "searchbit", "sortFlag", "sortbit", "ortflag"], "sortURL": [" sorturl", "controlUR", "orderURI", " sortURI", "ortUR", "searchURI", "controlHTTP", "sorturl", "orturl", "controlCL", "sortSSL", "sortHTTP", "orderURL", "ortSSL", "controlURL", "searchurl", "searchURL", " sortUrl", "orderurl", "filterCL", "searchUR", "filterSSL", "filterUR", "filterHTTP", " sortUR", "sortURI", "ortURL", "searchUrl", " sortSSL", "sortUR", "ortHTTP", "sortCL", "orderUrl", "ortUrl", "sortUrl", "ortCL", "searchSSL", "filterUrl", "filterURL"]}}
{"id1": "21363911", "id2": "9996334", "code1": "    public void testTransactions() throws Exception {\n        con = TestUtil.openDB();\n        Statement st;\n        ResultSet rs;\n        con.setAutoCommit(false);\n        assertTrue(!con.getAutoCommit());\n        con.setAutoCommit(true);\n        assertTrue(con.getAutoCommit());\n        st = con.createStatement();\n        st.executeUpdate(\"insert into test_a (imagename,image,id) values ('comttest',1234,5678)\");\n        con.setAutoCommit(false);\n        st.executeUpdate(\"update test_a set image=9876 where id=5678\");\n        con.commit();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        st.executeUpdate(\"update test_a set image=1111 where id=5678\");\n        con.rollback();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        TestUtil.closeDB(con);\n    }\n", "code2": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "label": 0, "substitutes": {"con": ["common", "custom", "an", "ca", "ctx", "cons", "un", "cl", "ocon", "sync", "cm", "x", "core", "cond", "cf", "Con", "connect", "form", "cn", "pen", "db", "const", "bc", "cr", "pc", "conf", "fc", "this", "pr", "fa", "can", "min", "conn", "co", "ran", "pl", "act", "don", "com", "ct", "connection", "pub", "contract", "CON", "ec", "fac", "client", "conv", "ain", "reg", "c", "exec", "cc", "po", "en", "rc", "win", "ctrl", "cache", "ver", "run", "log", "ac", "cur", "xc", "clean", "ex", "enc", "uc", "mc", "coll", "col", "crit"], "st": ["ST", "inst", "rest", "ost", "ust", "sts", "session", "cl", "bl", "d", "sync", "src", "ck", "sb", "rd", "put", "sh", "str", "sy", "ks", "fr", "pc", "pe", "t", "sta", "sl", "sth", "ess", "pr", "sa", "ut", "nt", "est", "os", "conn", "sc", "se", "co", "sp", "mt", "pl", "act", "ct", "ist", "s", "tx", "St", "ec", "set", "c", "en", "ss", "l", "rc", "log", "pt", "r", "ld", "fe", "ste", "la", "sn"], "rs": ["rys", "ans", "cs", "ris", "re", "dr", "rr", "row", "kr", "Rs", "changes", "lines", "hr", "src", "pers", "rd", "acks", "sr", "cr", "str", "ds", "hs", "repl", "ra", "pr", "yrs", "bs", "ys", "RS", "errors", "rows", "maps", "vs", "ns", "co", "rss", "ras", "ins", "res", "ls", "ges", "ms", "err", "qs", "spec", "s", "results", "tx", "ats", "ums", "rt", "ws", "xs", "details", "runs", "vers", "sw", "rc", "ps", "ros", "ss", "rors", "ts", "js", "rx", "rl", "r", "ars", "ows", "arms", "mr", " RS", "ks"]}}
{"id1": "10361370", "id2": "2668853", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"saltBefore": ["singALTBefore", "isaltFrom", "saltStart", "sertAbove", "singaltAbove", "saultFrom", "isaltBefore", "saultBefore", "singaltBefore", "sertStart", "isaultStart", "sALTBefore", "sALTAfter", "sintHead", "sALTAbove", "isaultFrom", "sintBefore", "saultHead", "sintFrom", "singALTAfter", "seedBefore", "saltAbove", "saltHead", "sultStart", "sultHead", "saltFrom", "sultFrom", "singALTAbove", "sALTStart", "sintStart", "isaltStart", "singaltAfter", "isaultBefore", "sertAfter", "seedAbove", "isaultHead", "singaltStart", "sultBefore", "saultStart", "seedAfter", "singALTStart", "seedStart", "isaltHead", "sertBefore"], "content": ["expression", "address", "filename", "length", "version", "data", "format", "script", "string", "source", "section", "xml", "document", "resource", "output", "str", "password", "character", "input", "text", "json", "value", "entity", "cont", "creator", "parent", "raw", "url", "temp", "method", "comment", "image", "hash", "header", "media", "buffer", "code", "pattern", "size", "stream", "cache", "body", "music", "word", "Content", "object", "model", "sequence", "message"], "saltAfter": [" sALTAfter", "singALTBefore", "saltedEnd", "sintAfter", "saultAfter", "singaltAround", "saultafter", "saultBefore", "singaltBefore", "saltEnd", "sALTExtra", "singALTEnd", "sintafter", " sALTafter", "sALTBefore", "sALTAfter", " saltExtra", "saltedBefore", " saltafter", "sALTEnd", "sintExtra", "singALTAround", "saltExtra", "sintBefore", "sertAround", "singALTAfter", " sALTExtra", "sALTafter", "saltedAfter", "singaltEnd", "saltafter", "singaltAfter", "sertAfter", "saltAround", " sALTBefore", "saltedAround", "saultExtra", "sALTAround", "sertEnd", "sertBefore"], "repeatedHashingCount": ["repeatedHashesType", "repeatedShashingCounter", "repeatedHashingCode", "repeatedHashCounter", "repeatedHashesCounter", "repeatedHatingCount", "repeatedHumpingNumber", "repeatedHashingType", "repeatedHumpingcount", "repeatedHashCode", "repeatedChashesType", "repeatedHashingNumber", "repeatedHashCount", "repeatedHashesLength", "repeatedHatingCounter", "repeatedShashingCount", "repeatedChashesCount", "repeatedHumpingType", "repeatedChashingType", "repeatedShashingCode", "repeatedHashescount", "repeatedShashingLength", "repeatedChashingNumber", "repeatedShashCode", "repeatedChashingcount", "repeatedHashingcount", "repeatedHashingLength", "repeatedHashesCode", "repeatedHatingCode", "repeatedChashescount", "repeatedShashLength", "repeatedShashCounter", "repeatedShashCount", "repeatedHumpingCount", "repeatedHatingLength", "repeatedChashingCount", "repeatedHashedCount", "repeatedHashesNumber", "repeatedHashesCount", "repeatedHashLength", "repeatedHashedNumber", "repeatedHashedType", "repeatedHashingCounter", "repeatedHashedcount", "repeatedChashesNumber"], "digest": ["loggest", "logester", "generested", "finested", "mixester", " Diger", "hashString", "loger", "diggest", " digEST", "digEST", "digusher", "hexString", "valider", " Digator", " digger", "Digusher", "Digator", "ngest", " digested", "digger", "diger", "digests", "Digested", "digString", " Digest", "signest", "mixusher", "signger", " Digester", "Digester", "generest", "digester", "mixest", "signester", "signested", "Diggest", " digester", " diggest", "generester", "validested", "finests", "finest", "ngested", " digests", "Digests", "hexests", "DigEST", "nger", " diger", "validester", "hexested", "DigString", "digested", "mixested", "hexest", "hashests", "ngester", "validest", "hashested", "Digger", " digusher", "generests", "logest", "Diger", " digator", "signEST", "finester", "digator", "hashest", "Digest"], "digestLength": ["digesterLen", "digestinglength", "DigesterLength", "digestsLength", "digestedLength", "digesterLength", " digestLen", " digestlength", "digestingLength", " digesterlength", "Digestlength", "digestType", " digesterLength", "digestLen", "DigesterLen", "DigestLength", "digestsType", "digestslength", "digestingType", " digesterLen", "digesterType", " digestType", "digestsLen", " digesterType", "Digesterlength", "DigestLen", "digestlength", "digestingLen", "digestedlength", "digesterlength", "digestedLen"], "i": ["phi", "f", "length", "x", "d", "ui", "ami", "ti", "uri", "bi", "lc", "ci", "gi", "qi", "slice", "mu", "di", "t", "h", "pi", "xi", "chi", "p", "zi", "v", "ai", "u", "k", "iu", "io", "s", "ii", "o", "c", "ri", "I", "b", "multi", "fi", "j", "anti", "wei", "l", "start", "n", "si", "li", "ini", "count", "oi", "api", "index", "info", "e", "id"]}}
{"id1": "18370075", "id2": "22338097", "code1": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 1, "substitutes": {"password": ["account", "address", "filename", "data", "words", "Pass", "wd", "user", "string", "source", "token", "path", "pad", "command", "text", "username", "database", "p", "auth", "phrase", "security", "secret", "wallet", "seed", "hash", "name", "email", "pattern", "Password", "pass", "PASS", "key", "crypt", "padding", "login", "word", "config", "sword", "message"], "salt": ["sALT", "ssecret", "sesalt", "palt", "sssecret", " sass", "ssalt", "Ssecret", "Salt", "psecret", " sALT", "sesALT", "SALT", "ssass", "sessecret", "pALT", "pass", "ssALT", "Sass", "sesass", "sass", " ssecret"], "md": ["nm", "pd", "mail", "d", "ad", "pm", "gd", "amd", "mad", "ind", "sha", "kg", "di", "zip", "mn", "meta", "mm", "bf", "MD", "dd", "od", "mand", "ma", "mt", "m", "ms", " MD", "bd", "mb", "dm", "cd", "code", "cmd", "mod", "po", "nd", "ph", "me", "mac", "mag", "clean", "mc", "metadata", "ld", "mo", "message"], "digest": [" digress", "hashester", "dester", " digEST", "digEST", " digested", "digests", "Digested", "dest", "digress", "signest", "generress", "dested", "Digester", "generest", "digester", "signester", "decester", "generester", "signested", " digester", " digests", "decests", "hashcode", "DigEST", "signcode", "decest", "digested", "hashested", "dEST", "generests", " digcode", "hashest", "digcode", "Digest", "decress"]}}
{"id1": "8815137", "id2": "19322941", "code1": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "code2": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"dir": ["target", "ir", "f", "d", "plugin", "data", "tree", "wd", "uri", "home", "domain", "source", "container", "div", "path", "output", "DIR", "director", "db", "diff", "dc", "http", "editor", "entry", "zip", "project", "lib", "this", "class", "dist", "dest", "folder", "store", "parent", "base", "root", "lock", "url", "temp", "keep", "directory", " directory", "files", "manager", "type", "module", "name", "coll", "Dir", "build", "doc", "cache", "log", "loc", "local", "report", "direction", "out", "object", "model", "id"], "file": ["path", "http", "class", "File", "block", "url", "full", "type", " directory", "unit", "self", "code", "FILE", " filename", "current", "view", "body", "out", "model", "e", "queue", "f", " base", "data", "home", "source", " module", "lib", "binary", "folder", "base", "lane", "connection", "io", "write", "stream", "log", "local", "key", "fe", "use", "info", "id", "live", "content", "string", "resource", "handler", "line", "db", "zip", "this", "function", "fp", "part", " name", "directory", "single", "comment", "letter", "table", "module", "media", "up", " source", "ile", "cache", "default", "object", "create", "message", "filename", "found", "format", "parent", "p", "page", "files", "image", "force", "name", "l"], "fileOutputStream": ["fileByteStream", "filesInputstream", "filesOutputChannel", "fileResponseFile", "fileIOSteam", "fileInputSem", "filesOutputstream", "fileInputSteam", "fileConfigChannel", "fileOperStream", "fileWriteChannel", "FileInputSteam", "fileInputLength", "fileOutputFile", "fileOutputLength", "fileIOFile", "fileByteSteam", "fileWritestream", "fileWriteSteam", "fileConfigStream", "filesInputChannel", "FileOutputFile", "fileOperSteam", "fileInputFile", "fileIOSem", "fileOutputSteam", "fileIOStream", "fileResponseStream", "fileOutputstream", "FileInputFile", "FileInputSem", "filesInputSteam", "fileResponseSteam", "fileInputChannel", "FileOutputSteam", "fileOutputChannel", "fileConfigstream", "FileOutputSem", "fileOperLength", "fileConfigSteam", "filesOutputSteam", "fileOperstream", "fileBytestream", "filesOutputLength", "filesOutputStream", "filesInputLength", "fileOutputSem", "fileInputstream", "fileByteLength", "fileWriteStream", "FileOutputStream", "FileInputStream", "filesInputStream", "fileResponseSem"], "fileInputStream": ["fileSourceStream", "fileInputThread", "fileInstallSteam", "filesInputstream", "filesOutputstream", "fileInputSteam", " fileInputThread", "fileOutputPass", " fileInputstream", "fileInternalThread", "fileStorageStream", "fileInSteam", "fileInThread", " fileOutputThread", "fileInputPass", "fileStoragePass", "fileStorageSteam", "fileOutputSteam", " fileOutputSteam", "fileOutputstream", "fileAsyncSteam", "fileInternalSteam", "fileOutputThread", "filesInputSteam", "fileInternalstream", "fileInPass", "filesOutputPass", "filesInputThread", "fileAsyncStream", "filesInputPass", "fileStorageThread", "fileSourceThread", "filesOutputSteam", "fileInternalStream", "fileInStream", "filesOutputStream", "fileInputstream", "filesOutputThread", " fileOutputstream", "fileSourcestream", "fileSourceSteam", " fileInputSteam", "fileInstallStream", "fileAsyncstream", "filesInputStream", "fileInstallstream"], "read": ["lex", " write", "next", "length", "readable", "sync", "allow", "index", "find", "check", "last", "parse", "i", "Read", "resource", "send", "end", "feed", "iter", "input", "wait", "total", " Read", "reading", "load", "add", "raw", "sleep", "reader", "se", "play", "select", "fill", "seek", "level", "io", "get", "READ", "ride", "ip", "open", "b", "old", "write", "build", "exec", "close", "size", "reads", "start", "pass", "work", "ask", "loop", "run", "ok", "view", "current", "count", "r", "use", "default", "create", "e", "id"], "buffer": ["queue", "border", "length", "uffer", "data", "row", "flush", "request", "wave", "feed", "zero", "slice", "layer", "limit", "iter", "buff", "buf", "binary", "base", "load", "transfer", "shape", "reader", "comment", "offset", "seed", "Buffer", "batch", "channel", "b", "bytes", "write", "result", "size", "cache", "split", "null", "message"]}}
{"id1": "22993368", "id2": "22135199", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 1, "substitutes": {"infile": ["inputfp", "minfile", "inputfilename", "infilename", " infilename", " infiles", " inbase", "minFile", " instream", "outfp", "inputfile", "inputfiles", "Instream", "Inbase", "inFile", "infp", "inbase", "Infile", "infiles", " infp", "InFile", "instream", "minbase", "minstream", "outfilename", "outfiles", " inFile"], "outfile": ["outputfilename", "outputdatabase", " outfolder", "outputFile", "infilename", "outputfile", "inputpath", "inputfile", "infolder", " outpath", "inFile", "outpath", " outFile", " outfilename", "outfolder", "outputpath", "inputFile", "outdatabase", "outputfolder", " outdatabase", "outFile", "inputdatabase", "outfilename"], "in": ["gin", "a", "re", "data", "isin", "socket", "inn", "source", "i", "thin", "ic", "con", "sin", "is", "input", "init", "inas", "min", "din", "conn", "lin", "reader", "rin", "ins", "bin", "m", "into", "err", "inner", "s", "b", "inside", "as", "win", "In", "pass", "cin", "inc", "ac", "IN", "nin", "ini", "r", "login", "again", "pin", "id"], "out": ["session", "sync", "OUT", "socket", "point", "home", "no", "exit", "output", "off", "line", "lib", "writer", "parent", "Out", "base", "ou", "error", "file", "conn", "co", "timeout", "bin", "one", "err", "net", "io", "to", "inner", "image", "name", "up", "client", "job", "o", "obj", "channel", "outs", "exec", "write", "or", "outer", "In", "work", "cache", "log", "post", "inc", "pass", "ex", "copy", "again"], "buffer": ["queue", "border", "address", "length", "uffer", "data", "flush", "reference", "bb", "source", "wave", "feed", "slice", "layer", "server", "limit", "iter", "buff", "buf", "input", "binary", "value", "base", "raw", "transfer", "url", "reader", "bin", "type", "offset", "seed", "Buffer", "batch", "channel", "bytes", "b", "write", "result", "size", "cache", "split", "count", "padding", "null"], "read": ["lex", " write", "f", "length", "x", "sync", "allow", "next", " copy", "find", "ad", "check", "parse", "i", "Read", "connect", "send", "end", "feed", "tell", "slice", "ind", "limit", "iter", "wait", "len", "reading", " Read", "load", "add", "raw", "sleep", "reader", "select", "play", "se", "fill", "seek", "io", "get", "ride", "READ", "ip", "_", " count", "write", "exec", "size", "reads", "start", "work", "n", "pass", "run", "inc", "current", "count", "r", "copy", "use", " skip", "id"], "success": ["primary", "growth", "construct", "better", "data", "content", "follow", "fast", "flash", " succ", "successful", "status", "cess", "path", "rolling", "response", "valid", "model", "rolled", "initial", "fail", " successful", "value", "failed", "ccess", "roll", "func", "error", "winner", "first", "true", "method", "danger", "comment", " succeed", "results", "warning", "open", "done", "right", " Success", "ceed", "result", "successfully", "good", "Success", "pass", "xx", "positive", "complete", "continue", "default", "again", "null", "message"]}}
{"id1": "17716716", "id2": "19147281", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"loggerCol": ["loggeeDr", "progercol", "loggeCol", "pluggerCor", "progingCol", "loggingCollection", "progerCol", "logorerCollection", "logorerCol", "progerCollection", "loggingColumn", "loggerDr", "loggingCor", "loglercol", "loggeeCol", "loggeecol", "pluggingCol", "logorerColumn", "progingcol", "loggingcol", "loggingDr", "loggecol", "loggerCor", "progingCollection", "loglerCollection", "loggeCor", "pluggerCol", "loggercol", "progerColumn", "loggerCollection", "loggeDr", "loglerColumn", "loggingCol", "pluggercol", "pluggingcol", "progingColumn", "loggerColumn", "logorercol", "pluggingCor", "pluggingDr", "loglerCol", "pluggerDr", "loggeeCor"], "input": ["inf", "data", "format", "request", "string", "source", "form", "xml", "ssl", "empty", "output", "path", "container", "plus", "str", "password", "list", "text", "context", "base", "raw", "url", "file", "in", "Input", "reader", "temp", "connection", "state", "image", "buffer", "cmd", "instance", "audio", "IN", "null", "config", "model", "alpha", "dict"], "byteHash": ["ByteHash", " byteBlock", " byteArray", " byteSum", "bitHash", "blockhash", "bitBlock", "byteshash", "stringSalt", "blockBlock", "stringHash", "wordHash", "Bytehash", "stringArray", "wordSum", "blockSum", "bitArray", "stringhash", "ByteSum", "byteBlock", "wordhash", "wordArray", "byteArray", "blockHash", "bytesArray", "bitSum", "ByteBlock", "bithash", "bytesSalt", " byteSalt", "bytehash", "bytesHash", "byteSalt", "byteSum", " bytehash"], "md": ["cm", "nm", "f", "pd", "d", "um", "dr", "sm", "msg", "dh", "ad", "pm", "hm", "amd", "rpm", "mu", "di", "mn", "meta", "pkg", "mm", "am", "Cmd", "MD", "dd", "mand", "ma", "mt", "m", "ms", "Msg", " MD", "bd", "rm", "dig", "mb", "hash", "mg", "dm", "cd", "cmd", "mod", "cc", "doc", "ph", "df", "mac", "mag", "mp", "mc", "mo", "metadata"], "md5result": [" md5package", "md7result", " md305result", "md5Result", "md512Result", "md4runner", "md305result", "md5report", "md7Result", "md305results", " md5runner", "md4result", "md25Result", " md5data", "md4response", " md25data", "md512results", "md512report", " md305results", "mddownpackage", "mddownresult", "md7results", "md5package", "md4results", "md305runner", " md305response", " md305runner", " md7results", "md305response", " md25result", "mddownResult", "md25data", " md7result", "md5response", "md53response", "md53results", "md6results", "md6data", "md6report", "md25package", " md5response", " md5Result", "md6result", "md5data", "md6Result", "md5results", "md53result", " md7report", "md25result", " md5report", " md5results", " md25Result", "md7report", "md5runner", "md512result", "mddowndata", "md53runner", " md25package", " md7Result", "md6package"], "i": ["hi", "f", "length", "x", "d", "ui", "ti", "uri", "bi", "ci", "gi", "qi", "mu", "di", "h", "z", "pi", "zi", "p", "v", "ai", "u", "io", "s", "ii", "o", "b", "c", "I", "ri", "multi", "fi", "j", "l", "n", "si", "key", "li", "r", "oi", "ji", "index", "xi", "e", "id"]}}
{"id1": "6988216", "id2": "10266116", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public InputStream retrieveStream(String url) {\n        HttpGet getRequest = new HttpGet(url);\n        try {\n            HttpResponse getResponse = getClient().execute(getRequest);\n            final int statusCode = getResponse.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n                Log.w(getClass().getSimpleName(), \"Error \" + statusCode + \" for URL \" + url);\n                return null;\n            }\n            HttpEntity getResponseEntity = getResponse.getEntity();\n            return getResponseEntity.getContent();\n        } catch (Exception e) {\n            getRequest.abort();\n            Log.w(getClass().getSimpleName(), \"Error for URL \" + url, e);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"dummySource": ["suddySite", "suddySource", "duddyServer", "dellySite", "dellyService", "dummyInterface", "dumperService", "dummyService", "dummySite", "dumperProvider", "dazyServer", "sdazyContent", "summySite", "dazyUrl", " dumbServer", "summySource", "suddyProvider", "dummiesUrl", "dumbServer", "dummiesSource", "duddySource", "dellyProvider", "dumbConfig", "dumbInterface", "sdummySource", "suddyService", " dummyServer", " dumbSource", "dummyProvider", "dumperSite", "sdazySource", "dummiesType", "dumperSource", " dummyInterface", "duddyContent", "duddyService", " dumbInterface", "summyService", "duddyProvider", "dummyUrl", "duddySite", "dazyType", "dumbSource", "sdummyType", "duddyType", "dummiesContent", "dummyConfig", "sdazyType", "duddyInterface", "dazyInterface", "dummyServer", "dazyConfig", "sdazyUrl", "dummyType", "sdummyContent", " dummyConfig", "duddyConfig", "summyProvider", "dazyContent", "dellySource", "dazySource", " dumbConfig", "sdummyUrl", "duddyUrl"], "os": ["oss", "obs", "OS", "cs", "ori", "bos", "ols", "aos", "es", "oid", "ol", "cos", "ds", "nos", "mos", "los", "us", "is", "http", "uns", "ow", "ors", "bs", "op", "ou", "conn", "iso", "ns", "ens", "dos", "vs", "object", "ms", "css", "io", "s", "Os", "ios", "ops", "obj", "o", "oses", "pos", "as", "om", "or", "ss", "ros", "ps", "oa", "acs", "js", "ok", "osi", "ows", "oos", "out", "oS", "fs", "ks"], "dummyContent": ["duckyHeader", "dummiesContents", "DummyContext", "dellyHeader", "bummiesMessage", "bummyContent", "dummyMessage", "dummyCode", "dumperCode", "dellyContent", "DuckySource", "dummiesSource", "dummiesHeader", "duckySource", "bummiesHeader", "duckyContents", "DummyCode", "dummiesContext", "dummyContents", "bummiesContents", "dumperSource", "dummiesCode", "duckyCode", "duckyContext", "bummyMessage", "dumperContext", "dummyContext", "DummySource", "DuckyCode", "DuckyContext", "DummyContent", "dumperContent", "dummiesContent", "bummiesContent", "bummyHeader", "duckyMessage", "dummyHeader", "dummiesMessage", "DuckyContent", "dellyMessage", "bummyContents", "dellyContents", "duckyContent"], "source": ["session", "target", "sync", "core", "src", "uri", "service", "from", "site", "i", "resource", "string", "sin", "ources", "SOURCE", "server", "cos", "sl", "search", "text", "parent", "url", "reader", "rss", "scope", "object", "security", "connection", "slave", "s", "seed", "unit", "element", "storage", "client", "channel", "result", "ss", "size", "stream", " sources", "cache", "Source", "node", "ource", "config", "use", "proxy", "e"], "content": ["expression", "comments", "version", "child", "x", "data", "script", "core", "condition", "service", "section", "resource", "document", "xml", "output", "response", "cos", "server", "input", "sol", "text", "value", "parent", "cont", "html", "load", "url", "conn", "full", "connection", "comment", "image", "children", "media", "title", "cms", "code", "update", "name", "description", "size", "current", "body", "activity", "report", "clean", "transform", "config", "Content", "object", "model", "message"], "qResult": ["reqRe", "queryResults", "qRes", "qSuccess", "eqSuccess", "dqResult", "queryResult", "pRes", "rResult", "qRe", "dqSuccess", "eqReturn", "pResponse", "dqResults", "eqResult", "qResponse", "qReturn", " qresult", "querySource", "queryresult", "reqResult", "presult", " qSource", "pRe", "rResponse", "rRes", "rRe", "qSource", " qResponse", "querySuccess", "reqRes", "qResults", "eqResults", "queryReturn", "dqReturn", "qresult", "pResult", "pSource", "queryResponse", "reqResponse"], "results": ["ids", "data", "features", "words", "lines", "times", "blocks", "resources", "response", "its", "reports", "groups", "items", "errors", "rows", "tests", "Results", "events", "ins", "res", "files", "shows", "qs", "children", "users", "collection", "ries", "pages", "ions", "details", "runs", "vers", "result", "vals", "forms", "versions", "values", "models", "RESULTS"], "it": ["lit", "mit", "which", "you", "the", "i", "and", "slice", "ind", "pit", "entry", "t", "iter", "list", "its", "iti", "ite", "init", "p", "op", "nt", "v", "itted", "in", "rit", " It", "ins", "ait", "stat", "edit", "ip", "It", "set", "sit", "not", "or", "l", "ITS", "n", "iz", "split", "r", "ort", "IT", "id"], "rSrc": ["rDsource", " rSsrc", "rAsdk", "rShrc", "rAsrc", " rDsrec", "rEsRC", " rSRC", "rDssrc", "rMsRC", " rSnc", "rDsrec", " rDsrc", " rSrec", "rSRC", " rDsRC", "rAsRC", " rSource", "rDsrc", "rShdk", " rDsdk", "rAsnc", "rMsnc", " rEsnc", " rDssrc", " rSdk", "rSsrc", " rEsource", "rCource", "rMsrc", "rCsrc", "rDsdk", "rSnc", "rSdk", " rDsource", "rEsource", "rShRC", "rCrec", "rSource", "rEsnc", "rDsRC", " rEsrc", "rSrec", "rEsrc", "rShource", "rCrc", " rEsRC", "rAsource", "rMsource"], "rSrcIn": ["rSscOut", "rSRCin", "rCsrcOut", "rSourceIn", "rAsrcIN", "rAsrcIn", "rSscin", "rAsRCIn", "rSsrcOut", "rSRCOut", "rSourcein", "rAsRCIN", "rSscIn", "rSsrcIn", "rCsrcIN", "rSrcIN", "rCsrcIn", "rSrcin", "rCrcIn", "rSRCIn", "rSsrcin", "rSrcOut", "rSRCIN", "rAsrcin", "rCrcin", "rCrcIN", "rSsrcIN", "rSscIN", "rAsrcOut", "rAsRCOut", "rCsrcin", "rAsRCin", "rCrcOut", "rSourceIN", "rSourceOut"], "actualOut": [" actualIn", "viewIn", " ActualOut", "eventout", "actualOUT", "viewout", "conceptIn", "eventOUT", " ActualStr", "actualout", "initialOut", "actualStr", "eventOut", " actualOutput", "viewOUT", "initialout", "realOut", "viewOut", " actualout", " actualOUT", "eventIn", "initialIn", " ActualOUT", "realout", "realOutput", "actualOutput", "conceptout", " actualStr", "initialOutput", "initialOUT", "actualIn", "initialStr", "conceptOUT", "conceptOut", "realIn", " ActualIn"]}}
{"id1": "10451698", "id2": "18433984", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"source": ["target", "filename", "sync", "data", "src", "ie", "from", "service", "string", "site", "resource", "sf", "proxy", "document", "path", "section", "SOURCE", "slice", "server", "iter", "project", "remote", "class", "ce", "folder", "parent", "secure", "origin", "root", "volume", "file", "url", "reader", "directory", "connection", "slave", "unit", "seed", "force", "image", "storage", "name", "archive", "client", "result", "stream", "start", "cache", "flat", "view", "current", "Source", "null", "ource", "copy", "use", "config", "object", "model"], "destinationDirectory": ["destructionPath", "destinationFile", "destinatorPoint", "destinationSystem", " destationDir", "destinationsFile", " destinationDir", " destinationFile", "destationPath", "DestinationPoint", "DestinationPath", "destinationDatabase", " destationPath", "destinatorDatabase", "destributionFolder", "destinatorSystem", "DestinationsDatabase", " destationDirectory", "destinationsSystem", "destinatorPath", "destinationPoint", "destinationFolder", "destinationsDirectory", "destinatorDirectory", "destructionFile", " destationFile", "destributionDirectory", "DestinationFolder", "destporaryDirectory", "DestinationsDirectory", "destinationsPoint", "destationFile", "DestributionDirectory", "DestributionPath", "destributionPath", "destporarySystem", "destationDirectory", "DestinationsPath", "DestributionPoint", "destructionDir", "DestributionFolder", "destructionDirectory", "DestinationsSystem", "destinationPath", "DestinationDatabase", "destinationsDatabase", "destributionPoint", "destporaryPath", "DestinationDirectory", "destinationsFolder", "destinationDir", "destporaryDatabase", "DestinationSystem", "destationDir", "destinationsDir", "destinatorFolder", " destinationPath", "destinationsPath"], "newDir": ["firstFile", " newDIR", "smallDIR", "nextDir", "firstDirectory", "Newdir", "NewFile", "smallFile", "smallDirectory", "newDirectory", "smallDir", "firstDir", "newDIR", " newdir", " newDirectory", "firstDIR", "newdir", "NewDir", "NewDirectory", "nextdir", "NewDIR", "nextFile", "nextDirectory"], "children": ["filename", "child", "parents", "data", "content", "words", "which", "other", "begin", "web", "rules", "Children", "sub", "blocks", "pes", "plus", "packages", "balls", "members", "each", "list", "iv", "opens", "when", "parent", "errors", "rows", "tests", "url", "mount", "events", "ins", "files", "sort", "roots", "ums", "collection", "pages", "kids", " Children", "all", "values", "current", "scenes", "plugins", "iblings", "loc", "uc", "projects", "names", "ul", "ools"], "i": ["hi", "f", "x", "d", "ori", "ui", "it", "ti", "ie", "uri", "bi", "lc", "ci", "gi", "qi", "end", "slice", "mu", "di", "h", "pi", "xi", "q", "p", "v", "in", "ai", "ix", "part", "u", "type", "m", "k", "iu", "io", "inner", "range", "ip", "ii", "y", "name", "o", "b", "ri", "I", "multi", "c", "fi", "j", "start", "n", "si", "key", "li", "ini", "oi", "mi", "ji", "index", "info", "e", "id"], "newFile": ["createfile", " newFiles", "createDir", "nextDir", "nextDirectory", "newSource", "nextFiles", "oldFiles", "oldDir", "createFile", "newSourceFile", "createSource", "oldFile", "NewFile", "newDirectory", " newSourceFile", "NewSourceFile", "NewFiles", "newFiles", "nextfile", "nextSourceFile", "Newfile", " newDirectory", "nextSource", "NewDir", "NewDirectory", "nextFile", "NewSource", "oldDirectory", "newfile", " newfile"], "output": ["application", "target", "operation", "address", "four", "core", "socket", "service", "other", "resource", "web", "flow", "put", "layer", "response", "Output", "kernel", "option", "generation", "writer", "console", "binary", "again", "parent", "error", "file", "page", "full", "temp", "network", "connection", "unit", "image", "display", "default", "change", "generated", "update", "o", "ilo", "result", "write", "outer", "external", "current", "control", "oper", "after", "complete", "copy", "config", "out", "object"], "input": ["inf", "child", "data", "socket", "request", "form", "resource", "flow", "ack", "through", "http", "binary", "this", "context", "text", "parent", "load", "raw", "error", "in", "Input", "reader", "temp", "keep", "connection", "inner", "io", "s", "image", "buffer", "self", "update", "client", "exec", "instance", "stream", "current", "inc", "ink", "audio", "config", "index", "out", "active", "pull"], "buff": ["f", "length", "bind", "bug", "rb", "data", "flush", "cod", "bb", "gb", "cf", "uff", "feed", "pad", "slice", "comb", "buf", "fb", "ff", "cp", "text", "txt", "load", "shape", "bin", "cb", "Buff", "boot", "gz", "bound", "oct", "char", "rib", "comment", "buffer", "ffff", "batch", "cmd", "b", "pack", "uf", "ph", "count", "fe", "ob", "back", "info", "cell"], "read": ["lex", " write", "f", "length", "x", "d", "sync", "allow", "readable", "find", "check", "parse", "Read", "end", "send", "feed", "and", "tell", "ind", "slice", "wait", "len", "text", "reading", "load", "add", "rate", "transfer", "raw", "reader", "select", "play", "se", "fill", "seek", "k", "io", "get", "buffer", "ip", "READ", "open", " count", "b", "write", "skip", "exec", "en", "close", "size", "reads", "start", "pass", "ask", "loop", "run", "index", "ink", "n", "count", " load", "copy", "use", "create", "id"]}}
{"id1": "5061606", "id2": "23246123", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "label": 0, "substitutes": {"out": ["sync", "OUT", "a", "prefix", "data", "plugin", "flush", "socket", "user", "source", "i", "app", "output", "exit", "path", "off", "server", "editor", "model", "password", "writer", "this", "init", "group", "by", "parent", "Out", "window", "lock", "array", "error", "conn", "file", "page", "plain", "url", "timeout", "bin", "object", "err", "connection", "net", "io", "image", "name", "up", "obj", "client", "o", "channel", "outs", "write", "result", "exec", "cache", "at", "log", "pool", "cookie", "ex", "copy", "index", "again", "null", "config"], "fSettings": [" fFs", "FJs", "rfSettings", "fmSetup", "sfSetting", "fsConfig", "fsSettings", "FConfig", "rfFs", "fJs", "fileettings", " fsettings", "fmConfig", "FSetting", "fSetting", "fsettings", "rfSetting", "filesettings", "FSettings", "sfJs", "fFs", "fsSetting", "fileSettings", " fConfig", "fsSetup", "Fsettings", "rfConfig", "fConfig", "fileSetting", "fmSettings", " fJs", "sfSettings", "sfsettings", "FSetup", "fettings", "sfettings", "fsFs", " fettings", " fSetting", "fmSetting", "fSetup"], "src": ["filename", "st", "rb", "ref", "uri", "gb", "ssl", "string", "source", "sb", "prot", "path", "sub", "sr", "str", "attr", "tmp", "sl", "dist", "dest", "text", "base", "req", "fp", "file", "url", "sc", "ins", "img", "cb", "storage", "route", "b", "settings", "sel", "rc", "lower", "stream", "ctr", "cur", "loc", "uc", "ource", "config"], "in": ["gin", "f", "data", "inn", "source", "i", "thin", "con", "path", "sin", "input", "init", "kin", "din", "file", "url", "rin", "reader", "ins", "bin", "err", "connection", "inner", "s", "image", "b", "c", "l", "win", "index", "In", "stream", "n", "inc", "IN", "ini", "r", "copy", "login", "again", "id"]}}
{"id1": "12389873", "id2": "13644375", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public String get(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toString(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"conn": ["session", "Connection", "ca", "ctx", "cat", "dh", "oci", "pg", "sb", "connect", "ci", "Exec", "con", "dc", "cn", "db", "cr", "pc", "conf", "nc", "pr", "cp", "p", "nt", "ns", "co", "ls", "act", "ct", "connection", "state", "pub", "sql", "rt", "ec", "client", "c", "reg", "cc", "exec", "util", "Conn", "n", "cache", "ann", "dn", "pt", "loc", "ch", "mc", "enc", "config", "h", "coll", "col"], "stmt": [" stmi", "slpl", "flmt", "estert", "STms", "STpl", "stct", " stmn", "stmb", "estmp", "stmn", "steth", "stql", "stst", "slmn", "thegr", "syor", "stpl", "stms", " stert", "eltor", " stt", "stert", "putts", "dmd", "estct", "elts", "plb", "stgt", "putur", "themt", "estgt", "stts", "tsp", "playmd", "Stdb", "stmd", " stts", "flgt", "putmt", "plpl", "flmp", " stdb", "estmi", "putml", " stgt", "stml", "Sttor", "sybf", "stmc", "Steth", " stct", " stmc", "Stpl", "dMT", "tmt", " stpl", " stwd", "flct", "estmt", "STql", "slmp", "Stmt", "Stts", "Stwd", "plmb", "putmb", "Stql", " stapter", "Stmn", "Stbl", "Stml", " stmb", "ttr", "stbf", "slbl", "STts", "STeth", "playct", "STapter", "Sttr", "putnt", " stmp", "stwd", "putmd", " sttor", " stur", "estst", "playeth", "estapter", "elpl", "stgr", "Stmb", "stur", "stMT", "Stms", " stor", "Stur", "plmt", "playnt", " stql", "statwd", "stnt", "thepl", "Stb", " steth", "slgr", "statb", "STbl", "Stgr", " stMT", "sttor", "stbl", "playml", "stmp", "Stbf", "sytr", "Stnt", "stsp", "Stor", "esteth", "plmn", " stb", "stmi", " stms", "puttr", "slmt", "statmt", "sltr", "estms", " stsp", "tmb", "stdb", " stbf", "playmc", " stbl", " stmd", "estql", "putsp", " stst", "stb", "Stmc", "symt", "STdb", "Stmi", "Stmd", "STst", "STmt", "Stt", "STct", "StMT", "plur", "stapter", "puteth", "estts", "Stct", "playmt", "dpl", "stt", "plt", "putct", " sttr", "dmt", "sttr", "Stmp", "estur", "elmt", "putert", "stor", "themn", "statmn"]}}
{"id1": "12171364", "id2": "8150996", "code1": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 0, "substitutes": {"url": ["loader", "plug", "address", "f", "re", "bel", "data", "github", "rel", "src", "uri", "service", "ssl", "string", "source", "socket", "resource", "path", "feed", "server", "http", "fr", "ur", "org", "sl", "el", "URL", "class", "this", "blog", "base", "orb", "file", "gl", "location", "cdn", "err", "href", "image", "buffer", "b", "lr", "browser", "l", "stream", "Url", "loc", "r", "ob", "config", "coll"], "br": ["bar", "bl", "bh", "rb", "dr", "jar", "bb", "BR", "hr", "src", "abs", "flash", "bro", "ler", "HR", "resource", "sr", "cr", "db", "str", "http", "fr", "tr", "ur", "fb", "buf", "sl", "org", "pr", "obl", "orb", "bf", "reader", "handle", "sp", "img", "yr", "er", "cb", "err", "ab", "io", "Br", "brush", "arr", "vr", "href", "b", "result", "lr", "browser", "stream", "bridge", "ber", "ch", "r", "ob", "ner", "mr", "ver"], "s": ["d", "side", "ssl", "sb", "sf", "second", "hs", "sl", "input", "its", "shell", "w", "su", "as", "n", "sv", "sym", "strings", "fs", "e", "comments", "f", "sync", "data", "words", "g", "abs", "source", "search", "v", "in", "u", "res", "rs", "ps", "pass", "js", "r", "h", "an", "S", "a", "string", "i", "es", "line", "str", "text", "os", "ls", "single", "m", "ws", "c", "sum", "message", "session", "site", "ds", "t", "is", "p", "ns", "spec", "sets", "signed", "name", "ops", "o", "b", "sid", "ss", "l", "si", "enc", "your"]}}
{"id1": "20929570", "id2": "9738825", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    public void load(URL url) throws IOException {\n        ResourceLocator locator = null;\n        try {\n            locator = new RelativeResourceLocator(url);\n        } catch (URISyntaxException use) {\n            throw new IllegalArgumentException(\"Bad URL: \" + use);\n        }\n        ResourceLocatorTool.addResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n        InputStream stream = null;\n        try {\n            stream = url.openStream();\n            if (stream == null) {\n                throw new IOException(\"Failed to load materials file '\" + url + \"'\");\n            }\n            logger.fine(\"Loading materials from '\" + url + \"'...\");\n            load(stream);\n        } finally {\n            if (stream != null) stream.close();\n            ResourceLocatorTool.removeResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n            locator = null;\n        }\n    }\n", "label": 0, "substitutes": {"str": ["f", "kr", "st", "dr", "data", "msg", "string", "source", "sr", "cr", "fr", "tr", "input", "text", "txt", "url", "conn", "sp", "temp", "exp", "err", "char", "s", "buffer", "arr", "br", "name", "STR", "obj", "bytes", "b", "result", "Str", "pass", "r", "enc", "sec", "out", "stri", "e"], "messageDigest": ["messageDigester", " messageDer", "messageDen", "messageDester", "messageGester", "messageGher", "messageDher", "messageDigeter", "messageGested", "messagediger", "messageMarkest", "objectDigen", "MessageMarkpace", " messageDigester", " messageDher", "messageMarkEST", "objectdigester", "messagedigpace", "messageDeter", "messagePedest", "messagedigen", "messageSigner", "MessageDigester", "messageMailester", "messageDigit", "messageDighest", "messageDigpace", "MessageMarkEST", "messagedigeter", "objectDigest", "messageDpace", " messageDester", "MessageDigEST", "MessageDigest", "messagedigest", "messageDit", "messageMaileter", "messagePedhest", "Messagedighest", "messagedigester", "Messagedigest", "messageDefest", "messageSignester", "messageMailen", "messageSignest", "messageGest", "messageDefester", "messageDiger", "objectDigester", "messagePedEST", "Messagedigester", " messageDest", "MessageMarkester", "messageDer", "messageDigher", "objectDigeter", "messageDigested", "messageSignit", "messageDest", "messageDEST", " messageDigher", "objectdigest", "messageDigen", "messagedighest", "messageDested", "messageMarkester", "messageDefher", " messageDiger", "MessagedigEST", "messagePedester", "MessageDigpace", "objectdigen", " messageDit", " messageDigit", "MessageDighest", "messageMailest", "objectdigeter", "MessageMarkest", "messageDefested", " messageDigested", "messageDigEST", "messagedigit", "messageMarkpace", " messageDested", "messagedigEST"], "byteArray": ["byteBuffer", "charLength", "charOrder", " byteBuffer", "byteOrder", "characterArray", "bitLength", "letterObject", "fileBuffer", "ByteStream", "letterLength", "byteAmount", "ByteAmount", "byteAr", " byteAr", " byteOrder", "charStream", "byteObject", "ByteObject", "byteIndex", "wordString", "byteString", " byteAmount", "ByteLength", "byteStream", "charObject", "bitArray", "wordAr", " byteLength", "fileArray", "fileString", "charArray", "letterArray", "wordBuffer", "charAmount", "charIndex", "ByteArray", "bitOrder", "wordArray", "fileAr", "characterOrder", "byteLength", "bitAmount", "characterBuffer", " byteIndex", "ByteIndex", " byteString", "charBuffer", "characterAmount", "letterStream"], "md5StrBuff": ["md5strPref", "md5BrBuffer", "md5StringPref", "md5StBuff", "md5SlBuff", "md5StComp", "md2StrBuff", "md6strBuilder", "md6strText", "md2StringBuff", "md2StringBuffer", "md5StText", "md5StPref", "md5Slbuff", "md2StrProp", "md6StrBuff", "md5StringBuffer", "md5BrBuff", "md5SlProp", "md5StringBuff", "md5StrBuffer", "md5StApp", "md5Stringbuff", "md2StrApp", "md2StringProp", "md5LineBuffer", "md2StringPref", "md6strBuffer", "md2StrComp", "md5Trbuff", "md6StrText", "md5StrText", "md5strComp", "md5TrBuff", "md5StringComp", "md5SlBuffer", "md5LineText", "md5BrText", "md5StringApp", "md5StrComp", "md2StringApp", "md2StrBuffer", "md5StringBuilder", "md6strBuff", "md2StringComp", "md6StrBuffer", "md5strBuilder", "md2StringText", "md5BrApp", "md5strBuffer", "md5StrPref", "md5TrProp", "md5StringProp", "md5Strbuff", "md2StrText", "md2Strbuff", "md5StringText", "md5StBuffer", "md5strText", "md6StrBuilder", "md5LineBuff", "md5StrProp", "md5TrBuffer", "md5StrApp", "md5LineBuilder", "md2StrPref", "md5StrBuilder", "md5strBuff", "md2Stringbuff"], "i": ["phi", "f", "length", "x", "d", "it", "ui", "ti", "uri", "ie", "bi", "ci", "gi", "qi", "slice", "mu", "di", "abi", "pi", "chi", "p", "v", "in", "ai", "ix", "part", "u", "k", "iu", "io", "inner", "ip", "ii", "y", "name", "info", "o", "c", "ri", "I", "b", "fi", "multi", "j", "l", "n", "si", "key", "li", "oi", "ji", "field", "index", "xi", "e", "id"]}}
{"id1": "2676365", "id2": "17111859", "code1": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 0, "substitutes": {"currentPilot": ["currentpector", "currentpooter", "activePacket", "activePistor", "currentCPilot", "currentPortilot", "currentCPector", " currentCPacket", "currentPector", "currentpilot", "activePilot", "currentPointilot", "currentPiece", " currentCPooter", " currentCPector", "currentPortacket", "currentPooter", "currentPointistor", "currentPayilot", " currentCPilot", "currentPayiece", "currentPacket", "currentPayacket", "currentPistor", "currentpiece", "currentCPooter", "activepilot", " currentPector", "currentpacket", "activepistor", "activepacket", "currentpistor", " currentPooter", "activePiece", "currentCPacket", "currentPointiece", "currentPointacket", " currentPacket", "currentPayistor", "currentPortector", "currentPortooter", "activepiece"], "psta": ["psa", "Psa", "pda", "Pda", " pste", "pela", "Pasi", "paresta", "Pla", "peppa", "pppa", "jda", "pste", "Pppa", " psa", "jsta", "pla", " pla", "pesta", "jste", "parsta", "pesa", " pppa", "parsa", " pesta", "Pste", " pda", "parasi", "jsa", "pasi", "Psta", " pasi", "Pesta"]}}
{"id1": "18793482", "id2": "4798332", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"locale": ["localue", "locationame", "locality", "cale", "LOCales", "locationales", "localoding", "cales", "locationALE", "locame", "localale", "LocALE", "localALE", "localame", "locationale", "Locame", "langale", "locue", "localality", "cue", "Locales", "localales", "langALE", "LOCALE", "Locale", "Locoding", "locoding", "locALE", "langales", "Locue", "coding", "locales", "LOCale", "langality", "LOCality"], "messageName": ["MessageKey", "phraseName", "format", " messageType", "msgKey", "http", "this", " messageKey", "phraseValue", "text", "messageType", " messageNames", "MessageValue", "add", "plain", "url", "phraseKey", "get", "MessageNames", "s", "messageKey", "_", "messageNames", "language", "msgNames", "MessageType", "msgType", "MessageName", "msgName", "phraseType"], "messageValue": ["applicationName", " messageVal", "applicationType", " messageType", "msgVal", "MessageVal", "messageType", "MessageValue", "messageVal", "applicationVal", "MessageType", "applicationValue", "msgType", "MessageName", "msgValue", "msgName"], "properties": ["Pro", "pb", "data", "xml", "stats", "resources", "conf", "tmp", "perties", "Property", "json", "pro", "txt", "params", "prop", " Properties", "py", "ops", "obj", "ips", "settings", "property", "ps", "api", "config", " props", "options", "metadata"], "i18nPath": ["i18nsText", "i18nsUrl", "i18neUrl", "i11pnPath", "i18nsPath", "i18fPath", "i14nPath", "i18bPath", "i11nCorp", "i14nsPath", "i16nStr", "i11nPath", "i18nsStr", "i18nCorp", "i11pnpath", "i14npath", "i18onText", "i18bpath", "i16nFormat", "i18onUrl", "i18bStr", "i18naPath", "i14nsUrl", "i18bFormat", "i18nFormat", "i16nsFormat", "i14nUrl", "i16nsStr", "i18fpath", "i18fFormat", "i18onPath", "i18onpath", "i14nspath", "i11pnCorp", "i11nUrl", "i18nStr", "i18nText", "i18nsFormat", "i18nePath", "i16nspath", "i18neCorp", "i11npath", "i18nepath", "i14nsText", "i18nspath", "i18pnPath", "i16nPath", "i14nText", "i18naText", "i18nUrl", "i18npath", "i16npath", "i18pnCorp", "i11pnUrl", "i18pnpath", "i18naUrl", "i18napath", "i18pnUrl", "i18nsCorp", "i18fStr", "i16nsPath"], "englishFile": ["EnglishJar", "internetFile", "officialPath", "internetResource", "englishDir", "englishPlace", "ianaFile", "EnglishFile", "ianaJar", "EnglishFiles", "EnglishPlace", "ianaDir", "Englishfile", "examplePath", " englishDir", "officialPlace", "englishResource", "englishPath", " englishPath", " englishFiles", "exampleFile", "englishFiles", "englishJar", "officialfile", "officialFile", "examplePlace", " englishResource", " englishJar", "englishfile", "EnglishPath", "examplefile", "ianaFiles", "EnglishResource", "EnglishDir", "internetPath", "internetFiles"], "propertiesFilePath": ["propertiesfilepath", "propertiesFilesName", "propertiesFileUrl", "pertiesFilepath", "pertiesDirUrl", "propertiesfilePath", "propertiesFilesPath", "propertiesDirPath", "propertiesFilepath", "pertiesDirName", "propertiesFullUrl", "propertiesFullName", "pertiesFileLocation", "propertiesfileUrl", "propertiesfileName", "pertiesDirPath", "pertiesFileName", "propertiesDirpath", "propertiesDirLocation", "propertiesFilespath", "propertiesDirUrl", "pertiesDirpath", "propertiesfileLocation", "pertiesFilePath", "propertiesDirName", "pertiesfilePath", "propertiesFullpath", "propertiesFileName", "pertiesfileName", "pertiesFileUrl", "pertiesfilepath", "propertiesFilesLocation", "pertiesfileLocation", "propertiesFileLocation", "propertiesFullPath"], "file": ["path", "http", "pe", "class", "File", "url", "full", "future", "unit", "buffer", "FILE", "model", "e", "application", "f", "data", "socket", "source", "binary", "folder", "base", "reader", "connection", "io", "stream", "log", "fe", "field", "h", "word", "use", "content", "string", "resource", "handler", "zip", "text", "book", "entity", "function", "fp", "part", "play", "directory", "single", "letter", "module", "media", "language", "up", "le", "property", "or", "ile", "work", "object", "message", "filename", "child", "it", "format", "parent", "lock", "p", "page", "die", "php", "files", "one", "force", "name", "b", "l"], "in": ["gin", "d", "it", "isin", "inn", "i", "con", "ic", "sin", "input", "init", "kin", "p", "din", "lin", "reader", "rin", "ins", "bin", "er", "into", "err", "io", "inner", "s", "image", "b", "ri", "inside", "or", "l", "win", "In", "n", "inc", "cin", "IN", "nin", "ini", "r", "login", "again", "pin"], "out": ["ext", "f", "sync", "OUT", "socket", "string", "home", "i", "builder", "output", "and", "cli", "lib", "by", "Out", "p", "ou", "v", "error", "full", "part", "co", "w", "plain", "bin", "one", "exp", "err", "net", "io", "to", "s", "inner", "image", "up", "obj", "client", "o", "b", "outs", "exec", "outer", "work", "n", "inc", "r", "ex", "fn", "word", "again"], "c": ["cl", "f", "d", "x", "a", "cu", "cf", "lc", "i", "ci", "ic", "con", "dc", "cr", "dec", "character", "col", "ce", "p", "cy", "v", "esc", "sc", "w", "ct", "k", "arc", "char", "code", "ec", "abc", "o", "b", "cc", "ice", "rc", "size", "l", "n", "ac", "ch", "xc", "r", "uc", "enc", "h", "pointer", "C", "e"], "is": ["ir", "lis", "ris", "re", "serv", "it", "ui", "iss", "i", "es", "ais", "does", "path", "has", "str", "ib", "us", "iter", "isu", "its", "isa", "os", "iso", "ins", "res", "get", "s", "bis", "IS", "ios", "ri", "as", "was", "Is", "are", "stream", "si", "api", "info", "id"], "breader": [" breaders", "rowner", " birders", " Breader", " Breaders", "breworer", "breadner", "breadler", "rainer", "brewner", "breaders", "breadER", "brewER", "rainER", " birder", "rainner", "rainorer", "rownner", " birdler", "brewer", " Breadler", " breadler", "rownorer", " BreadER", " birdER", " breadER", "rownER", "breadorer"], "line": ["sync", "plugin", "data", "row", "lines", "strip", "string", "section", "parse", "no", "end", "profile", "feed", "rule", "LINE", "str", "response", "lined", "model", "entry", "character", "nl", "sl", "el", "cell", "lf", "liner", "text", "value", "license", "day", "block", "error", "url", "page", "lin", "part", "inline", "one", "phrase", "style", "letter", "comment", "header", "name", "Line", "code", "look", "write", "le", "l", "link", "pass", "item", "definition", "frame", "log", "key", "split", "body", "li", "lo", "word", "status", "band", "message"], "strBuilder": ["strbuilder", " strReader", "StrBlock", " strParser", "strBot", "styleReader", "bcBuilt", "execParser", "stringbuilder", "arrBuilding", "StrBuilding", "StrReader", "stringBlock", "stringHelper", "StrBu", " strBot", "stringBuilt", "strBuilt", "execBuilder", "stringReader", "stringBuffer", "arrBuild", "stringBuilder", "strReader", " strBu", "styleBot", " strBuild", "arrbuilder", "strBuffer", " strBuilt", "styleBuilding", " strbuilder", "arrBuilder", "bcBuild", "strBuild", " strBuffer", "stringParser", "StrBuffer", "strBlock", "execBuild", "stringBuild", "bcHelper", "stringBuilding", "StrBuilder", "stringBu", " strHelper", "execBuffer", " strBlock", "StrBuild", "strBuilding", "stringBot", "strBu", "bcBuilder", "styleBuilder", " strBuilding", "strParser", "strHelper"], "pieces": ["rings", "bones", "styles", "pins", "tools", "bits", "circle", "features", "words", "lists", "lines", "clips", "bands", "phones", "blocks", "str", "sections", "parts", "cuts", "boxes", "tips", "tops", "photos", "nets", "groups", "cards", "items", "apps", "files", "css", "steps", "marks", "services", "cells", "ops", "objects", "bytes", "letters", "places", "vals", "caps", "cats", "values", "keys", "seconds", "pots", "split", "strings", "stars", "piece", "packs", "names"], "found": ["defined", "sent", "existent", "readable", "exist", "find", "left", "confirmed", "empty", "matched", "successful", "path", "built", "valid", "broken", "fall", " Found", "where", "z", "Found", "available", "search", "F", "lost", "failed", "enabled", "supported", "only", "first", "expected", "full", "identified", "true", "temp", "missing", "installed", "printed", "normal", "got", "finding", "existing", "closed", "used", "err", "given", "still", "changed", "filled", "initialized", "loaded", "result", "old", "not", "pos", "all", "good", "published", "l", "successfully", "fixed", "count", "created", "fl", "default", "null"]}}
{"id1": "14783950", "id2": "2461169", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"fileList": ["FileStream", "filelist", " fileCollection", "modelEx", "modelCollection", "fileChain", "ziplist", " fileSet", "fileEx", "FileChain", "stringChain", "FileSet", "stringlist", "wordName", "inputStream", "FileName", "FileList", " fileStream", "Filelist", "fileStream", "fileSet", "fileCollection", "wordStream", "modelStream", "wordString", "inputList", "fileString", "zipList", "wordList", "FileString", "inputCollection", "stringList", " fileString", "zipName", " filelist", "modelList", "inputEx", "zipSet", " fileEx", "stringName", " fileChain"], "zipFileName": ["zipFilename", "archiveDirPath", "folderFilePath", "zipFileDir", "zipGlobalPath", "folderGlobalPath", "zipFullNames", "folderFileName", "zipGlobalNames", "zipFullDir", "zipPackageDir", "zipGlobalName", "folderGlobalNames", "zipFullName", "archiveFileDir", "zipFilePath", "zipDirDir", "folderGlobalname", "zipDirname", "archiveDirDir", "zipFullPath", "folderGlobalName", "zipGlobalname", "zipDirPath", "folderFileNames", "archiveFileName", "folderFilename", "archiveDirName", "zipFullname", "zipDirName", "zipPackageName", "zipFileNames", "archiveFilePath", "zipDirNames", "zipPackagePath"], "fos": ["Fos", "FoS", "faos", " fosh", "afis", "Fis", "flos", "fosh", "infoS", "afaos", "afos", "infaos", "flis", "foS", "Fosh", "afoS", "infos", "infis", "flosh", "Faos"], "zos": ["tz", "phi", "bos", "nz", "budget", "ses", "ozo", "lins", "LOS", "es", "zen", "inos", "zz", "zik", "zers", "cos", "zb", "zag", "ZA", "zip", "bag", "z", "zar", "abi", "zl", "onz", "zer", "zy", "zi", "jobs", "webkit", "os", "obb", "jas", "fits", "zo", "dos", "zzy", "closure", "zon", "css", "zx", "gz", "bis", "bes", "oses", "lol", "outs", "rez", "fi", "kos", "ros", "iframe", "zan", "uz", "chini", "seconds", "loop", "osi", "packs", "spin", "zes", "ZI"], "iter": ["walker", "ir", "itter", "f", "next", "it", "ener", "cher", "fer", "gener", "ie", "parse", "i", "former", "end", "slice", "http", "fr", "is", "iner", "iterator", "list", "ator", "el", "ite", "file", "chain", "keep", "er", "izer", "inter", "ter", "err", "sort", "inner", "finder", "ip", "liter", "Iterator", "inse", "set", "order", "Iter", "outer", "inc", "oper", "iz", "loc", "test", "upper", "ner", "ser", "index", "coll", "enter", "e"], "fileName": ["fullName", "FilePart", "filename", " fileInfo", "fullOpen", "FilePath", "fileInfo", "pageString", "Filename", "localPart", "filePath", "fLine", "filenamename", "fileFull", " fileType", "FileName", "filenameInfo", " fileUrl", "FileUrl", "simpleOpen", "pageName", "FileData", " fileData", "simplePath", "FileLine", " fileLine", "fPart", "filenameFull", "filePart", "currentname", "fileString", "fileOpen", " filePath", "localname", "fileData", "filenameName", "currentUrl", "FileFull", "FileString", "fname", " filePart", " fileString", "fileUrl", "currentData", "simpleName", "currentName", " fileOpen", "pageType", "fullPath", " fileFull", " filename", "fileType", "fileLine", "fName", "localName", "pagename", "localPath", "FileType", "FileInfo"], "ind": ["bind", "length", "x", "d", "pull", "cond", "ad", "inn", "i", "ci", "end", "div", "mid", "eff", "fr", "ord", "z", "len", "ded", "Ind", "vert", "ix", "in", "rib", "ii", "dir", "pos", "j", "pend", "nd", "start", "inc", "pt", "loc", "val", "count", "ld", "index", "wind", "IND", "mind", "id"], "shortName": ["fullName", "longPath", " shortString", "smallname", "longName", "shortString", "smallPath", "longPart", "fullString", " shortname", "Shortname", "shortPath", "longname", "fullname", "ShortName", "shortname", "ShortPath", " shortPath", " shortLine", "smallPart", "ShortString", "shortLine", "shortPart", "fullLine", "fullPath", "ShortPart", "longLine", "smallName"], "fis": ["Fos", " fisa", "gisa", " fris", " fs", "gios", "fris", "cfris", "afis", "Fis", " fiss", "pios", " fios", "afiss", "fios", "cfis", "pisa", "Fs", "afos", "pris", "fisa", "gris", "cfiss", "fiss", "cfos", "afris", "Fiss", "cfs", "pis", "fs", "gis"], "buf": ["queue", "ba", "pb", "bl", "bh", "rb", "data", "feat", "bb", "wb", "bc", "tmp", "buff", "fb", "bu", "grab", "cv", "seq", "ff", "lb", "bf", "v", "vec", "fd", "bp", "lim", "bin", "cb", "Buff", "box", "bd", "buffer", "br", "done", "batch", "b", "bytes", "rc", "uf", "cur", "loc", "uc", "bag", "la"], "bytesRead": ["bytesWrite", "secondsRead", "flowsLength", "wordsLength", "wordsWrite", "flowsRead", "tesRead", "wordsUse", "tesWrite", "secondsLength", "flowsNeed", "bytesSkip", " bytesLoad", "bitsLoad", " bytesWrite", "tesLoad", "secondsWrite", "bitsLength", "bytesLength", " bytesSkip", "bytesLoad", "bitsRead", "bitsSkip", "secondsNeed", "bitsWrite", "bytesUse", " bytesNeed", "bytesNeed", "tesSkip", " bytesLength", "wordsRead", "flowsWrite", " bytesUse", "bitsUse"]}}
{"id1": "23273706", "id2": "14598566", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"treeData": ["noteInfo", "moduleList", "treeString", "flatText", "TreeList", "TreeString", "treeInfo", "treeArray", "reeText", "reeArray", "treeText", "reeString", " treeInfo", "reeInfo", "eltList", "TreeInfo", "TreeArray", "noteCode", "treeDat", "reeData", "noteData", "flatArray", "treeList", "flatString", "reeList", " treeString", "eltData", "eltDat", "moduleText", " treeList", " treeCode", "reeCode", "moduleArray", "flatData", "moduleDat", "moduleData", "eltText", "TreeData", "noteText", " treeDat", "moduleString", " treeArray", " treeText", "treeCode"], "filename": ["nil", "prefix", "data", "uri", "jpg", "xml", "ername", "dylib", "Filename", "path", "password", "tmp", "kl", "sheet", "File", "username", "folder", "kn", "txt", "database", "utf", "fp", "url", "fil", "file", "wav", "dll", "fd", "whatever", "directory", "files", "location", "phrase", "title", "name", "journal", "FILE", "kj", "fn", "ppa", "SourceFile", "localhost", "figure", "framework", "metadata"], "urlString": ["URLstring", "locationstring", "locationString", " urlStr", "locationUrl", "urlUrl", "URLString", "filestring", "fileStream", "URLUrl", "locationStr", "urlStream", " urlstring", "fileString", "urlstring", " urlStream", "URLStream", "fileStr", " urlUrl", "URLStr", "urlStr"], "urldata": [" urldada", "urllddata", "urldatum", " urlddata", "urlfdata", "urlfATA", "urledada", "urlddata", "urlldATA", "urledata", "urLDada", "urlfatum", " urldATA", "urLDATA", "urledatum", "urlLDatum", "urLDatum", "urLData", "urlLData", "urleddata", "urldada", "urlfada", "urlldata", " urLData", "urlfata", "urlLDdata", " urLDdata", " urLDATA", "urldATA", " urLDada", "urlLDATA", "urlldatum", "urledATA", "urLDdata"], "factory": [" fistry", "bactory", "cactory", " fixture", "fluent", "affluent", "affixture", "coo", "binally", "bFactory", "infistry", "infoo", "infactory", "ufancy", "affFactory", "ufactory", "cFactory", "fFactory", " foo", "cfFactory", "cfactory", "foo", "fixture", "affactory", "cfluent", " fancy", "cinally", "ufoo", "boo", "infancy", "cfixture", "fistry", " fluent", " fFactory", "ufistry", "fancy"], "parser": ["loader", "monkey", "plugin", "fruit", "uri", "Parser", "parse", "string", "xml", "builder", "handler", "http", "writer", "json", "parent", "utils", "p", "paragraph", "fp", "reader", "pdf", "se", "library", "er", "arser", "manager", "inner", "s", "up", "b", "util", "as", "instance", "l", "ph", "auto", "audio", "driver", "info", "raf"], "u": ["nu", "plug", "hu", "cu", "ru", "ui", " ur", "uri", "http", "mu", "ur", "us", "eu", "ut", "p", "ou", "tu", "url", "uu", "iu", "io", "lu", "s", "yu", "o", "su", "b", "util", "U", "l", "uv", "uf", "uni", "ul"], "is": ["oss", "obs", "ir", "lis", "ris", "it", "ori", "ui", "iss", "isl", "iris", "ie", "abs", "es", "ais", "has", "im", "ib", "http", "iter", "us", "isu", "gets", "its", "pi", "isa", "in", "iso", "ai", "ins", "ar", "io", "s", "ip", "bis", "IS", "mis", "ios", "ri", "as", "or", "Is", "are", "isi", "si", "api", "info", "fs"], "os": ["oss", "obs", "OS", "bos", "oos", "aos", "es", "ose", "ol", "http", "cos", "los", "us", "bs", "p", "op", "file", "iso", "ens", "dos", "ms", "io", "s", "Os", "bis", "ios", "ops", "o", "oses", "pos", "as", "or", "ros", "ps", "oa", "osi", "so", "ob", "sys", "oS", "oes", "fs"], "iBufSize": ["iBllfsize", "iLuffize", "iBlfLen", "iBatchize", "iBatchLength", "iBundleLength", "iBuffSize", "iLufSize", "iBlufSize", "iBundleize", "iBlfSize", "iLufLength", "iBuffize", "iBuffOffset", "iLuffLength", "iBbufSize", "iBbufLen", "iBundleSize", "iBufsize", "iBufLen", "iBundleOffset", "iBllfSize", "iLufOffset", "iBufize", "iLufize", "iBllfLen", "iBufferSize", "iLuffOffset", "iBlfsize", "iBbufsize", "iBuffLength", "iBlufsize", "iBuffersize", "iBatchOffset", "iBufLength", "iBlufLen", "iBufferLen", "iBatchSize", "iBufOffset", "iLuffSize"], "inBuf": ["inBuffuffer", "inSubaf", " inFaf", "inBump", "outBuffbuf", "inBuffbuf", " inBuffer", "inBuffaf", " inBump", "inBlaf", "inFluffer", "inSubbuf", "inBlbuf", "inBlump", "inLbuf", " inBuffuffer", " inBuffump", "inFbuff", " inFbuff", "outBuffaf", "inCbuf", "inFlump", "inBuffer", "inCbuff", " inBaf", "inBbuff", " inBbuff", " inBuffuf", "inCaf", "inBuffump", "inFbuf", "inFluf", "inBaf", "inFump", "inBuffuf", " inBuffbuf", "inFuf", "inBluf", "outBump", "inCuf", "outBuffuf", "inSubbuff", "inLump", "inLuffer", "inFlbuf", "inLuf", "inBbuf", "inFaf", " inFuf", "outBaf", " inFbuf", " inBbuf", "outBuf", "outBbuf", "outBuffump", "inSubuf"], "iNumRead": ["iLenread", "iNumReader", "oiNumRun", "iNumread", "iNumWritten", "iTonText", "iLenReader", " iFatRead", "iTonWrite", "oiNumREAD", "iFatRead", "iNUMWrite", "oiOrdRun", " iNumText", "oiOrdREAD", "iNUMWritten", " iNumread", "iTonRead", "iOrdWritten", "iNUMRun", " iNumWrite", "iRamReader", "iOrdRead", "oiNumWritten", "iRamRead", "oiNumRead", "iNUMGet", "oiOrdRead", "iNumText", "iNumberRead", "iNumberRun", "iNUMRead", " iFatText", " iNumGet", "iNumberREAD", " iNumReader", "iFatWrite", "iLenRead", "iNumberWritten", "iNUMREAD", "iNumREAD", "iOrdRun", " iFatGet", " iFatWrite", "iOrdREAD", "oiOrdWritten", "iFatText", "iTonGet", "iNumGet", "iFatGet", "iNUMText", "iRamread", "iNumRun", "iNumWrite"], "f": ["d", "g", "sf", "feed", "fr", "t", "F", "fa", "ff", "p", "v", "file", "fp", "fd", "w", "m", "io", "s", "rf", "o", "c", "b", "fi", "j", "l", "uf", "df", "n", "fn", "r", "fe", "h", "info", "fs", "e"], "inputstream": ["inputchannel", "outputfield", " inputf", "inputf", " inputchannel", "Inputstream", "inputStream", "outputstream", "outputf", "Inputf", "contextchannel", "InputStream", "inputfield", "contextfield", "contextstream", " inputStream", "outputStream", "contextStream", "outputchannel", " inputfield"], "document": ["docs", "data", "content", "tree", "ocument", "Document", "source", "xml", "container", " documents", "output", "graph", "director", "person", "response", "t", "project", "list", "total", "context", "json", "window", "html", "p", "v", "file", "page", "office", "directory", "dom", "m", "element", "media", "collection", "c", "b", "result", "doc", "node", "h", "object"], "nodelist": [" nodeelist", "nodestyle", "nodedeline", "nodedette", "enodemark", " nodestyle", "nODelist", "anodette", "anodename", "anodestyle", "nodesette", "nODzilla", "nodette", "nodedestate", "nodeest", "nodeszilla", "nodesestyle", "nodesList", "nodzilla", "nodesestate", "nodselist", "enodename", "anodsename", "nodeelist", "nodsestyle", "enodeselist", "nodedestyle", "enodList", "nokeline", " nodeselist", "nodedemark", "nodsette", "nodest", "nokelist", "nODestyle", " nodesestyle", "nodedest", "nodemark", "nodedelist", "enodesename", " nodeszilla", " nodzilla", " nodestate", "nODestate", "nodeline", "enodesemark", " nodeestate", "nodedList", "anodelist", "nodedzilla", "nodsename", "nodename", "noddList", " nodeeline", "nokestate", "nodeestate", "anodselist", "anodsette", "nodesename", "nodList", " nodesestate", " nodeline", " nodest", "anodsestyle", "enodelist", "noddelist", "noddemark", "nodesemark", "nodedename", "enodesList", "nodestate", "noddename", " nodeest", "nodeselist", "nodeeline", "nokest"], "num": ["number", "nu", "umi", "um", "cum", "nb", "uri", "no", "span", "div", "con", "zero", "comb", "total", "init", "len", "nc", "Num", "part", "temp", "lim", "bin", "dom", "type", "NUM", "dim", "nam", "net", "unit", "multi", "np", "om", "mult", "sum", "tri", "max", "nom", "n", "uni", "nr", "inc", "norm", "loc", "node", "count", "index", "col", "ul"], "i": ["hi", "phi", "d", "ori", "x", "ui", "it", "ti", "g", "uri", "ie", "bi", "ij", "ci", "gi", "qi", "slice", "mu", "di", "cli", "z", "iv", "pi", "chi", "ik", "p", "my", "v", "in", "ai", "ix", "part", "m", "iu", "yi", "io", "ip", "ii", "y", "info", "o", "c", "b", "I", "ri", "fi", "multi", "j", "l", "start", "uni", "isi", "si", "li", "ini", "mi", "oi", "ji", "index", "xi", "eni", "e", "id"]}}
{"id1": "9954926", "id2": "4562786", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "label": 0, "substitutes": {"out": ["prefix", "flush", "server", "store", "raw", "full", "w", "buffer", "outs", "external", "view", "pool", "sys", "next", "data", "tmp", "lib", "console", "group", "base", "conn", "in", "plain", "down", "exp", "net", "io", "write", "log", "key", "report", "word", "again", "info", "dump", "OUT", "msg", "string", "resource", "output", "line", "db", "list", "writer", "Out", "part", "temp", "bin", "state", "comment", "table", "up", "client", "pre", "outer", "cache", "copy", "object", "point", "flow", "con", "off", "password", "cli", "parent", "window", "lock", "error", "page", "co", "gen", "err", "now", "name", "obj", "o", "result", "post", "null"], "file": ["loader", "queue", "address", "f", "filename", "data", "port", "socket", "source", "resource", "path", "handler", "output", "line", "feed", "rule", "pe", "class", "File", "book", "base", "lock", "fp", "url", "in", "page", "full", "connection", "unit", "buffer", "name", "up", "b", "le", "l", "ile", "FILE", "stream", "cache", "log", "report", "message"], "obtainUserReputationRequest": ["obtainUserComputationsPoint", "obtainUserReputeRequest", "obtainUserComputeRequest", "obtainUserReputationPoint", "obtainUserDemutationRequest", "obtainUserReputationsSuccess", "obtainUserReputableRequest", "obtainUserReputionQuery", "obtainUserRepigrationrequest", "obtainUserReputableResponse", "obtainUserDemutableGrant", "obtainUserComputationQuery", "obtainUserRepationResponse", "obtainUserReputationGrant", "obtainUserRepationRequest", "obtainUserComputeInfo", "obtainUserComputationsSuccess", "obtainUserReputableGrant", "obtainUserReputeInfo", "obtainUserRepationInfo", "obtainUserReputationQuery", "obtainUserReputationInfo", "obtainUserComputationPoint", "obtainUserRepurationQuery", "obtainUserComputeResponse", "obtainUserDemutationrequest", "obtainUserReputationsRequest", "obtainUserRepurationRequest", "obtainUserDemutableRequest", "obtainUserReputablerequest", "obtainUserRepigrationInfo", "obtainUserReputionRequest", "obtainUserRepationrequest", "obtainUserRepigrationRequest", "obtainUserDemutablerequest", "obtainUserReputableSuccess", "obtainUserRepigrationResponse", "obtainUserReputedPoint", "obtainUserComputationsRequest", "obtainUserReputationsQuery", "obtainUserReputationsPoint", "obtainUserReputablePoint", "obtainUserRepationQuery", "obtainUserRepurationrequest", "obtainUserReputationSuccess", "obtainUserReputeResponse", "obtainUserComputationRequest", "obtainUserDemutationGrant", "obtainUserComputerequest", "obtainUserComputationInfo", "obtainUserComputationSuccess", "obtainUserComputationsResponse", "obtainUserReputationsResponse", "obtainUserReputeGrant", "obtainUserReputedSuccess", "obtainUserRepurationResponse", "obtainUserReputerequest", "obtainUserReputeQuery", "obtainUserComputationrequest", "obtainUserReputedResponse", "obtainUserReputionResponse", "obtainUserRepigrationGrant", "obtainUserReputedRequest", "obtainUserReputationrequest", "obtainUserReputationsrequest", "obtainUserComputationResponse", "obtainUserComputeQuery", "obtainUserReputionrequest"], "obtainUserReputationResponse": ["obtainUserReputationresponse", "obtainUserReputeRequest", "obtainUserExecutationResult", "obtainUserRepationResponse", "obtainUserRepationRequest", "obtainUserReputationResult", "obtainUserExecutationresponse", "obtainUserExecutionResult", "obtainUserReputionresponse", "obtainUserExecutationRequest", "obtainUserExecutationResponse", "obtainUserReputionRequest", "obtainUserExecutionresponse", "obtainUserRepationresponse", "obtainUserReputeResponse", "obtainUserReputionResult", "obtainUserExecutionResponse", "obtainUserExecutionRequest", "obtainUserReputionResponse", "obtainUserReputeResult", "obtainUserReputeresponse", "obtainUserRepationResult"], "rateUserRequest": ["rateByteRequest", "rateUserrequest", "rateRoleQuery", "rateApplicationrequest", " rateFileResult", "rateFilerequest", "rateuserRequest", "rateUQuery", " rateWordQUEST", " rateWordResponse", "rateByteGrant", "rankUserRequest", "rateClientGrant", " rateWordRequest", " rateClientGrant", "rateServerGrant", "rateUserGrant", " rateServerRequest", " rateUsersRequest", "rateRoleRequest", " rateUserQuery", "rateWordrequest", "ratinguserrequest", "rateClientRequest", " rateUsersQuery", "rateURequest", "rateApplicationRequest", "rateuserrequest", "rateServerId", "rateUserError", "rateUsageRequest", "rateClientError", "rateUsageResponse", "rateMessageRequest", "rateWordResult", " rateUserError", "rateClientResponse", "rateUsersrequest", " rateUserQUEST", "rateWordQuery", "rateWordGrant", "rateWordError", " rateFileResponse", "rateServerRequest", "rating\n", "rateUrequest", "rateClientQuery", "rateCustomGrant", "rateMessageError", "rateServerQuery", " rateClientQuery", "rated\n", "rateUsersQuery", "rateUserQUEST", " rateUserrequest", " rateWordrequest", "rateUsageQUEST", "ratingUserRequest", "rateWordRequest", "rateUserAttempt", " rateUserResult", " rateWordQuery", "rateCustomAttempt", "ratinguserRequest", "rateCustomRequest", "rateUsersResponse", "rateByterequest", "rateFileResponse", " rateServerGrant", "rateUResponse", "rateMessageQuery", "rateServerQUEST", " rateClientError", "rateRoleError", "rateWordResponse", "rateServerAttempt", "rankUserAttempt", "rankUserGrant", " rateUserGrant", "rateWordQUEST", " rateServerId", " rateUserId", "rateMessageGrant", "rateServerrequest", "rateApplicationQuery", " rateUsersrequest", "rateClientQUEST", "rateuserQuery", "rateServerError", "rateUserResult", "rateUserId", "rateByteId", " rateServerrequest", "rateFileRequest", "rateUsersRequest", "ratinguserQuery", "ratingUserrequest", "rateClientResult", " rateUsersResponse", "rateFileQuery", "rateApplicationResponse", "rateUserQuery", "rateUsageQuery", " rate\n", "rateuserResponse", " rateClientRequest", "rateFileResult", " rateFileRequest", " rateFileGrant", "rateRoleQUEST", " rateWordError", "ratingUserQuery", "rateWordId", "rate\n", "rateFileGrant"], "rateUserResponse": [" rateUserInfo", "createuserResp", "rateUsersresponse", " rateUserResp", "rateuserRes", " rateUserresponse", "rateuserReturn", "gradeUserResponse", "createuserResult", "rateUResp", "rateUsersResp", "rateApplicationresponse", "createUserResponse", "rateUserRes", "rateUserresponse", "rateUseresponse", "ratingUserResp", "rateWordReturn", " rateuserCustomer", "rateHumanresponse", "rateUsageResponse", "rateUresponse", "createUserResult", "gradeUserResult", "rateUsageCustomer", "gradeuserResult", "rateWordResult", "rateUserInfo", "rateHumanResponse", "gradeUserResp", "gradeuserresponse", "gradeuserResponse", "rateUsersResult", "rateUseResp", "rateFileRes", " rateFileResponse", "rateUseResponse", " rateuserInfo", "ratingHumanReturn", "gradeuserResp", "ratingHumanResp", "ratingUserresponse", "rateUseResult", " rateUserRes", "ratingHumanresponse", "rateFileResp", "createUserResp", "rateUsersResponse", "rateuserResp", " rateFileresponse", "rateFileresponse", "rateApplicationResp", "rateFileResponse", "rateUResult", "rateUResponse", " rateFileResp", " rateUserCustomer", "rateWordResponse", "gradeUserresponse", " rateFileRes", "rateWordresponse", " rateuserResp", "rateApplicationRes", "ratingUserResponse", "ratingUserReturn", "rateUserResult", "createUserresponse", " rateuserResponse", "rateUsageResp", "rateHumanReturn", "rateUserCustomer", "ratingHumanResponse", "rateApplicationResponse", "rateuserCustomer", "rateHumanResp", "rateuserInfo", "createuserresponse", "rateWordResp", "rateuserResult", "rateuserResponse", "createuserResponse", "rateUserReturn", "rateUserResp", "rateuserresponse", "rateUsageInfo"], "fis": ["Fos", " fIs", "sfis", " fris", "feiss", "Fris", "sfos", "feis", "fris", " fos", "feris", " fid", "fIs", "sfIs", "Fis", " fiss", "sfiss", "feid", "fos", "fiss", "FIs", "Fid", "Fiss", "fid"], "br": [" bio", "bl", "gr", "rb", "dr", "ref", "hr", "BR", "string", "i", "bro", "bc", "str", "cr", "fr", "tr", "is", "buf", "bed", "reader", "wr", " tr", "res", "er", "err", "io", "Br", "buffer", "arr", "obj", "b", "result", "lr", "fin", "browser", " reader", "stream", "bridge", "ber", "ch", "body", "r", "ocr", "ob", " fr", "Reader"], "call": ["cl", "address", "Call", "cat", "push", "data", "cod", "check", "ck", "request", "string", "xml", "flow", "send", "output", "contact", "line", "str", "response", "input", "cell", "text", "invoke", "block", "roll", "raw", "query", "url", "claim", "load", "co", "sc", "fax", "ell", "play", "calling", "throw", "comment", "buffer", "Line", "code", "name", "c", "charge", "result", "callback", "write", "all", "create", "l", "doc", "work", "log", "run", "phone", "loc", "body", "called", "r", "use", "voice", "e", "message"]}}
{"id1": "21425787", "id2": "18974466", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"in": ["a", "data", "inn", "source", "i", "input", "base", "min", "file", "url", "reader", "ins", "bin", "m", "connection", "inner", "io", "image", "name", "up", "c", "b", "exec", "or", "In", "work", "at", "inc", "ac", "IN", "ini", "ex", "login", "index", "again", "id"], "out": ["target", "prefix", "OUT", "x", "data", "point", "user", "source", "output", "off", "server", "writer", "dest", "again", "Out", "base", "p", "v", "file", "conn", "part", "w", "temp", "connection", "call", "io", "to", "name", "up", "client", "o", "c", "b", "outs", "exec", "result", "n", "at", "inc", "cache", "ex", "object"], "sourceChannel": ["sourceChan", "ourceChannel", "Sourcechannel", "srcConnection", " sourceConnection", "ourceChan", "srcChannel", "SourceChannel", "sourceStream", "targetChannel", "SourceStream", "SourceConnection", "targetStream", "resourceChannel", " sourceStream", "resourcechannel", "sourceConnection", "srcSocket", "ourceSocket", " sourceSocket", "SourceChan", "targetChan", "srcChan", "resourceConnection", "sourcechannel", " sourcechannel", " sourceChan", "targetchannel", "ourcechannel", "resourceChan", "ourceConnection", "sourceSocket"], "destinationChannel": ["DestinatorChan", "destinationFile", "destinationchannel", "destinatorchannel", "destinatorManager", "destinationConnection", "destructionConnection", "DestinationConnection", "DestinatingManager", "DestinatorConnection", "destinateChannel", "destinatorStream", "destinatedChannel", "DestinationChan", "destinateConnection", "destinationStream", "destinatingStream", "destructionChannel", "DestinationManager", "destinatorFile", "destinatedStream", "destationFile", "destinatorConnection", "destinatedManager", "destinatingChannel", "DestinationStream", "destinatedchannel", "destructionChan", "destinatingManager", "destinatorChannel", "destationConnection", "destinatingChan", "DestinatingChannel", "DestinatingChan", "destinatedFile", "destinateChan", "DestinationFile", "destinatedConnection", "destationchannel", "DestinatorFile", "DestinatorChannel", "destinatedChan", "destationChannel", "destinatorChan", "DestinatingStream", "Destinationchannel", "Destinatorchannel", "DestinationChannel", "destinationChan", "destinationManager"]}}
{"id1": "841724", "id2": "732800", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"inFile": ["InPlace", "inPlace", "infile", "outFilename", " infile", "outPath", "outFiles", "oldfile", " inPath", "oldFiles", "outPlace", "oldFilename", "inputfile", "incFile", "oldFile", "inputFiles", "InPath", "incPlace", "outfile", "Infile", "incfile", "incFiles", "inFiles", "inFilename", "InFile", "inputFile", "inputFilename", " inFiles", "inPath", "InFiles"], "outFile": ["zipFilename", "Outfile", "outFilename", "outputFile", " outTable", "outputFolder", " outFolder", "OutFile", "outPlace", " outPlace", "OutDir", "OutPlace", "outputTable", " outString", "newFile", "inputFolder", "inputTable", "newDir", " outDir", "inputPlace", "outFolder", "zipString", "outfile", "outputString", "zipFILE", "outputFilename", "outDir", "zipFile", " outFilename", "inputFile", " outfile", "outputFILE", "outputPlace", "outFILE", "newPlace", "outString", " outFILE", "newfile", "outTable"], "iis": ["ioIs", "iniIs", "iIs", "iniais", "iisc", "iniisc", " iIS", "ciid", "iniiss", "iiIS", "Iiss", "iils", " iid", "iais", "iid", "ioisc", "iIS", "iniils", "Iis", "iniIS", "iniis", "ioiss", "ciis", " iais", "IIs", "ciiss", " iIs", "iiss", "ciais", "iniid", "iiIs", " iiss", "Iisc", "iois", "iiils", "iiis", " iils"], "dcmParser": ["dmcPar", " dcmLoader", "dcpReader", "DcmJar", "pdymReader", "pdymJar", "dmmarser", "dcrJar", "dcmStreamer", "DcmParser", "ddcParser", "dtermStreamer", " dpmPar", "dymReader", "dcrWriter", "dcpParser", "dmmReader", "dcmPar", "dcyJar", " dpmBuilder", "ddcLoader", "dcmarser", " dcmPlugin", "dpmparser", " dcmBuilder", "ddcPlugin", " dpmarser", "dmoduleParser", "dsemStreamer", "dpmStreamer", "dymParser", "dtermPlugin", "pdymParser", " dcmarser", "dtermParser", "ddcReader", "Dcmarser", "dymJar", " dcmPar", "dcrparser", "dsemParser", "Dcmparser", "dcmWriter", "dmmParser", " dpmJar", "dcmBuilder", " dpmStreamer", "dsemReader", " dpmPlugin", " dcmStreamer", "dcmparser", "dcmLoader", "dcmPlugin", "dmoduleReader", "dmcJar", "dcpJar", " dpmReader", "dpmLoader", "dcyParser", "dcyarser", "dcyReader", "dcrReader", "dpmJar", "pdcmReader", "dcrParser", "dpmBuilder", "dpmPar", "dymparser", "pdymparser", " dpmLoader", "DcmReader", " dpmParser", "pdcmParser", "dcpparser", " dcmReader", "dtermReader", "dmcParser", "dcmReader", "dcmJar", "dpmarser", "pdcmparser", "dcrarser", " dcmJar", "DcmWriter", "dmmWriter", "dpmParser", "dpmReader", "dcrPar", "dmodulePlugin", "pdcmJar", "dmoduleBuilder", "dsemPlugin", "dmcarser", "dpmPlugin"], "ds": ["session", "cs", "pd", "d", "docs", "uds", "data", "dt", "dr", "sync", "src", "iss", "gd", "Ts", "tes", "asi", "da", "dc", "ays", "db", "ipes", "DS", "parts", "di", "ads", "points", "is", "dds", "bs", "amps", "nas", "utils", "ys", "os", "des", "dd", "vs", "ns", "ils", "fd", "gs", "ins", "ls", "conn", "cdn", "Ds", "s", "Os", "tx", "services", "ws", "xs", "client", "details", "rs", "ss", "ps", "ros", "Db", "df", "js", "ts", "drivers", "plugins", "ld", "sys", "eps", "dat", "ks"], "pdReader": ["pidReader", "dsReader", "pidScan", "pidLoader", "xdreader", "hdRead", "pdParser", "dsLoader", "hdWriter", "pbLoader", "pdRead", "pcRead", "wdLoader", "xdReader", "pidParser", "xdRead", "pdLoader", "pcLoader", "pbParser", "pdreader", "pbReader", "wdWriter", "dsRead", "dsWriter", "hdreader", "wdRead", "pcScan", "wdReader", "hdReader", "pbScan", "pcParser", "pdScan", "dsreader", "pcWriter", "pcReader", "xdWriter"], "out": ["d", "flush", "ssl", "class", "store", "url", "full", "w", "code", "outs", "as", "external", "at", "inc", "pool", "auto", "sys", "model", "oder", "ext", "sync", "data", "with", "lib", "group", "base", "conn", "file", "in", "down", "img", "exp", "connection", "net", "io", "device", "write", "exec", "pass", "log", "key", "word", "again", "dot", "OUT", "builder", "output", "line", "db", "list", "writer", "Out", "array", "temp", "manager", "to", "s", "later", "up", "client", "order", "doc", "outer", "sum", "cache", "ex", "copy", "default", "object", "session", "child", "point", "user", "flow", "password", "cli", "parent", "lock", "page", "co", "gen", "err", "now", "call", "inner", "image", "name", "obj", "o", "result", "term", "over", "login", "null"], "dcmEncParam": ["dcmElParameter", "dcmAccSm", "dcmEngVar", "dpmDecParam", "dcmDecSm", "dcmElType", "dcmDecPar", "dcmEncSm", "dcmencParameter", "dcmEncVar", "dcmEncType", "dcmEncPar", "dcmEncParameter", "dcmencSm", "dcmAccParam", "dpmEncSm", "dcmEnVar", "dcmEngParam", "dcmElParam", "dcmEngType", "dcmEngParameter", "dcmElVar", "dcmEnType", "dpmDecParameter", "dcmEnParam", "dpmEncParam", "dpmDecSm", "dcmEnParameter", "dcmDecParameter", "dcmDecParam", "dcmencParam", "dcmAccParameter", "dcmEnPar", "dpmEncParameter"], "pdWriter": ["ddWrite", "dsWrite", "ddWriter", "tdOutput", "hdOutput", "hdWR", "hdWriter", "tdContent", "pdWR", "PDContent", "tdReader", "dsWR", "dsOutput", "ddOutput", "pxOutput", "ddWR", "PDOutput", "hdWrite", "pdContent", "PDReader", "dsWriter", "tdWriter", "pdOutput", "pxContent", "PDWriter", "pdWrite", "pxReader", "pxWriter"]}}
{"id1": "19944975", "id2": "2461169", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"out": ["ext", "filename", "OUT", "prefix", "flush", "user", "string", "xml", "resource", "path", "output", "line", "server", "password", "project", "list", "writer", "lib", "init", "this", "again", "window", "Out", "array", "file", "conn", "reader", "plain", "w", "temp", "res", "exp", "connection", "err", "io", "inner", "buffer", "name", "obj", "client", "o", "c", "outs", "write", "exec", "external", "cache", "pool", "IN", "key", "report", "ex", "copy", "index", "object", "config"], "url": ["address", "f", "rel", "uri", "service", "ssl", "string", "source", "xml", "resource", "web", "path", "feed", "server", "http", "org", "sl", "URL", "base", "file", "page", "ls", "location", "connection", "io", "image", "open", "name", "channel", "b", "l", "ll", "stream", "Url", "log", "rl", "api", "config", "object"], "in": ["gin", "f", "a", "data", "isin", "socket", "inn", "ssl", "source", "i", "resource", "xml", "con", "is", "input", "inas", "kin", "min", "din", "conn", "file", "reader", "rin", "ins", "bin", "inner", "s", "cms", "b", "c", "inside", "as", "win", "In", "stream", "n", "inc", "ac", "IN", "cin", "nin", "ini", "r", "login", "again", "pass", "id"]}}
{"id1": "19335986", "id2": "9236363", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"t": [" template", "f", "d", "it", "ti", "g", "te", " T", "tr", "let", "p", "T", "w", " td", "type", "m", "ed", "ing", "s", "tx", "c", "l", "ts", "n", "r", "out", "ty"], "e": ["esi", "f", "d", "a", "data", "ev", "ie", "eb", "i", "ception", "es", "pe", "eu", "el", "ce", "E", "p", "event", "error", "se", "environment", "er", "de", "m", "err", "ea", "exc", "element", "ed", "ee", "code", "ec", "o", "c", "b", "oe", "j", "en", "ele", "me", "example", "enter", "fe", "ace", "ae", "object", "be"], "display": ["system", "scroll", "platform", "d", "Display", "content", "profile", "container", "app", "host", "model", "dis", "layout", "monitor", "console", "this", "panel", "hide", "p", "gui", "page", "play", "screen", "de", "draw", "style", "image", "process", "design", "description", "show", "me", "view", "position", "report", "fe", "summary", "config", "default", "status", "be"], "shell": ["system", "help", "launch", "cl", "tool", "child", "live", "tools", "sb", "hell", "xml", "app", "container", "sh", "server", "bash", "kernel", "cli", "el", "console", "lock", "p", "gui", "Shell", "sound", "poll", "m", "image", "process", "machine", "clone", "b", "echo", "exec", "ml", "l", "log", "loop", "sym", "math", "body", "null", "copy", "h", "status"], "message": ["application", "queue", "mess", "address", "mail", " messenger", "msg", "data", "content", "Message", "xml", "document", "flash", "output", "response", "meter", "model", "server", "monitor", "console", "binary", "value", "error", "page", "translation", "shadow", "m", "management", "header", "essage", "buffer", "image", "media", "code", "update", "email", "result", "description", "log", "view", "body", "report", "summary", "copy", "object", "status"]}}
{"id1": "12066447", "id2": "8932510", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"file": ["loader", "uri", "per", "path", "http", "class", "File", "url", "full", "type", "future", "open", "FILE", "body", "out", "model", "e", "queue", "address", "f", "data", "source", "lib", "binary", "folder", "base", "reader", "connection", "io", "archive", "stream", "log", "local", "info", "content", "string", "resource", "document", "handler", "db", "plus", "line", "layer", "zip", "writer", "this", "book", "function", "fp", "part", "directory", "single", "get", "letter", "dir", "job", "or", "ile", "work", "cache", "object", "filename", "it", "format", "feed", "parent", "page", "files", "one", "image", "name", "route", "phase", "l"], "backupRoot": ["Backdownroot", "backureDirectory", "backoutroot", "backupDir", "backdownDir", "BackdownSupport", "BackbackRoot", "backbackDirectory", "Backbackroot", "BackbackDir", "backflowRoot", "backupSupport", "backupsDirectory", "backdownRoot", "backoutDirectory", "backuproot", "backbackRoot", "workupHome", "workuproot", "backupsroot", "BackupRoot", "workdownHome", "backoutSupport", "backflowHome", "backupDirectory", "BackupSupport", "backbackDir", "backureHome", "backbackHome", "backflowroot", "workupDirectory", "backdownroot", "backupsRoot", "backoutRoot", "backureRoot", "BackupDir", "backupsHome", "backupsSupport", "backdownDirectory", "BackdownRoot", "workdownroot", "workupRoot", "BackdownDirectory", "backdownHome", "BackbackHome", "workdownDirectory", "backureroot", "Backuproot", "backupsDir", "backbackroot", "BackbackDirectory", "workdownRoot", "backflowDir", "backdownSupport", "BackupDirectory", "BackupHome", "backupHome"], "df": ["f", "pd", "DF", "d", " def", "data", "format", "dt", "cf", "form", "sf", "flow", "da", "dc", "db", "dat", "fr", "xf", "ds", "fb", "CF", "dp", "tf", "bf", "func", "fp", "dd", "fd", "pdf", "de", "der", "deb", "io", "dm", "md", "printf", "dict", "af", "dn", "dq", "def", "fn", "fe", "dl", "fs", "raf"], "date": ["custom", " Date", "updated", "version", "d", "x", "sync", "data", "format", "dt", "days", "time", "string", "form", "output", "rule", "diff", "Dat", "db", "str", "valid", "pe", "duration", "input", "Date", "tag", "value", "modified", "day", "atom", "min", "ate", "type", "D", "m", "style", "open", "code", "update", "name", "year", "md", "pre", "stage", "j", "doc", "work", "age", "log", "inc", "dates", "dose", "complete", "created", "use", "out", "back", "create", "dat", "message"], "zipFile": ["zipDir", "zFiles", "archiveDir", "ressFiles", " zipfile", "zfile", "archivefile", "ZipFile", "ressFile", "zipfile", "ZipDir", "zMessage", "archiveFile", "zipMessage", "zipFiles", " zipMessage", " zipFiles", "Zipfile", "ressMessage", "ressfile", "archiveFiles", "zFile", "ZipFiles", " zipDir"], "zos": ["tz", "hess", "phi", "address", "roth", "bos", "nz", "budget", "cash", "ses", "las", "ozo", "ssl", "hei", "zen", "inos", "dylib", " sands", "zero", "zik", "robe", "liquid", "han", "cos", "zb", "los", "ZA", "zip", "zag", "z", "zar", "forge", "zl", "zy", "zi", "zona", "os", "webkit", "obb", "jas", "fits", "zo", "dos", "zzy", "closure", "ls", "zin", "zon", "zx", "gz", "nox", "bes", "ops", "her", "bitcoin", "outs", "rez", "kos", "ros", "js", "zan", "chini", "zh", "uz", "osi", "packs", "zes", "zn", "asio", "zer"], "fis": [" fIs", "infisa", "fii", "lfis", " fisa", " fils", "sfis", " fris", "lfris", "feiss", "Fris", "infip", "fris", "feis", "Fils", "feires", " fos", "lfiss", "feris", " fires", "fIs", "Fis", " fiss", "flids", "flii", "sfiss", "flris", "fliss", "sfris", "fires", "Fires", "flis", "fos", " fids", " fii", "sfii", "fisa", "Fids", "affip", "fids", "fiss", "lfIs", "FIs", "fils", "infos", " fip", "Fiss", "affos", "infis", "affis", "fip", "flils", "affisa"], "entry": ["extra", "address", "next", "ry", "it", "data", "row", "ui", "ie", "the", " Entry", "lc", "uri", "per", "feed", "and", "pe", "see", "zip", "z", "event", "add", "array", "card", "reader", "zo", "de", "exp", "ge", "style", "comment", "element", "image", "offset", "letter", "io", "archive", "ries", "obj", "her", "term", "or", "ion", "index", "auto", "si", "key", "ticket", "r", "ace", "cel", "config", "Entry", "record", "attribute", "info", "e"], "buffer": ["number", "queue", "address", "length", "uffer", "data", "flush", "texture", "reference", "wave", "document", "FFER", "feed", "slice", "layer", "server", "iter", "buff", "buf", "writer", "binary", "available", "value", "window", "base", "array", "vector", "shape", "page", "transfer", "reader", "header", "seed", "beta", "Buffer", "batch", "channel", "b", "bytes", "result", "memory", "cache", "padding", "default", "null", "sequence"], "readed": ["Readned", "cedned", "loaden", "readen", "cededs", "lexed", "cedED", "runed", "runered", "lexen", " readled", "loadered", " readeds", "readned", "Readed", "keyned", " readED", "readeds", "Readen", "Readled", " readen", "keyeds", " readped", "loadped", "readped", "keyed", "lexled", "runped", "runen", "loaded", "keyED", "ceded", "readered", " readned", " readered", "readled", "readED", "lexned"]}}
{"id1": "9796161", "id2": "11049257", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "label": 1, "substitutes": {"s": ["styles", "ends", "S", "comments", "f", "cs", "a", "data", "g", "ses", "lines", "ssl", "string", "sb", "i", "es", "source", "abs", " returns", "str", "parts", "ds", "is", "input", "ings", "its", " fails", "scripts", "bs", "p", "os", "v", "tests", "in", "ns", "als", "gs", "ls", "ates", "ms", "self", "sets", "services", "ws", "bytes", "b", "c", "ips", "rs", "l", "ss", "ps", " signs", "ts", "n", "js", "si", "sym", "strings", "ows", "e"], "m": ["gm", "man", "cm", "nm", "f", "um", "d", "sm", "hm", "pm", "vm", "i", "em", "im", "mu", "e", "ym", "mm", "am", "p", "bm", "mand", "M", "mt", "manager", "ms", "rm", "arm", "module", "wm", "dm", "machine", "md", "c", "o", "om", "tm", "l", "me", "mac", "mi", "mc", "h", "mr", "fm"]}}
{"id1": "1586662", "id2": "20414923", "code1": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "code2": "    protected int deleteBitstreamInfo(int id, Connection conn) {\n        PreparedStatement stmt = null;\n        int numDeleted = 0;\n        try {\n            stmt = conn.prepareStatement(DELETE_BITSTREAM_INFO);\n            stmt.setInt(1, id);\n            numDeleted = stmt.executeUpdate();\n            if (numDeleted > 1) {\n                conn.rollback();\n                throw new IllegalStateException(\"Too many rows deleted! Number of rows deleted: \" + numDeleted + \" only one row should be deleted for bitstream id \" + id);\n            }\n        } catch (SQLException e) {\n            LOG.error(\"Problem deleting bitstream. \" + e.getMessage(), e);\n            throw new RuntimeException(\"Problem deleting bitstream. \" + e.getMessage(), e);\n        } finally {\n            cleanup(stmt);\n        }\n        return numDeleted;\n    }\n", "label": 1, "substitutes": {"bid": ["wid", "bas", "ud", "bh", "rb", "hid", "ref", "bb", "ad", "received", "ast", "bi", "aud", "mad", "oid", "vid", "mid", "bc", "sha", "bed", "abi", "ban", "lay", "du", "aba", "base", "bf", "bm", "rid", "cb", "uid", "bn", "bon", "ed", "seed", "chid", "bt", "paid", "batch", "year", "pid", "b", "sid", "ld", "bit", "la", "auth", "id"], "tid": [" tiden", "pbase", "timbid", "TID", "Tide", "trids", "ptinfo", "Tbid", "piden", "ptid", "trid", "tide", " taid", "pids", "tids", "Tids", "pinfo", "taid", "ptiden", "pide", "trbid", " tids", "Tid", "tbase", "timids", "tbid", "tiden", " tbase", "paid", " tinfo", "trID", "pid", "ptaid", "Tbase", " tide", "timid", "timID", "tinfo", "tID"], "aid": ["ga", "idd", "pa", "ca", "man", "bas", "delay", "d", "a", "anc", "ding", "ad", "acid", "ast", "au", "aud", "alias", "said", "mad", "da", "oid", "ays", "aed", "ase", "sha", "ased", "aned", "lan", "added", "du", "lay", "cas", "dd", "ai", "aida", "ady", "ab", "ed", "na", "az", "sat", "paid", "sd", "order", "ay", "sid", "ada", "aa", "Aid", "af", "ac", "ia", "ara", "aim", "lied", "auth", "id"], "delta": ["dota", "D_", "D\n", "edDelta", "DDelta", "data", "Delt", "edelta", "ndetime", "ddDelta", " d_", "Delta", "lelt", "dada", "dta", "adDelta", "ddelt", "sdelta", "sdata", "ndata", "lelta", "ldelta", "Dada", " d\n", "lota", " dota", "adota", "adada", "ldelt", "edetime", "sdetime", " dDelta", " delt", "Dota", "detime", "ndelta", "ndta", "lada", "adelt", "edta", "d_", "dDelta", "sdelt", " dada", "ldDelta", "ldota", "ndelt", "ndDelta", "delt", "ndota", "ddota", "ddelta", "d\n", "sdDelta", "adelta", "sdota", "sdta"], "aBalance": ["abalance", "aaAmount", " aBal", "aHalf", "bBalance", "sabalance", "aaHalf", "pWeight", "aabalance", "saCost", "aCredit", "aAmount", "eaBalance", "eaCost", "aBal", "aCost", " aCredit", "aaBalance", "bCredit", "bHalf", " aWeight", "pBalance", " aHalf", "eabalance", " aAmount", " abalance", "aWeight", "eaBal", "saBal", "aaWeight", " aCost", "aaCredit", "pCredit", "bAmount", "saBalance", "pbalance"], "RS": ["RW", "AR", "CL", "Res", "OS", "Ms", "Vs", "MS", "RI", "BS", "Rs", "RT", "PS", "NRS", "MR", "RC", "SW", "RO", "TS", "DS", "JS", "RP", "OSS", "VR", "RN", "KS", "CS", "RM", "POST", "JR", "IR", "RB", "FS", "VS", "SH", "US", "CD", "SS", "IS", "LS", "RD", "DR", "RL", "RE", "LL", "TR", "KR", "MC", "rs", "HS", "RR", "SR", "GR"], "Stmt": ["Stau", " Stpr", " Sttm", "Cmn", "stgr", "Stmb", " StMT", "stp", "stpr", "Stpr", "Sttm", "stmb", "stMT", "Firstmt", "STMT", "StTr", "STp", " stmt", " Stmn", "Cau", "Strmt", "Lmt", " Stau", "StrMT", "Cmp", "Strau", "Lmp", "STmn", " Stbl", " Stut", " Stp", "Stut", "stmt", "Stmn", "STTr", "Firsttm", "Cmt", "Stbl", "sttm", "STmt", " Stmb", "StMT", "CMT", "Stgr", "STbl", "LMT", "Firstmb", " stMT", "Cut", "Firstpr", "stbl", "STut", " stgr", "Stp", "stmp", "Strmp", " stmp", " Stmp", "Stmp", "Lgr", " StTr", "stTr"], "Query": ["Connection", "Comment", "Check", " query", "Time", "Style", "Statement", "Rule", "ERY", "Init", "Format", "Display", "Document", "Test", "Cache", "Method", "Route", "Service", "Row", "Filter", "URI", "File", "Report", "Key", "Factory", "Form", "query", "Info", "QL", "Common", "Code", "Exp", "Function", "SQL", "Table", "Array", "Driver", "Condition", "Do", "Update", "Join", "Msg", "Stage", "Raw", "Option", "Script", "Error", "This", "Line", "Flow", "Scan", "Module", "Model", "Qu", "Body", "Conn", "Str", "Range", "Db", "Q", "Url", "Command", "Server", "Source", "Fixed", "Force", "Database", "Request", "Previous"], "res": ["rest", "Res", "Gr", "re", "gr", "resh", "PS", "Ret", "Resp", "Cons", "Response", "ES", "rem", "rows", "Results", "ras", "Resources", "results", "ches", "obj", "reg", "RE", "vals", "RES", "runs", "resp", "lets", "js"]}}
{"id1": "6271502", "id2": "18570190", "code1": "    @Override\n    public InputStream getResourceByClassName(String className) {\n        URL url = resourceFetcher.getResource(\"/fisce_scripts/\" + className + \".class\");\n        if (url == null) {\n            return null;\n        } else {\n            try {\n                return url.openStream();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n    }\n", "code2": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"className": ["ClassName", "instanceName", "scriptname", "classPart", "ClassPart", "instancename", "CLASSNames", "CLASSname", "CLASSName", "scriptCode", "classCode", "instancePart", "ClassNames", " classNames", " classCode", "classNames", "CLASSCode", " classname", "classname", " classPart", "scriptNames", "Classname", "instanceNames", "scriptName"], "url": ["loader", "plug", "address", "f", "bel", "data", "ref", "rel", "uri", "bb", "service", "ssl", "string", "source", "resource", "xml", "web", "path", "feed", "resources", "server", "http", "zip", "sl", "org", "lib", "el", "URL", "class", "blog", "base", "orb", "event", "file", "page", "impl", "ls", "www", "location", "io", "element", "buffer", "name", "job", "b", "lr", "instance", "l", "Url", "log", "loc", "api", "r", "rl", "ob", "config", "object", "e"]}}
{"id1": "62362", "id2": "3767903", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"src": ["inst", "ctx", "filename", "st", "rb", "feat", "ref", "uri", "gb", "ssl", "sb", "source", "string", "resource", "upload", "prot", "Dest", "path", "sin", "RC", "slice", "tmp", "buf", "sth", "input", "sl", "supp", "dist", "username", "secure", "load", "req", "fp", "url", "file", "sc", "reader", "impl", "img", "cb", "gz", "spec", "href", "s", "cpp", "storage", "gn", "vr", "name", "code", "obj", "sit", "sel", "rc", "proc", "download", "stream", "component", "cmp", "dep", "Source", "loc", "fn", "rl", "SourceFile", "ource", "config", "sec", "back", "sn"], "dest": ["target", "orig", "home", "source", "wb", "Dest", "dc", "path", "di", "tmp", "lib", " destination", "class", "dist", "cont", "txt", "temp", "img", "bin", "std", "dir", "obj", "disk", "fn", " dst", "null", "dat"], "in": ["inf", "f", "d", "a", "data", "isin", "inn", "source", "i", "t", "is", "input", "inas", "din", "file", "reader", "ins", "bin", "err", "io", "up", "as", "doc", "win", "ps", "In", "stream", "n", "pass", "inc", "IN", "ini", "r", "ex", "val", "login", "pin"], "p": ["pa", "pb", "pd", "f", "d", "pg", "g", "lp", "pm", "i", "per", "pc", "pe", "t", "h", "pp", "pr", "cp", "pi", "op", "fp", "v", "wp", "bp", "part", "sp", "cop", "m", "s", "py", "o", "pre", "c", "np", "b", "po", "j", "l", "ps", "jp", "parser", "tp", "P", "e"], "ds": ["docs", "d", "uds", "dt", "lp", " db", "ays", "hs", "ads", " DS", "ded", "scripts", "des", "ils", "icks", "ants", "qs", "dm", "vals", "dates", "ld", "sys", "dat", "posts", "ks", "styles", "ans", "pd", "cs", "sync", "data", "words", "points", "dp", "bs", "dd", "gs", "cdn", "Ds", "ups", "rs", "ps", "js", " dd", "sts", "cons", "tools", "els", "lines", "db", "DS", "di", "dist", "amps", "os", "tests", "vs", "dos", "ins", "ls", " sd", "s", "ws", "xs", "ts", "plugins", " props", " ps", "eps", "obs", "gd", "da", "dc", "parts", "dds", "ys", "utils", "nas", "ns", "ss", "df", "models", "dl"], "format": ["filter", "f", "filename", "prefix", "template", "feat", "data", "Format", "plugin", "version", "string", "source", "form", "xml", "path", "handler", "host", "t", "layout", "atter", "class", "tag", "scale", "function", "sche", "fp", "file", "url", "fd", "part", "type", "act", "spec", "style", "letter", "unit", "table", "language", "name", "struct", "ant", "pattern", "nat", "at", "frame", "parser", "fn", "api", "config", "magic", "record", "object", "model", "match"], "hasPixelData": ["hasPictureData", "hasPicOps", "haspixelStyle", " hasPixeldata", "hasBytedata", "hasPicStyle", "hasPixelDATA", "hasPictureDATA", "haspixelData", " hasPixelOps", "hasPixeldata", "hasPixelStyle", "haspixelOps", "hasPicData", "hasByteData", " hasPixelSize", "haspixelSize", "hasPicturedata", "hasPixelSize", "haspixelDATA", "haspixeldata", "hasPixelOps", " hasPixelStyle", " hasPixelDATA", "hasByteSize"], "inflate": [" inflATE", "infloocate", "uninflocate", "infloase", "uninfloute", "uninfloate", "information", "informATE", "incollate", "infloATE", "inflation", "infolute", " information", "infolame", "incollame", "inFlase", "incollocate", "inFlate", "informate", "infloate", "influte", "inflase", "incollute", "uninfloame", "inFlation", "uninflute", "infolate", "informase", "inflame", "infolocate", "infloation", " informase", "uninfloocate", " informate", "infloame", "infloute", "inflocate", "uninflame", " inflation", "inFlATE", " inflase", "inflATE", " informATE", "uninflate"], "pxlen": ["nplin", "pyln", "pxlf", "fxlen", "pngden", "xyfin", "pyden", "pxden", "fxden", "rxfin", "xplength", "xplen", "fxval", "pglf", "xylen", "pyl", "xpval", "cpden", "fxlf", "pxlin", "pxLen", "rxlen", "pylen", "pngln", "pplen", "fxl", "cpln", "pngLen", "rxlin", "nplen", "npden", "xyden", "fxlength", "ppden", "pxval", "pxfin", "pxl", "ppln", "npfin", "rxden", "xyLen", "xylin", "fxln", "pxlength", "xplf", "pxln", "pglen", "cplen", "pnglen", "cpl", "xyln", "ppLen", "pglength", "pgval"], "out": ["session", "dump", "prefix", "OUT", "re", "user", "point", "output", "line", "server", "cli", "lib", "list", "group", "parent", "store", "lock", "Out", "base", "v", "conn", "error", "page", "gen", "err", "inter", "io", "code", "up", "obj", "step", "print", "outs", "work", "cache", "log", "post", "copy", "sys", "again"]}}
{"id1": "293167", "id2": "8166767", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public Object invoke(MethodInvocation invocation, int retryTimes) throws Throwable {\n        retryTimes--;\n        try {\n            String url = getServiceUrl() + \"/\" + invocation.getMethod().getName();\n            HttpPost postMethod = new HttpPost(url);\n            if (invocation.getMethod().getParameterTypes().length > 0) postMethod.setEntity(new StringEntity(JsonUtils.toJson(invocation.getArguments())));\n            HttpResponse rsp = HttpClientUtils.getDefaultInstance().execute(postMethod);\n            StatusLine sl = rsp.getStatusLine();\n            if (sl.getStatusCode() >= 300) {\n                throw new RuntimeException(\"Did not receive successful HTTP response: status code = \" + sl.getStatusCode() + \", status message = [\" + sl.getReasonPhrase() + \"]\");\n            }\n            HttpEntity entity = rsp.getEntity();\n            StringBuilder sb = new StringBuilder();\n            InputStream is = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"utf-8\"));\n            String line;\n            while ((line = reader.readLine()) != null) sb.append(line).append(\"\\n\");\n            reader.close();\n            is.close();\n            String responseBody = null;\n            if (sb.length() > 0) {\n                sb.deleteCharAt(sb.length() - 1);\n                responseBody = sb.toString();\n            }\n            Type t = invocation.getMethod().getGenericReturnType();\n            if (t.equals(Void.class) || responseBody == null) return null;\n            return JsonUtils.fromJson(responseBody, t);\n        } catch (ConnectTimeoutException e) {\n            if (retryTimes < 0) throw e;\n            if (urlFromDiscovery) {\n                String serviceUrl = discoverServiceUrl(getServiceInterface().getName());\n                if (!serviceUrl.equals(getServiceUrl())) {\n                    setServiceUrl(serviceUrl);\n                    log.info(\"relocate service url:\" + serviceUrl);\n                }\n            }\n            return invoke(invocation, retryTimes);\n        }\n    }\n", "label": 1, "substitutes": {"view": ["session", "gu", "f", "can", "template", "ui", "row", "port", "user", "check", "request", "section", "form", "container", "VIEW", "review", "im", "views", "server", "http", "see", "layout", "el", "input", "by", "this", "list", "group", "window", "html", "base", "lock", "block", "event", "query", "head", "page", "v", "full", "reader", "ou", "screen", "manager", "widget", "box", "style", "View", "buffer", "image", "display", "change", "self", "edit", "up", "update", "client", "vol", "sel", "link", "show", "index", "cache", "body", "config", "out", "object", "model", "use", "vis", "e", "cell"], "url": ["loader", "address", "f", "length", "data", "socket", "uri", "jar", "ssl", "string", "source", "resource", "web", "builder", "path", "host", "server", "http", "hub", "fb", "sl", "zip", "URL", "blog", "base", "file", "page", "www", "gl", "location", "connection", "buffer", "image", "open", "name", "client", "channel", "job", "b", "email", "browser", "download", "l", "link", "stream", "Url", "log", "position", "ob", "config", "ul", "id"], "in": ["data", "isin", "socket", "inn", "source", "resource", "con", "sin", "on", "is", "input", "arin", "init", "din", "file", "lin", "reader", "rin", "ins", "inner", "s", "buffer", "bis", "b", "as", "doc", "win", "In", "stream", "cin", "inc", "ac", "IN", "nin", "ini", "login", "out", "again", "pin"], "bin": ["loader", "an", "gin", "nb", "socket", "bb", "ruby", "inn", "bi", "source", "con", "sin", "is", "input", "lib", "binary", "init", "abi", "ban", "kin", "lock", "din", "file", "lin", "reader", "bot", "connection", "bn", "inner", "buffer", "b", "inside", "fin", "browser", "win", "cache", "cin", "run", "IN", "body", "ini", "record", "spin", "out", "login", "oin", "pin"], "line": ["cl", "column", "data", "row", "lines", "user", "service", "parse", "string", "lc", "section", "end", "LINE", "str", "id", "nl", "entry", "pe", "ine", "el", "lf", "text", "base", "block", "file", "page", "lin", "inline", "part", "type", "ge", "comment", "letter", "range", "unit", "ip", "name", "Line", "code", "job", "up", "look", "b", "le", "l", "link", "definition", "log", "key", "val", "word", "out", "status", "pin", "e", "cell"], "version": ["cover", "install", "video", "filename", "bug", "plugin", "patch", "format", "string", "section", "id", "server", "vision", "option", "project", "username", "vert", "value", "license", "v", "type", "product", "dev", "secret", "unit", "image", "beta", "Version", "name", "update", "info", "versions", "code", "VERSION", "release", "download", "description", "feature", "python", "position", "driver", "null", "model", "date", "pull", "ver"], "build": ["install", "help", "length", "bug", "Build", "hold", "patch", "follow", "rel", "push", "row", "home", "builder", "built", "valid", "make", "label", "where", "tag", "lock", "base", "load", "block", "add", "boot", "building", "style", "comment", "unit", "image", "name", "update", "info", "job", "print", "release", "how", "work", "run", "log", "test", "clean", "use", "uild", "show", "pull", "ver"]}}
{"id1": "9109613", "id2": "4164833", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"from_name": ["fromFullName", " from_image", "from_Name", "fromFullalias", "from__Name", " from_Name", " from_word", "fromameno", " from_resource", "fromqfilename", " from_alias", " from_key", "from__address", "from_key", "from_time", "fromThespace", "from_image", "from_filename", " from__Name", " from__alias", "fromqname", "fromFullname", " from_size", "fromamename", "from__name", "from_size", " from__name", " from_no", "fromqpath", "from_address", "fromTheName", " from_filename", "from_word", "fromThename", "fromameName", "from_resource", " from_path", " from_time", "from__alias", "fromTheword", "fromqName", "from_no", "fromametime", " from_space", " from_address", "from_space", "from_path", "from_alias", "fromFulladdress", " from__address"], "to_name": ["to_key", "To_common", "To_name", "from_Name", "to_common", "to_path", "tokName", "to_file", " to_key", " to_file", "tokcommon", "from_names", "from_path", "To_Name", "to_names", "to_Name", "tokname"], "fromFile": ["fromLine", "fromFactory", "fromLibrary", "FromPage", "FromFunction", "ofFolder", "connectionPackage", "onePage", "onefile", "oneFolder", "fromFunction", "FromDir", " fromDir", "oneModel", " fromDirectory", "autoFolder", "FromLibrary", "autoFile", "ofFile", "fromPackage", " fromPage", "oneDir", "sourceLibrary", "fromDir", "fromModel", " fromModel", "fromDirectory", " fromPackage", "ofPackage", "fromFiles", " fromLibrary", "Fromfile", " fromFactory", "connectionFile", "sourcePage", "connectionfile", "fromPage", "toFunction", " fromFunction", "asFactory", "autofile", "fromFolder", "autoPage", "offile", "toFiles", " fromfile", "oneFile", "FromModel", " fromFolder", "FromDirectory", "FromLine", "toFactory", " fromFiles", "toLine", "tofile", "connectionFolder", "FromFile", "sourceFile", "asfile", "FromFolder", "FromFiles", "sourceDirectory", "asFile", "asFiles", "oneFunction", "fromfile", " fromLine"], "toFile": ["fromLine", "cofile", " toPage", "ofTable", "ToPage", " toFactory", "ofFile", "aFiles", "fromDirectory", "ofDir", "targetPlace", " toSourceFile", "baseFile", "noLibrary", " toTable", "targetSourceFile", "targetFactory", "basefile", "ToSourceFile", "TODir", "ToLine", " tofile", "coFile", "tempFactory", "TOPlace", "toSourceFile", "toDir", "baseTable", "toFolder", "ToFiles", "fromFiles", "aFile", "ToPlace", "targetfile", "offile", "nofile", "toPage", "toLibrary", " toDir", "baseDir", "toTable", "ToLibrary", "coFunction", "sofile", "Tofile", "soLibrary", "ToFunction", "soPage", " toDirectory", "toFunction", "fromPage", "ToFile", "tempfile", "noFile", "targetFolder", "noPage", " toFiles", " toLine", "tempFolder", "tempFile", "TOFile", "ToDir", "ToDirectory", "toPlace", "soFile", "toDirectory", "toFiles", " toFunction", "coDirectory", "afile", "targetFile", "targetPage", "targetDir", "toFactory", "toLine", "tofile", "aDir", " toFolder", "TOPage", "ToFactory", "fromDir", "fromfile"], "parent": ["pa", "lc", "path", "server", "pe", "class", "root", "large", "shape", "url", "full", "type", "current", "inc", "pool", "out", "address", "parents", "data", "g", "home", "source", "guard", "pr", "search", "par", "file", "exp", "connection", "owner", "region", "paren", "test", "pt", "key", "complete", "col", "id", "any", "patch", "content", "string", "resource", "div", "rule", "and", "line", "option", "Parent", "part", "directory", "manager", "client", "or", "ac", "api", "master", "session", "child", "port", "point", "user", "section", "remote", "valid", "p", "page", "location", "ip", "name", "term", "loc", "null"], "dir": ["ir", "f", "d", "cat", "dr", "wd", "rel", "home", "container", "per", "path", "dc", "DIR", "director", "db", "dec", "div", "di", "attr", "dis", "iter", "lib", "class", "group", "dist", "rec", "folder", "lock", "root", "block", "url", "file", "die", "fd", "keep", "directory", "manager", "exp", "dev", "name", "Dir", "mod", "build", "or", "doc", "dep", "dict", "inc", "cur", "loc", "def", "r", "out", "coll", "col", "ver"], "from": ["cm", "who", "left", "user", "low", "parse", "source", "form", "empty", "per", "con", "cr", "with", "fr", "without", "by", "ce", "this", "ra", "when", "flo", "base", "can", "ou", "add", "query", "file", "conn", "in", "url", "se", "part", "bean", "normal", "de", "one", "connection", "From", "get", "range", "self", "io", "module", "hand", "name", "vol", "client", "channel", "o", "c", "old", "po", "or", "link", "component", "stream", "start", "auto", "wh", "view", "ch", "api", "clean", "so", "out", "e"], "to": ["target", "will", "To", "sync", "port", "source", "no", "proxy", "go", "eto", "token", "output", "on", "db", "plus", "with", "http", "see", "fb", "two", "top", "by", "flo", "pi", "store", "base", "op", "again", "too", "file", "office", "page", "co", "type", "one", "connection", "io", "tom", "name", "about", "o", "b", "until", "su", "po", "or", "not", "size", "cache", "auto", "tto", "api", "fat", "so", "via", "copy", "out", "object", "TO", "be", "ver"], "buffer": ["number", "queue", "border", "address", "length", "uffer", "data", "flush", "reference", "row", "texture", "string", "resource", "document", "feed", "layer", "server", "read", "character", "iter", "buff", "buf", "duration", "binary", "total", "available", "value", "block", "vector", "shape", "page", "variable", "transfer", "reader", "table", "comment", "header", "seed", "device", "Buffer", "batch", "channel", "bytes", "result", "memory", "cache", "position", "padding", "default", "null", "message"], "bytes_read": ["classes_available", "classesavview", "bytes___available", "bytes___READ", "bytes___view", "bytesESSreceived", "bytesESSput", "lines_received", "bytes_available", "lines_written", "bytesESSwritten", "bytes_received", "bytesavavailable", " bytes_written", "bytesavREAD", "bytesavread", "lines_read", "classes_read", "bytes_view", "bytesayread", "bytesayput", "lines_put", "classesavavailable", " bytes_write", "bytes_write", "bytesaywritten", "bytesavview", "bytes_load", "bytes_put", "classes_view", "bytes_READ", " bytes_load", "bytes_written", "bytesayreceived", "classesavREAD", "bytes___read", "classes_READ", "classesavread", "bytesESSread"]}}
{"id1": "20623709", "id2": "2324868", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 1, "substitutes": {"targetDirectory": [" targetRoot", "targetRoot", "TargetDirectory", "destDirectory", "outputFile", "currentPath", "outputFolder", "TargetCollection", " targetFolder", " targetPath", "destFile", "TargetPath", "TargetDir", "TargetRoot", "contentCollection", "basePath", "TargetFile", "currentDirectory", "currentDir", " targetFile", "baseFile", "baseFolder", "outputDirectory", "contentDir", "targetPath", "TargetFolder", "contentPath", "baseCollection", "targetFile", "baseDirectory", "destFolder", "targetDir", "contentDirectory", "targetFolder", "currentRoot", "targetCollection", "outputDir", "destDir", "baseDir", " targetDir", "currentFolder"], "prefix": ["number", "queue", "filename", "template", "patch", "format", " suffix", "uri", "string", "domain", "prot", "resource", "path", "username", "folder", "base", "root", "txt", "processor", "fp", "ix", "first", "temp", "timeout", "type", "directory", "FIX", "Pref", "offset", "unit", "name", "pre", "pattern", "resolution", "cache", "append", "padding", "config", "index", "fix", "sequence"], "maxUnitBases": ["maxunitBasks", "maxUnitPlaches", "maxUnitPlase", "maxunitAliasing", "maxUnitMaches", "maxUnitMases", "maxunitBases", "maxUnitChase", "maxUnitBasing", "maxunitAliasks", "maxUnitAliaches", "maxunitAliases", "maxunitBasing", "maxUnitMase", "maxUnitChasing", "maxunitBaches", "maxUnitBase", "maxunitAliase", "maxUnitPlases", "maxUnitAliases", "maxunitBase", "maxunitAliaches", "maxUnitPlasing", "maxUnitMasing", "maxUnitAliasing", "maxUnitChases", "maxUnitAliasks", "maxUnitAliase", "maxUnitChasks", "maxUnitBasks", "maxUnitBaches"], "maxUnitEntries": ["maxunitEntrys", "maxUnitEntryrs", "maxUnitEntents", "maxUnitIntrys", "maxunitEntryrys", "maxUnitEntryry", "maxUnitCountrs", "maxUnitEntrs", "maxUnitCountries", "maxUnitEntry", "maxunitEntryries", "maxunitCountry", "maxunitEntrs", "maxunitCountries", "maxUnitSequrys", "maxUnitCountrys", "maxunitCountrys", "maxunitEntry", "maxUnitEntrys", "maxUnitentries", "maxUnitEntryures", "maxunitEntryies", "maxUnitentrs", "maxUnitEntryies", "maxUnitEntryrys", "maxunitEnties", "maxUnitCountures", "maxUnitEntryries", "maxUnitSequies", "maxUnitSequents", "maxUnitCountry", "maxUnitIntries", "maxUnitEntryents", "maxUnitEnties", "maxUnitentrys", "maxUnitSequries", "maxunitCountrs", "maxUnitInties", "maxunitEntents", "maxUnitentry", "maxUnitEntures", "maxunitEntryents", "maxunitEntries", "maxUnitIntents"], "fis": ["affai", "cci", "fii", " fai", " fisa", "bos", " fris", "fai", "Fris", "fris", "cisa", "bai", "Fis", "cris", " fii", "fisa", "bis", "affii", "bii", "affos", "cis", "affis", "Fisa", "Fci"], "fci": ["ofco", "Foci", "fii", "frco", "sfcy", "fai", "ofcf", "lfco", "lcy", "sfai", "sfci", "Fco", "fcf", "frni", "lci", "ofci", "ofni", "Fai", "lfii", "lai", " fii", "lco", " foci", " fni", "foci", "frci", "sfco", "lfoci", "lfci", "frcf", "fcy", "Fii", "fni", "Fcy", "Fci", " fcf"], "fos": ["Fos", "fOS", "infoss", "infOS", "xos", " fo", "xOS", "Fis", " fcos", " foss", "Foss", "foss", "eo", "fo", "ecos", "eos", "infos", "xo", "infis", "fcos", " fOS", "xcos", "eOS", "FOS"], "fco": ["cci", "lcos", "gcos", "fcon", "fscon", " foc", "fico", "foc", "fsco", "lro", " fcon", "fsci", "fro", " fcos", "lci", "hco", "gci", "gco", "hico", "coc", "lco", "fscos", " fro", "hci", "cro", " fico", "cco", "hcos", "fcos", "lico", "loc", "gcon"], "buffer": ["number", "loader", "queue", "border", "bar", "expression", "length", "uffer", "data", "port", "reference", "flush", "texture", "counter", "request", "wave", "resource", "document", "feed", "zero", "layer", "capacity", "response", "server", "bc", "entry", "holder", "iter", "buff", "buf", "pause", "input", "writer", "binary", "scale", "base", "rate", "vector", "transfer", "reader", "translation", "timeout", "bin", "comment", "offset", "header", "image", "device", "Buffer", "batch", "channel", "callback", "result", "cube", "size", "memory", "cache", "view", "position", "null", "copy", "info", "message"], "currentBasesCount": ["currentBasingCounter", "currentBasingcount", "currentChaseCounter", "currentBancesCount", "currentBasescount", "currentBancesCounter", "currentBaseCount", "currentBasingCount", "currentBasesCounter", "currentBancescount", "currentChaseCount", "currentChasecount", "currentBasecount", "currentBaseCounter", "currentChasescount", "currentChasesCounter", "currentChasesCount"], "currentEntriesCount": ["currentEntriesSize", "currentAddoriesSize", "currentAddriesLimit", "currentAddriesCount", "currentEntirsSize", "currentEntmissionsSize", "currentEntoriesAmount", "currentEntriesAmount", "currentEntmissionsAmount", "currentEntriesLimit", "currentAddoriesCount", "currentAddriesSize", "currentEntirsAmount", "currentEntoriesSize", "currentEntirsLimit", "currentEntmissionsCount", "currentAddoriesLimit", "currentEntirsCount", "currentAddoriesAmount", "currentEntoriesCount", "currentEntmissionsLimit", "currentEntoriesLimit", "currentAddriesAmount"], "targetCount": ["argetcount", "parentCount", "Targetcount", "TargetCount", "parentSize", "TargetSize", "parentcount", "targetcount", "targetSize", "argetSize", "argetCount"], "fastaChannel": ["fastasConnection", "fastaChan", "fastanaTexture", " fastAConnection", " fastaChan", "fastaTexture", "fastAChan", "fastATexture", " fastaContainer", "fastABuffer", "fastasContainer", " fastATexture", " fastAContainer", "fastasChannel", "fastanaContainer", " fastaConnection", " fastAChan", "fastasChan", "fastasBuffer", "fastanaBuffer", "fastaConnection", "fastAConnection", "fastaiConnection", "fastaContainer", "fastaiChan", "fastasTexture", "fastanaChannel", "fastAContainer", "fastAChannel", "fastaiBuffer", " fastAChannel", "fastaiChannel", " fastaTexture", " fastABuffer"], "totalSeqCount": ["totalSeqsSize", "totalSeqSize", "totalSequeNum", "totalSeqNum", "totalSequeCounter", "totalSeQCount", "totalSeqsNum", "totalSeQNum", "totalSequeCount", "totalSeqCounter", "totalSeQSize", "totalSeqsCount", "totalSeqsCounter", "totalSeQCounter", "totalSequeSize"], "totalResiduesCount": ["totalResinuesCount", "totalResiduescount", "totalResinuesCounter", "totalResiduecount", "totalResiduingCount", "totalResiduesCode", "totalResiduingCode", "totalResinuescount", "totalResiduumcount", "totalResidueCode", "totalResinuecount", "totalResinueCounter", "totalResinueCode", "totalResiduingcount", "totalResiduumCode", "totalResidueCounter", "totalResiduumCount", "totalResiduesCounter", "totalResinuesCode", "totalResiduingCounter", "totalResidueCount", "totalResiduumCounter", "totalResinueCount"], "prevTime": ["viousCount", "trainTIME", "viousTime", "prevCounter", "viousCounter", "trainCount", "prevTIME", "trainCounter", " prevCount", " prevTIME", " prevCounter", "trainTime", "viousTIME", "prevCount"], "fastaFileSize": ["fastaHeaderName", "fastAFileLength", "fastaBufferSize", "fastAFileStore", "fastasFileAddress", "fastaFilesLength", "fastasHeaderName", "fastasFileName", "fastaBufferCount", "fastABufferCount", "fastaFilesAddress", "fastasFileSize", "fastaHeaderLength", "fastaFileName", "fastABufferStore", "fastaStreamName", "fastasHeaderLength", "fastaFilesName", "fastABufferSize", "fastaFileLength", "fastaFileStore", "fastAFileSize", "fastaBodyLength", "fastasHeaderSize", "fastaLineLength", "fastaHeaderSize", "fastaStreamAddress", "fastaStreamLength", "fastAFileCount", "fastaBodyStore", "fastasHeaderAddress", "fastaStreamSize", "fastaFileCount", "fastaFilesSize", "fastABufferLength", "fastaBodySize", "fastaFileAddress", "fastasFileLength", "fastaLineCount", "fastaLineStore", "fastaBufferStore", "fastaBodyCount", "fastaBufferLength", "fastaHeaderAddress", "fastaLineSize"], "fastaFileReadOffset": ["fastaBufferWriteoffset", "fastaFileReadLocation", "fastaFileWritePosition", "fastaFilereadOffset", "fastaFilereadPosition", "fastaFileReadLength", "fastaFileReadOff", "fastaBufferWriteLength", "fastaFilesWriteLength", "fastaFileLoadPosition", "fastaFilesReadLength", "fastaFileReadPosition", "fastaFileWriteStart", "fastaFilereadLocation", "fastaFileWriteoffset", "fastaFileLengthoffset", "fastaFileWriteLength", "fastaBufferReadoffset", "fastaFileReaderoffset", "fastaFileLengthStart", "fastaBufferWriteStart", "fastaFilesReadOffset", "fastaBufferReadPosition", "fastaFileReaderStart", "fastaFilesWriteLocation", "fastaFilesReadLocation", "fastaFileReadoffset", "fastaFileLengthLength", "fastaBufferReadOffset", "fastaBufferreadoffset", "fastaFileLoadOffset", "fastaFileReadStart", "fastaFilesWriteOffset", "fastaFileWriteOffset", "fastaFileLengthOff", "fastaBufferreadOffset", "fastaFilereadOff", "fastaFileReaderLength", "fastaBufferreadOff", "fastaBufferReadStart", "fastaFilereadoffset", "fastaBufferWriteOffset", "fastaFileWriteLocation", "fastaFileWriteOff", "fastaFileLengthLocation", "fastaBufferreadPosition", "fastaFileLoadOff", "fastaFileLoadoffset", "fastaFileLengthOffset", "fastaFilereadLength", "fastaBufferReadOff", "fastaFileReaderOffset", "fastaBufferReadLength", "fastaFilesWriteOff", "fastaFilesReadOff"], "partitionStartOffset": ["partitionStartOff", "partitionsEndAlias", "partitionsStartSlot", "partitionsStartOffset", "partitionStartSlot", "partitionRunAlias", "partitionParamOff", "partitionStartAlias", "partitionsEndOffset", "partitionParamAlias", "partitionParamOffset", "partitionEndAlias", "partitionsStartAlias", "partitionsEndSlot", "partitionEndSlot", "partitionsStartOff", "partitionRunOff", "partitionEndOff", "partitionParamSlot", "partitionsEndOff", "partitionRunOffset", "partitionRunSlot"], "bufferSize": ["queueSize", " bufferMode", " buffersize", "bufferSIZE", "queueCount", " bufferLen", "BufferCount", "bufsize", "queueLength", "buffersize", "bufferLen", "sourceMode", " bufferLength", "BufferSize", "sourceSize", "sourceSIZE", "bufSize", "bufferMode", " bufferSIZE", "bufMode", "BufferLen", "bufferCount", " bufferCount", "BufferLength", "queueLen", "sourcesize", "bufferLength", "bufSIZE"], "fastaBuffer": [" fastABuff", "FastaBuffer", " fastasStream", "fastfBuff", "fastasQueue", "fastABuff", "Fastasbuffer", " fastaStream", "fastyBuff", "fastanQueue", "fastAPtr", "fastAbuffer", " fastasChannel", "fastABuffer", "FastanQueue", "fastasStream", "Fastabuffer", "fastaBuff", "fastaFile", " fastasBuffer", " fastaFile", "FastaQueue", "fastasbuffer", "FastanFile", "fastasChannel", "FastanChannel", "FastasChannel", "FastanBuffer", "FastaFile", "fastyChannel", "fastanFile", "fastasFile", "fastasBuffer", "fastanBuffer", "fastaPtr", "FastaChannel", "fastasPtr", "fastAStream", "fastybuffer", "fastasBuff", "fastanStream", "fastfPtr", "fastaStream", "fastAChannel", "FastasBuff", "FastasPtr", " fastaBuff", " fastAFile", "fastfChannel", " fastAChannel", "fastfBuffer", "fastAQueue", "fastanChannel", "fastyBuffer", "fastaQueue", "fastabuffer", "fastanBuff", "FastaBuff", " fastasFile", "FastasBuffer", "fastAFile", "FastaPtr", " fastABuffer"], "fastaReadState": ["fastaFileState", "fastaReaderState", "fastaReaderMode", "fastasReadType", "fastaReadingstate", "fastaReadMode", "fastasReadMode", "fastaFileMode", "fastaFileType", "fastasReaderState", "fastaReaderType", "fastaReadType", "fastasReaderType", "fastaFilestate", "fastasReadState", "fastaReadingState", "fastaReadingType", "fastaReadstate", "fastasReaderstate", "fastaReadingMode", "fastaReaderstate", "fastasReadstate", "fastasReaderMode"], "nBytes": ["NParts", "ninBytes", "iBytes", "NBytes", "nFiles", "Nbytes", "nBlocks", "nPages", "ibytes", "ninByte", " nByte", "NBlocks", " nPages", "numBytes", "cParts", "cPages", "numbytes", " nBlocks", "cbytes", " nbytes", " nParts", "nbytes", "numFiles", "ninBlocks", " nFiles", "NByte", "ninParts", "iBlocks", "iFiles", "numBlocks", "nByte", "cBytes", "nParts", "NPages"]}}
{"id1": "18891988", "id2": "15445861", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"serviceName": ["ServiceName", "ServiceUrl", " servicePath", "servicename", "ServicePath", "servicePath", "packagename", "Servicename", "packagePath", "packageName", "serviceUrl", " servicename", " serviceUrl", "packageUrl"], "wsdlLocation": ["awsdlDirectory", "wsllFolder", "wslUrl", "wddlAddress", "wslpLocation", "wdlFolder", "wdlDirectory", "wssdFolder", "awsdlUrl", "wslFile", "wslpAddress", "wssdFile", "wslLocation", "wdlLocation", "wsdlDirectory", "wddlDirectory", "wdlAddress", "wsllDirectory", "wssdLocation", "wddlFile", "wsdlFolder", "wslAddress", "wsdlFile", "wslFolder", "wddlLocation", "wsDLDirectory", "wslDirectory", "awsdlLocation", "awslUrl", "wsllAddress", "wssdDirectory", "awsdlFile", "wslpDirectory", "wsdlUrl", "wsllLocation", "wdlFile", "wsdlAddress", "wddlFolder", "awslFile", "wsDLLocation", "wsllUrl", "wsDLFile", "awslDirectory", "wsllFile", "wslpFile", "wsDLUrl", "awslLocation"], "endpoint": ["enpoints", "ENDpoints", "enport", "gepoint", "ENDination", "enination", " endolution", "enPoint", " endPoint", " endport", "endaddress", "geport", "enpoint", "Endolution", "endsolution", " endaddress", "geaddress", "Endword", "endination", " endocol", "ENDpoint", " endword", "endocol", "Endpoint", "Endination", "endpoints", "endport", "endsocol", "gePoint", "endword", "endPoint", "endsword", "enaddress", "endspoint", "ENDPoint", "EndPoint", "Endocol", "Endpoints", "endolution"], "fileLocation": ["fileName", " fileName", "FileName", " filelocation", "Filelocation", "resourcelocation", "resourceLoc", "resourceLocation", "FileLoc", "resourceName", "fileLoc", "FileLocation", "filelocation", " fileLoc"], "tempDir": [" tempFile", "tempFile", "tempJar", "TempDir", "TempPath", "tmpPath", " tempDirectory", " tempJar", "tempDirectory", "tmpDir", "Tempdir", "tmpDirectory", "tempPath", "TempFile", " tempPath", "tmpJar", "tempdir", "TempJar", " tempdir", "TempDirectory", "tmpdir"], "url": ["plug", "address", "f", "bug", "socket", "uri", "bb", "service", "ssl", "string", "git", "source", "web", "path", "host", "server", "http", "ur", "zip", "sl", "URL", "base", "file", "conn", "ls", "www", "gl", "connection", "io", "image", "open", "client", "channel", "l", "ll", "link", "stream", "Url", "download", "log", "config", "fl", "coll", "pull"], "WSDLFile": ["WINDlFile", "WSDDLfile", "WSDLPath", "WINDLUrl", "WSDDLFiles", "WSDELFolder", "WSDLSourceFile", "WSDELFile", "WSDLLFolder", "WSDLFolder", "WDDLFolder", "WDDLFiles", "WDDlPath", "WSDlFile", "WSDELfile", "WINDlUrl", "WSDDLFile", "WSDlPath", "WSDELFiles", "WINDLFile", "WSDlUrl", "WINDLSourceFile", "WSDLLPath", "WDDLFile", "WDDDLPath", "WDDLPath", "WDDDLFolder", "WSDLUrl", "WSDDLSourceFile", "WSDELSourceFile", "WDDDLFile", "WSDELUrl", "WSDDLFolder", "WSDLLFile", "WSDlfile", "WINDlSourceFile", "WDDDLFiles", "WSDLLFiles", "WSDlFiles", "WINDlfile", "WSDlFolder", "WSDLFiles", "WDDlFile", "WSDlSourceFile", "WSDLfile", "WSDDLUrl", "WSDELPath", "WDDlFolder", "WINDLfile", "WDDlFiles", "WSDDLPath"], "tmpWSDLFile": ["tmpWSDSLFile", "tmpWDDELFiles", "tmpWSDLUrl", "tmpWDDLUrl", "tmpWSDLLDir", "tmpWSDELFiles", "tmpWSDLLFile", "tmpWSDSLPath", "tmpWDDLDir", "tmpWSDSLDir", "tmpWSDlDir", "tmpWSDLDir", "tmpWDDELPath", "tmpWSDLFolder", "tmpWSDLLFolder", "tmpWSDELPath", "tmpWDDELFolder", "tmpWDDLFolder", "tmpWDDlUrl", "tmpWDDLFile", "tmpWSDLLFiles", "tmpWSDLFiles", "tmpWDDlPath", "tmpWSDLLUrl", "tmpWSDlFiles", "tmpWSDlFolder", "tmpWDDlFile", "tmpWSDELFile", "tmpWSDSLUrl", "tmpWDDlDir", "tmpWDDLFiles", "tmpWSDLPath", "tmpWSDlFile", "tmpWSDELFolder", "tmpWSDLLPath", "tmpWDDELFile", "tmpWDDLPath", "tmpWSDlPath", "tmpWSDlUrl"], "inputFile": ["tempPlace", "tempFolder", "tempStream", "tempFile", "inputLine", "InputPlace", "outputFile", "outputFiles", "InputDir", "outputfile", "alphafile", "inputFactory", "inputSourceFile", "InputLine", "InputSourceFile", "inputfile", "InputFile", "inputStream", "inputFolder", "inputPage", " inputFilename", " inputLine", "inputFiles", "outputDirectory", " inputDirectory", "InputPage", "outputPage", "InputStream", "inputPlace", " inputDir", "alphaFile", "InputDirectory", "tempPage", "inputDir", "Inputfile", " inputfile", "alphaFilename", "tempLine", "InputFilename", " inputFolder", "tempfile", "outputStream", " inputFiles", "InputFolder", "outputDir", " inputFactory", "inputFilename", "alphaPlace", " inputSourceFile", " inputPlace", "InputFactory", "tempFactory", "InputFiles", "inputDirectory", "tempSourceFile"], "tmpFile": ["tempPlace", "tmpFiles", "tempFile", "tempStream", " tmpFiles", " tmpFilename", "tempFilename", "tmpSourceFile", "inputSourceFile", " tmpSourceFile", "tempFiles", "empFile", "empPlace", "inputFiles", " tmpStream", "tmpFilename", "tmpStream", "empStream", " tmpPlace", "tmpPlace", "inputFilename", "tempSourceFile", "empFiles"], "in": ["gin", "f", "data", "socket", "inn", "ssl", "source", "plus", "is", "input", "init", "p", "din", "file", "conn", "reader", "impl", "ins", "bin", "m", "connection", "inner", "io", "image", "up", "client", "c", "win", "In", "pass", "inc", "IN", "r", "login", "again", "pin", "id"], "out": ["sync", "OUT", "socket", "remote", "output", "on", "line", "server", "conf", "writer", "group", "parent", "Out", "lock", "can", "error", "file", "co", "conn", "part", "timeout", "bin", "connection", "err", "net", "io", "to", "inner", "image", "name", "up", "client", "channel", "conv", "exec", "outs", "outer", "cache", "inc", "log", "IN", "ch", "copy", "extra", "again"], "con": ["Connection", "cm", "un", "sync", "socket", "cf", "Con", "ssl", "connect", "cn", "conf", "input", "fc", "nc", "rec", "kin", "can", "conn", "file", "plain", "co", "ran", "ins", "connection", "inner", "open", "CON", "client", "channel", "conv", "c", "close", "en", "win", "Conn", "rc", "inc", "IN", "ch", "xc", "uc", "pin"], "fileLength": ["fileSize", "channelLength", "FileLength", "fileLen", "channelWidth", " fileLen", "fileNumber", "FileSize", "FileLen", "channelLen", "fileWidth", "FileWidth", " fileWidth", "channelNumber", "channelSize", " fileNumber", "FileNumber", " fileSize"], "channelIn": ["resourceIN", "resourceOut", "Channelin", " channelin", "containerOut", "ChannelIN", " channelInt", "streamInt", "containerIn", "ChannelOut", "streamOut", "resourceIn", "ChannelIn", "containerin", "containerIN", " channelIN", "resourcein", "ChannelInt", "channelin", "channelInt", "streamIn", "streamin", "channelIN"], "channelOut": ["connectionIn", " channelName", " channelOutput", " channelout", "chanIn", "connectionOut", "chanOut", "ChannelOutside", "ChannelOutput", "fileOut", "ChannelOut", "fileOutput", "chanOutside", "fileIn", "fileout", "Channelout", "ChannelIn", "connectionOutside", "channelName", "channelout", "channelOutside", "chanout", "channelOutput", "connectionout", "connectionName", "ChannelName"], "tmpDocument": ["tabdocument", "tempNode", "tempFile", "tmpDoc", "mpNode", "tmpClient", "mpDocument", "tmpNode", "inputContent", "tempClient", " tmpContent", "mpFile", " tmpdocument", " tmpNode", "tabDoc", "inputClient", "tabNode", "mpDoc", "tempContent", "tempDoc", "inputDocument", "tmpdocument", " tmpClient", "tempdocument", "tempDocument", "tmpContent", " tmpDoc", "tabDocument"], "nl1": ["wlOne", "dl3", "wl1", "ln1", "kl5", "nl2", "nl11", "NL3", "wl5", "dl2", "dl0", "nlOne", "nn11", "dl1", "nl6", "nl3", "jlOne", "nlFirst", "ln11", "nl0", "jl5", "NL0", "ln6", "NL6", "nn1", "ln2", "nn6", "jlFirst", "klOne", "nn0", "nn3", "NL1", "klFirst", "kl1", "wlFirst", "jl1", "nn2", "NL2", "NL11", "nl5"], "i": ["hi", "phi", "f", "d", "it", "ui", "ti", "uri", "ni", "bi", "ci", "gi", "qi", "slice", "mu", "di", "z", "pi", "chi", "v", "ix", "ai", "part", "m", "iu", "yi", "io", "inner", "ip", "ii", "y", "info", "o", "b", "ri", "I", "multi", "fi", "j", "l", "n", "si", "li", "ini", "mi", "oi", "ji", "index", "xi", "eni", "e", "id"], "node1": ["nOne", " nodeone", "shapeOne", "node7", "n0", "NodeOne", "n1", " node7", "node2", "entityFirst", "neOne", "sourceFirst", "shape7", "entityone", "nodeOne", "node0", "entityOne", "source1", " node0", "sourceone", "node81", "ne1", "Node2", " node2", "shape81", "entity1", "Node0", "shape1", " node81", " nodeFirst", "ne7", "nodeFirst", "Node1", "n2", " nodeOne", "nodeone", "sourceOne", "ne81"], "tmpOut": ["partout", "tempFile", "tempWriter", "tempOUT", "partOUT", "tmpout", "tmpOUT", "pmOut", "mpOut", "tmpIn", "mpIn", "tempIn", "pmOutput", "tempout", "mpFile", "bbOut", "tempOut", "pmOUT", "bbOutput", " tmpOUT", "partIn", "mpWriter", "pmWriter", "bbout", "tempOutput", "partOut", " tmpWriter", " tmpIn", " tmpOutput", " tmpout", "tmpWriter", "tmpOutput", "bbIn"], "retVal": ["New", "data", "xml", "path", "http", "Service", "this", "URL", "Socket", "s", "_", "HTTP", "Url", "Address"]}}
{"id1": "18504192", "id2": "411595", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"in": ["d", "data", "src", "inn", "i", "diff", "input", "parent", "base", "min", "file", "url", "reader", "part", "ins", "bin", "m", "inner", "io", "image", "buffer", "name", "c", "old", "b", "or", "In", "at", "inc", "ac", "IN", "ini", "copy", "index", "again", "info", "login", "id"], "out": ["target", "prefix", "OUT", "data", "point", "string", "output", "line", "password", "writer", "dest", "again", "Out", "base", "p", "file", "conn", "part", "w", "temp", "err", "connection", "call", "io", "name", "obj", "client", "o", "c", "b", "outs", "exec", "external", "n", "cache", "inc", "ex", "copy", "object"], "source": ["target", "sync", "core", "src", "ie", "service", "ssl", "from", "i", "origin", "sin", "ources", "SOURCE", "slice", "server", "iter", "sl", "project", "input", "writer", "dest", "parent", "secure", "se", "reader", "scope", "connection", "slave", "get", "unit", "self", "storage", "channel", "clone", "client", "settings", "component", "size", "stream", "start", "view", "Source", "ource", "copy", "use", "proxy", "null"], "destination": ["dependination", "contining", "Destinator", "Destinations", " destining", " destinations", "testinations", "destinations", "declination", "destinated", "Destination", "testinated", "dependinated", "Destinated", "declification", "testination", "dependinator", "declinator", "Destining", "continator", "dependification", "Destification", "declinated", "contination", "destification", "testinator", "destinator", " destinator", "destining", "continated", " destinated"]}}
{"id1": "8973505", "id2": "15810440", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"uriFile": ["URIfile", "sourceStream", "URIFiles", "uiFiles", "URIStream", "uiFile", "urifile", "uriFiles", "riFile", "uiSourceFile", "uifile", "sourceFiles", "URIFile", "uriSourceFile", "riSourceFile", "URISourceFile", "riStream", "uriStream", "riFiles", "sourceFile", "sourcefile", "rifile"], "outputfile": ["outputfiles", "OutputFile", "unitf", "outputFile", "Outputdir", "unitstring", "inputf", "Outputfile", "outputstring", "inputdir", "inputfile", "Outputfull", "inputfiles", "outputf", "Outputstring", "outputdir", "Outputf", "inputstring", "Outputfiles", "inputfull", "unitfile", " outputfull", "outputfull", "inputFile", " outputFile", "unitfiles", " outputdir"], "num": ["number", "common", "nu", "umi", "length", "nb", "no", "span", "con", "zero", "limit", "initial", "len", "Num", "nam", "NUM", "amount", "dim", "offset", "unit", "name", "batch", "coord", "multi", "mult", "term", "sum", "n", "inc", "loop", "count", "index", "col", "master"], "writer": ["loader", "walker", "ler", "server", "entry", "value", "root", "wr", "w", "er", "writers", "unit", "buffer", "header", "element", "written", "external", "index", "out", "writing", "e", "wan", "sync", "data", "socket", "service", "source", "riter", "file", "Writer", "method", "worker", "connection", "io", "ee", "write", "width", "journal", "driver", "key", "report", "r", "writ", "word", "author", "rw", "wave", "builder", "wb", "document", "output", "handler", "layer", "book", "office", "part", "temp", "manager", "later", "ws", "outer", "wt", "object", "master", "message", "session", "wrapper", "format", "feed", "wa", "wire", "editor", "window", "lock", "page", "widget", "engine", "inner", "style", "wl", "null"], "uri": ["nil", "prefix", "ori", "token", "server", "http", "URI", "pi", "href", "unit", "element", "link", "feature", "uni", "address", "plugin", "ui", "source", "qi", "oid", "binary", "du", "sheet", "context", "folder", "base", "file", "verb", "uid", "connection", "iri", "component", "li", "direction", "metadata", "id", "reference", "string", "i", "resource", "gi", "document", "handler", "di", "database", "winner", " URI", "directory", "collection", "doi", "ri", "or", "description", "node", "eni", "message", "umi", "filename", "remote", "cli", "username", "query", "location", "range", "nor", "route", "multi", "term", "picture", "mi", "attribute", "theme", "sequence"], "counter": ["number", "loader", "expression", "reference", "runner", "time", "lc", "i", "handler", "second", "server", "entry", "Counter", "iter", "trace", "currency", "book", "parent", "repeat", "creator", "processor", "vector", "page", "ter", "inter", "thread", "comment", "inner", "offset", "buffer", "collection", "name", "coll", "batch", "info", "clock", "step", "c", "result", "keeper", "timer", "instance", "cube", "outer", "current", "ctr", "loop", "parser", "nr", "controller", "computer", "stop", "count", "ner", "record", "index", "continue", "pointer", "enter", "master", "cookie", "race", "ver"], "reader": ["loader", "ir", "bird", "rr", "row", "ruby", "ler", "per", "feed", "handler", "layer", "read", "editor", "riter", "iter", "e", "reading", "in", "rer", "er", "worker", "finder", "io", "inner", "rar", "buffer", "keeper", "ri", "lr", "l", "stream", "ger", "parser", "rx", "driver", "r", "upper", "ner", "Reader", "oder"], "url": ["address", "plugin", "user", "ssl", "string", "web", "resource", "ler", "xml", "path", "server", "http", "ur", "facebook", "sl", "URL", "base", "file", "page", "ls", "www", "connection", "image", "open", "client", "channel", "ri", "browser", "link", "l", "stream", "Url", "li", "config", "id"], "myConnection": ["MyConnector", "myConn", "yourConn", "yourconnection", "MyReader", "MyConn", "myconnection", " myConnector", "yourReader", "MyConnection", "yourConnection", " myConn", "Myconnection", "yourConnector", " myconnection", "myConnector"], "myReader": ["yourRead", "myWriter", "Myreader", "bodyreader", "myRead", "myreader", " myWriter", "MyRead", "MyWriter", "yourReader", "MyReader", "bodyReader", "bodyRead", "myParser", "bodyWriter", "MyParser", " myParser", " myreader", " myRead", "yourWriter", "yourParser"], "line": ["cl", "column", "data", "row", "lines", "user", "point", "parse", "string", "source", "lc", "no", "end", "feed", "rule", "LINE", "str", "response", "entry", "message", "pe", "el", "cell", "lf", "liner", "note", "text", "day", "block", "error", "page", "file", "lin", "part", "inline", "ge", "comment", "letter", "range", "header", "style", "element", "name", "Line", "ri", "le", "link", "l", "non", "pass", "definition", "log", "frame", "key", "rl", "r", "val", "word", "use", "id"], "linecount": ["pagecache", "linesize", "Linecount", "Linelength", "Linecache", "Linecode", "linkcache", "LineCount", "pagecount", " lineCount", "linkcount", " linesize", "pagelength", "pagesize", " linecode", "linecode", "linelength", "lineCount", " linecache", " linelength", "pagecode", "linecache", "linkCount", "pageCount", "Linesize", "linklength"], "hasOWL": [" hasEWLM", "hasEWLM", "showsOWDL", "hasEWDL", "showsOWL", "hasSWLM", "hasODLM", "hasODLL", "hasEWLA", "hasODLS", "hasODLA", "hasOWLL", "hasAWDL", "hasOWSLA", "hasAWLA", "hsODL", "hsODLL", "hasOWDL", "hasEWLL", "hsOWL", "hasODL", "hasOWSL", " hasEWLA", "hasSWLA", "showsAWLL", "hasEWL", "hasOWLM", "hasAWL", "hsOWLA", " hasOWLM", "hsODLA", "hasOWSDL", "hsOWLS", "showsAWL", "hasSWL", "hasEWLS", "hasAWLL", "showsOWLL", " hasEWL", "hsOWLL", " hasEWLL", "showsAWDL", " hasOWLA", "hasOWLS", "hasOWLA", "showsOWLA", "hasOWSLL", "hasSWLL", "showsAWLA", " hasOWLL", "hsODLS"], "hasRDFS": ["hasCDFNS", "hasXDFS", "hasCDPSE", "hasRdfs", "hasRFDSS", "hasRAFU", "hasDFDU", "hasRFDN", "hasCDFS", "hasDDFS", "hasRDFSS", "hasRDPS", "hasRDFSE", "hasDFDN", "hasROWS", "hasRFDU", "hasRdfSS", "hasROWs", "hasRIFS", "hasCDPs", "hasRUFS", "hasRdfS", "hasCDFSE", "hasRUFNS", "hasRDPSS", "hasRDPs", "hasRAFS", "hasXDPU", "hasRFDS", "hasRIFN", "hasDDFN", "hasRDFNS", "hasXDPS", "hasCDFs", "hasRUFSE", "hasRIFU", "hasRDFN", "hasXDFU", "hasDFDS", "hasRFDs", "hasXDPs", "hasRDPU", "hasROWNS", "hasXDFSS", "hasXDPSS", "hasRDFs", "hasROWSE", "hasRDPSE", "hasDDFU", "hasRDPNS", "hasRAFN", "hasRdfU", "hasCDPS", "hasCDPNS", "hasRUFs", "hasXDFs", "hasRDFU"], "hasRDF": ["usesRLP", "hasURLP", "hasROW", "hasGRFD", " hasRDEF", "hasRRFD", "hasRGDF", "hasRGTF", " hasSROW", "hasCRTF", "hasRDEF", "hasRRDEF", "hasURDF", "HasRRFD", "hasSRDEF", "hasCROW", "hasRRDP", "hasGRDF", " hasSRDEF", "hasUDS", "hasSRDF", "hasRGOW", "hasRDP", " hasSRTF", " hasRTF", "usesRDF", "HasRDF", "hasURDP", "hasRTF", " hasROW", "hasUDF", "usesRDS", "HasRRDEF", "hasCRDEF", "HasRRDP", "hasRDS", "usesRDP", "hasSRTF", "hasURDS", "hasRGDEF", "HasRDEF", "HasRFD", "hasSRFD", "hasCRDF", "hasGRDP", "hasULP", "hasRRDF", "hasGRDEF", "hasSROW", "hasUDP", " hasSRDF", "hasRFD", "hasSRDP", "HasRRDF", "hasRLP", "HasRDP"]}}
{"id1": "13783898", "id2": "22536033", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"infile": ["inputfp", "Infiles", "inputfilename", "infilename", " infilename", " infiles", "outfp", "inputfile", "inputfiles", "inFile", "infp", "Infile", "Infilename", "infiles", " infp", "InFile", "inputFile", "outFile", "outfilename", "outfiles"], "outfile": ["Outfile", "outputfilename", " outfolder", "infilename", " outfp", "outputfile", "OutFile", "outfp", "infolder", "newFile", " outFile", "infp", " outfilename", "outfolder", "newfolder", " outname", "outputfp", "Outname", "Outfolder", "outputfolder", "outFile", "outname", "outfilename", "newfile", "newname"], "in": ["gin", "vin", "a", "re", "data", "isin", "socket", "inn", "source", "i", "thin", "ic", "con", "sin", "is", "input", "init", "inas", "base", "min", "din", "conn", "reader", "rin", "ins", "bin", "m", "into", "err", "inner", "s", "image", "b", "inside", "as", "win", "In", "pass", "cin", "inc", "ac", "IN", "nin", "ini", "r", "login", "again", "pin", "id"], "out": ["session", "sync", "OUT", "socket", "point", "home", "no", "source", "output", "exit", "on", "off", "line", "lib", "writer", "parent", "Out", "base", "ou", "error", "file", "conn", "co", "timeout", "bin", "one", "err", "net", "io", "to", "inner", "image", "name", "up", "client", "job", "o", "obj", "outs", "exec", "write", "or", "outer", "In", "work", "cache", "inc", "post", "ex", "copy", "again"], "buffer": ["queue", "border", "address", "length", "uffer", "data", "flush", "reference", "bb", "source", "wave", "feed", "slice", "layer", "server", "limit", "iter", "buff", "buf", "fb", "input", "binary", "len", "value", "base", "raw", "transfer", "url", "reader", "type", "offset", "seed", "Buffer", "batch", "bytes", "b", "write", "result", "size", "cache", "split", "count", "padding", "null"], "read": ["lex", " write", "f", "length", "x", "sync", "allow", "next", " copy", "find", "ad", "check", "parse", "i", "Read", "connect", "send", "end", "feed", "tell", "slice", "ind", "limit", "iter", "input", "wait", "len", " Read", "reading", "load", "add", "raw", "sleep", "reader", "select", "play", "se", "fill", "seek", "io", "get", "ride", "READ", "ip", "_", " count", "write", "exec", "close", "size", "reads", "start", "work", "n", "pass", "run", "inc", "current", "count", "copy", "use", " skip", "id"], "success": ["primary", "growth", "construct", "better", "data", "content", "follow", "fast", "flash", " succ", "successful", "status", "cess", "path", "rolling", "response", "valid", "model", "rolled", "initial", "fail", " successful", "value", "modified", "failed", "ccess", "roll", "func", "respons", "winner", "error", "first", "true", "method", "danger", "comment", " succeed", "results", "warning", "open", "done", "right", " Success", "ceed", "result", "successfully", "good", "Success", "pass", "xx", "complete", "continue", "default", "again", "null", "message"]}}
{"id1": "4531653", "id2": "18046717", "code1": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    private String getFullClassName(URL url, String className) throws Exception {\n        JarInputStream jis = new JarInputStream(url.openStream());\n        ZipEntry zentry = null;\n        while ((zentry = jis.getNextEntry()) != null) {\n            String name = zentry.getName();\n            int lastPos = name.lastIndexOf(\".class\");\n            if (lastPos < 0) {\n                continue;\n            }\n            name = name.replace('/', '.');\n            int pos = -1;\n            if (className != null) {\n                pos = name.indexOf(className);\n                if (pos >= 0 && name.length() == pos + className.length() + 6) {\n                    jis.close();\n                    return (name.substring(0, lastPos));\n                }\n            }\n        }\n        jis.close();\n        return (null);\n    }\n", "label": 0, "substitutes": {"data": ["address", "a", "template", "content", "format", "script", "alpha", "string", "hex", "source", "output", "pad", "str", "sha", "input", "this", "text", "base", "database", "in", "method", "buffer", "image", "media", "name", "code", "bytes", "ata", "cache", "DATA", "key", "body", "api", "dat", "message"], "md": ["material", "nm", "pd", "d", "sm", "wd", "ad", "pm", "gd", "amd", "db", "editor", "ds", "di", "grad", "meta", "mm", "od", "MD", "dd", "mand", "ma", "mt", "m", " MD", "bd", "dig", "mb", "rod", "mg", "dm", "code", "cd", "cmd", "docker", "mod", "hd", "mac", "mag", "mp", "mc", "mo", "metadata"]}}
{"id1": "9236363", "id2": "23370621", "code1": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"jarPath": ["JarName", "JarUrl", "relUrl", " jarpath", " jarCase", "jarFile", "jarLog", "narDrive", " jarDir", " jarLog", "jamPath", "narName", "javaName", "JarCase", "relEntry", "javaContent", "javaFile", "jarUrl", "JarPath", " jarDrive", "relFile", "javaEntry", "jamDir", "jarContent", "garpath", "JarEntry", "javaUrl", "garLog", "jarCase", "javapath", "jarDir", "javaLog", "garPath", "jarName", "jarDrive", "bareFile", " jarContent", "JarDrive", "Jarpath", "JarLog", "barepath", " jarFile", "javaPath", "garContent", "jamFile", "barePath", "jamLog", "JarFile", "javaDir", "bareCase", "narpath", "narPath", "jarpath", "garFile", " jarName"], "jarEntryStart": ["jarFileStart", "jarEnterStart", "javaInfoStart", " jarEntrystart", "javaInfoEnd", " jarImportstart", "jarEntryEnd", "jarentryEnd", "jarImportEnd", "jarImportStart", " jarEntryStr", "javaEntryEntry", " jarEntryPart", "jarentryPart", " jarentryStr", "javaEntryPart", "jarReaderstart", "jarImportPart", " jarEntrySt", "javaInfoEntry", "jarFileEntry", "jarEntryPart", "jarEnterStr", "jarentrySt", "jarEntryStr", " jarentrySt", "jarReaderStart", "jarInfoPart", "jarFileStr", "jarInfoBase", "jarFileBase", "jarEntrystart", " jarImportStart", "jarEnterSt", " jarentryPart", "jarFileEnd", " jarImportEnd", "jarReaderPart", "jarEnterPart", "jarentryStr", "javaEntryStart", "jarEntryEntry", "javaInfoPart", "javaEntryEnd", "jarImportstart", " jarentryStart", "jarFileSt", "jarInfoEntry", "jarEntryBase", "javaInfoBase", "jarFilestart", "jarReaderEnd", "jarInfoStart", "jarFilePart", " jarImportPart", " jarEntryEnd", "javaEntryBase", "jarEntrySt", "jarentryStart", "jarInfoEnd", "jarentryBase"], "path": ["prefix", "uri", "request", "host", "reason", "then", "cross", "root", "url", "full", "Path", "type", "right", "code", "ion", "config", "next", "template", "data", "left", "home", "context", "folder", "base", "file", "conn", "walk", "method", "boot", "archive", "mode", "ph", "pass", "log", "test", "key", "col", "id", "ath", "ctx", "PATH", "patch", "content", "wd", "string", "output", "plus", "zip", "this", "text", "part", "ith", "temp", "prop", "mount", "dir", "pattern", "work", "cache", "clean", "object", "system", "graph", "parent", "lock", "p", "error", "location", "style", "image", "name", "route", "step", "skip", "loc"], "relPath": ["relath", "relUrl", "realPath", "RelUrl", "RelPath", "relativeName", " relName", "realUrl", "realpath", " relath", "relKey", "realKey", "relativeath", "relativepath", "relName", " relpath", " relUrl", " relKey", "relpath", "Relath", "RelName", "relativePath", "Relpath", "RelKey"], "jar": ["session", "bar", "pod", " job", "serv", "plugin", "dr", "tar", "parse", "ssl", "xml", "gi", "ler", "sr", "slice", "server", "war", " module", "zip", "sl", "binary", "zone", "sheet", "folder", "pkg", " java", "gap", "jo", " zip", "url", "file", "sp", "er", "drop", "java", "ge", "ar", "rar", "module", "open", "archive", "keeper", "job", "dir", "space", "her", "pack", "j", "browser", "pipe", "tab", "ger", "cur", "log", "Jar", "mag", "ser", "spin", "bag", "ball", "band"], "entries": ["intries", "Entries", "enures", "antents", "stries", "attry", "enry", "enlements", "infers", "itries", "entents", "inflements", "enders", "antlements", "incries", "endries", "antries", "endories", "entarts", "entories", "starts", "addries", "incures", "adders", "intry", "itories", "entryarts", "enries", "Entlements", "infories", "intlements", "entryers", "iters", "entlements", "enters", "attlements", "endlements", "attures", "attries", "infries", "antry", "itlements", "intents", "addarts", "entures", "sters", "inclements", "Entents", "Entry", "incry", "entryries"], "entry": ["ry", "it", "je", "cat", "ie", "parse", " Entry", "resource", "ler", "ent", "zip", "ce", "jo", "add", "file", "url", "in", "se", "reader", "ge", "mer", "element", "rar", "name", "ries", "obj", "lie", "keeper", "le", "pack", "or", "key", "r", "ace", "cel", "record", "Entry", "enter", "be", "la", "e"], "jarEntry": ["garEntry", "dropSection", "jsonEnt", "jarFile", "garEnt", "javaEnt", "jobentry", "varentry", "jsonElement", "jobElement", "varEnt", "javaFile", "zipEnt", "dropEntry", "tarEntry", "javaEntry", "zipInfo", "jobPath", "varElement", "varEntry", "jarSection", "javaElement", "garSection", "dropentry", "garElement", "jsonEntry", "jarentry", " jarInfo", "jarElement", "zipFile", "javaInfo", "jarEnt", " jarFile", " jarEnt", "jarInfo", "tarElement", "jobSection", "javaPath", "dropElement", "jsonPath", "tarEnt", "tarentry", "jobEntry", "zipEntry", "garentry", "jobEnt"], "ze": ["je", "ie", "te", "ja", "zen", "za", "zz", "slice", "pe", "e", "zip", "sl", "ine", "z", "ce", "zi", "jo", " zip", "die", " ele", "se", "zo", "zin", "ke", "ge", "ea", " je", "ee", "code", "ice", "ZE", "ele", "li", "fe", "cel", "sea", "zes", " ce", "be", "zer"], "bin": ["border", "bar", "ba", "vin", "bas", "plugin", "isin", "bb", "src", "inn", "home", "bi", "gi", "sin", "zip", "lib", "binary", "zone", "abi", "ban", "init", "lock", "base", "abin", "fen", "boot", "bot", "addin", "bn", "bon", "io", "inner", "bis", "obin", "pack", "download", "win", "cin", "ini", "spin", "proxy", "buster", "pin", "bank", "bit"]}}
{"id1": "11484416", "id2": "19335986", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "label": 1, "substitutes": {"orig": ["ext", "real", "f", "internal", "bas", "ori", "Orig", "rb", "src", "home", "source", "remote", "origin", "raid", "iter", "tmp", "buf", "comb", "org", "init", "dest", "folder", "raf", "base", "exe", "array", "file", "temp", "impl", "img", "bin", "image", "archive", "coll", "original", "obj", "coord", "old", "prev", "build", "ctr", "imag", "frame", "loc", "transform", "copy", "proxy", "info", "id"], "target": ["join", "next", "f", "it", "platform", "template", "format", "reference", "compatible", "source", "prot", "remote", "resource", "origin", "path", "replace", "t", "tmp", "project", "this", " Target", "dest", "parent", "base", "nt", "eth", "temp", "manager", "to", "force", "archive", "original", "result", "build", "arget", "external", "current", "auto", "ret", "Target", "copy", "object", "master", "match"], "buffer": ["queue", "address", "length", "uffer", "data", "content", "reference", "bb", "request", "source", "wave", "resource", "feed", "slice", "layer", "read", "iter", "buff", "buf", "input", "binary", "repeat", "base", "block", "raw", "transfer", "file", "url", "bin", "stack", "header", "code", "Buffer", "batch", "b", "bytes", "result", "write", "cache", "frame", "position", "padding", "copy", "null", "sequence", "message"], "bread": ["hello", "knife", "length", "circ", "rub", "brew", "four", "fed", "bb", "eb", "inn", "ffe", "web", "div", "feed", "zero", "grain", "robe", "str", "bc", "broken", "fall", "bee", "zip", "abi", "buck", "choice", "ble", "beat", "sleep", "die", "rows", "meal", "fif", "num", "raft", "fee", "fen", "rib", "fine", "bat", "bare", "bn", "cook", "fred", "wen", "batch", "design", "width", "cake", "good", "fle", "loop", "key", "fe", "food", "piece", "wake"], "fis": [" fIs", "lfis", " fisa", " fils", "ufils", "qis", "ufos", "fxis", "qils", "lfiss", "his", "fIs", "afis", " fiss", "afiss", "qos", "lfos", "fxIs", "afos", "hisa", "qiss", "fisa", "ufis", "fxisa", "fiss", "lfIs", "afIs", "fils", "hIs", "hos", "fxos", "ufiss"], "fos": ["Fos", " fose", "infois", "fose", "flors", "fors", "faos", "flose", "flens", "Fis", "flaos", "flos", "Fros", " foses", "Fens", " foss", "Foss", "infors", "Fose", "infaos", "Fors", "fens", "foss", " fens", "goss", "Fois", " fros", "foses", "gos", "flois", "infos", "gros", "floses", "Foses", "fros", "fois", "Faos", "gis"]}}
{"id1": "21821404", "id2": "596993", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    private String makeLoginRequest(URL url) throws IOException {\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setDoInput(true);\n        urlConnection.setDoOutput(true);\n        urlConnection.setUseCaches(false);\n        urlConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        StringBuilder content = new StringBuilder();\n        content.append(\"Email=\").append(URLEncoder.encode(EMAIL, \"UTF-8\"));\n        content.append(\"&Passwd=\").append(URLEncoder.encode(PASSWORD, \"UTF-8\"));\n        content.append(\"&service=\").append(URLEncoder.encode(SERVICE, \"UTF-8\"));\n        content.append(\"&source=\").append(URLEncoder.encode(\"Google Base data API\", \"UTF-8\"));\n        OutputStream outputStream = urlConnection.getOutputStream();\n        outputStream.write(content.toString().getBytes(\"UTF-8\"));\n        outputStream.close();\n        int responseCode = urlConnection.getResponseCode();\n        InputStream inputStream;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            inputStream = urlConnection.getInputStream();\n        } else {\n            inputStream = urlConnection.getErrorStream();\n        }\n        return toString(inputStream);\n    }\n", "label": 0, "substitutes": {"urlObj": [" urlInst", "strobj", "urlPart", "urlobj", "urlInst", "UrlObject", " urlPart", "resourceobj", "strObj", "blogobj", "strObject", " urlExt", "URLExt", "urlObject", "UrlObj", "blogObj", "URLObject", "resourceExt", "resourcePart", " urlobj", "blogInst", "UrlPart", "blogObject", "resourceObj", "URLObj", "Urlobj", "URLobj", "resourceObject", "urlExt", " urlObject", "strInst"], "is": ["ish", "rest", "nis", "lis", "any", "ris", "x", "it", "ui", "isin", "you", "iss", "iris", "isl", "ius", "abs", "ie", "i", "es", "ais", "does", "ise", "ois", "http", "us", "its", "by", "problem", "isa", "os", "est", "al", "in", "iso", "ai", "be", "ins", "ar", "io", "s", "ip", "bis", "cms", "IS", "mis", "ios", "ops", "ri", "as", "was", "or", "irc", "Is", "isc", "isp", "stream", "ps", "isi", "r", "out", "info", "il", "fs", "sis", "id"], "reader": ["loader", "bird", "x", "rr", "row", "cher", "ro", "i", "Reader", "ler", "director", "handler", "layer", "server", "read", "editor", "iter", "writer", "actor", "reading", "in", "rer", "er", "worker", "io", "inner", "buffer", "rar", "ri", "or", "l", "rc", "stream", "parser", "driver", "report", "r", "ser", "ner", "h", "e", "oder"], "line": ["cl", "f", "data", "row", "lines", "user", "strip", "string", "source", "lc", "section", "LINE", "str", "cr", "entry", "character", "ine", "el", "cell", "sl", "lf", " inline", "text", "value", "block", "url", "page", "file", "lin", "part", "inline", "err", "connection", "char", "comment", "buffer", "name", "Line", "code", "cle", "l", "link", "pass", "item", "key", "body", "word", "out", "object", "col", "e", "message"], "content": ["wrapper", "comments", "data", "core", "lines", "string", "source", "section", "resource", "empty", "output", "feed", "const", "str", "response", "server", "text", "value", "html", "cont", "load", "raw", "array", "url", "page", "loading", "css", "java", "connection", "comment", "header", "buffer", "code", "job", "c", "fully", "result", "width", "write", "work", "current", "body", "clean", "report", "Content", "null", "message"]}}
{"id1": "18370075", "id2": "3375724", "code1": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "code2": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"password": ["account", "address", "filename", "data", "words", "Pass", "wd", "user", "string", "source", "token", "path", "pad", "command", "text", "username", "database", "p", "auth", "phrase", "security", "secret", "wallet", "seed", "hash", "name", "email", "pattern", "Password", "pass", "PASS", "key", "crypt", "padding", "login", "word", "config", "sword", "message"], "salt": ["sALT", "ssecret", "sesalt", "palt", "sssecret", " sass", "ssalt", "Ssecret", "Salt", "psecret", " sALT", "sesALT", "SALT", "ssass", "sessecret", "pALT", "pass", "ssALT", "Sass", "sesass", "sass", " ssecret"], "md": ["nm", "pd", "mail", "d", "ad", "pm", "gd", "amd", "mad", "ind", "sha", "kg", "di", "zip", "mn", "meta", "mm", "bf", "MD", "dd", "od", "mand", "ma", "mt", "m", "ms", " MD", "bd", "mb", "dm", "cd", "code", "cmd", "mod", "po", "nd", "ph", "me", "mac", "mag", "clean", "mc", "metadata", "ld", "mo", "message"], "digest": [" digress", "hashester", "dester", " digEST", "digEST", " digested", "digests", "Digested", "dest", "digress", "signest", "generress", "dested", "Digester", "generest", "digester", "signester", "decester", "generester", "signested", " digester", " digests", "decests", "hashcode", "DigEST", "signcode", "decest", "digested", "hashested", "dEST", "generests", " digcode", "hashest", "digcode", "Digest", "decress"]}}
{"id1": "6403868", "id2": "9109613", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"_destPath": ["_srcPath", " _sourceFile", "_dcPath", "_dcLoc", "_targetpath", "_destpath", "_DestDir", " _sourceDirectory", "_sourceDir", "_srcDir", "_destDir", "_targetFile", "_distDir", "_DestPath", " _destDir", "_srcFile", "_dcDir", "_tmpPath", "_DestLoc", "_distPath", "_sourcePath", "_destLoc", " _destFile", "_sourceFile", "_destDirectory", "_dcpath", "_Destpath", "_targetPath", "_DestDirectory", "_destFile", "_sourceDirectory", " _sourcePath", "_distFile", "_tmppath", "_srcDirectory", "_distpath", " _destDirectory", "_tmpDir", "_tmpLoc", "_targetDir", " _sourceDir", "_DestFile"], "upgrade": ["ingrading", "ingrades", "upgrades", "offgrade", "offgrading", "Upgrades", "upgraded", "offgrades", "upge", "offgraded", " upge", "uptge", "Upgrading", "Upge", " upgrades", "Upgrade", " upgrading", "ingraded", "uptgrades", " upgraded", "ingrade", "uptgrade", "uptgrading", "upgrading"], "lastVer": ["LastVER", "lastVersion", "firstVersion", "LastVer", "LastVers", "nextver", "lastVers", " lastVER", " lastver", " lastVersion", "nextVersion", "firstver", "Lastver", "firstVer", "lastVER", " lastVers", "nextVers", "LastVersion", "nextVer", "lastver", "firstVER"], "oldlog": ["oldLOG", "OldLog", " olderror", "newlog", " oldpath", "Oldpath", "newLog", "Oldlog", "oldLog", "oldererror", "oldpath", "newstat", "oldstat", "newpath", "newLOG", "olderLOG", "olderror", "olderlog", "OldLOG", "olderstat", " oldLog", "newerror", " oldstat", "olderLog", " oldLOG"], "destPath": ["Destpath", " destDir", "outputCase", "restPath", "destScript", "outpath", "restDir", "restFile", "homeRoot", "tempPath", "destpath", "restLog", " destP", " destLog", "storepath", "descLog", " destCase", "doneDir", "targetName", "targetRoot", "DestRoot", "homePath", "DestHome", "doneP", " destName", "distDir", "destHome", "storePath", "DestLog", "descDir", "destPoint", "targetpath", "dcPATH", "DestPoint", "descP", " destFile", "outputPath", "outputpath", " destPoint", "temppath", "dcpath", "donePath", "distPoint", "outPath", "DestPath", " destPATH", "destName", "destP", "destRoute", "distpath", "distPath", "homeDir", "descScript", "DestFile", "descpath", "DestRoute", " destScript", "storePATH", "destDir", " destRoute", " destRoot", "destLog", "descFile", "destPATH", "DestPATH", "outputFile", "DestDir", "dcPath", "homepath", "destFile", "destCase", "DestCase", "doneLog", "tempHome", "targetPath", "outPATH", "tempDir", "DestName", "targetFile", "outDir", "targetDir", "descRoute", "descPath", "destRoot", " destHome", " destpath", "tempScript"], "lastVerPath": ["lastVersionPath", " lastVerP", " lastverCh", " lastVersionpath", "lastverP", "lastVersionCh", " lastVersionFile", "lastVERpath", "lastVersFile", "lastVERPath", "lastModCh", " lastModPath", "lastVerCh", "lastVersPath", " lastverFile", " lastverpath", " lastVerCh", "lastverCh", "prevVerpath", "lastVersCh", " lastModpath", "lastVERCh", "prevverName", " lastModP", "lastVersionpath", "lastverName", "lastModName", "lastVerpath", "lastVersionName", " lastVerpath", "prevVerPath", "lastTestpath", "lastTestId", " lastVerFile", "lastTestPath", "prevverFile", "prevverPath", "lastTestFile", "lastVersionId", "lastModpath", "lastVersionFile", "lastverId", "lastVerId", "lastVerName", "lastverpath", "lastVERP", "lastVerspath", "lastVerP", " lastverPath", " lastVersionPath", " lastVerId", "lastModId", "prevverpath", "lastModPath", "lastverPath", " lastVersionId", "prevVerFile", "lastModFile", "lastVerFile", " lastModCh", "lastModP", "lastverFile", "prevVerName"], "bkdir": ["bkfile", " bktdirectory", "bkkpath", "bckpath", "bkdirectory", "bKDir", "bkir", " bktdir", "bkkir", " bakdir", "bkDir", " bkDir", "bakir", "bakDir", "bktdist", "bkgdirectory", " bkkdir", " bakDir", "bakdir", "bkgdir", " bkkir", " bkgdir", " bkpath", " bakdirectory", "bckDir", "bkkdir", "bktfile", "bkgdist", "bKpath", "bckir", "bktdirectory", "bkgfile", "bckdir", "bKdirectory", "bkgDir", "bktDir", "bktpath", " bkfile", " bkgfile", "bKdir", " bkdirectory", " bkkpath", " bktDir", " bkgdist", "bakpath", "bakdirectory", "bckdirectory", "bktdir", " bkgpath", " bkir", " bakpath", " bktpath", "bckdist", "bkpath", "bkgpath", "bkdist", "bckfile", " bkdist"], "oldClassCopied": ["oldClassCopyies", "oldPackageCopified", "oldClasscopies", "oldClassCopies", "oldFilecopying", "oldFileCopies", "oldFilecopies", "oldClassCopyied", "oldclassCopie", "oldclassCopies", "oldFilecopie", "oldclassCopified", "oldClasscopying", "oldPackageCopying", "oldclassCopied", "oldClassCopyie", "oldClassCopyified", "oldFileCopied", "oldPackageCopied", "oldClasscopified", "oldFilecopied", "oldClasscopie", "oldClasscopied", "oldClassCopying", "oldPackageCopies", "oldClassCopified", "oldClassCopyying", "oldClassCopie", "oldFileCopying", "oldFileCopie"], "ls": ["lis", "sels", "cs", "lists", "lines", "lp", "lc", "ln", "lt", "los", "list", "lf", "irs", "lb", "bs", "ils", "ns", "vs", "als", "tl", "files", "bps", "qs", "les", "ii", "iffs", "ches", "LS", "fts", "lr", "igs", "l", "ll", "less", "mails", "wl", "rl", "fl", "lv", "ails", "dl", "ols", "la", "fs"], "i": ["hi", "phi", "f", "x", "d", "it", "ui", "data", "ti", "uri", "lc", "ij", "ci", "gi", "qi", "end", "slice", "ind", "mu", "di", "t", "z", "abi", "pi", "q", "p", "min", "v", "ai", "ix", "u", "m", "iu", "yi", "io", "inner", "ip", "ii", "y", "info", "o", "b", "ri", "I", "c", "fi", "multi", "j", "l", "start", "si", "uli", "li", "val", "mi", "ini", "oi", "index", "ji", "xi", "eni", "e", "id"]}}
{"id1": "12428013", "id2": "4118412", "code1": "    public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) {\n        if (monitor != null && monitor.isCanceled()) {\n            return;\n        }\n        try {\n            ftpClient = new FTPClient();\n            ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST)));\n            ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT));\n            ftpClient.connect();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD)));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (from != null) {\n                FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false);\n                synchedSet.add(ftpHolder);\n            }\n            JobHandler.aquireFTPLock();\n            for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) {\n                if (monitor != null && monitor.isCanceled()) {\n                    JobHandler.releaseFTPLock();\n                    ftpClient.quit();\n                    return;\n                }\n                Thread.yield();\n                FTPHolder element = (FTPHolder) iter.next();\n                ftpClient.setType(FTPTransferType.ASCII);\n                ftpClient.put(element.from, element.to);\n                if (element.renameTo != null) {\n                    try {\n                        ftpClient.delete(element.renameTo);\n                    } catch (Exception e) {\n                    }\n                    ftpClient.rename(element.to, element.renameTo);\n                    log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo);\n                }\n            }\n            JobHandler.releaseFTPLock();\n            ftpClient.quit();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (FTPException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        synchedSet.clear();\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 0, "substitutes": {"monitor": ["number", "loader", "umi", "cm", "annot", "sm", "core", "cher", "runner", "condition", "port", "pm", "counter", "watch", "Monitor", "container", "progress", "handler", "reason", "meter", "duration", "member", "username", "mor", "function", "period", "processor", "conn", "method", "timeout", "directory", "manager", "don", "m", "widget", "thread", "state", "stat", "unit", "image", "module", "dm", "update", "clock", "client", "callback", "mon", "timer", "or", "program", "component", "control", "log", "oper", "controller", "consumer", "report", "mc", "driver", "body", "config", "object", "status", "master", "match", "message"], "from": ["address", "prefix", "who", "left", "user", "uri", "string", "source", "form", "remote", "resource", "origin", "path", "contact", "host", "server", "with", "small", "org", "by", "ce", "actor", "username", "since", "base", "front", "add", "ou", "url", "part", "type", "connection", "owner", "From", "action", "range", "name", "code", "vol", "about", "channel", "route", "email", "or", "component", "size", "start", "at", "loc", "false", "attribute", "back", "id"], "to": ["target", "To", "address", "prefix", "version", "ref", "left", "user", "uri", "site", "source", "remote", "go", "resource", "eto", "token", "server", "with", "two", "top", "by", "repl", "dest", "value", "base", "database", "reply", "url", "file", "full", "type", "location", "into", "connection", "io", "range", "table", "name", "info", "about", "o", "pos", "until", "su", "po", "toc", "size", "key", "so", "out", "TO"], "renameTo": ["renributeTarget", "reameToken", "renewTo", "renameto", "rennameTarget", "renageToken", "renributeTo", " RenAMETo", "reageTo", " RenseFor", "renseOf", "renAMEToken", "rennameFrom", "renAMETarget", "renokeTO", " RenAMEFor", "renributeFor", " RenameTo", "renamFor", "renameFor", " renAMEFrom", " renAMETarget", "reageto", " renameTarget", "relameTo", "renenameTarget", " renameFrom", "renseFor", "renamelOf", "renenameto", " RenameOf", "renokeFor", "relalFrom", "renseTO", "renameTO", "renalTO", "renageTO", "relalTo", "relalTarget", "renamTarget", " RenseTo", "renamelTo", "renamTo", "renameToken", "renameWill", " RenameFor", "renalToken", "renokeTo", "renenameTo", "relenameTo", "renalto", "renewTarget", "renributeWill", "relameTarget", "renamelTO", "renenameUrl", "relenameto", "renAMEUrl", " renAMETo", " RenameWill", "renAMEto", "renAMETo", "renameTarget", "renalFrom", "renamelFor", "renameOf", " RenAMETarget", "rennameto", "renokeFrom", "renamWill", "renalTo", "reameTo", "renoketo", "renseTo", " RenameTO", "renageto", "renAMEFor", "renalTarget", "reageTO", " RenseOf", "reameto", " RenAMEWill", "relenameUrl", " RenameTarget", "relameto", "renageTo", "renAMETO", "reameTO", "relalto", "relameUrl", "rennameTo", "renokeUrl", " RenseTO", "renAMEWill", "renewFrom", "renokeOf", "relameFrom", "renameUrl", "renenameFrom", "renameFrom", "reageToken", "renAMEFrom", "relenameFrom"], "ftpClient": ["ftfpCloud", " ftpControl", "ftapiServer", "aftpClient", "ftpiServer", "ftcpCloud", " ftpiHost", " ftlClient", " ftpCan", "ftmServer", " ftlCommunity", " ftoServer", "ftfCloud", " ftnServer", "fttpClient", " fttpClass", "ftiClient", " ftiGuest", " ftlCenter", "ftiGuest", " ftnClient", "fttpHost", "ftmClient", " ftoHost", "ctcpClient", " ftapiClient", " ftlConnection", " ftpHost", "ftfpChannel", "ftfpCenter", " ftpHelper", "ftfpServer", "ftoServer", "afttStream", "ftpControl", " ftapiServer", "ftbHost", "ftoCan", "ftiServer", "afttClient", "fttpStream", " ftpoClient", " ftpoCenter", "ftfpResource", "ftpoCloud", " ftpChannel", "fttpCan", "ftnHost", " ftiServer", "ftcpHost", "fttpServer", "ftcpGuest", " ftapiCloud", "ftpCenter", " ftpServer", " fticlient", "ftbCan", "ftapiCloud", "aftpStream", "ctpResource", "ctpClient", "ftpStream", "ftpcServer", "fttpClass", "ftpclient", "ftpsClient", "ftbServer", " ftpCloud", "ftpiHost", "ftlClient", "ftcGuest", "ftpcClass", "ftlCenter", "ftfClient", "ftcServer", "ftpcCenter", "ftbrClient", "ftpoCenter", "ctcpResource", "ftpHost", "ftmResource", "ftcClient", "ftcpCommunity", "ctpServer", " ftpGuest", "ftpcConnection", "ftcclient", "ctcpChannel", " fttpControl", "ftpoClient", "ftcpConnection", " ftpiChannel", "ftnClient", " ftpiServer", "ftbClient", "ftapiClient", "ftpsContainer", " ftpCommunity", " ftapiHelper", "ftpcHelper", " ftpContainer", "fttStream", "fticlient", "ftfpClient", " ftiClient", " ftnHost", "ftcpChannel", "ftpcControl", " fttpClient", "ftpsClass", " ftpConnection", "ftpcCommunity", "ftpiClient", "ftcpHelper", "ftfCenter", "ftpContainer", "ftpiChannel", "ctpChannel", " fttpContainer", "ftoHost", "fttpChannel", "ftpServer", "ftpcClient", " ftoClient", "ftlCommunity", "ftoClient", "ftpCommunity", "ftapiHelper", "ftpChannel", "ftpResource", "ftpcCloud", "ftpCloud", "ftpClass", "ftpCan", "ftcpResource", "fttpControl", "ftbrStream", "ftnServer", " ftpclient", "ftpConnection", "ctcpServer", " ftpClass", "ftcpServer", "ftlConnection", "ftpHelper", "ftcpCenter", "ftcpclient", "ftmChannel", " ftpiClient", "ftcpClient", "ftpcContainer", " ftpoCloud", " ftoCan", "fttpContainer", "ftpGuest", "fttClient", "ftpsControl", " ftpCenter"], "ftpHolder": ["fttpChard", "ftpWolder", "fttpHook", "ftphold", "ftpShook", "fttpChander", "ftphather", "ftphander", "ftpHold", "ftpcWold", "ftpChook", "ftpCholder", "ftpWholder", "ftpcHholder", "ftpHook", "fttpChook", "ftphook", "ftpShander", "ftpHander", "ftpWather", "ftphard", "ftpShard", "ftpcWolder", "ftpChard", "fttpHolder", "ftpcHolder", "fttpHard", "ftpHather", "ftpWold", "ftpholder", "fttpHander", "ftpWorkolder", "ftpSholder", "ftpChander", "ftpHholder", "fttpCholder", "ftpWorkholder", "ftpcHold", "ftpcHather", "ftpcWather", "ftpWorkather", "ftpHard", "ftpcWholder", "ftphholder", "ftpWorkold"], "iter": ["walker", "ir", "itter", "next", "f", "it", "ener", "cher", "gener", "i", "former", "end", "http", "entry", "limit", "iterator", "ator", "list", "its", "ite", "iv", "init", "collect", "file", "chain", "in", "reader", "keep", "ipper", "er", "ter", "inter", "err", "izer", "finder", "inner", "ip", "Iterator", "set", "skip", "result", "Iter", "or", "outer", "size", "over", "ver", "inc", "enter", "oper", "loc", "ner", "ser", "index", "coll", "info", "e", "id"], "element": ["number", "et", "per", "token", "server", "entry", "input", "value", "atom", "variable", "er", "type", "header", "e", "cell", "next", "plugin", "data", "Element", "service", "air", "folder", "reader", "connection", "owner", "action", "ee", "optional", "instance", "component", "item", "key", "article", "content", "empty", "resource", "document", "output", "layer", "line", "option", "el", "this", "text", "entity", "part", "comment", "letter", "module", "or", "ele", "node", "activity", "coll", "object", "match", "expression", "child", "section", "container", "editor", "member", "parent", "event", "page", "environment", "style", "inner", "email", "result", "definition", "attribute"]}}
{"id1": "4618237", "id2": "11049257", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "label": 0, "substitutes": {"fin": ["Fin", "pins", "inf", "f", "ris", "ori", "inn", "thin", "ln", "fr", "arin", "init", "fa", "kin", "fp", "din", "lin", "conn", "fd", "file", "rin", "fen", "fine", "FIN", "rt", "nir", "inv", "rf", "fi", "en", "include", "ini", "fat", "fn", "pin", "fm", "raf"], "fout": ["Fin", "Fout", "FOut", " fOut", "rfout", "fint", "fOut", " fint", "boff", "bOut", "bout", "foff", "bin", "rfint", "rfOut", "Fint", " foff", "Foff", "rfin"], "append": ["ext", "leaf", "opp", "save", "push", "flush", "spread", "string", "want", "end", "send", "app", "pad", "password", "apply", "fail", "text", "vert", "add", "only", "protect", "ended", "ending", "future", "remove", "open", "optional", "update", "batch", "atten", "printf", "except", "pack", "pend", "flat", "enc", "adjust", "padding", "null"], "inChannel": ["inputConnection", "outStream", "innerchannel", "INConnection", "innchannel", "inChan", "inputChannel", "loginchannel", "InChan", "loginChannel", "loginStream", " inQueue", "Inchannel", "innerConnection", "inputStream", "outchannel", "outChan", " inStream", "innerStream", "innerChannel", "innChannel", "INQueue", " inchannel", "inConnection", "outQueue", "InStream", "inchannel", "INChannel", "innStream", "INChan", "inputChan", "inStream", "InChannel", "innerChan", "inQueue", "INStream", "INchannel"], "outChannel": ["outStream", "outContext", "outSocket", "OutChan", "ioChannel", "inChan", "OutChannel", "OutContext", "OutStream", "ioChan", "iochannel", "outchannel", "outChan", "inContext", " outContext", "externalSocket", " outchannel", "externalChan", " outChan", "outputSocket", "inchannel", "externalChannel", "outputChannel", "outputchannel", "inSocket", "inStream", "externalchannel", "outputChan", "Outchannel", "ioStream"]}}
{"id1": "4593011", "id2": "20275821", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"stmt": ["tdb", "tmt", "Stor", "esttt", "STor", "actt", "strbl", "strmt", "stmb", "actdb", " stmn", "strmr", "stmn", "rmd", "rdb", "stMT", "Stmr", "estmt", "tmb", " stor", "Stm", "Stmt", "stdb", "STmr", " stmd", " stbl", "tmd", " stt", " sttt", " stm", "stm", "estmd", "Stmn", "actmt", "Stbl", "Stmd", "STmt", "Stt", "strMT", "stmr", "StMT", "Stdb", "stmd", "estm", "Sttt", " stMT", "sttt", "actmn", " stdb", " stmr", "rmt", "STmd", "stbl", "stt", "rmb", "stor", " stmb"], "qry": ["qurys", "questrys", "qrys", "Qri", " qrys", " qrey", "questry", "Qery", "qri", "qrey", "Qry", "quri", "query", "questrey", " qri", "quRY", "qery", "qurey", "questRY", "Qrys", "qRY", " qRY", "qury", " qery"], "q": ["queue", " query", "f", "d", "quest", "request", "i", "qu", "t", "qq", "p", "query", "req", " p", "v", "qt", "select", "u", "k", "m", "qs", " sq", "quant", "requ", "eq", "c", "b", "iq", "sq", "ql", " Q", "qa", "Q", "n", "dq", " req", "ch", "r", "config", "e", "id"]}}
{"id1": "339517", "id2": "4921631", "code1": "    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n        URL url = getClass().getResource(name);\n        InputStream in = url.openStream();\n        try {\n            return ClassFile.read(in);\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 0, "substitutes": {"name": ["loader", "named", "address", "filename", "prefix", "data", "uri", "request", "string", "source", "i", "resource", "path", "str", "class", "this", "parent", "base", "file", "part", "type", "connection", "NAME", "Name", "ame", "size", "pass", "n", "definition", "key", "config", "default", "object", "info", "names", "id"], "url": ["loader", "f", "found", "user", "uri", "service", "ssl", "string", "source", "i", "resource", "feed", "rule", "host", "resources", "server", "http", "sl", "el", "URL", "class", "this", "base", "file", "page", "reader", "ls", "connection", "io", "image", "open", "b", "instance", "l", "ll", "Url", "rl", "r", "config", "id"], "in": ["gin", "f", "data", "isin", "socket", "inn", "ssl", "source", "i", "resource", "con", "token", "read", "ax", "is", "input", "inas", "init", "din", "lin", "reader", "rin", "ins", "bin", "err", "inner", "s", "image", "b", "inside", "as", "win", "In", "stream", "n", "inc", "ac", "IN", "nin", "ini", "r", "ex", "login", "out", "again", "id"]}}
{"id1": "12306305", "id2": "2668634", "code1": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"srcFile": [" srcFiles", " srcTime", "sslFile", "sourcePath", "restF", "destPath", "rcPage", "destFiles", "destPage", "destTime", " srcPage", "srcTime", "srcFiles", " srcF", "srcfile", "srcF", " srcName", "rcFile", "restFile", "restfile", "rcTime", "sslF", "sourceFiles", "sourceDir", "srcDir", " srcfile", "sslName", "rcPath", "sslfile", "restName", " srcPath", "srcPath", "rcDir", "srcPage", "sourceFile", "rcfile", "destDir", "sourcefile", " srcDir", "rcFiles", "srcName"], "destFile": ["srcFolder", "DestSourceFile", "distLine", "destDirectory", "targetName", " destSourceFile", "DestDir", " destinationFile", " destDir", "DestPage", "destFiles", "destName", "restFiles", "sourceFolder", "restSourceFile", "destPage", "distFile", "srcLine", "DestFolder", "destTime", "srcTime", "DestFilename", "srcFiles", "restFilename", " destTime", " destFilename", "restDir", " destName", "sourcePage", "destLine", "restFile", "srcPlace", "restfile", "destPlace", " destinationFiles", "DestFile", " destPage", "sourceDir", "srcDir", "DestName", "destSourceFile", "targetFile", "DestFiles", "targetFiles", " destinationPage", "destFolder", " destDirectory", "destFilename", "targetPage", "targetDir", " destinationFilename", "destfile", "targetDirectory", " destfile", "restFolder", "sourceFile", "Destfile", "destDir", " destFolder", "sourceFilename", "distTime", " destPlace", "sourceDirectory", "distPlace", " destLine", " destFiles", "srcName"], "preserveFileDate": ["preservedTimeDate", "preservePageTime", "preserveDirectoryDate", "preserveTimedate", "preserveTimeDate", "preservedFiledate", "preservedTimeDay", "preservedFileTime", "preserveFiledate", "preservedTimeTime", "preservingFileFormat", "preserveFileTime", "preserveTimeFormat", "preserveTimeTime", "preserveFilesDay", "preserveDateDate", "preserveTimeDay", "preservingTimeFormat", "preserveDateFormat", "preservingTimedate", "preservePageDay", "preserveDirectoryFormat", "preserveFileDay", "preservingTimeDate", "preservingFiledate", "preserveFileFormat", "preservingFileDate", "preserveDatedate", "preserveFilesdate", "preservedFileDate", "preserveFilesTime", "preserveFilesDate", "preservePageDate", "preserveDirectorydate", "preservedFileDay", "preservePagedate", "preservedTimedate"], "input": ["target", "address", "internal", "child", "data", "socket", "ssl", "request", "source", "i", "form", "upload", "feed", "Output", "entry", "binary", "context", "parent", "event", "error", "conn", "file", "in", "url", "Input", "reader", "temp", "active", "img", "single", "connection", "io", "inner", "image", "self", "buffer", "up", "client", "channel", "result", "exec", "instance", "stream", "current", "audio", "api", "copy", "config", "out", "object", "null"], "output": ["application", "target", "video", "operation", "address", "next", "child", "core", "socket", "other", "source", "put", "exit", "response", "Output", "writer", "console", "binary", "parent", "entity", "ou", "file", "office", "temp", "environment", "connection", "io", "unit", "image", "self", "client", "channel", "o", "ilo", "write", "download", "outer", "external", "current", "control", "audio", "copy", "config", "out", "null"]}}
{"id1": "11477906", "id2": "13886238", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"configFileName": ["configFILEName", "settingFilenameNum", "configFileSync", "settingFileType", "configFileNum", "dataFILEType", "dataFileName", "dataFileType", "configDirLocation", "configFILEType", "configFullDie", "settingFileName", "configfileType", "configFileType", "configfileName", "configFILENum", "configFILELocation", "configfileSync", "settingFilenameSync", "configfileNum", "settingFileNum", "configFilenameSync", "configDirName", "dataFileLocation", "configDirType", "dataFILEName", "settingFilenameName", "configFileDie", "configFullName", "configFilenameNum", "dataFileDie", "settingFilenameType", "dataFILELocation", "settingFileSync", "configFILEDie", "configFileLocation", "dataFILEDie", "configDirDie", "configFullLocation", "configFullType", "configFilenameType", "configFilenameName", "configFILESync"], "in": ["f", "a", "it", "data", "socket", "inn", "ssl", "source", "i", "resource", "con", "diff", "plus", "read", "pc", "is", "input", "init", "this", "base", "din", "conn", "url", "reader", "ins", "bin", "m", "err", "work", "inner", "up", "c", "inside", "as", "In", "stream", "n", "cin", "inc", "log", "IN", "nin", "ini", "r", "login", "config", "again", "pass", "pin", "pull", "id"], "out": ["prefix", "d", "server", "url", "outs", "at", "inc", "config", "ext", "f", "sync", "version", "serv", "data", "socket", " o", "lib", " back", "conn", "file", "timeout", "exp", "connection", "net", "io", "set", "exec", "write", "instance", "log", "again", " write", "OUT", "string", "output", " file", "writer", "Out", "bin", "to", "s", "up", "client", "c", "cache", "ex", "copy", "default", "back", "object", "point", "user", " output", "off", "password", "t", "parent", "ou", "error", "err", "name", "obj", "o", "all", "null"]}}
{"id1": "1508161", "id2": "8047989", "code1": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"mail": ["address", "f", "content", "data", "Email", "follow", "pm", "user", "request", " email", "xml", "proxy", "mo", "id", "server", "del", "zip", "el", "class", "pkg", "html", "base", "load", "event", "file", "mand", "ship", "mass", "m", "call", "letter", "element", "Mail", "gmail", "open", "name", "update", "md", "email", "multi", "order", "build", "match", "ml", "sel", "l", "link", "mails", "mill", "item", "log", "test", "view", "local", "body", "key", "object", "model", "il", "e", "message"], "client": ["session", "et", "bird", "plugin", "socket", "uri", "service", "request", "ssl", "i", "resource", "web", "app", "con", "contact", "handler", "host", "http", "server", "cli", "project", "this", "ce", "base", "conn", "method", "connection", "call", "self", "force", "l", "cache", "driver", "api", "config", "e", "Client"], "url": ["address", "f", "data", "uri", "service", "request", "string", "ssl", "resource", "web", "path", "feed", "host", "http", "server", "ur", "sl", "URL", "base", "file", "method", "www", "connection", "href", "name", "up", "channel", "route", "email", "l", "download", "Url", "key", "config", "e", "id"], "get": ["session", "next", "find", "check", "uri", "service", "parse", "resource", "put", "send", "end", "Get", "server", "read", "GET", "cli", "gets", "invoke", "json", "query", "load", "req", "method", "call", "connection", "open", "update", "set", "exec", "build", "show", "start", "post", "body", "api", "like", "info", "create", "pull"], "response": ["application", "re", "data", "received", "request", "wave", "resource", "document", "success", "output", "status", "feed", "http", "server", "onse", "Response", "json", "respond", "event", "reply", "error", "page", "full", "environment", "res", "connection", "collection", "result", "resp", "Entity", "body", "api", "object", "e", "message"], "entity": ["application", "esi", "data", "content", "resource", "xml", "document", "em", "output", "ent", "line", "person", "server", "entry", "pe", "el", "ce", "json", "event", "error", "file", "page", "connection", "agent", "unit", "element", "image", "ee", "collection", "coll", "email", "result", "om", "instance", "article", "Entity", "resp", "body", "node", "object", "model", "e", "message"], "doc": ["f", "docs", "d", "dr", "content", "data", "Document", "study", "xml", "document", "resource", "div", "dc", "db", "line", "valid", "dec", "pc", "lib", "text", "meta", "json", "desc", "html", "file", "page", "type", "m", "exp", "unit", "media", "up", "struct", "dir", "md", "pos", "dict", "Doc", "oc", "body", "coll", "map", "message"], "msg": ["comm", "mess", "dr", "data", "content", "g", "mid", "str", "reason", "db", "message", "ug", "text", "desc", " ms", "pkg", "html", "req", "error", "ma", "gs", "type", "ms", "Msg", "m", "ge", "gen", "comment", "err", "ag", "urg", " desc", "title", "ko", "code", "info", "cmd", "md", "reg", "log", "loc", "status", "map", "e", "id"]}}
{"id1": "16079868", "id2": "5049453", "code1": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private BingResponse queryBing(BingRequest request) throws BingException {\n        try {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Searching through bing...\");\n            }\n            String query = request.getQuery();\n            query = URLEncoder.encode(query, \"UTF-8\");\n            URL url = new URL(\"http://api.bing.net/json.aspx?\" + \"AppId=\" + request.getAppId() + \"&Query=\" + query + \"&Sources=\" + request.getType().toString());\n            URLConnection connection = null;\n            if (useProxy) {\n                if (proxyType == null) {\n                    throw new BingException(\"Please set a proxy first before trying to connect through a proxy\", new Throwable());\n                }\n                connection = ProxyWrapper.getURLConnection(url.toString(), proxyType.toString(), proxyHost, proxyPort);\n            } else {\n                connection = new URL(url.toString()).openConnection();\n            }\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            String response = builder.toString();\n            ResponseParser parser = new ResponseParser();\n            parser.getError(response);\n            return parser.getResults(response);\n        } catch (MalformedURLException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        } catch (IOException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        }\n    }\n", "label": 0, "substitutes": {"url": ["address", "data", "user", "uri", "service", "ssl", "string", "source", "resource", "remote", "path", "feed", "host", "rule", "server", "http", "entry", "ur", "org", "sl", "input", "URL", "base", "file", "gl", "location", "connection", "io", "image", "buffer", "name", "job", "channel", "email", "l", "link", "stream", "Url", "rl", "object", "date"], "list": ["queue", "join", "LIST", "data", "tree", "lists", "detail", "counter", "server", "listed", "conf", "member", "this", "group", "search", "menu", "json", "parent", "items", "p", "load", "share", "array", "part", "owner", "table", "get", "self", "name", "coll", "batch", "client", "code", "obj", "result", "all", "l", "cache", "view", "pool", "test", "loop", "li", "record", "index", "out", "object", "status", "map", "show", "dict"], "in": ["loader", "gin", "f", "re", "data", "socket", "inn", "ssl", "source", "i", "xml", "con", "read", "fr", "iter", "is", "input", "rec", "min", "raw", "din", "file", "lin", "reader", "ins", "bin", "m", "err", "inner", "io", "s", "buffer", "image", "client", "c", "b", "as", "l", "In", "stream", "inc", "IN", "nin", "ini", "r", "login", "h", "out", "again", "id"], "inputLine": ["commandLine", "outputFile", "inputline", " inputPage", " inputL", "inputName", "commandWord", "issueLine", "singleItem", "InputLine", "commandItem", "viewL", "InputUrl", "inputUrl", "requestUrl", "InputFile", " inputBlock", "viewPage", "inputPage", "issueline", "InputName", " inputString", "outputline", "inputL", "currentLine", "issuePath", "requestFile", "outputLine", "InputPage", "viewLine", "outputL", "inputItem", "viewline", "issueWord", "commandBlock", "outputString", "InputBlock", " inputFile", "InputString", "commandPath", "singleBlock", "inputBlock", " inputPath", "commandline", "inputPath", "singleLine", " inputName", " inputItem", "currentName", "inputFile", "Inputline", "commandFile", "requestline", "currentString", " inputUrl", "currentline", " inputWord", "requestLine", "singleline", "inputWord", "inputString", "InputL", " inputline"], "commandNameBegin": ["commandStringbegin", "CommandLineBegin", " commandLineBeginning", " commandNamebegin", " commandNameBeginning", " commandLineBegin", " commandLinebegin", "commandParamEnd", "CommandNamebegin", "CommandNameBeginning", "commandStringBegin", "commandLineBegin", "CommandLineEnd", "CommandLineBeginning", "commandLinebegin", "commandTimeBeginning", "CommandNameEnd", "commandTimeEnd", "commandLineEnd", "commandNamebegin", "commandStringBeginning", "commandTimeBegin", "commandStringEnd", " commandLineEnd", "CommandNameBegin", "commandLineBeginning", "commandNameBeginning", "commandParamBegin", "commandParamBeginning", " commandTimebegin", " commandTimeBeginning", " commandTimeBegin", "CommandLinebegin", "commandParambegin", "commandTimebegin", " commandTimeEnd"], "commandNameEnd": ["commandNameStart", "commandNameend", "commandLineStart", "commandTimeStart", " commandNameEND", " commandTimeend", "commandLineend", "commandLengthEND", " commandLineBegin", " commandLineStart", " commandLineEND", "commandLineBegin", "commandNameEND", "commandTypeend", "commandLengthBegin", " commandLineend", "commandTimeEnd", "commandTypeBegin", " commandNameend", "commandLineEnd", "commandTypeEnd", "commandTimeBegin", " commandTimeEnd", "commandTimeEND", "commandLengthEnd", " commandLineEnd", "commandLineEND", " commandTimeEND", "commandTimeend", "commandTypeEND", "commandLengthStart", " commandNameStart", " commandTimeBegin", "commandLengthend"], "item": ["queue", "bar", "child", "it", "ui", "Item", "user", "service", "other", "site", "section", "i", "xml", "builder", "app", "source", "handler", "layer", "server", "entry", "option", "iter", "el", "member", "this", "group", "menu", "value", "parent", "base", "items", "atom", "event", "p", "add", "page", "hop", "part", "temp", "manager", "owner", "action", "edit", "element", "image", "ip", "name", "up", "job", "channel", "client", "obj", "order", "result", "or", "instance", "link", "admin", "si", "li", "api", "area", "extra", "object", "info"], "e": ["esi", "f", "a", "x", " event", "d", "ze", "je", "ev", "ie", "te", "ception", "es", "i", "ue", "ise", "handler", "pe", "t", "el", "ce", "ite", "E", "p", "event", "v", "error", "Event", " ev", "events", "se", "u", "er", "environment", "one", "ke", "err", "ea", "ed", "exc", "ee", "ec", "o", "c", "oe", "le", "or", "en", "l", "ne", "me", "ve", "fe", "ae"]}}
{"id1": "3046085", "id2": "17974661", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "label": 0, "substitutes": {"s": ["S", "f", "a", "data", "content", "uploads", "ses", "string", "source", "i", "es", "sample", "sb", "str", "parts", "t", "is", "text", "p", "v", "in", "w", "ls", "m", "south", "speech", "sets", "testers", "services", "ws", "b", "ss", "ps", "less", "n", "js", "strings", "r", "e", "sharing"], "tokenizer": ["tunator", "Tokenator", "generener", " tokenener", "okener", "Tokenizable", " tokenize", "tokenizable", "hanizable", "hanize", "okeniner", "Tokenization", "okeniser", "tokenner", "serializer", "Tokenner", " tokenization", "hanator", "serialner", " tokenizable", "lexizer", "lexization", "numberizer", "generizer", "generize", "tunize", "numberizing", " tokenzer", "hanizer", " tokeniser", "tokenener", "tokenizing", " tokenator", "tunizable", "generizable", "tunizer", "okenizable", "lexizable", "Tokeniser", "lexize", " tokener", "okenizer", "tokenize", "tokenization", "tokeniner", "hanoser", "serialer", "Tokenizer", "numberizable", "serialize", " tokenoser", "hanization", "generator", "Tokenoser", "sonizable", "sonize", "generler", " tokenler", "okenizing", "okenzer", "sonizer", "okenize", "sonener", "tokenoser", "Tokeniner", "okenator", "tokener", "haniner", "sonization", "tokeniser", "tokenator", "okenler", " tokenizing", "tokenzer", "numberler", "okenener", "sonator", "tokenler", "Tokener", " tokenner", "Tokenize", "okenization", "sonzer"], "title": ["song", "author", "filename", "version", "template", "prefix", "length", "format", "content", "company", "string", "source", "profile", "layer", "id", "Title", "label", "text", "meta", "username", "license", "photo", "url", "type", "bot", "team", "media", "art", "name", "description", "genre", "summary", "music", "theme", "master", "metadata"], "artist": ["cover", "song", "master", "video", "target", "season", "author", "patch", "source", "alias", "output", "layer", "Artist", "track", "writer", "tag", "username", "creator", "chart", "photo", "winner", "episode", "team", "image", "media", "art", " artists", "archive", "player", "album", "feature", "genre", "audio", "music", "theme", "piece", "voice", "metadata"], "location": ["video", "address", "station", "live", "length", "Location", "content", "mobile", "time", "path", "layer", "lang", "motion", "game", "url", "level", "image", "media", "language", "region", "weather", "lace", "position", "audio", "loc", "area", "theme", "layout"], "rating": ["season", "live", "training", "alpha", "weight", "game", "random", "rate", "score", "rock", "episode", "tracking", "style", "fps", "media", "scoring", "trial", "resolution", "album", "rank", "breaking", "genre", "boarding", "picking", "playing", "padding", "ranking", "sharing"], "overplay": ["gameface", "gameplay", "reface", "rebid", "microface", "microplay", "overface", "overlay", "relay", "microlay", "gamelay", "microbid", "overbid", "gamebid", "replay"], "temp": ["prefix", "template", "data", "content", "format", "emp", "string", "source", "empty", "path", "str", "id", "font", "tmp", "track", "tag", "fake", "base", "p", "txt", " temporary", "type", "tc", "unit", "tx", "partial", "media", "name", "original", "stage", " tmp", "flat", "current", "cache", "test", "pt", "loc", "body", "area", "Temp", "layout", "message"], "tags": ["ids", "styles", "comments", "shirts", "features", "words", "phones", "stats", "blocks", "resources", "sections", "packages", "atts", "reports", "thumbnails", "ags", "relations", "tracks", "tests", "products", "events", "Tags", "files", "users", "assets", "types", "keys", "plugins", "modules", "images", "strings", "dates", "videos", "fields", "bugs", "bots", "stars", "names", "terms"], "bytes": ["comments", "bits", "data", "words", "content", "Bytes", "lines", "tes", "es", "blocks", "balls", "parts", "notes", "gets", "errors", "tracks", "resses", "params", "units", "files", "bps", "les", "articles", "pages", "objects", "ips", "letters", "outs", "codes", "size", "values", "pieces", "keys", "seconds", "body", "strings", "packs"], "hasher": ["rusher", "Hasbuilder", " hasipper", "hasusher", "hadipper", "gother", "gotest", " hashing", "hadest", " hashers", " hasest", "haster", "hasipper", "Hasest", "gotbuilder", "hashing", "hardhers", "rusipper", "macest", "hadher", "hardhing", "hardest", "hasbuilder", "hasest", "havehers", " haster", "macer", "sher", "machers", " hasusher", "hadusher", "haser", "havehing", " hasbuilder", " haser", "gotter", "shers", "Hasher", "rususher", "macher", "hardher", "Haster", "sest", "haveher", "ser", "rusest", "haveest", "hashers"]}}
{"id1": "9275622", "id2": "2642914", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"_file1": ["_zip1", "_fone", "_resource1", "_files01", "_fileOne", "_f1", "_mail2", "_zipOne", "_files0", "_mail0", "_fOne", "_File2", "_mail01", "_fileone", "_files1", "_resourceone", "_files2", "_file01", "_fileFirst", "_resourceFirst", "_file0", "_File01", "_File0", "_fFirst", "_File1", "_mail1", "_resourceOne", "_zipone", "_zipFirst"], "_file2": [" _files4", "_play2", "_Filesecond", "_playsecond", "_play3", "_model1", "_File5", "_filesTwo", " _file4", " _filesTwo", "_playTwo", " _fileTwo", "jmodelsecond", "jmodel2", "jmodel5", "_File2", "_play5", "jfile2", "_play1", " _files3", "jfile1", "_files2", "_file3", "_model5", "_filesecond", "_files4", "_play4", "_File1", "jfile5", "_modelsecond", "_file4", "jmodel1", "_fileTwo", "jfilesecond", "_files3", " _files2", "_file5", " _file3", "_model2"], "fis": ["Fos", "lfis", "fas", " fils", " fris", "lfais", " fas", "Fris", "fris", "cfas", " fais", "Fils", "cfris", "lfiss", "afis", "afi", "Fis", " fiss", "infils", " fi", "afiss", "cfis", "afais", "fais", "cfiss", "fiss", "infiss", "cfos", "fils", "Fas", "fi", "infos", "Fiss", "lfi", "infis"], "fos": ["Fos", "foes", "feoses", "Foos", "lis", "fOS", "lOS", "feis", "flOS", "infios", "gus", "faos", "poes", "floes", "fus", " fo", "infoos", "goses", "Fis", "los", "flos", "foos", "Fros", " fios", "fios", "infros", " fus", " faos", "Fus", "infaos", "flis", "Fios", "fo", " foos", " fros", "pos", "foses", "gos", "infos", "Fo", "Foses", "feos", "infus", "pis", "pOS", "fros", "Faos", "feus", "info", "loes", "gis"], "canalFuente": ["canalBuente", "canallBuente", "canallBuencia", "canalBuze", "canalsFuencia", "canalFUje", "canalsBuente", "canalCraento", "canaledBuje", "canalFUence", "canalBuento", "canaledFuje", "canalKuze", "canalsFuento", "canalsFuente", "canaledFuze", "canalBuestro", "canalFUze", "canalCraente", "canalBuencia", "canalSuze", "canalSuestro", "canalFUente", "canalsFuence", "canalCraencia", "canalBuje", "canalSuente", "canallFuence", "canalFuze", "canallFuze", "canalCraence", "canallBuence", "canalFUestro", "canalFuestro", "canalsBuento", "canaledBuze", "canalFuje", "canalKuence", "canallBuze", "canaledBuestro", "canalSuje", "canallFuente", "canalFuence", "canalKuente", "canalKuencia", "canalKuento", "canalFuento", "canalsBuencia", "canaledBuente", "canalFUencia", "canalsBuence", "canalBuence", "canallFuencia", "canaledFuente", "canalFuencia", "canaledFuestro"]}}
{"id1": "10131427", "id2": "8747840", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"in": ["a", "data", "inn", "source", "i", "resource", "diff", "input", "again", "base", "min", "file", "url", "reader", "ins", "bin", "m", "inner", "io", "image", "buffer", "name", "c", "b", "or", "In", "work", "at", "inc", "ac", "IN", "ini", "ex", "copy", "index", "config", "login", "id"], "out": ["target", "prefix", "OUT", "x", "data", "point", "string", "source", "output", "off", "writer", "dest", "Out", "base", "p", "v", "file", "conn", "part", "w", "temp", "connection", "io", "image", "buffer", "name", "client", "o", "c", "outs", "exec", "external", "n", "cache", "at", "ex", "copy", "object"], "sourceChannel": ["srcManager", "sourceChan", "ourceChannel", "sourceManager", "Sourcechannel", "srcConnection", "ourceChan", " sourceConnection", " sourceManager", "srcChannel", "SourceChannel", "sourceStream", "targetChannel", "SourceStream", "SourceConnection", "sourceQueue", "targetStream", " sourceStream", "SourceManager", "sourceConnection", "srcSocket", "SourceQueue", " sourceSocket", "SourceChan", "srcStream", "targetChan", "srcChan", "srcQueue", "SourceSocket", "sourcechannel", " sourcechannel", " sourceQueue", " sourceChan", "ourceStream", "targetchannel", "ourcechannel", "sourceSocket"], "destinationChannel": ["DestinatorChan", "destinatorCh", "DestinatorStream", "destinationchannel", "destinatorchannel", "destinationConnection", "DestinationConnection", "DestinatorConnection", "destinateStream", "destinationCh", "destinateChannel", "destinatorStream", "destinatedChannel", "DestinationChan", "destinateConnection", "destinationStream", "DestinatorCh", "destinatedCh", "destinatorConnection", "DestinationStream", "destationConnection", "destinatorChannel", "destinationsStream", "destinatedConnection", "destationchannel", "DestinatorChannel", "destinatechannel", "destationCh", "destinatedChan", "destationChannel", "destinatorChan", "destinationschannel", "destinationsConnection", "DestinationCh", "destationChan", "Destinationchannel", "Destinatorchannel", "destinationsChannel", "DestinationChannel", "destinationChan"]}}
{"id1": "21033686", "id2": "1235538", "code1": "    public File read() throws IOException {\n        URLConnection conn = url.openConnection();\n        conn.setConnectTimeout(5000);\n        conn.setReadTimeout(5000);\n        conn.connect();\n        int length = conn.getContentLength();\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        if (tempDir == null) {\n            tempDir = \".\";\n        }\n        File tempFile = new File(tempDir + \"/\" + new GUID() + \".dat\");\n        tempFile.deleteOnExit();\n        InputStream in = null;\n        OutputStream out = null;\n        ProgressMonitor monitor = new ProgressMonitor(parentComponent, \"Downloading \" + url, null, 0, length);\n        try {\n            in = conn.getInputStream();\n            out = new BufferedOutputStream(new FileOutputStream(tempFile));\n            int buflen = 1024 * 30;\n            int bytesRead = 0;\n            byte[] buf = new byte[buflen];\n            ;\n            long start = System.currentTimeMillis();\n            for (int nRead = in.read(buf); nRead != -1; nRead = in.read(buf)) {\n                if (monitor.isCanceled()) {\n                    return null;\n                }\n                bytesRead += nRead;\n                out.write(buf, 0, nRead);\n                monitor.setProgress(bytesRead);\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n            monitor.close();\n        }\n        return tempFile;\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 0, "substitutes": {"conn": ["Connection", "comm", "ca", "ctx", "cm", "sync", "serv", "socket", "cf", "ssl", "connect", "ci", "con", "cn", "dc", "http", "cli", "init", "nc", "cp", "p", "nt", "url", "ai", "ct", "cb", "connection", "err", "stat", "sql", "open", "rt", "connected", "client", "conv", "cmd", "c", "channel", "exec", "not", "en", "Conn", "n", "oa", "cmp", "ann", "loc", "ch", "fn", "mc", "enc", "config", "login"], "length": ["delay", "time", "angle", "Length", "path", "distance", "limit", "duration", "total", "len", "lock", "block", "load", "sleep", "url", "offset", "range", "l", "size", "max", "position", "count", "depth"], "tempDir": ["tempFolder", "tmpFolder", "TempDir", " tempDirectory", "currentDirectory", "currentDir", "tempDirectory", "TempFolder", "tmpDir", "currentFile", "Tempdir", "tmpDirectory", "TempFile", " tempFolder", "tempdir", "tmpFile", " tempdir", "TempDirectory", "tmpdir", "currentFolder"], "tempFile": ["tempPlace", "TempClass", "tmpFiles", "poraryPlace", "poraryUrl", "TempDir", "tmpfile", " temporaryfile", " temporaryFile", "tmpClass", "tmpUrl", " temporaryClass", " tempUrl", "tmpLibrary", " tempDirectory", "tempFiles", " tempPlace", "tempDirectory", "tmpDir", " temporaryDir", " tempLibrary", " tempfile", "tempClass", "tmpDirectory", "TempLibrary", "TempFile", "tempUrl", "TempFiles", "tempfile", " tempFiles", "Tempfile", "poraryDir", "tmpPlace", "tmpFile", "poraryFile", "TempDirectory", "tempLibrary"], "in": ["gin", "f", "a", "serv", "re", "data", "socket", "inn", "source", "i", "con", "on", "diff", "is", "input", "init", "this", "fa", "p", "din", "url", "lin", "reader", "file", "impl", "ins", "rin", "bin", "m", "into", "err", "inner", "s", "image", "name", "b", "c", "as", "exec", "or", "en", "l", "win", "In", "work", "n", "cin", "inc", "IN", "nin", "ini", "r", "like", "login", "index", "again", "info", "pin", "pull"], "out": ["ext", "sync", "OUT", "prefix", "data", "socket", "more", "source", "i", "output", "off", "plus", "with", "option", "writer", "init", "by", "parent", "Out", "lock", "min", "error", "file", "co", "part", "temp", "timeout", "bin", "err", "connection", "net", "io", "inner", "unit", "image", "call", "name", "up", "client", "o", "write", "outs", "exec", "or", "outer", "cache", "n", "log", "key", "cookie", "ex", "copy", "login", "again", "null"], "monitor": ["number", "wrapper", "cm", "condition", "port", "pm", "counter", "watch", "source", "Monitor", "per", "own", "output", "handler", "reason", "meter", "param", "duration", "member", "writer", "mor", "parent", "lock", "p", "processor", "temp", "method", "timeout", "manager", "m", "widget", "connection", "state", "inner", "unit", "update", "client", "reg", "mon", "timer", "program", "admin", "control", "log", "pool", "view", "trace", "report", "summary", "config", "info", "master", "pin", "metadata"], "buflen": ["buFlens", "Bullength", "bufleng", "bullens", " buflong", " bullan", "buFLen", " bullens", "buflens", "Bufleng", "bugelen", "Bullen", "buFlength", "buflength", "bullan", "Bulleng", "buFLan", "Bufllen", "buFlong", "bugeleng", "bulllen", "bugellen", "buflong", "bullong", "Buflen", "buFleng", "buFLong", "buFllen", " bullong", " bullen", "bulleng", "Buflength", " buflan", "buflan", "buFlen", "buFLens", "bullength", "bugelength", "Bulllen", "bullen", "buFlan", " buflens", "bufllen"], "bytesRead": ["bytesWrite", " bytesread", "bpsWrite", "bytesread", "nWrite", " bytesReader", "bitsread", " bytesWrite", "BytesLength", "bytesLength", "BytesWrite", "bytesReader", "nread", "nsRead", "Bytesread", "bpsRead", "bitsRead", "bpsread", "bpsReader", "nsLength", "bitsWrite", "nsread", " bytesLength", "BytesRead", "BytesReader"], "buf": ["queue", "ctx", "bh", "rb", "data", "ref", "home", "wb", "pad", "bc", "dec", "off", "tmp", "buff", "fb", "bu", "comb", "grab", "cv", "seq", "ff", "cas", "context", "pkg", "base", "raw", "fp", "vec", "fam", "func", "bp", "fd", "bin", "cb", "exc", "buffer", "header", "br", "done", "Buffer", "batch", "cmd", "b", "bytes", "result", "rc", "uf", "auc", "ha", "cur", "loc", "cap", "uc", "bag", "la"], "start": ["st", "data", "from", "time", "last", "end", "progress", "read", "init", "scale", "since", "base", "error", "state", "offset", "art", " Start", "step", "set", "pos", "size", "started", "max", "run", "stop", "trace", "count", "Start"], "nRead": ["gRead", "fnReader", " nReading", "gWrite", "cReading", "neReader", " nUse", "neRead", "cWrite", "nWrite", "nReading", "fnRead", "ntReader", "NWrite", "fnWrite", "ninWrite", "NReader", " nReader", "nReader", "nUse", "numReading", "ninUse", "enReading", "neReading", "ninRead", "numRead", "ntReading", "ntRead", "gReading", "enRead", "enWrite", "nLoad", "cUse", "NRead", "NReading", "numWrite", "fnLoad", "neWrite", "ntWrite", "enReader", "cRead", "cLoad", "ninReader", " nWrite", "cReader", "numReader", " nLoad", "gReader"]}}
{"id1": "293167", "id2": "5951961", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"view": ["session", "gu", "f", "can", "template", "ui", "row", "port", "user", "check", "request", "section", "form", "container", "VIEW", "review", "im", "views", "server", "http", "see", "layout", "el", "input", "by", "this", "list", "group", "window", "html", "base", "lock", "block", "event", "query", "head", "page", "v", "full", "reader", "ou", "screen", "manager", "widget", "box", "style", "View", "buffer", "image", "display", "change", "self", "edit", "up", "update", "client", "vol", "sel", "link", "show", "index", "cache", "body", "config", "out", "object", "model", "use", "vis", "e", "cell"], "url": ["loader", "address", "f", "length", "data", "socket", "uri", "jar", "ssl", "string", "source", "resource", "web", "builder", "path", "host", "server", "http", "hub", "fb", "sl", "zip", "URL", "blog", "base", "file", "page", "www", "gl", "location", "connection", "buffer", "image", "open", "name", "client", "channel", "job", "b", "email", "browser", "download", "l", "link", "stream", "Url", "log", "position", "ob", "config", "ul", "id"], "in": ["data", "isin", "socket", "inn", "source", "resource", "con", "sin", "on", "is", "input", "arin", "init", "din", "file", "lin", "reader", "rin", "ins", "inner", "s", "buffer", "bis", "b", "as", "doc", "win", "In", "stream", "cin", "inc", "ac", "IN", "nin", "ini", "login", "out", "again", "pin"], "bin": ["loader", "an", "gin", "nb", "socket", "bb", "ruby", "inn", "bi", "source", "con", "sin", "is", "input", "lib", "binary", "init", "abi", "ban", "kin", "lock", "din", "file", "lin", "reader", "bot", "connection", "bn", "inner", "buffer", "b", "inside", "fin", "browser", "win", "cache", "cin", "run", "IN", "body", "ini", "record", "spin", "out", "login", "oin", "pin"], "line": ["cl", "column", "data", "row", "lines", "user", "service", "parse", "string", "lc", "section", "end", "LINE", "str", "id", "nl", "entry", "pe", "ine", "el", "lf", "text", "base", "block", "file", "page", "lin", "inline", "part", "type", "ge", "comment", "letter", "range", "unit", "ip", "name", "Line", "code", "job", "up", "look", "b", "le", "l", "link", "definition", "log", "key", "val", "word", "out", "status", "pin", "e", "cell"], "version": ["cover", "install", "video", "filename", "bug", "plugin", "patch", "format", "string", "section", "id", "server", "vision", "option", "project", "username", "vert", "value", "license", "v", "type", "product", "dev", "secret", "unit", "image", "beta", "Version", "name", "update", "info", "versions", "code", "VERSION", "release", "download", "description", "feature", "python", "position", "driver", "null", "model", "date", "pull", "ver"], "build": ["install", "help", "length", "bug", "Build", "hold", "patch", "follow", "rel", "push", "row", "home", "builder", "built", "valid", "make", "label", "where", "tag", "lock", "base", "load", "block", "add", "boot", "building", "style", "comment", "unit", "image", "name", "update", "info", "job", "print", "release", "how", "work", "run", "log", "test", "clean", "use", "uild", "show", "pull", "ver"]}}
{"id1": "21754659", "id2": "16549995", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"buttonSonido": ["buttonHomigo", "buttonSunado", "ButtonSonida", "ButtonDonida", "btnDonado", "buttonsonido", "buttonDonira", "buttonsonito", "btnSonardo", "buttonTenira", " buttonSenido", "buttonsonardo", "ButtonSonardo", "buttonSunito", "ButtonDonini", "btnSonini", " buttonSenardo", "ButtonDonido", " buttonSenira", "buttonTenado", "buttonSenado", "buttonDonado", "buttonsonado", "btnSonado", "buttonDonida", "btnSonido", "buttonSonira", "buttonSenito", "buttonSenigo", "ButtonDonardo", "buttonDonigo", " buttonSenado", " buttonSenito", "buttonSonado", "buttonTenido", "btnSonigo", "ButtonSonido", " buttonSonito", "buttonSonida", "buttonSonito", "buttonsonini", "buttonDonido", "ButtonSonigo", "buttonSenini", " buttonSonira", "btnDonido", "ButtonDonigo", "buttonHomido", " buttonSenini", "buttonSenido", "buttonSenardo", "ButtonDonado", "buttonHomado", "buttonSonini", " buttonSonini", "buttonTenardo", "buttonSunini", "buttonSonigo", "buttonDonini", "buttonsonigo", " buttonSonado", " buttonSonardo", "buttonSonardo", "buttonDonardo", "buttonHomida", "buttonSunido", "ButtonSonini", "buttonSenira", "btnDonardo", "ButtonSonado", "btnDonigo"], "e": [" ate", " caught", " events", " ignored", " cause", "t", " pe", " E", " fe", " en", " Event", "E", " exc", "event", " ace", "Event", " ev", " ele", " inst", " je", "ed", "ee", " ste", " exception", " exp", " te", " ie"], "fc": ["f", "fed", "cf", "WF", "FE", "lc", "GF", "con", "dc", "bc", "fx", "fr", "xf", "pc", "fb", "CF", "LC", "lf", "nc", "F", "Factory", "fa", "flo", "bf", "fp", "fd", "wk", "WC", "roc", "ct", "tc", " FC", "FS", "DC", "ec", "c", "fi", "wic", "isc", "irc", "af", "fw", "wt", "xc", "mc", "fe", "FC", "fn", "fl", "enc", "il", "fs", "fm"], "returnVal": ["continueVal", "exitval", "Returnval", " returnVAL", "continueNum", " returnNum", "ReturnVal", "ReturnNum", "returnValue", "returnval", " returnval", "returnNum", "exitValue", "returnVAL", "ReturnVAL", "exitVal", "continueValue", "exitVAL", "ReturnValue", " returnValue", "continueval"], "file": ["f", "filename", "data", "user", "uri", "cf", "socket", "parse", "source", "resource", "sf", "document", "per", "path", "handler", "rule", "db", "http", "zip", "class", "this", "binary", "File", "folder", "base", "function", "lock", "fp", "url", "page", "plain", "full", "php", "part", "directory", "files", "type", "single", "connection", "to", "get", "io", "image", "future", "name", "dir", "b", "l", "ile", "FILE", "log", "local", "fe", "use", "out", "object", "info", "global", "message"], "rutaGlobal": ["rundaGlobal", "prutaInternational", " rutoForeign", "rottaGlobal", "runtaGeneral", "rutaForeign", "rundaInternational", "rundaGeneral", "rutiInternational", "rutaCurrent", " rutaGeneral", "pruntaGlobal", "pruntaInternational", " rutaForeign", "prutaGlobal", "ritaForeign", "ritaGeneral", "pruntaGeneral", "rottaForeign", "rutaGeneral", " rutoGlobal", "rutiGlobal", "ritaCurrent", "rutoGlobal", "runtaInternational", "rottaGeneral", "rottaCurrent", " rutaCurrent", "rutiGeneral", "rutoForeign", "ritaGlobal", " rutoGeneral", "prutaGeneral", " rutoCurrent", "rutoCurrent", "runtaGlobal", "rutaInternational", "rutoGeneral"], "rutaRelativa": ["rutaMalativo", "rutaMalattiva", "rutaMalattiv", "rutaRelatival", "rutaReliatieri", "rutaMalatieri", "rutaRelpativa", "rutaRelarativo", "rutaMalativas", "rutaRelativ", "rutaRelarativa", "rutaRelartieri", "rutaRelattiv", "rutaRelartivo", "rutaRelattivist", "rutaRelativas", "rutaRelativo", "rutaRelattivo", "rutaRelarivist", "rutaReliativo", "rutaRelatieri", "rutaRelpatival", "rutaRelatiival", "rutaMalarivo", "rutaRelarivas", "rutaMalativa", "rutaRelartiv", "rutaRelarativist", "rutaRelatiivo", "rutaRelattieri", "rutaRelattival", "rutaRelatiiv", "rutaMalarivas", "rutaRelariva", "rutaReliativ", "rutaRelpativo", "rutaRelpativ", "rutaRelatiiva", "rutaRelarivo", "rutaMalativ", "rutaMalattivo", "rutaMalativist", "rutaRelattivas", "rutaRelarativas", "rutaMalarivist", "rutaRelativist", "rutaReliativa", "rutaMalariva", "rutaMalattieri", "rutaRelattiva", "rutaRelartiva"], "fis": ["Fos", "sfus", "dfus", "tiss", " fils", "sfis", " fris", "sfos", "Fris", "fris", "tus", "Fils", "fus", "Fis", " fiss", "sfiss", "dfiss", "dfris", "cfis", " fus", "Fus", "cfiss", "fiss", "tis", "cfos", "fils", "dfis", "Fiss", "tos", "cfils"], "fos": ["Fos", "foes", "fsoes", "Fops", "fOS", "infOS", " fs", " foes", "fsops", "faos", "hs", "Fis", "hoes", "fsos", "fsis", " faos", "Fs", "fops", "infaos", "infos", "Foes", "hos", "infis", "hops", " fops", " fOS", "Faos", "FOS", "fs"], "canalFuente": ["canalLicento", "canalJuence", "canalBuente", "canallBuente", "canallBuencia", "canalLicente", "canallFuento", "canalFuenta", "canalBuento", "canpalKuente", "canpalKuencia", "canallJuencia", "canalBuencia", "canpalFuencia", "canallJuente", "canalJuente", "canalFUente", "canallJuento", "canalFUinea", "canalKuenza", "canpalFuente", "canalBuenta", "canalBuinea", "canallFuenta", "canalJuento", "canalFuinea", "canpalFuenza", "canalJuenza", "canalKuence", "canalJuencia", "canallBuenta", "canalFiente", "canalLicencia", "canalFienta", "canalFiinea", "canalFiencia", "canallFuente", "canalFuence", "canalFuento", "canalKuente", "canalKuencia", "canpalKuenza", "canallBuinea", "canalLicence", "canpalKuence", "canpalFuence", "canallFuinea", "canalFuenza", "canalFUencia", "canallJuence", "canalBuence", "canalFUenta", "canallFuencia", "canalFuencia", "canallFuence", "canalBuenza"], "canalDestino": ["canialDestinos", "canalCombinos", "canalCatro", "canalCampino", "canalCatino", "canalCampro", "canaldestina", "canelDestina", "canelDestinos", "canaldestino", "canalCampina", "canalDestoin", "canalCatinos", "canialCombino", "canialDestoin", "canialCombinos", "canialCombro", "canaldestinos", "canalCombino", "canelCampinos", "canialDestino", "canalDestro", "canelCampina", "canalCampaco", "canalCampinos", "canialComboin", "canalDestina", "canialDestro", "canalCombro", "canalCatoin", "canelCampino", "canaldestaco", "canalCampoin", "canelCampaco", "canalDestaco", "canalDestinos", "canelDestino", "canelDestaco", "canalComboin"]}}
{"id1": "11556231", "id2": "12766394", "code1": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 0, "substitutes": {"urlstr": ["URLstring", "URLSTR", "URLstr", "httpSTR", "httpstring", "UrlStr", "Urlstring", "UrlSTR", "URLname", " urlname", " urlstring", " urlSTR", "urlstring", "httpstr", "URLStr", "urlStr", "urlname", "urlSTR", "Urlname", "httpStr", "Urlstr"], "uri": ["address", "filename", "prefix", "ui", "string", "i", "resource", "domain", "qi", "path", "host", "server", "http", "URI", "URL", "text", "username", "pi", "base", "database", "query", "file", " URI", "directory", "type", "manager", "location", "absolute", "href", "io", "image", "collection", "route", "ri", "iri", "description", "Url", "attribute", "direction", "id"], "url": ["loader", "session", "system", "address", "f", "user", "service", "ssl", "string", "resource", "web", "feed", "path", "host", "server", "http", "sl", "URL", "base", "conn", "file", "page", "location", "image", "client", "channel", "l", "link", "download", "stream", "Url", "loc", "li", "proxy", "id"], "connection": ["application", "Connection", "system", "socket", "connect", "i", "resource", "con", "director", "handler", "server", "http", "response", "writer", "URL", "context", "database", "conn", "directory", "io", "open", "connected", "collection", "client", "channel", "relation", "c", "or", "l", "stream", "control", "body"], "in": ["f", "a", "socket", "inn", "i", "connect", "con", "and", "input", "writer", "init", "kin", "conn", "lin", "ins", "bin", "inner", "s", "cms", "client", "c", "as", "or", "In", "stream", "inc", "ac", "IN", "ini", "r", "login", "out"], "reader": ["loader", "wrapper", "row", "i", "resource", "ler", "ais", "handler", "server", "read", "entry", "iter", "input", "writer", "reading", "conn", "er", "io", "inner", "buffer", "client", "channel", "result", "or", "rc", "stream", "parser", "ini", "r", "out", "Reader"], "is": ["nis", "lis", "ris", "serv", "ui", "iss", "src", "iris", "isl", "i", "ci", "ais", "has", "sr", "isa", "os", "conn", "ai", "iso", "sp", "ins", "rss", "err", "io", "s", "bis", "cms", "IS", "mis", "info", "ios", "ri", "as", "was", "or", "rs", "Is", "iri", "isi", "si", "out", "im", "fs"], "document": ["application", "docs", "content", " documentation", "ocument", "Document", "resource", "xml", " documents", "output", "graph", "response", "writer", "class", "parent", "root", "database", "m", "element", "collection", "result", "doc", "Documents", "node", "config", "object", "message"], "source": ["content", "src", "service", "string", "resource", "container", "SOURCE", "input", "class", "context", "text", "parent", "file", "unit", "element", "language", "instance", "stream", "parser", "Source", "driver", "node", "object", "info"], "name": ["named", "prefix", "filename", "format", "string", "domain", "resource", "URI", "text", "tag", "value", "parent", "base", "root", "file", "type", "location", "NAME", "comment", "element", "Name", "property", "instance", "description", "definition", "key", "node", "attribute", "word", "object", "info", "names", "id"], "namespaceURI": ["NamespacesFINE", "namespacesMI", "namesistenceuri", "nameservingURI", "Namespaceuri", "namespacesuri", "namespaceuri", "namespacedGI", "perspaceURI", "namespaceMI", "namesheeturi", "namespaceGI", "NamespaceFINE", "namespacedURI", "namespaceFINE", "NamespaceNS", "namesistenceMI", "nameservingNS", "namesferenceuri", "namespaceNS", "namesferenceFINE", "namesferenceURI", "namesheetGI", "namesheetURI", "namesistenceURI", "nameservinguri", "namespacesURI", "perspacedGI", "Namespacesuri", "perspacedURI", "perspaceuri", "namespacesFINE", "namesferenceMI", "NamespacesURI", "NamespaceMI", "namespaceduri", "NamespaceURI", "perspaceGI", "perspaceduri", "NamespacesMI", "namesistenceFINE", "namespacedNS"], "qualifiedName": ["qualURI", "qualName", "qualifiedURI", "qualname", "simplename", " qualifiedURI", "fixedPath", "localType", "qualifiedname", "qualifiedType", "simplePath", " qualifiedType", " qualifiedname", "localname", "fixedname", " qualifiedPath", "fixedName", "simpleURI", "simpleName", "qualifiedPath", "fixedType", "localPath", "qualPath"], "data": ["number", "comments", "child", "template", "content", "format", "script", "string", "xml", "resource", "output", "str", "model", "message", "input", "class", "text", "context", "value", "parent", "base", "type", "NAME", "element", "buffer", "media", "language", "property", "description", "ata", "doc", "stream", "definition", "DATA", "body", "def", "node", "config", "default", "object", "info", "id"], "tagName": ["Tagname", "TagName", "localname", "TagClass", "localClass", " tagClass", "tagClass"], "target": ["address", "next", "template", "format", "domain", "resource", "path", "host", "label", "class", "parent", "base", "root", "head", "prop", "method", "uid", "location", "NAME", "href", "property", "instance", "component", "node", "Target", "object", "info"], "elementId": ["objectTag", "nodeTag", " elementTag", "objectID", "nodeID", "elementTag", "objectid", "nodeId", "objectId", "nodeid", " elementid", " elementID", "elementid", "elementID"], "tagname": ["className", "classname", "Tagname", "TagName", "TagNAME", "tagNAME", "classNAME", " tagNAME"], "localName": ["localNAME", "clientName", " localNAME", "clientNAME", "localname", "qualifiedname", "clientname", "qualifiedNAME", " localname"]}}
{"id1": "21316706", "id2": "19687456", "code1": "    @Override\n    protected URLConnection openConnection(URL url, Proxy proxy) throws IOException {\n        if ((url == null) || (proxy == null)) {\n            throw new IllegalArgumentException(Messages.getString(\"luni.1B\"));\n        }\n        return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy);\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 0, "substitutes": {"url": ["loader", "address", "f", "ref", "port", "socket", "uri", "user", "service", "ssl", "string", "source", "web", "resource", "path", "host", "layer", "str", "server", "http", "db", "sl", "URL", "base", "file", "page", "library", "ls", "object", "connection", "io", "image", "name", "client", "channel", "email", "lr", "or", "l", "link", "Url", "log", "ob", "default", "null"], "proxy": ["pa", "address", "child", "port", "socket", "uri", "service", "ssl", "source", "resource", "web", "host", "server", "http", "pe", "zip", "project", "lib", "parent", "base", "p", "page", "pointer", "fax", "roxy", "library", "manager", "object", "friend", "connection", "io", "pse", "ip", "Proxy", "client", "clone", "instance", "cache", "pool", " proxies", "config"]}}
{"id1": "20091126", "id2": "4599372", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"in": ["f", "a", "data", "source", "i", "ic", "diff", "input", "base", "query", "min", "url", "file", "lin", "reader", "part", "ins", "bin", "m", "connection", "inner", "image", "buffer", "name", "b", "old", "or", "l", "In", "work", "inc", "ac", "IN", "config", "index", "again", "login", "id"], "out": ["ext", "target", "dot", "prefix", "OUT", "x", "a", "data", "content", "point", "string", "source", "i", "output", "off", "server", "parent", "Out", "base", "p", "value", "array", "v", "file", "page", "plain", "url", "temp", "object", "exp", "call", "err", "comment", "io", "image", "buffer", "default", "name", "channel", "o", "c", "outs", "exec", "write", "result", "external", "cache", "ex", "copy", "again"], "inChannel": ["outStream", "inputGate", " inClient", "inputchannel", "iniChannel", "inChan", "inClient", "inputChannel", "inButton", "INButton", "inputStream", " inChan", "iniGate", "iniStream", "outchannel", " inStream", "outChan", "INClient", "winChannel", "insStream", "winchannel", " inchannel", "insClient", "inchannel", "INGate", "INChannel", " inButton", "inputButton", "insChannel", "INChan", "inputChan", "inStream", "winChan", "outButton", "winStream", "INStream", "inGate", "iniChan", "INchannel", "insChan"], "outChannel": ["outStream", "OutClient", "outContext", "OutChan", "inChan", "inClient", "OutChannel", "OutContext", "OutStream", "outputClient", "inContext", "outchannel", "outChan", " outContext", "outConnection", " outchannel", " outChan", " outConnection", "inConnection", " outStream", "inchannel", "outsStream", "outputStream", "outputChannel", "outputchannel", "inStream", "outsChannel", "outsConnection", "outClient", "outsChan", "outputChan", "Outchannel"]}}
{"id1": "3330944", "id2": "21979717", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"input": ["inf", "RAW", "prefix", "OUT", "standard", "address", "data", "src", "request", "string", "source", "form", "empty", "xml", "i", "resource", "sin", "dc", "path", "SOURCE", "command", "tmp", "init", "text", "parent", "base", "raw", "file", "url", "Input", "PUT", "temp", "reader", "img", "bin", "type", "inner", "image", "media", "rc", "amp", "In", "work", "include", "current", "DATA", "audio", "IN", "qa", "ink", "view", "inc", "picture", "config", "API", "out", "ini", "null", "pull", "id"], "output": ["target", "address", "filename", "version", "prefix", "data", "format", "string", "source", "resource", "document", "path", "response", "password", "Output", "text", "parent", "file", "temp", "environment", "bin", "STDOUT", "secret", "unit", "image", "name", "generated", "dir", "write", "result", "outer", "external", "current", "config", "out", "message"], "params": ["target", "pins", "styles", "ctx", "lis", "template", "data", "features", "words", "lp", "pm", "las", "lc", "i", "xml", "Parameters", "resources", "server", "http", "parts", "param", "attr", "dis", "conf", "mos", "cos", "cli", "afi", "banks", "par", "pro", "pi", "mm", "json", "p", "pixel", "base", "processor", "properties", "vs", "reader", "phys", "ras", "ams", "apps", "manager", "ms", "phrase", "spec", "fps", "bis", "services", "py", "batch", "obj", "details", "settings", "ps", "proc", "Param", "plugins", "models", "mac", "si", "api", "config", "theme", "Par", "mr", "names", "options", "rules"], "w": ["kw", "rw", "wd", "wave", "xml", "web", "wb", "nw", "world", "wa", "war", "writer", "ow", "aw", "p", "wx", "wp", "W", "reader", "wal", "worker", "m", "widget", "wi", "hw", "wm", "ws", "sw", "write", "we", "pipe", "wei", "work", "fw", "wt", "wl", "out", "wcs"], "in": ["gin", "f", "vin", "data", "isin", "socket", "inn", "ssl", "source", "i", "thin", "con", "ic", "ani", "cli", "init", "binary", "inas", "fa", "kin", "p", "min", "din", "file", "lin", "conn", "rin", "part", "ai", "ins", "img", "bin", "cgi", "m", "connection", "image", "b", "inside", "win", "index", "In", "qa", "n", "cin", "inc", "include", "IN", "ac", "nin", "ini", "r", "ex", "mc", "login", "config", "out", "again", "null", "pin", "id"], "dest": ["delete", "target", "rest", " Dest", "d", "st", "wd", "src", "home", "source", "thin", "usr", "wb", "Dest", "dc", "path", "exit", "di", "tmp", "comb", "project", " destination", "du", "dist", "desc", "folder", "cont", "txt", "din", "sup", "destroy", "die", "gui", "prop", "temp", "img", "de", "nam", "dom", "style", "beta", "done", "name", "dir", "route", "coord", "doc", "dep", "trans", "flat", "test", "loc", "config", "default", "dat"], "bi": ["ga", "adi", "ba", " bio", "umi", "phi", "bas", "bh", "nb", "ori", "oci", "ti", "bb", "gb", "ni", "i", "ci", "qi", "gi", "bc", "ib", "BI", "di", "mu", "ki", "cli", "abi", "fa", "pi", "chi", "zi", "mini", "bs", "bm", "ai", "bin", "agi", "ii", "bis", "info", "b", "fi", "wei", "isi", "si", "vi", "li", "Bi", "ini", "ji", "ibi", "oi", "obi", "xi", "pin", "bank"], "os": ["oss", "OS", "cs", "ori", "bos", "aos", "i", "es", "cos", "ot", "nos", "ds", "los", "us", "is", "ors", "bs", "ou", "des", "vs", " bos", "ns", "dos", "co", "ls", "ms", "io", "s", "Os", "ws", "ios", "ops", "xs", "o", "oses", "pos", "outs", "rs", "oa", "osi", "so", "ob", "oos", "out", "oS", "oes", "fs", "ks"]}}
{"id1": "8468859", "id2": "3536332", "code1": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"status": ["session", "version", "sync", "standard", "ui", "content", "user", "site", "source", "output", "success", "progress", "str", "response", "server", "fail", "speed", "wait", "parent", "min", "full", "temp", "type", "stat", "state", "style", "edit", "unit", "Status", "update", "code", "step", "stage", "skip", "result", "index", "current", "log", "si", "count", "summary", "complete", "login", "continue", "active", "use", "id"], "reply": ["address", "next", "sync", "prefix", "data", "request", "send", "reason", "response", "server", "second", "answer", "dy", "repl", "respond", "base", "random", "query", "ping", "error", "vote", "fee", "bot", "connection", "state", "call", "action", "comment", "code", "py", "info", "update", "result", "link", "Reply", "resp", "post", "ret", "count", " response", "message"], "isConnected": ["IsConnects", "isAccepted", "isAdaptified", "isAcceptted", "isConnectioneded", "isConnectaged", " isAcceptaged", "isAdapted", " isAcceptable", "isconnectedp", "isFinable", "isaConnecting", "isconnecteded", "isNECTing", "isAdapteded", "isAdapting", "IsConnectioning", " isConnectionalled", "isconnecteds", "isconnecteding", "isFinished", " isConnectable", " isConnectioned", "isAcceptaged", "isFinaged", "isConnectioning", "isaConnectified", " isConnecting", "isaConnected", "isConnectionished", "isConnecting", " isConnectaged", "isFining", " isConnectted", " isConnectioning", "IsConnections", "isaAdapted", "isFinalled", "isaAdapteded", "isaAdaptified", "isConnectionified", " isAccepted", "isConnectable", " isConnectionished", "isaAdapting", "isConnectp", "IsConnectp", "isNECTalled", "isConnectalled", "IsConnected", "isConnectified", "IsConnecting", "isConnectionp", "isConnecteded", "isNECTished", " isConnectished", "isNECTed", "isaConnecteded", "isConnectionalled", "isFined", "isConnectished", "IsConnectioned", "isFinted", "isConnectioned", "isConnects", "isConnections", "isAcceptable", "IsConnectionp", "isConnectted", " isConnectalled", " isAcceptted"]}}
{"id1": "12869602", "id2": "11154758", "code1": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        FileOutputStream fos = null;\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String filename = \"i.exe\";\n            fos = new FileOutputStream(filename);\n            client.retrieveFile(\"/\" + filename, fos);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fos != null) {\n                    fos.close();\n                }\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"factory": ["dinder", "pault", "affault", "ifuture", "pictionary", "ifault", "facuild", "newault", "dault", "ifuild", "newictionary", "fuild", "affactory", "finder", "facactory", "dictionary", "fault", "future", "newactory", "pactory", "ifactory", "newinder", "affuild", "facuture", "pinder", "fictionary", "dactory", "facault", "affuture"], "schemaLocation": ["schemaslocation", "schemasPath", "specmaLocation", "symlLocation", "schebasePosition", "schemlLocation", "schemalocation", "schemasLocation", "schemasPosition", "specbasePosition", "schemePosition", "symaLocation", "specmaPath", "symaFile", "symllocation", "schemeFile", "schemaPosition", "schemaFile", "symlFile", "schebasePath", "schemasFile", "specmaPosition", "symalocation", "specbaseFile", "schebaseFile", "schemaPath", "specmaFile", "schebaseLocation", "schemeLocation", "specbaseLocation", "specbasePath", "schemllocation", "schemlFile", "schebaselocation", "schemePath"], "schema": ["chemas", "scheml", "masmas", "defme", "mamas", "mama", "schege", "masmma", "vermas", "mage", "defma", "masma", "verml", "mamma", "cheml", "masge", "schemas", "verme", "schemma", "chege", "cheme", "verma", "chemma", "scheme", "defml", "chema", "defmas"], "validator": [" invalidater", " validner", "validoder", "valider", "Validoder", "Validater", "validner", " validation", " validoder", "valation", "validater", " valider", "Valider", "Validner", " invalidner", "valoder", "valater", " invalidator", "validation", "Validation", " invalider", "valator", "Validator", " validater"], "url": ["address", "f", "user", "uri", "ssl", "resource", "web", "xml", "feed", "path", "host", "server", "http", "sl", "URL", "text", "file", "method", "www", "location", "connection", "image", "buffer", "channel", "email", "b", "browser", "download", "l", "stream", "Url", "loc", "api", "config", "coll", "date"], "inputStream": ["downSteam", "downForm", "InputPath", " inputForm", "InputFile", "responseStream", "inputSteam", "inputForm", "responseSource", " inputSource", "InputStream", " inputFile", "downSource", " inputPath", "inputPath", "InputSource", "responseFile", " inputSteam", "inputFile", "InputSteam", "InputForm", "responsePath", "downStream", "inputSource"], "source": ["session", "target", "data", "format", "src", "uri", "service", "from", "string", "proxy", "resource", "document", "path", "ources", "SOURCE", "slice", "handler", "input", "class", "context", "text", "file", "reader", "method", "connection", "slave", "level", "s", "image", "channel", "result", "instance", "stream", "view", "parser", "Source", "ource", "scene", "out", "object", "model"]}}
{"id1": "3558512", "id2": "812803", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"out": ["loader", "dump", "filename", "OUT", "a", "data", "content", "string", "source", "i", "output", "server", "writer", "parent", "Out", "raw", "file", "conn", "page", "temp", "w", "bin", "gen", "err", "io", "buffer", "image", "name", "up", "archive", "obj", "client", "o", "outs", "exec", "cache", "pool", "report", "ex", "copy", "png"], "parser": ["loader", "system", "wrapper", "pillar", "plugin", "lp", "Parser", "parse", "xml", "builder", "upload", "per", "handler", "server", "pe", "pp", "writer", "class", "cp", "pkg", "parent", "base", "p", "txt", "processor", "file", "reader", "php", "er", "arser", "worker", "manager", "seed", "rar", "up", "as", "instance", "ss", "cache", "test", "tt", "copy", "master"], "on_disk": ["onnetdemand", "onbootlock", "on_demand", "on_storage", "onjspace", "onjdrive", "onnetdrive", "onJdisk", "off_delete", "onnetfile", "onnetdisk", "off_demand", "onbookdelete", "onJlock", "off_space", "off_drive", "off_file", "onjdisk", "onbootdisk", "off_storage", "on_space", "onjfile", "on_file", "off_disk", "on_lock", "on_delete", "onbookdisk", "onbootstorage", "onJdrive", "on_drive", "onbookdrive", "off_lock", "onnetspace", "onbootdrive", "onJdemand"], "in": ["f", "data", "socket", "inn", "source", "i", "thin", "con", "ax", "input", "inas", "kin", "min", "din", "file", "conn", "lin", "reader", "rin", "ins", "bin", "connection", "inner", "o", "c", "as", "win", "In", "stream", "pass", "inc", "ac", "IN", "ini", "r", "copy", "login", "again", "info", "pin"]}}
{"id1": "3309233", "id2": "23215235", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public void readFile(URL url) throws PedroException, IOException, ParserConfigurationException, SAXException {\n        this.zipFileName = url.toString();\n        URLConnection urlConnection = url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n        unzipNativeFormatFile(inputStream);\n        parseAlertFiles();\n        deleteAlertFiles();\n    }\n", "label": 0, "substitutes": {"params": ["pins", "ctx", "address", "comments", "data", "lines", "pm", "parse", "source", "i", "Parameters", "resources", "parts", "ds", "los", "reports", "par", "json", "p", "mes", "properties", "page", "sp", "ams", "type", "ls", "files", "phrase", "s", "results", "services", "py", "objects", "details", "settings", "types", "ps", "arms", "values", "Param", "keys", "strings", "config", "Par", "eps", "names", "options", "posts"], "param": ["ctx", "cm", "pb", "address", "vm", "pm", "camp", "string", "lc", " parameter", "path", "meter", "password", "option", "conf", "pc", "project", "monitor", "prom", "Parameter", "par", "mor", "parent", "mm", "am", "p", "km", "rem", "cp", "conn", "page", "mand", "part", "temp", "ams", "single", "connection", "comment", "arm", "contract", "name", "prem", "channel", "ram", "pri", "gram", "aram", "amp", "proc", "Param", "pool", "null", "config", "default", "object", "model", "iam"], "client": ["session", "help", "cm", "cl", "bird", "plugin", "service", "request", "ssl", "proxy", "connect", "resource", "app", "con", "handler", "host", "response", "http", "server", "cli", "project", "ce", "cp", "secure", "base", "p", "conn", "url", "apache", "connection", "comp", "force", "self", "google", "channel", "c", "api", "config", "Client"], "post": ["install", "pb", "next", "f", "pod", "push", "patch", "request", "form", "put", "upload", "send", "feed", "and", "response", "http", "server", "entry", "zip", "pp", "Post", "json", "base", "p", "op", "head", "load", "dd", "wp", "add", "query", "POST", "part", "hop", "comment", "submit", "set", "c", "pre", "pos", "proc", "posted", "body", "api", "create", "e"], "resp": ["comm", "re", "serv", "content", "ref", "rel", "received", "request", "resource", "success", "status", "handler", "rh", "response", "http", "server", "Resp", "fc", "Response", "rec", "json", "respond", "par", "req", "reply", "error", "conn", "page", "sp", "res", "err", "rep", "obj", "exec", "download", "body", "api", "enc", " response", "e"], "entity": ["data", "content", "ity", "string", "resource", "xml", "output", "status", "ent", "line", "person", "response", "entry", "el", "json", "base", "event", "conn", "translation", "connection", "unit", "element", "code", "ec", "coll", "obj", "instance", "article", "Entity", "body", "node", "activity", "enc", "attribute", "object", "model", "e", "agent"], "result": ["address", "data", "content", "row", "string", "source", "resource", "success", "output", "line", "response", "entry", "text", "desc", "value", "json", "url", "page", "translation", "res", "location", "place", "results", "Result", "name", "details", "property", "instance", "description", "ret", "report", "record", "default", "object", "status", "match", "message"]}}
{"id1": "17158020", "id2": "4921631", "code1": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 0, "substitutes": {"passwordString": ["PasswordText", " passwordBytes", " passwordText", "PasswordString", "passwordText", " passwordStr", "passStr", "passBytes", " passwordPassword", "passwordPassword", "PasswordBytes", "passwordBytes", "passPassword", "passString", "passText", "passwordStr", "PasswordPassword", "PasswordStr"], "digest": ["hedested", "diggest", "digit", "Digse", "mainHash", " digEST", "digEST", "signse", "genergest", "hedest", "diger", " digested", "digHash", "compit", "Digested", "signest", "generest", "Digester", "signer", "hedester", "digester", "compested", "signester", "generester", "Diggest", " digester", " diggest", " digse", "mainit", "DigEST", " diger", "digested", "mainest", "heder", " digHash", "Diger", "signEST", "mainested", " digit", "generer", "compHash", "compest", "Digest", "digse"], "raw": ["aws", "unsigned", "wrapper", "RAW", "rew", "row", "wrap", "alpha", "hex", "empty", "pure", "feed", "dec", "initial", "input", "unknown", "binary", "ng", "random", "block", "array", "load", "full", "temp", "missing", "secret", "shared", "Raw", "buffer", "image", "serial", "original", "channel", "instance", "local", "clean", "enc", "out", "null", "none"], "hash": ["version", "Hash", "data", "row", "ruby", "hex", "sh", "id", "response", "sha", "input", "html", "base", "block", "utf", "array", "url", "ashes", "secret", "dig", "image", "header", "hed", "her", "ash", "sum", "index", "ha", "pass", "cache", "mac", "kh", "key", "h", "auth", "rh", "message"]}}
{"id1": "8468859", "id2": "9718328", "code1": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "code2": "    public void actionPerformed(ActionEvent e) {\n        if (\"register\".equals(e.getActionCommand())) {\n            buttonClicked = \"register\";\n            try {\n                String data = URLEncoder.encode(\"ver\", \"UTF-8\") + \"=\" + URLEncoder.encode(Double.toString(questVer), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"name\", \"UTF-8\") + \"=\" + URLEncoder.encode(name.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"os\", \"UTF-8\") + \"=\" + URLEncoder.encode(os.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"jre\", \"UTF-8\") + \"=\" + URLEncoder.encode(jre.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(email.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"key\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"Qr7SchF\", \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"answers\", \"UTF-8\") + \"=\" + URLEncoder.encode(Integer.toString(getAnswers()), \"UTF-8\");\n                URL url = new URL(\"http://ubcdcreator.sourceforge.net/register.php\");\n                URLConnection conn = url.openConnection();\n                conn.setDoInput(true);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = rd.readLine()) != null) {\n                }\n                rd.close();\n                wr.close();\n            } catch (Exception ex) {\n            }\n            setVisible(false);\n        } else if (\"cancel\".equals(e.getActionCommand())) {\n            buttonClicked = \"cancel\";\n            setVisible(false);\n        } else if (\"never\".equals(e.getActionCommand())) {\n            buttonClicked = \"never\";\n            setVisible(false);\n        }\n    }\n", "label": 0, "substitutes": {"status": ["session", "version", "sync", "standard", "ui", "content", "user", "site", "source", "output", "success", "progress", "str", "response", "server", "fail", "speed", "wait", "parent", "min", "full", "temp", "type", "stat", "state", "style", "edit", "unit", "Status", "update", "code", "step", "stage", "skip", "result", "index", "current", "log", "si", "count", "summary", "complete", "login", "continue", "active", "use", "id"], "reply": ["address", "next", "sync", "prefix", "data", "request", "send", "reason", "response", "server", "second", "answer", "dy", "repl", "respond", "base", "random", "query", "ping", "error", "vote", "fee", "bot", "connection", "state", "call", "action", "comment", "code", "py", "info", "update", "result", "link", "Reply", "resp", "post", "ret", "count", " response", "message"], "isConnected": ["IsConnects", "isAccepted", "isAdaptified", "isAcceptted", "isConnectioneded", "isConnectaged", " isAcceptaged", "isAdapted", " isAcceptable", "isconnectedp", "isFinable", "isaConnecting", "isconnecteded", "isNECTing", "isAdapteded", "isAdapting", "IsConnectioning", " isConnectionalled", "isconnecteds", "isconnecteding", "isFinished", " isConnectable", " isConnectioned", "isAcceptaged", "isFinaged", "isConnectioning", "isaConnectified", " isConnecting", "isaConnected", "isConnectionished", "isConnecting", " isConnectaged", "isFining", " isConnectted", " isConnectioning", "IsConnections", "isaAdapted", "isFinalled", "isaAdapteded", "isaAdaptified", "isConnectionified", " isAccepted", "isConnectable", " isConnectionished", "isaAdapting", "isConnectp", "IsConnectp", "isNECTalled", "isConnectalled", "IsConnected", "isConnectified", "IsConnecting", "isConnectionp", "isConnecteded", "isNECTished", " isConnectished", "isNECTed", "isaConnecteded", "isConnectionalled", "isFined", "isConnectished", "IsConnectioned", "isFinted", "isConnectioned", "isConnects", "isConnections", "isAcceptable", "IsConnectionp", "isConnectted", " isConnectalled", " isAcceptted"]}}
{"id1": "13122204", "id2": "8788371", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"filename": ["nil", "uri", "src", "string", "source", "Filename", "path", "slice", "kl", "username", "folder", "json", "database", "txt", "utf", "fp", "url", "file", "fil", "fits", "fd", "directory", "files", "location", "jet", "module", "title", "name", "archive", "download", "FILE", "loc", "fn", "SourceFile", "il", "metadata"], "tempdir": ["zipDir", "zipdir", "Tempdirectory", " tempfolder", "tmppath", "tmpfile", " tempDIR", "testDir", "temdirectory", "testfolder", "tmpDIR", "tempfolder", "temdir", "zipfile", "tempdirectory", "tmpDir", "tmpfolder", "Temppath", "tmpdirectory", " temppath", "temfolder", "temDir", "tempDir", " tempfile", "Tempfolder", "Tempdir", " tempdirectory", "testdir", "tempfile", "temppath", "testdirectory", " tempDir", "tempDIR", "tmpdir", "zipDIR"], "dest": ["delete", "session", "target", "rest", " Dest", "st", "ui", "src", "git", "home", "source", "usr", "wb", "Dest", "output", "dc", "exit", "const", "slice", "handler", "di", "tmp", "zip", "iter", "comb", "writer", "dist", "desc", "store", "folder", "cont", "txt", "sup", "transfer", "die", "export", "walk", "temp", "opt", "de", "img", "cdn", "gen", "inner", "default", "done", "later", "std", "dir", "result", "proc", "trans", "flat", "outer", "test", "loc", "transform", "out", "null"], "fis": ["Fos", "ffos", "bos", "ffi", "ffus", "ffis", "fisi", "bi", "flais", "fus", "bus", "Fis", "flos", "bisi", "vus", "Fisi", "vos", "flis", "fais", "bais", "bis", "flisi", "fi", "Fais", "vi", "vis"], "BUFFER": ["TAFIN", " BUPLE", "TAFFER", " BUPER", "BUFIN", "CUPER", "CUFIN", "FAVER", " BUFIX", "CUVER", "UMVER", "MAFIX", "MAFFER", " BUVER", "BUFF", "BUFIX", "FAFIN", "BUVER", " BUFF", "FAFFER", "BUPLE", "UMFFER", "UMFIN", "MAPLE", "FAPER", "TAPER", "MAPER", "BUPER", "TAPLE", " BUFIN", "UMFF", "TAVER", "TAFIX", "CUFF", "CUFFER"], "zis": [" zi", "jis", "zori", "xhas", "zIS", " zIS", "jiss", "ziss", "Zisa", "Zais", "fes", "zipiss", "ezas", "zs", "zie", "ezori", " zas", "xis", "Zis", " zori", " zais", "zas", "zi", "zhas", "Zes", "xiss", " zes", "fais", " zs", "zisa", "fisa", "ezhas", "zipIS", "jie", "xs", "xori", " zhas", "ezis", "xIS", " zisa", "zipis", " ziss", "ji", "zais", "xas", "zes", "xi", "xie", "zips", " zie"], "entry": ["ga", "next", "ry", "cat", "je", "ie", " Entry", "lc", "source", "feed", "ent", "line", "valid", "server", "fr", "pe", "zip", "porter", "iterator", "folder", "nt", "file", "se", "reader", "part", "ident", "de", "exp", "inter", "ge", "connection", "inner", "spec", "element", "image", "archive", "ries", "obj", "her", "result", "match", "or", "rc", " reader", "stream", "inc", "enter", "si", "li", "ace", "cel", "record", "Entry", "info", "la", "e", "id"], "count": ["number", "f", "length", "allow", "next", "child", "core", "content", "cond", "counter", "time", "last", "weight", "end", "feed", "ind", "read", "limit", "iter", "list", "writer", "len", "parent", "base", "lock", "add", "file", "in", "part", "num", "type", "offset", "Count", "code", "name", "c", "b", "write", "skip", "size", "sum", "start", "max", "cache", "current", "log", "key", "val", "index", "use", "e", "id"], "data": ["number", "extra", "length", "d", "content", "format", "alpha", "feed", "zero", "pad", "str", "id", "read", "slice", "shift", "zip", "buf", "input", "binary", "len", "value", "base", "p", "block", "load", "reader", "buffer", "image", "name", "batch", "bytes", "write", "result", "pack", "size", "start", "DATA", "body", "index", "info", "la", "dat", "message"], "fos": ["Fos", "ffoos", "Fops", "Foos", "afops", "ffos", "bos", "fosi", "bios", "infosi", "infoos", "bops", "afis", "foos", "infops", "afios", "ffosi", " fios", "fios", "afos", "fops", "bis", "Fosi", "infos", "ffops", " fops"]}}
{"id1": "2525897", "id2": "15166511", "code1": "    public static byte[] decode(String cryptPassword, byte[] encoded, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decoded = cipher.doFinal(encoded);\n            return decoded;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"cryptPassword": ["encryptedpassword", "ryptPassword", "encryptedPass", "encryptedPassword", " cryptpassword", "cryptpassword", "ryptpassword", "ryptPass", "CryptPass", "Cryptpassword", "CryptPassword", "cryptPass", " cryptPass"], "encoded": ["deccoded", "ecoded", "escode", "encrypted", "decrypted", "ecode", "explcoded", "exploded", "Encored", "Encrypted", "encode", "explrypted", "decode", "enccoded", "escoded", "Encoded", "encored", "eccoded", "esccoded", "ecrypted", "escrypted", "explored", "Enccoded", "decored"], "salt": ["sALT", " seal", " sipher", "cALT", "sipher", " saled", "essalt", "essALT", "Salt", "essodium", "calt", "esseal", " sALT", "caled", "saled", "Sipher", "SALT", "seal", "Saled", "sodium", "Seal", "Sodium", " sodium"], "digester": ["digcher", " Diger", "generener", "digest", "Digener", " digest", "signitter", "diger", " Digest", "Digamer", " digitter", "signest", "generest", " Digester", "Digester", "signer", "signester", "generester", "digamer", " diger", " digamer", "Digitter", " digcher", "Diger", " digener", "digitter", "generer", "Digcher", " Digamer", "signcher", "digener", "Digest"], "random": ["author", "re", "monkey", "gener", "ro", "user", "runner", "unique", "remote", "resource", "token", "handler", "server", "password", "initial", "init", "creator", "root", "query", "chain", "winner", "reader", "temp", "normal", "network", "worker", "gen", "inner", "io", "range", "seed", "serial", "default", "right", "regular", "inv", "reg", "or", "rand", "exclusive", "cur", "general", "driver", "crypt", "r", "clean", "config", "extra", "out"], "i": ["hi", "phi", "f", "x", "it", "ui", "ti", "uri", "ni", "bi", "ci", "gi", "mu", "di", "h", "init", "abi", "pi", "chi", "zi", "p", "v", "in", "ai", "num", "u", "k", "m", "iu", "io", "inner", "ip", "ii", "o", "b", "c", "I", "multi", "ri", "j", "start", "n", "si", "li", "ini", "count", "oi", "index", "xi", "e", "id"], "hash": ["cover", "address", "version", "Hash", "row", "user", "check", "hex", "host", "sha", "password", "message", "total", "base", "block", "array", "url", "phrase", "chip", "secret", "seed", "image", "header", "code", "hed", "her", "ash", "sum", "ha", "pass", "cache", "mac", "kh", "crypt", "h", "master", "auth", "id"], "maxKeySize": [" maxKeysize", " maxKeyLength", "maxBlockSize", "maxSignLength", "maxSecretSIZE", "maxBlocksize", "maxCharsize", "maxBlockLen", "maxSecretSize", "maxBlockLength", "maxSecretLength", "maxSecretLen", "maxCharLength", "maxCharLen", "maxCharSIZE", "maxKeysize", "maxSignSIZE", " maxSecretLength", "maxKeySIZE", "maxSecretsize", "maxKeyLen", " maxSecretSIZE", " maxSecretSize", "maxCharSize", " maxSecretLen", "maxSignLen", "maxKeyLength", " maxKeyLen", " maxKeySIZE", "maxSignSize", " maxSecretsize"], "generator": ["initiator", "encator", "gener", "terminate", "initator", "generate", "geninator", "Generiator", "genrator", "generation", "genate", "terminator", "Generer", "Generation", "initate", "Generrator", "Generinator", "initrator", "Generator", "genator", "terminer", "generiator", "encer", "encation", "geniator", "encate", "generer", "generinator", "genation", "Generate", "termininator", "generrator"], "key": ["number", "row", "core", "user", " secret", "service", "source", "sign", "server", "ce", "Key", "p", "kid", "raw", "file", "chain", "temp", "type", "k", "gen", "secret", "phrase", "char", "box", "connection", "image", "seed", "pair", "ip", " object", "name", " source", "client", "or", "keys", "cache", "driver", "crypt", "copy", "word", "KEY", "id"], "cipher": ["scoder", "encoder", "Cursor", "Cipher", "scrypt", "encairo", "coder", "encipher", "encursor", "cryption", "ecryption", "Cryption", "encryption", "Cairo", "Coder", "scryption", "scipher", "Crypt", "cairo", "ecursor", "encrypt", "scairo", "crypt", "ecipher", "ecrypt", "cursor"], "decoded": ["deccoded", "ecoded", "ecoder", "decrypted", "recrypted", "deoder", "decoding", "decoder", "deoding", " decrypted", " deccoded", "deoded", "derypted", " decoder", "eccoded", "recoder", "recoded", "ecrypted", "recoding", " decoding"]}}
{"id1": "1966310", "id2": "13159394", "code1": "    public void init() {\n        super.init();\n        Runnable doActions = new Runnable() {\n\n            public void run() {\n                if (_plot == null) {\n                    _plot = newPlot();\n                }\n                getContentPane().add(plot(), BorderLayout.NORTH);\n                int width;\n                int height;\n                String widthspec = getParameter(\"width\");\n                if (widthspec != null) {\n                    width = Integer.parseInt(widthspec);\n                } else {\n                    width = 400;\n                }\n                String heightspec = getParameter(\"height\");\n                if (heightspec != null) {\n                    height = Integer.parseInt(heightspec);\n                } else {\n                    height = 400;\n                }\n                _setPlotSize(width, height);\n                plot().setButtons(true);\n                Color background = Color.white;\n                String colorspec = getParameter(\"background\");\n                if (colorspec != null) {\n                    background = PlotBox.getColorByName(colorspec);\n                }\n                setBackground(background);\n                plot().setBackground(background);\n                getContentPane().setBackground(background);\n                Color foreground = Color.black;\n                colorspec = getParameter(\"foreground\");\n                if (colorspec != null) {\n                    foreground = PlotBox.getColorByName(colorspec);\n                }\n                setForeground(foreground);\n                plot().setForeground(foreground);\n                plot().setVisible(true);\n                String dataurlspec = getParameter(\"dataurl\");\n                if (dataurlspec != null) {\n                    try {\n                        showStatus(\"Reading data\");\n                        URL dataurl = new URL(getDocumentBase(), dataurlspec);\n                        InputStream in = dataurl.openStream();\n                        _read(in);\n                        showStatus(\"Done\");\n                    } catch (MalformedURLException e) {\n                        System.err.println(e.toString());\n                    } catch (FileNotFoundException e) {\n                        System.err.println(\"PlotApplet: file not found: \" + e);\n                    } catch (IOException e) {\n                        System.err.println(\"PlotApplet: error reading input file: \" + e);\n                    }\n                }\n            }\n        };\n        try {\n            SwingUtilities.invokeAndWait(doActions);\n        } catch (Exception ex) {\n        }\n    }\n", "code2": "    public HttpResponse fetch(HttpServletRequest request) throws IOException {\n        GUI = SwingUI.getApplicatoin();\n        DefaultHttpClient httpclient = new DefaultHttpClient();\n        CookieSpecFactory csf = new CookieSpecFactory() {\n\n            public CookieSpec newInstance(HttpParams params) {\n                return new BrowserCompatSpec() {\n\n                    @Override\n                    public void validate(Cookie cookie, CookieOrigin origin) throws MalformedCookieException {\n                    }\n                };\n            }\n        };\n        if (Helper.useProxy()) {\n            HttpHost proxy = new HttpHost(Helper.getProxyServer(), Helper.getProxyPort());\n            httpclient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);\n        }\n        httpclient.getCookieSpecs().register(\"easy\", csf);\n        httpclient.getParams().setParameter(ClientPNames.COOKIE_POLICY, \"easy\");\n        String currentRemoteGAEHost = Helper.getRemoteServer();\n        try {\n            HttpUriRequest httpRequest = createRequest(request);\n            addHeader(request, httpRequest);\n            HttpResponse response = httpclient.execute(httpRequest);\n            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_FORBIDDEN) {\n                challengeProxy(currentRemoteGAEHost);\n            }\n            logger.info(Helper.count.incrementAndGet() + \" Response received from \" + request.getRequestURL().toString() + \", status is \" + response.getStatusLine());\n            GUI.updateFetchCount();\n            return response;\n        } catch (ClientProtocolException e) {\n            logger.error(\"Fetch ClientProtocol Error\", e);\n            throw e;\n        } catch (IOException e) {\n            logger.error(\"Fetch IO Error\", e);\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"doActions": [" plotAlAction", " animationCaactions", " plotActionactions", " plotAlaction", " plotCaaction", " plotCaactions", " plotActions", " plotCaAction", " animationActions", " animationCaaction", " plotActionctions", " plotActionaction", " animationAAction", " plotAlctions", " plotAactions", " animationAactions", " plotCactions", " plotAaction", " animationCaAction", " plotAAction", " animationCactions", " animationAaction", " plotAlactions", " plotActionAction"], "_plot": ["_fit", "_log", "_pl", "_chart", "_patch", "_project"], "width": ["number", "border", "wn", "length", "platform", "filename", "west", "port", "idth", "left", "weight", "flow", "Width", "wa", "capacity", "fall", "fb", "duration", "density", "speed", "writer", "wait", "high", "scale", "value", "window", "large", "shape", "hop", "page", "wp", "lon", "w", "down", "fill", "gender", "amount", "widget", "dim", "draw", "style", "image", "name", "design", "space", "write", "description", "size", "crop", "work", "fw", "age", "frame", "position", "area", "padding", "index", "quality", "layout", "pull"], "height": ["length", "bottom", "data", "wrap", "port", "row", "alpha", "weight", "thin", "angle", "pad", "slice", "id", "grid", "capacity", "h", "density", "duration", "deep", "scale", "window", "gravity", "margin", "gap", "thumbnails", "volume", "head", "rows", "shape", "inches", "grow", "th", "stroke", "shadow", "dim", "draw", "level", "style", "square", " heights", "image", "ip", "radius", "y", "right", "build", "Height", "resolution", "size", "arrow", "rank", "crop", "index", "view", "upper", "padding", "direction", "quality", "layout", "pull", "depth"], "widthspec": ["widthparse", "Widthspec", "weightstring", "lengthspec", "widthstring", "poolset", "weightSpec", " widthstring", "lengthparse", "weightstyle", "poolparse", "widthstyle", "sizespec", "lengthSpec", " widthstyle", "widthset", "sizeSpec", "poolspec", " widthset", "widthscale", "weightpec", "widthSpec", "WidthSpec", "sizescale", "Widthpec", "sizestring", "weightspec", "weightscale", " widthpec", " widthSpec", "Widthstyle", "lengthset", "poolSpec", " widthscale", " widthparse", "widthpec"], "heightspec": ["peightslip", "heetsspec", "peightspec", "heetspe", "heightspe", "heightsSpec", "heetslip", "peightspe", "heowspec", "weightspect", "peatspect", "heowsSpec", "weightsSpec", "heightsspec", "weowspect", "heetspec", "heightspect", "heatspec", "peatspe", "heatspect", "heekspec", "weightsspec", "heatsync", "heatslip", "heckspec", "heekspe", "heowsync", "heowsspec", "peatsync", "peightspect", "heakspec", "heekslip", "heowspect", "heaksync", "heakspect", "heaksspec", "heatsSpec", "heatsspec", "heeksspec", "hecksSpec", "peatspec", "weightspec", "peightsspec", "heightsync", "weowspec", "heckspect", "peatsspec", "hecksspec", "heatspe", "peightsync", "heightslip", "peatslip", "weowsSpec", "weowsspec"], "background": ["cover", "border", "wrapper", "ba", "gold", "blue", "prefix", "Background", "reference", "color", "ruby", "alpha", "source", "resource", "profile", "support", "gradient", "ignore", "bc", "comment", "foundation", "panel", "gray", "colour", "gravity", "base", "margin", "large", "shell", "sound", "brown", "shadow", "fill", "draw", "black", "focus", "brush", "image", "display", "buffer", "ghost", "shield", "collection", "regular", "pattern", "bg", "description", "rc", "ha", "pool", "summary", "padding", "theme", "area", "default", "back", "null", "ground", "clip", "pull", "callback"], "colorspec": ["colororesspec", "colandsspec", "colarspec", "collorespec", "colandsSpec", "coloursnp", "colorspace", "colonship", "collorspec", "colorespec", "colonsspec", "coloursspec", "collorespect", "collorspace", "colonspace", "colorspir", "Colonspec", "colonsSpec", "Colorslip", "colororspect", "coloresspec", "collectionspec", "colonspect", "colororesSpec", "colourspace", "colarspect", "colonspec", "colionsspec", "Colorespect", "colourspec", "Colorespir", "Colonslip", "colororsSpec", "collorespace", "colororespec", "Colonspace", "colionspec", "colorsnp", "colonslip", "colourspir", "Colorship", "Coloresnp", "colarship", "Colorspect", "colorespir", "colourspect", "colarsspec", "colorspect", "collorspect", "Colorsspec", "colorsSpec", "colionspace", "colandspect", "colorship", "Colonsspec", "colorespace", "collectionsspec", "Colorespec", "colionspir", "colionslip", "Coloreship", "Colorspace", "colionsnp", "colloresspec", "coloreslip", "Colorspir", "colorespect", "colorslip", "coloreship", "Coloresspec", "collectionspect", "colandspec", "Colorsnp", "colororespect", "collorsspec", "Colorspec", "coloresSpec", "colororspec", "colorsspec", "colororsspec", "coloresnp"], "foreground": ["forground", " foreparent", "flyellow", "roughmission", "flyground", "understal", "broadellow", "ftercast", "backmission", "foremission", "forefill", "forestal", "Foreparent", "forcast", "forstal", "fterbackground", "roughellow", "chement", "forepoint", "broadcast", "Forecast", " foreGROUND", "forment", "Forebackground", "roughfill", " forebackground", "roughbackground", "underparent", "roughcast", "backpoint", "ForeGROUND", "Foreground", "backbackground", "Foremission", "broadfill", "flycast", "fterGROUND", "undercast", "roughpoint", "checast", "Forepoint", "fterground", "foreparent", "underbackground", "forebackground", "underment", "chestal", "roughground", " forecast", "forement", "cheground", "foreellow", "broadground", "forecast", "underground", "flyfill", "foreGROUND"], "dataurlspec": ["datafilestr", "datalogparse", "dataurlstr", " datalogspace", "datafileparse", " dataurlparse", "dataUrlSpec", " dataUrlspec", "datastringspe", "dataURLstr", "dataURLparse", " datalogstr", " datalogspec", " datalogparse", " dataurlSpec", "dataurlspe", "dataURLspace", "dataurlparse", "datafeedspec", "dataURLSpec", "datafeedSpec", "dataUrlspe", "datafilespec", "datalogspec", "dataUrlspec", "datalogspace", "datastringspec", "datafilespace", " dataurlspe", "datalogstr", " dataurlstr", "datastringSpec", " dataurlspace", " dataUrlspe", "dataURLspe", "dataurlSpec", "dataurlspace", "dataURLspec", " dataUrlSpec"], "dataurl": ["thisUrl", "dataURL", "ataURL", "inputUrl", "thisURL", "inputurl", " dataURL", " database", "Datafile", "database", "thisurl", "ataurl", "datafile", "dataUrl", "imageURL", " datafile", "DataURL", "Dataurl", "thisfile", " dataUrl", "atabase", "inputURL", "ataUrl", "imageurl", "imageUrl", "DataUrl", "Database"], "in": ["f", "d", "a", "serv", "data", "isin", "socket", "inn", "source", "i", "resource", "con", "server", "t", "input", "inas", "init", "p", "din", "url", "reader", "ins", "bin", "err", "inner", "image", "b", "c", "as", "win", "In", "stream", "inc", "IN", "body", "ini", "r", "record", "h", "out", "login"]}}
{"id1": "10451698", "id2": "13891080", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"source": ["target", "filename", "sync", "data", "src", "ie", "from", "service", "string", "site", "resource", "sf", "proxy", "document", "path", "section", "SOURCE", "slice", "server", "iter", "project", "remote", "class", "ce", "folder", "parent", "secure", "origin", "root", "volume", "file", "url", "reader", "directory", "connection", "slave", "unit", "seed", "force", "image", "storage", "name", "archive", "client", "result", "stream", "start", "cache", "flat", "view", "current", "Source", "null", "ource", "copy", "use", "config", "object", "model"], "destinationDirectory": ["destructionPath", "destinationFile", "destinatorPoint", "destinationSystem", " destationDir", "destinationsFile", " destinationDir", " destinationFile", "destationPath", "DestinationPoint", "DestinationPath", "destinationDatabase", " destationPath", "destinatorDatabase", "destributionFolder", "destinatorSystem", "DestinationsDatabase", " destationDirectory", "destinationsSystem", "destinatorPath", "destinationPoint", "destinationFolder", "destinationsDirectory", "destinatorDirectory", "destructionFile", " destationFile", "destributionDirectory", "DestinationFolder", "destporaryDirectory", "DestinationsDirectory", "destinationsPoint", "destationFile", "DestributionDirectory", "DestributionPath", "destributionPath", "destporarySystem", "destationDirectory", "DestinationsPath", "DestributionPoint", "destructionDir", "DestributionFolder", "destructionDirectory", "DestinationsSystem", "destinationPath", "DestinationDatabase", "destinationsDatabase", "destributionPoint", "destporaryPath", "DestinationDirectory", "destinationsFolder", "destinationDir", "destporaryDatabase", "DestinationSystem", "destationDir", "destinationsDir", "destinatorFolder", " destinationPath", "destinationsPath"], "newDir": ["firstFile", " newDIR", "smallDIR", "nextDir", "firstDirectory", "Newdir", "NewFile", "smallFile", "smallDirectory", "newDirectory", "smallDir", "firstDir", "newDIR", " newdir", " newDirectory", "firstDIR", "newdir", "NewDir", "NewDirectory", "nextdir", "NewDIR", "nextFile", "nextDirectory"], "children": ["filename", "child", "parents", "data", "content", "words", "which", "other", "begin", "web", "rules", "Children", "sub", "blocks", "pes", "plus", "packages", "balls", "members", "each", "list", "iv", "opens", "when", "parent", "errors", "rows", "tests", "url", "mount", "events", "ins", "files", "sort", "roots", "ums", "collection", "pages", "kids", " Children", "all", "values", "current", "scenes", "plugins", "iblings", "loc", "uc", "projects", "names", "ul", "ools"], "i": ["hi", "f", "x", "d", "ori", "ui", "it", "ti", "ie", "uri", "bi", "lc", "ci", "gi", "qi", "end", "slice", "mu", "di", "h", "pi", "xi", "q", "p", "v", "in", "ai", "ix", "part", "u", "type", "m", "k", "iu", "io", "inner", "range", "ip", "ii", "y", "name", "o", "b", "ri", "I", "multi", "c", "fi", "j", "start", "n", "si", "key", "li", "ini", "oi", "mi", "ji", "index", "info", "e", "id"], "newFile": ["createfile", " newFiles", "createDir", "nextDir", "nextDirectory", "newSource", "nextFiles", "oldFiles", "oldDir", "createFile", "newSourceFile", "createSource", "oldFile", "NewFile", "newDirectory", " newSourceFile", "NewSourceFile", "NewFiles", "newFiles", "nextfile", "nextSourceFile", "Newfile", " newDirectory", "nextSource", "NewDir", "NewDirectory", "nextFile", "NewSource", "oldDirectory", "newfile", " newfile"], "output": ["application", "target", "operation", "address", "four", "core", "socket", "service", "other", "resource", "web", "flow", "put", "layer", "response", "Output", "kernel", "option", "generation", "writer", "console", "binary", "again", "parent", "error", "file", "page", "full", "temp", "network", "connection", "unit", "image", "display", "default", "change", "generated", "update", "o", "ilo", "result", "write", "outer", "external", "current", "control", "oper", "after", "complete", "copy", "config", "out", "object"], "input": ["inf", "child", "data", "socket", "request", "form", "resource", "flow", "ack", "through", "http", "binary", "this", "context", "text", "parent", "load", "raw", "error", "in", "Input", "reader", "temp", "keep", "connection", "inner", "io", "s", "image", "buffer", "self", "update", "client", "exec", "instance", "stream", "current", "inc", "ink", "audio", "config", "index", "out", "active", "pull"], "buff": ["f", "length", "bind", "bug", "rb", "data", "flush", "cod", "bb", "gb", "cf", "uff", "feed", "pad", "slice", "comb", "buf", "fb", "ff", "cp", "text", "txt", "load", "shape", "bin", "cb", "Buff", "boot", "gz", "bound", "oct", "char", "rib", "comment", "buffer", "ffff", "batch", "cmd", "b", "pack", "uf", "ph", "count", "fe", "ob", "back", "info", "cell"], "read": ["lex", " write", "f", "length", "x", "d", "sync", "allow", "readable", "find", "check", "parse", "Read", "end", "send", "feed", "and", "tell", "ind", "slice", "wait", "len", "text", "reading", "load", "add", "rate", "transfer", "raw", "reader", "select", "play", "se", "fill", "seek", "k", "io", "get", "buffer", "ip", "READ", "open", " count", "b", "write", "skip", "exec", "en", "close", "size", "reads", "start", "pass", "ask", "loop", "run", "index", "ink", "n", "count", " load", "copy", "use", "create", "id"]}}
{"id1": "19934218", "id2": "5632808", "code1": "    public static String doCrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "        @Override\n        public void respondGet(HttpServletResponse resp) throws IOException {\n            setHeaders(resp);\n            final OutputStream os;\n            if (willDeflate()) {\n                resp.setHeader(\"Content-Encoding\", \"gzip\");\n                os = new GZIPOutputStream(resp.getOutputStream(), bufferSize);\n            } else os = resp.getOutputStream();\n            transferStreams(url.openStream(), os);\n        }\n", "label": 0, "substitutes": {"text": ["ext", "TEXT", "length", "data", "content", "format", " Text", "string", "hex", "source", "path", "token", "str", "password", "editor", "font", "input", "binary", "this", "class", "context", "value", "txt", "EXT", "url", " TEXT", "in", "secret", "connection", "letter", "buffer", "seed", "image", "contract", "name", "code", "obj", "struct", "pattern", "Text", "key", "crypt", "config", "word", "object", "message"], "md": ["nm", "pd", "d", "ud", "dr", "data", "wd", "ad", "pm", "hm", "gd", "amd", "mad", "valid", "sha", " Md", "mn", "meta", "mm", "am", "Cmd", "bf", "MD", "dd", "od", "bm", "mand", "ma", "method", "mt", "m", "ms", " MD", "dig", "rm", "hash", "mb", "mg", "vd", "bd", "code", "dm", "sd", "cmd", "mod", "mode", "hd", "df", "me", "mac", "mag", "mp", "body", "def", "mc", "ld", "metadata", "mo", "map", "message"], "sha1hash": ["sha0sum", "sha256hex", "sha0hex", "SHA1Hash", "md1h", "SHA1h", "sha1sum", "sha256sum", "SHA2hex", "sha5h", "SHA2hash", "md6hash", "md1hex", "sha1Hash", "shaonesha", "shaonehash", "sha256sha", "sha2sha", "SHA2sum", "sha6h", "shaonehex", "sha2h", "shaoneh", "sha2hash", "sha0hash", "SHA1hash", "sha5hash", "SHA1hex", "md6sha", "SHA1sum", "md1sha", "sha6hex", "sha2hex", "sha256Hash", "md6hex", "sha1sha", "md6h", "sha6sha", "sha1h", "sha2sum", "md1hash", "sha5Hash", "sha5hex", "SHA1sha", "SHA2h", "SHA2Hash", "SHA2sha", "sha256h", "sha256hash", "sha5sha", "sha0sha", "sha1hex", "sha2Hash", "sha6hash"]}}
{"id1": "771802", "id2": "9824814", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public void run() {\n        if (status == COMPLETE) {\n            return;\n        }\n        waitRandom();\n        RandomAccessFile file = null;\n        InputStream inputStream = null;\n        boolean success = false;\n        URL url = null;\n        try {\n            BeatportAccessor beatportAccessor = new BeatportAccessor();\n            if (sessionCookies == null) {\n                sessionCookies = beatportAccessor.getSessionCookies(user, password);\n            }\n            url = new URL(new BeatportAccessor().getTrackDownloadUrl(downloadId, sessionCookies));\n            log.info(\"Open (DownloadWorker.run): \" + url);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", BeatportAccessor.userAgent);\n            connection.setRequestProperty(\"Cookie\", sessionCookies);\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                log.error(\"Unexpected response from server: \" + connection.getResponseCode());\n                error();\n                return;\n            }\n            if (connection.getContentType().indexOf(\"text\") >= 0) {\n                log.error(\"Tried to request: \" + url.toString());\n                log.error(\"Unexpected file content type from server: \" + connection.getContentType());\n                log.error(\"Server replied:\\n\" + getContentAsString(connection));\n                error();\n                return;\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                log.error(\"Invalid content length: \" + connection.getContentLength());\n                error();\n                return;\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            } else if (size != contentLength) {\n                changeTotal(0, contentLength - size);\n            }\n            if (new File(tmpFileName(fileName)).exists()) {\n                if (!new File(tmpFileName(fileName)).delete()) {\n                    throw new Exception(\"Could not delete file: \" + tmpFileName(fileName));\n                }\n            }\n            file = new RandomAccessFile(tmpFileName(fileName), \"rw\");\n            file.seek(downloaded);\n            inputStream = connection.getInputStream();\n            if (started == 0) {\n                started = System.currentTimeMillis();\n                time = started;\n            }\n            statusChangedObserver.statusChanged(status);\n            byte buffer[] = new byte[MAX_BUFFER_SIZE];\n            while (status == DOWNLOADING) {\n                if (size - downloaded < MAX_BUFFER_SIZE) {\n                    buffer = new byte[(int) (size - downloaded)];\n                }\n                int read = inputStream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                changeTotal(read, 0);\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                stopped = System.currentTimeMillis();\n                status = COMPLETE;\n            }\n            statusChangedObserver.statusChanged(status);\n            stateChanged();\n            success = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            error();\n        } finally {\n            try {\n                file.close();\n            } catch (Exception e) {\n            }\n            if (success) {\n                try {\n                    if (!new File(tmpFileName(fileName)).renameTo(new File(fileName))) {\n                        throw new Exception(\"Rename Failed\");\n                    }\n                } catch (Exception e) {\n                    log.error(\"Error moving temp file \" + tmpFileName(fileName) + \" file: \" + fileName, e);\n                }\n            } else {\n                try {\n                    new File(tmpFileName(fileName)).delete();\n                } catch (Exception e) {\n                    log.error(\"Error deleting erroneous temp file: \" + tmpFileName(fileName), e);\n                }\n            }\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                log.error(\"Error closing input stream of: \" + url + \" / \" + fileName, e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"inFile": ["outStream", "infile", "outFiles", "incStream", "sourceStream", "insfile", "inputfile", "incFile", "insFiles", "inputStream", "insStream", "inputFiles", "sourceFiles", "outfile", "incfile", "incFiles", "inFiles", "insFile", "inStream", "inputFile", "sourceFile", "sourcefile"], "outFile": ["outStream", "infile", "inputTime", "workingfile", "inDir", "inputfile", "workDir", "targetStream", "targetfile", "workingStream", "outfile", "outTime", " outStream", "targetFile", "inputDir", "outDir", "inTime", " outDirectory", "workTime", "inputFile", "targetDirectory", " outfile", "workingFile", "workfile", "workingDirectory", "workFile", "outDirectory"], "k_blockSize": ["k_BlockLength", "k_blockLength", "k_lineCount", "k_byteLength", "k_bitSize", "k_byteSize", "k_lockLen", "k_byteCode", "k_byteLen", "k_lineSize", "k_BlockSize", "k_blockInfo", "k_bitInfo", "k_blocksLen", "k_BlockCode", "k_lockCode", "k_blocksSize", "k_byteInfo", "k_bitCount", "k_blocksLength", "k_lineInfo", "k_blockCount", "k_lockSize", "k_byteCount", "k_BlockCount", "k_lockCount", "k_blockCode", "k_lockLength", "k_blocksCount", "k_blockLen"], "byteCount": ["flushSize", "characterLength", " byteSum", "flushLength", "bytecount", "byteSize", "characterSize", "ByteLength", "flushcount", "blockSum", "byteLen", "ByteLen", " byteLength", "blockLength", "flushCount", " byteSize", "ByteCount", "byteLength", "characterLen", "characterCount", " byteLen", "Bytecount", " bytecount", "ByteSize", "blockCount", "byteSum", "blockSize", "ByteSum"], "buf": ["queue", "border", "ctx", "bh", "rb", "data", "feat", "flush", "src", "brace", "feed", "alloc", "font", "tmp", "buff", "fb", "ucc", "cv", "seq", "len", "cas", "base", "bf", "vec", "fd", "img", "cb", "Buff", "exc", "buffer", "Buffer", "batch", "cmd", "bytes", "b", "result", "background", "rc", "uf", "loc", "cap", "append", "config", "bag", "la"], "ofp": ["fort", "ofc", "OFl", "forp", "Oftp", "OFt", "OFc", "afnp", "OFp", "afc", "Ofl", "oft", "Oft", "forc", "OFtp", "Ofnp", "Ofc", "ofl", "afp", "afl", "oftp", "OFnp", "fortp", "ofnp", "Ofp"], "zos": ["zig", "bos", "cfg", "core", "inos", "los", "abi", "zon", "zx", "enos", "nox", "bitcoin", "outs", "iframe", "modules", "oda", "hz", "zn", "ZI", "ozo", "zik", "zers", "zb", "zar", "ossus", "zona", "zy", "zi", "zyk", "bs", "obb", "fits", "owicz", "css", "gz", "iffs", "bes", "lol", "uz", "js", "packs", "zes", "ogl", "nz", "budget", "za", "liquid", "rons", "cos", "zag", "zip", "z", "os", "zo", "zin", "ls", "ws", "rez", "ros", "osi", "oS", "zer", "obs", "tz", "ses", "lins", "zen", "dylib", "robe", "ZA", "forge", "zl", "utils", "webkit", "jas", "soon", "ops", "oses", "kos", "zh"], "osw": ["eswd", " osww", "bwo", "esd", "osws", "issw", "esww", " osfw", "ossfw", "bsws", "isd", "bswo", "ossww", "osow", "ossow", "osshell", "ossw", "isw", "bx", "esow", "osfw", "ossd", "osswd", "esw", "essw", "osnow", "osssw", " osow", "iswd", "osx", "lswo", "oshell", "lsw", "bsx", "isy", "esnow", "lsx", "oswo", "ishell", "osd", "esfw", "bsw", "ossy", "osy", "osww", "eshell", "oswd", "ossnow", "bws", "esy", "lsws", "isnow"], "bw": ["Bew", "bbw", " bws", "lbr", "abW", "ebW", "bbew", "lbw", "lbsw", "bwh", "bwd", "abwd", "Bws", "fwh", "baw", "abwe", " bwa", "Bw", "fx", "fr", "bx", "bz", "bwu", "lbwa", "fbw", "bbws", "bbz", "ow", "bbwu", "fsw", "owu", "bW", "bbwh", "lw", "abw", "fbW", "lwa", "lx", " bwh", "oaw", "lbwh", "lbws", "lbz", "ebwe", "bbwa", "lsw", " bew", "fbwe", "owa", " baw", "ebwd", "fwa", "bsw", "bew", "ebw", "bbaw", "Bwa", "bwa", "fw", "bwe", "lbx", "bws", "fbwd", " bwu", " bz"], "zot": ["zori", "Zot", "zerita", "Ziot", " zor", "Zit", "jos", "Zor", "ziot", " zori", "zor", "aziot", "jit", "zeros", "zott", "azit", "jori", "azita", "azott", "Zott", "zerott", "zita", " ziot", "zerot", "zerori", "azor", "azot", "Zita", "zerit", "jot"], "ifp": ["ifi", "Iff", "iff", "ipc", "ifc", "IFl", "IFf", "IFb", "ipb", "Ifc", " iff", "ipp", "IFi", " ifc", " ifb", "IFp", "Ifi", " ifl", "IFc", "ifl", " ifi", "Ifp", "ipl", "ifb"], "zis": ["zeits", "zenIS", "jis", " zisi", "zeiss", "zIS", " zIS", "zits", "ziss", "zipip", "xits", "zib", "zipiss", "zenis", "zeip", "xis", "Zits", "zip", "Zis", "xais", " zais", " zib", "xisi", "jit", "jits", "zenib", " zits", "xib", "zisi", "xIS", "zenais", "zipis", "zeis", "Zip", "zais", "Ziss", "jisi", "zipits", "xit"], "isr": ["ispr", "isrb", "iscr", "ISr", "isrs", "ISrs", "issrs", "ISrc", "rispr", "ISrb", "risrb", "ISsr", " iscr", "irpr", " issr", "ISpr", "irr", "isrc", " isrs", "isssr", "irrc", "risrc", "risr", "isscr", "IScr", "issr", "irrb"], "br": [" BR", "bar", "ibl", "kr", "bl", "bh", "rb", "gr", "hr", "BR", "mr", "bro", "HR", "div", "sr", "bc", "str", "fr", "tr", "obl", "bsp", "bp", "sp", "img", "yr", " dr", "rib", " Br", "err", "Br", "arr", "shr", "b", "lr", "cro", "rs", "browser", "ctr", "ber", "ch", "body", "r", "ocr", "ob", " fr", "obi", "ibr"], "zit": [" zi", "zeits", "jip", "zipita", "zipith", "jIT", "zits", "xic", "jite", "zipip", "zenitter", "zipite", "zic", "jith", "zeith", " zite", "zeita", "zitter", "zipit", "zip", "zipIT", " zith", "jit", "xit", "zi", "jits", "zeIT", " zip", "zite", "zith", "zeit", "zeitter", " zits", "xith", " zic", "zita", "zenits", "zipitter", "zIT", "zenith", "jic", "jita", "zenit", "ji", "zipits", "xi"]}}
{"id1": "3309233", "id2": "4168534", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "label": 0, "substitutes": {"params": ["pins", "ctx", "address", "comments", "data", "lines", "pm", "parse", "source", "i", "Parameters", "resources", "parts", "ds", "los", "reports", "par", "json", "p", "mes", "properties", "page", "sp", "ams", "type", "ls", "files", "phrase", "s", "results", "services", "py", "objects", "details", "settings", "types", "ps", "arms", "values", "Param", "keys", "strings", "config", "Par", "eps", "names", "options", "posts"], "param": ["ctx", "cm", "pb", "address", "vm", "pm", "camp", "string", "lc", " parameter", "path", "meter", "password", "option", "conf", "pc", "project", "monitor", "prom", "Parameter", "par", "mor", "parent", "mm", "am", "p", "km", "rem", "cp", "conn", "page", "mand", "part", "temp", "ams", "single", "connection", "comment", "arm", "contract", "name", "prem", "channel", "ram", "pri", "gram", "aram", "amp", "proc", "Param", "pool", "null", "config", "default", "object", "model", "iam"], "client": ["session", "help", "cm", "cl", "bird", "plugin", "service", "request", "ssl", "proxy", "connect", "resource", "app", "con", "handler", "host", "response", "http", "server", "cli", "project", "ce", "cp", "secure", "base", "p", "conn", "url", "apache", "connection", "comp", "force", "self", "google", "channel", "c", "api", "config", "Client"], "post": ["install", "pb", "next", "f", "pod", "push", "patch", "request", "form", "put", "upload", "send", "feed", "and", "response", "http", "server", "entry", "zip", "pp", "Post", "json", "base", "p", "op", "head", "load", "dd", "wp", "add", "query", "POST", "part", "hop", "comment", "submit", "set", "c", "pre", "pos", "proc", "posted", "body", "api", "create", "e"], "resp": ["comm", "re", "serv", "content", "ref", "rel", "received", "request", "resource", "success", "status", "handler", "rh", "response", "http", "server", "Resp", "fc", "Response", "rec", "json", "respond", "par", "req", "reply", "error", "conn", "page", "sp", "res", "err", "rep", "obj", "exec", "download", "body", "api", "enc", " response", "e"], "entity": ["data", "content", "ity", "string", "resource", "xml", "output", "status", "ent", "line", "person", "response", "entry", "el", "json", "base", "event", "conn", "translation", "connection", "unit", "element", "code", "ec", "coll", "obj", "instance", "article", "Entity", "body", "node", "activity", "enc", "attribute", "object", "model", "e", "agent"], "result": ["address", "data", "content", "row", "string", "source", "resource", "success", "output", "line", "response", "entry", "text", "desc", "value", "json", "url", "page", "translation", "res", "location", "place", "results", "Result", "name", "details", "property", "instance", "description", "ret", "report", "record", "default", "object", "status", "match", "message"]}}
{"id1": "3252116", "id2": "10176678", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "label": 0, "substitutes": {"source": ["target", "f", "data", "content", "src", "uri", "from", "service", "string", "resource", "document", "output", "SOURCE", "slice", "password", "sl", "input", "this", "text", "dest", "parent", "base", "fp", "file", "url", "sp", "security", "connection", "secret", "buffer", "code", "result", "stream", "Source", "body", "ource", "config", "object", "e"], "s": ["ends", "S", "f", "d", "ses", "g", "ssl", "string", "sb", "es", "ds", "t", "is", "sl", "its", "ings", "p", "sg", "os", "rows", "ns", "als", "gs", "ins", "ls", "m", "results", "sets", "bis", "services", "ws", "ops", "bytes", "b", "rs", "ss", "ps", "ts", "n", "js", "si", "sym", "series", "strings", "r", "h", "fs", "e"], "hexDigits": ["hexdigats", "hexFormists", "hexDigit", "hexFormits", "hexSignings", "hexdigitives", " hexDigases", "hexSignists", "hexdigites", "hexEdists", "hexFormats", "hexSignats", "tempSignits", "hexEdites", "tempDigals", "hexDigals", "tempDigits", " hexDigings", "hashDigits", "tempSignists", "hexDigists", "hexSignals", "hexDigats", "hashDigists", "hexdigists", "hexFormitives", "tempSignals", "hexDigings", " hexDigit", "hexdigases", "hexEdals", "tempSignites", "hashFormits", "hexdigings", "hexdigit", "hashDigats", "tempDigists", "hashFormists", "hexDigases", "hexEdits", "hexDigites", "hexSignites", "hexSignases", "hexSignit", "tempDigites", "hexdigits", "hashFormats", "hashDigitives", "hexdigals", "hexSignitives", "hexSignits", "hexDigitives", "hashFormitives"], "md": ["cm", "um", "f", "mail", "pd", "nm", "sm", "wd", "pm", "em", "amd", "mad", "dc", "rpm", "sha", "mu", "di", "meta", "mm", "am", "bf", "MD", "dd", "mand", "ma", "mt", "m", " MD", "bd", "dig", "rm", "mb", "mg", "vd", "dm", "cd", "cmd", "hd", "df", "mac", "mag", "mp", "mc", "mi", "metadata"], "tmp": ["rb", "data", "app", "pad", "stuff", "fb", "buf", "buff", "pp", "meta", "dest", " temp", "base", "p", "txt", "array", "sup", "v", "params", "wp", "bp", "temp", "sp", "img", "cb", "now", "buffer", "seed", "cpp", "storage", "bt", "obj", "pre", "np", "proc", "ppo", "cmp", "test", "mp", "api", "append", "area", "config", "extra", "pointer"], "str": ["cs", "st", "dr", "data", "hr", "string", "hex", "div", "sr", "cr", "dec", "tr", "fr", "iter", "sl", "pr", "text", "txt", "v", "part", "sp", "temp", " substr", " sp", "err", "exp", "spec", "char", "style", "unit", "inner", "arr", "br", "code", "STR", "obj", "pos", "exec", "j", "ss", "doc", "Str", "ctr", "cur", "r", "enc", "sec", "stri", "dict"], "k": ["kk", "kw", "f", "d", "x", "g", "ck", "sk", "ks", "ku", "ki", "kat", "ek", "ak", "q", "p", "kid", "v", "w", "u", "y", "ko", "unk", "K", "c", "b", "o", "dk", "j", "work", "n", "mk", "ok", "key", "kick", "ch", "e", "id"], "i": ["hi", "phi", "f", "x", "a", "d", "ui", "it", "ti", "uri", "bi", "gi", "ci", "qi", "shift", "mu", "di", "t", "z", "abi", "pi", "chi", "p", "v", "in", "ai", "u", "iu", "m", "io", "ip", "ii", "y", "info", "c", "b", "I", "ri", "multi", "j", "l", "n", "si", "li", "ini", "oi", "ji", "index", "xi", "e"], "byte0": ["number5", "word5", "number2", "byte2", "word1", "number0", "pixel2", "bytek", "number1", "byte6", "pixel00", " byte1", "letterk", "number6", "number00", "pixelk", "byte1", " byte2", "pixel5", " byte00", "letter2", "word2", "letter0", "numberk", " byte6", "pixel0", "word0", "letter00", "pixel6", " byte5", "byte00", "byte5"]}}
{"id1": "15580610", "id2": "12380475", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"dir": ["target", "filename", "d", "data", "wd", "uri", "home", "domain", "div", "path", "output", "DIR", "db", "di", "project", "lib", "class", "group", "dist", "du", "folder", "window", "base", "root", "database", "file", "url", "fd", "directory", " directory", "files", "module", "name", "cd", "md", "Dir", "build", "env", "doc", "loc", "report", "config", "direction", "out", "object", "model"], "command": ["delete", "system", "help", "operation", "three", "child", "script", "which", "service", "request", "string", "domain", "document", "word", "path", "and", "reason", "password", "move", "project", "input", "cli", "this", "clear", "power", "menu", "function", "root", "database", "event", "array", "error", "query", "file", "volume", "shell", "history", "directory", "one", "connection", "slave", "action", "comment", "usage", "image", "force", "module", "media", "language", "name", "archive", "info", "argument", "cmd", "machine", "category", "exec", "pattern", "program", "component", "control", "Command", "config", "attribute", "model", "sequence", "sudo", "message"], "length": ["number", "join", "left", "last", "time", "section", "form", "end", "angle", "strength", "Length", "span", "distance", "capacity", "slice", "id", "l", "limit", "character", "zip", "duration", "class", "len", "power", "value", "creator", "head", "shape", "full", "part", "th", "type", "dim", "now", "square", "letter", "range", "style", "level", "inner", "before", "width", "or", "how", "size", "sum", "max", "prime", "ph", "position", "ength", "loc", "body", "count", "padding", "word", "both", "sequence", "match", "depth"], "process": ["application", "session", "system", "processing", "sync", "child", "script", "user", "Process", "service", "parse", "document", "app", "cess", "path", "output", "host", "plus", "project", "console", "this", "class", "group", "parent", "function", "p", "share", "processor", "task", "file", "handle", "method", "worker", "thread", "call", "connection", "display", "cmd", "machine", "pid", "exec", "result", "program", "component", "proc", "python", "run", "post", "use", "out", "status", "master"]}}
{"id1": "12055086", "id2": "15445861", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"source": ["target", "f", "src", "ie", "from", "service", "site", "i", "resource", "remote", "path", "sin", "ources", "SOURCE", "iter", "input", "base", "file", "reader", "down", "connection", "inner", "s", "image", "storage", "archive", "route", "stream", "cache", "view", "Source", "ource", "copy", "use", "config", "master", "e"], "dest": ["target", "content", "src", "orig", "home", "thin", "wb", "Dest", "path", "exit", "slice", "destruct", "comb", "tmp", " destination", "class", "dist", "desc", "folder", "file", "destroy", "die", "temp", "opt", "de", "img", "bin", "slave", "done", "later", "dir", "result", "pipe", "trans", "flat", "default", "null", "master"], "buf": ["queue", "ctx", "length", "bh", "rb", "data", "feat", "port", "src", "feed", "pad", "bc", "off", "tmp", "buff", "fb", "cv", "seq", "len", "cp", "ff", "base", "txt", "bf", "raw", "vec", "bp", "img", "cb", "bd", "buffer", "br", "code", "Buffer", "batch", "cmd", "b", "bytes", "result", "pos", "rc", "uf", "loc", "append", "uc", "config", "bag"], "in": ["gin", "f", "data", "isin", "socket", "src", "inn", "i", "thin", "con", "sin", "plus", "read", "is", "input", "init", "p", "min", "din", "url", "conn", "file", "rin", "reader", "ins", "bin", "inner", "io", "image", "up", "c", "b", "inside", "exec", "win", "In", "stream", "n", "inc", "IN", "nin", "ini", "tin", "login", "again", "pin", "id"], "out": ["ext", "f", "sync", "OUT", "socket", "i", "app", "output", "lib", "writer", "parent", "Out", "conn", "file", "part", "w", "down", "img", "bin", "exp", "err", "io", "inner", "image", "buffer", "up", "client", "obj", "o", "b", "outs", "exec", "outer", "win", "n", "inc", "at", "pool", "ex", "again"], "count": ["number", "f", "length", "allow", "child", "cond", "weight", "path", "feed", "ind", "id", "read", "limit", "zip", "len", "parent", "base", "lock", "num", "part", "handle", "type", "offset", "buffer", "Count", "code", "name", "c", "b", "all", "close", "size", "sum", "start", "max", "n", "cache", "pool", "current", "key", "ch", "val", "index", "coll", "use", "depth"]}}
{"id1": "9805906", "id2": "22366505", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"source": ["address", "core", "src", "uri", "from", "service", "string", "site", "resource", "remote", "sin", "ources", "SOURCE", "slice", "server", "http", "iter", "input", "this", "parent", "base", "file", "se", "connection", "slave", "unit", "s", "stream", "start", "current", "view", "Source", "series", "ource", "scene", "use"], "target": ["address", "next", "platform", "template", "it", "follow", "port", "src", "resource", "alias", "path", "output", "host", "replace", "goal", "project", "top", "enemy", "dest", "parent", "base", "root", "large", "database", "file", "office", "pointer", "connection", "to", "table", "force", "result", "settings", "arget", "Target", "out", "object", "null", "master", "effect"], "is": ["oss", "obs", "nis", "lis", "ists", "ris", "cs", "ori", "bos", "ui", "iss", "ses", "isl", "iris", "abs", "i", "es", "ais", "has", "ois", "im", "us", "gets", "its", "opens", "bs", "isa", "ics", "iso", "ai", "in", "ens", "ins", "ls", "io", "s", "ip", "bis", "IS", "mis", "ws", "ios", "ops", "oses", "as", "was", "or", "Is", "ps", "isi", "info"], "os": ["oss", "obs", "OS", "cs", "ori", "bos", "aos", "i", "es", "ais", "ose", "cos", "ies", "nos", "ds", "los", "us", "its", "bs", "ens", "vs", "dos", "boot", "io", "s", "Os", "ios", "ops", "o", "oses", "ips", "as", "pos", "outs", "or", "ues", "ss", "ps", "ros", "acs", "oa", "osi", "ows", "oos", "ols", "oes", "fs", "ks"], "done": ["defined", "next", "disabled", "data", "did", " finished", "last", "confirmed", "empty", "yes", "checked", "finished", "made", "progress", "dirty", "ready", "once", "nice", "due", "odo", "die", "expected", "foo", "part", "de", "got", "running", "one", "future", "later", "loaded", "doing", "started", "always", "current", "dad", " Done", "gone", "after", "complete", "enabled", "Done", "none"]}}
{"id1": "15241397", "id2": "14758866", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"request": ["application", "queue", "data", "user", "uri", "received", "resource", "document", "xml", "web", "subject", "server", "http", "initial", "input", "context", "query", "req", "event", "url", "reader", "method", "er", "type", "connection", "buffer", "image", "QUEST", "client", "result", "instance", "parser", "report", "complete", "object", "info", "Request", "message"], "response": ["application", "queue", "version", "data", "content", "site", "other", "wave", "resource", "document", "output", "host", "server", "model", "generation", "writer", "onse", "Response", "json", "respond", "function", "parent", "reply", "error", "page", "connection", "results", "image", "collection", "client", "result", "resp", "cache", "view", "pool", "body", "report", "out", "object", "status", "message"], "rewrittenQueryString": ["rewrittenQueryLine", "rewrittenUrlService", "rewrittenPageString", "rewwrittenRequestString", "rewrittenPageLine", "rewrittenQuestionText", "rewrittenRequestArray", "rewwrittenQueryLine", "rewrittenPageService", "rewrittenRequestString", "rewwrittenQueryText", "rewrittenQuestionLine", "rewrittenHeaderLine", "rewrittenRequestText", "rewrittenqueryString", "rewrittenqueryStr", "rewrittenQuestionStr", "rewrittenRequestStr", "rewwrittenQueryStr", "rewwrittenRequestService", "rewrittenqueryText", "rewwrittenRequestArray", "rewrittenUrlLine", "rewrittenQueryService", "rewwrittenRequestText", "rewrittenQueryStr", "rewrittenQueryArray", "rewwrittenQueryService", "rewrittenPageArray", "rewwrittenQueryArray", "rewwrittenRequestLine", "rewrittenRequestService", "rewrittenQueryText", "rewrittenHeaderService", "rewrittenRequestLine", "rewrittenQuestionString", "rewrittenqueryService", "rewwrittenRequestStr", "rewrittenUrlText", "rewwrittenQueryString", "rewrittenHeaderArray", "rewrittenUrlString", "rewrittenqueryLine", "rewrittenHeaderString"], "rewrittenUrl": ["rewatchedText", "rewwrittenUr", "rewrittenFile", "rerittenJar", "RewwrittenUrl", "RewrittenText", "rewwrittenUrl", "rewedUrl", "RewwrittenServer", "RewrittenFile", "RewwrittenUr", "RewrittenUrl", "rewardedHost", "rewrapedUrl", "rewoldedURL", "rewrawnUrl", "rerittenUrl", "rewatchedServer", "rewreatedurl", "rewanedURL", "rewoldedFile", "rewedURL", "rewoldedUrl", "rewriteUr", "rewriteFile", "rewroteUrl", "rewrapedUr", "rewrawnurl", "RewrittenLocation", "rewrawnText", "rewrittenServer", "rewrawnURL", "rewardedLocation", "rewatchedURL", "rewedHost", "RewrittenURL", "rewrittenLocation", "rewrittenUr", "rewrittenJar", "rewriteServer", "rewroteURL", "rewrittenurl", "rewreatedUrl", "rewardedUrl", "RewwrittenHost", "rewanedHost", "rewardedURL", "Rewrittenurl", "rewrittenHost", "rewanedUrl", "RewwrittenURL", "RewrittenServer", "RewwrittenFile", "RewwrittenLocation", "RewrittenUr", "rewwrittenServer", "rewrapedFile", "rerittenFile", "rewrapedURL", "rewanedLocation", "rewatchedUrl", "rewriteUrl", "rewriteText", "rewrittenURL", "RewwrittenText", "rewwrittenURL", "rewedJar", "rewreatedText", "rewrittenText", "rewwrittenFile", "rewroteurl", "rewwrittenHost", "rerittenHost", "rewwrittenurl", "RewrittenHost", "rewreatedURL", "rewedFile", "rewwrittenText", "rewoldedHost", "rerittenURL", "rewriteURL", "Rewwrittenurl", "rewedurl", "rewwrittenLocation", "rerittenurl", "rewwrittenJar", "rewroteJar"], "httpURLConnection": ["httpMRconnection", "httpURLConstruction", "httpLLconnection", "httpURLOperation", "httpUrlInterface", " httpURLNode", "httpURIContext", "httpLLConnect", " httpRLConstruction", "facebookPathConnection", "cacheURLConnection", "httpURConnect", "httpURChannel", "facebookPathconnection", "cacheUrlConnect", "httpHTTPInterface", "httpPathConnect", "httpPathChannel", "httpURIConnect", "httpDBConnection", "httpUrlconnection", "httpURLApplication", " httpRLConnection", "facebookPathChannel", "httpURConstruction", " httpRLConnect", "httpUrlApplication", "httpStreamConn", "facebookURLconnection", "httpUrlConnection", "httpHTTPApplication", "httpRLConn", "httpMRConnect", "httpHTTPConn", "facebookPathConnect", "httpGETInterface", "httpRLConnect", "facebookURLChannel", "httpURConnection", "cacheURLOperation", "cacheUrlConn", "cacheUrlOperation", " httpURconnection", "cacheUrlConnection", " httpRLContext", " httpURLconnection", "httpRLconnection", "httpUrlConn", " httpURLConnect", "httpLLConn", "httpUrlOperation", "httpStreamConnect", "httpGETConn", "facebookURLConnection", "httpHTTPConnection", "httpStringConnect", "httpURLConnect", "httpStreamOperation", "facebookURLConnect", "httpLLConnection", " httpURLInterface", "httpURNode", "httpGETApplication", "httpURIConnection", "httpURContext", " httpURLConn", " httpRLConn", "cacheURLConnect", "httpPathConnection", " httpURLConstruction", "httpLLOperation", "httpUrlConnect", "httpPathconnection", " httpHTTPInterface", "httpGETConnection", "httpDBNode", "httpURLConn", " httpHTTPConnection", "httpURLContext", "httpURLChannel", "httpStreamConnection", "httpRLConnection", "httpRLConstruction", "httpURLInterface", " httpRLconnection", " httpURLApplication", " httpURNode", " httpHTTPApplication", "cacheURLConn", " httpURLContext", " httpHTTPConn", " httpURConnect", "httpStringconnection", "httpMRConn", "httpMRConnection", "httpRLContext", "httpStringChannel", " httpURConnection", "httpDBConnect", "httpDBconnection", "httpURLNode", "httpURconnection", "httpStringConnection", "httpURLconnection", "httpUrlNode", "httpURIConstruction"], "header": ["cover", "filter", "column", "version", "next", "dr", "data", "core", "string", "section", "document", "token", "rule", "handler", "director", "line", "layer", "server", "second", "entry", "character", "iter", "list", "writer", "member", "group", "block", "head", "event", "error", "part", "er", "single", "comment", "buffer", "hash", "pair", "later", "channel", "player", "her", "Header", "component", "outer", "feature", "over", "definition", "bridge", "item", "key", "driver", "consumer", "after", "headers", "index", "default", "back", "info", "field", "date", "attribute", "match", "message"], "value": ["hello", "expression", "version", "child", "Value", "data", "content", "format", "string", "end", "server", "valid", "model", "entry", "option", "VALUE", "label", "password", "member", "text", "json", "parent", "function", "v", "variable", "type", "now", "comment", "letter", "get", "element", "media", "name", "archive", "job", "set", "property", "description", "index", "values", "item", "current", "key", "val", "field", "default", "object", "info", "attribute", "message"], "inputStream": [" inputWriter", "inputstream", "outputWriter", "Inputstream", "inputWriter", "outputSteam", "inputResource", "outputstream", "inputSteam", "InputResource", "InputStream", " inputstream", " inputSteam", "InputSteam", "InputWriter", " inputResource", "outputResource"], "outputStream": ["OutputFile", "inputstream", "inputStreamer", "referencestream", "outputFile", "referenceSteam", "OutputStream", "outputSteam", "responseSteam", "responseStream", "outputstream", "inputSteam", "OutputChannel", "Outputstream", "referenceStream", "responseChannel", "OutputSteam", "OutputStreamer", "referenceStreamer", "outputStreamer", "outputChannel", "responseFile", " outputFile", " outputChannel", " outputSteam"]}}
{"id1": "3252116", "id2": "22022715", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "label": 1, "substitutes": {"source": ["target", "f", "data", "content", "src", "uri", "from", "service", "string", "resource", "document", "output", "SOURCE", "slice", "password", "sl", "input", "this", "text", "dest", "parent", "base", "fp", "file", "url", "sp", "security", "connection", "secret", "buffer", "code", "result", "stream", "Source", "body", "ource", "config", "object", "e"], "s": ["ends", "S", "f", "d", "ses", "g", "ssl", "string", "sb", "es", "ds", "t", "is", "sl", "its", "ings", "p", "sg", "os", "rows", "ns", "als", "gs", "ins", "ls", "m", "results", "sets", "bis", "services", "ws", "ops", "bytes", "b", "rs", "ss", "ps", "ts", "n", "js", "si", "sym", "series", "strings", "r", "h", "fs", "e"], "hexDigits": ["hexdigats", "hexFormists", "hexDigit", "hexFormits", "hexSignings", "hexdigitives", " hexDigases", "hexSignists", "hexdigites", "hexEdists", "hexFormats", "hexSignats", "tempSignits", "hexEdites", "tempDigals", "hexDigals", "tempDigits", " hexDigings", "hashDigits", "tempSignists", "hexDigists", "hexSignals", "hexDigats", "hashDigists", "hexdigists", "hexFormitives", "tempSignals", "hexDigings", " hexDigit", "hexdigases", "hexEdals", "tempSignites", "hashFormits", "hexdigings", "hexdigit", "hashDigats", "tempDigists", "hashFormists", "hexDigases", "hexEdits", "hexDigites", "hexSignites", "hexSignases", "hexSignit", "tempDigites", "hexdigits", "hashFormats", "hashDigitives", "hexdigals", "hexSignitives", "hexSignits", "hexDigitives", "hashFormitives"], "md": ["cm", "um", "f", "mail", "pd", "nm", "sm", "wd", "pm", "em", "amd", "mad", "dc", "rpm", "sha", "mu", "di", "meta", "mm", "am", "bf", "MD", "dd", "mand", "ma", "mt", "m", " MD", "bd", "dig", "rm", "mb", "mg", "vd", "dm", "cd", "cmd", "hd", "df", "mac", "mag", "mp", "mc", "mi", "metadata"], "tmp": ["rb", "data", "app", "pad", "stuff", "fb", "buf", "buff", "pp", "meta", "dest", " temp", "base", "p", "txt", "array", "sup", "v", "params", "wp", "bp", "temp", "sp", "img", "cb", "now", "buffer", "seed", "cpp", "storage", "bt", "obj", "pre", "np", "proc", "ppo", "cmp", "test", "mp", "api", "append", "area", "config", "extra", "pointer"], "str": ["cs", "st", "dr", "data", "hr", "string", "hex", "div", "sr", "cr", "dec", "tr", "fr", "iter", "sl", "pr", "text", "txt", "v", "part", "sp", "temp", " substr", " sp", "err", "exp", "spec", "char", "style", "unit", "inner", "arr", "br", "code", "STR", "obj", "pos", "exec", "j", "ss", "doc", "Str", "ctr", "cur", "r", "enc", "sec", "stri", "dict"], "k": ["kk", "kw", "f", "d", "x", "g", "ck", "sk", "ks", "ku", "ki", "kat", "ek", "ak", "q", "p", "kid", "v", "w", "u", "y", "ko", "unk", "K", "c", "b", "o", "dk", "j", "work", "n", "mk", "ok", "key", "kick", "ch", "e", "id"], "i": ["hi", "phi", "f", "x", "a", "d", "ui", "it", "ti", "uri", "bi", "gi", "ci", "qi", "shift", "mu", "di", "t", "z", "abi", "pi", "chi", "p", "v", "in", "ai", "u", "iu", "m", "io", "ip", "ii", "y", "info", "c", "b", "I", "ri", "multi", "j", "l", "n", "si", "li", "ini", "oi", "ji", "index", "xi", "e"], "byte0": ["number5", "word5", "number2", "byte2", "word1", "number0", "pixel2", "bytek", "number1", "byte6", "pixel00", " byte1", "letterk", "number6", "number00", "pixelk", "byte1", " byte2", "pixel5", " byte00", "letter2", "word2", "letter0", "numberk", " byte6", "pixel0", "word0", "letter00", "pixel6", " byte5", "byte00", "byte5"]}}
{"id1": "7872659", "id2": "18793482", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"completePath": ["completeRoot", "completeHome", "CompleteDir", "successpath", "successMusic", " CompletePath", "completeCh", "flatCorp", "iteMusic", "correctPoint", "execpath", " CompleteFile", "successPath", "completeCorp", "execVol", " completeMusic", " CompleteDir", " completeDir", "completeVol", "CompleteFile", "successCh", " completePoint", " completepath", "correctRoot", "flatPoint", "correctPath", "CompleteHome", "progressPath", "execPath", "itepath", "execLoader", "completeDir", "completePoint", "flatRoot", "progresspath", " CompleteHome", "itePath", "CompletePath", "doneVol", "completeFile", "completepath", "donePath", "doneLoader", "completeMusic", "iteCh", "correctCorp", "donepath", " completeRoot", "flatPath", "completeLoader", " completeCorp", "progressVol", " completeFile", " completeHome", "progressLoader", " completeCh"], "masterFile": ["MasterFilename", " masterFilename", "configName", "MasterFiles", "masterFiles", "masterName", "cacheFiles", "masterFILE", "cacheFILE", "mastersPath", "configFile", "MasterPath", "configFilename", "cachePath", "cacheFile", "masterPath", "mastersFile", "mastersFiles", "MasterFile", "mastersFILE", " masterPath", "MasterName", "configPath", "masterFilename", " masterName", "MasterFILE"], "CustRatingFileName": ["CustRatingClassVersion", "CustRateFileDesc", "CustRateFileName", "CustRateFilenameDesc", "CustIndexFilesPath", "CustRatingFilesPath", "CustRatingFilenameSize", "CustIndexFilePath", "CustRatingFullSize", "CustRatingFileType", "CustRateFileSize", "CustRateFilenamePath", "CustRatingFilesSize", "CustRatingFilenamePath", "CustIndexFileName", "CustRatingFilesDesc", "CustRatingLineType", "CustRatingLineName", "CustRatingFilesType", "CustIndexFileVersion", "CustIndexFilesType", "CustRatingFileDesc", "CustRatingFilenameDesc", "CustRateFilenameSize", "CustRateFilePath", "CustRatingFilePath", "CustRateFilenameName", "CustRatingFullPath", "CustIndexFilesName", "CustRatingFileVersion", "CustRatingFullDesc", "CustRatingFilesVersion", "CustRatingFilesName", "CustRatingFileSize", "CustIndexFileType", "CustRatingLinePath", "CustRatingClassName", "CustIndexFilesVersion", "CustRatingFilenameName", "CustRatingFullName", "CustRatingLineVersion", "CustRatingClassType", "CustRatingClassPath"], "MovieIndexFileName": ["MovieConfigFolderFile", "MovieIndexClassName", "MovieEditFSize", "MovieConfigFolderVersion", "MovieIndexClassSize", "MovieIndexFileUrl", "MovieEditFileName", "MovieIndexFILEHandle", "MovieIndexFSize", "MovieConfigFileName", "MovieIndexFileHandle", "MovieIndexFilesUrl", "MovieIndexFILEFile", "MovieIndexFolderHandle", "MovieIndexFname", "MovieIndexPlaceHandle", "MovieConfigFolderHandle", "MovieIndexFILEName", "MovieIndexPlaceVersion", "MovieConfigFileFile", "MovieConfigFileHandle", "MovieIndexFName", "MovieConfigFolderName", "MovieIndexFILEVersion", "MovieIndexFileVersion", "MovieEditFileUrl", "MovieIndexFilesSize", "MovieIndexFUrl", "MovieEditFileSize", "MovieIndexFileSize", "MovieIndexPlaceName", "MovieEditFilename", "MovieIndexFilename", "MovieIndexFileFile", "MovieEditFUrl", "MovieIndexFilesname", "MovieIndexPlaceFile", "MovieIndexFolderName", "MovieEditFName", "MovieIndexFolderFile", "MovieIndexFolderVersion", "MovieIndexClassname", "MovieEditFname", "MovieIndexFilesName", "MovieIndexClassUrl", "MovieConfigFileVersion"], "inFile": ["infile", " infile", "incC", "inputSourceFile", "InSourceFile", "inputfile", "incFile", "inputF", " inF", "InF", "outC", "outfile", "incSourceFile", "Infile", "incfile", "inSourceFile", "InFile", "inputFile", "outSourceFile", "inF", "outFile", " inSourceFile"], "inC": ["outF", "inputC", "InCL", "innerCC", "InCC", "inputCC", "inCC", "inB", "InCI", "outCC", " inCC", "inputF", "outB", " inF", "InF", "outC", "innerFile", " inB", "inCL", "inCI", "InB", "InFile", "inputFile", "outCL", "InC", "inF", "outFile", " inCL", "outCI", "innerCI", "innerC"], "outFile1": ["outFiles2", "outPath3", "againC1", "outfileName", "outFiles3", "outputFileId", "outFilesFirst", "outFileName", "outPlaceId", "againFile1", "outfile1", "againC3", "outFId", "outPlaceName", "outPathFirst", "outputfileName", "outputFile2", "outPlace2", "againFileFirst", "outfileId", "outPath2", "outPath1", "againC2", "againCFirst", "outFile3", "outFileFirst", "outFName", "outCFirst", "outputFileName", "outFileId", "outF1", "outC3", "againFile3", "outFiles1", "outputfile1", "outputFile1", "outputfile2", "outF2", "againFile2", "outputfileId", "outfile2", "outPlace1"], "outC1": ["newcOne", "outB8", "newC1", "newCOne", "againB1", "againC8", "outc1", "outD8", "againC1", "newCFirst", "outC81", "outF8", "outcOne", "outc81", "outCOne", "newC81", "outCFOne", "outB1", "newcFirst", "outCF81", "outBOne", "againB2", "outD1", "outDFirst", "outB2", "outcFirst", "againC2", "outD2", "outCFirst", "outCFFirst", "outDOne", "againBOne", "outF1", "newc81", "outFOne", "againB8", "outF2", "againCOne", "outC8", "outCF1", "outD81", "newc1"], "outFile2": ["outFiles2", "outputfile5", "outputFile4", "outChannel1", "outfileTwo", "outFiles6", "outChannel6", "againFile1", "againLine2", "outFile4", "outputfile4", "outFiles4", "outFile6", "outLine1", "outDirectory4", "outDirectory5", "outfile4", "againLineTwo", "outLine6", "outFileTwo", "outLine2", "outputFile2", "outChannel2", "outputFileTwo", "outFilesTwo", "outLineTwo", "againFile6", "outFiles5", "outputFile5", "outFiles1", "outputfileTwo", "outputfile2", "againFile2", "againLine6", "outfile2", "outChannelTwo", "outDirectoryTwo", "againLine1", "outFile5", "outfile5", "againFileTwo", "outDirectory2"], "outC2": ["outCache1", "outB4", "outFTwo", "againB1", "againC1", "outCache4", "OutC1", "outFileII", "OutF2", "OutC2", "OutCII", "outFile4", "outF4", "OutFII", "outB1", "OutF4", "outCache2", "againBTwo", "outFileTwo", "outC4", "againB2", "outCacheII", "outB2", "againCTwo", "outFII", "againB4", "againC2", "outBTwo", "outF1", "OutC4", "OutF1", "againC4", "outF2", "outCII", "outCTwo"], "fileSize": [" fileSIZE", "bufferSize", "FileLength", "resourceSize", "fileAddress", "resourceAddress", "imageLength", "FileAddress", "fileSIZE", "imageSize", " fileMode", "FileSize", "resourceSIZE", "imageSIZE", "fileLength", "bufferMode", " fileLength", "fileMode", "FileMode", "FileSIZE", " fileAddress", "bufferLength"], "totalNoDataRows": ["totalNoDataChues", "totalNoPageRues", "totalNoPageRrows", "totalNoDataCOWS", "totalNoDataLOWS", "totalNoDataRues", "totalNoDataROWS", "totalNoPageROWS", "totalNoPageLows", "totalNoDataCues", "totalNoPageRows", "totalNoDataRrows", "totalNoDataCows", "totalNoDataChOWS", "totalNoDataChows", "totalNoDataLues", "totalNoPageLues", "totalNoPageLrows", "totalNoDataLows", "totalNoDataCrows", "totalNoDataLrows", "totalNoPageLOWS", "totalNoDataChrows"], "mappedBuffer": ["machedURL", "mashedBuffer", "MappedFile", "mashedFile", "mappedbuffer", "MappingBuff", "mippedURL", "MachedURL", "machedBuff", "MachedBuff", "mippedStream", "mppedStream", "mashedChannel", "Machedbuffer", "mapedFile", "machedFile", "mashedBuff", "mapedStream", "mippedBuffer", "mactedBuffer", "mappingChannel", "mactedBuff", "MappedStream", "MappingBuffer", "machedbuffer", "MappedBuffer", "mappedBuff", "mactedStream", "mppedBuffer", "mappedFile", "MachedBuffer", "machedBuffer", "mapedBuffer", "MachedStream", "mppedChannel", "MappedURL", "mippedBuff", "mapedURL", "MappedBuff", "MappingFile", "mppedBuff", "mappingFile", "MappingChannel", "machedStream", "mappingbuffer", "mappedStream", "mappingBuff", "Mappedbuffer", "mapedBuff", "mappingBuffer", "mappingStream", "mactedbuffer", "mappedURL", "mappedChannel", "MappedChannel", "machedChannel", "MachedFile", "MachedChannel"], "startIndex": ["startRow", " startSection", "startingIndex", " startCode", "startPoint", "stopindex", "endInfo", "startSection", "useIndex", "useindex", "stopCode", "initInfo", "startCode", "initOffset", "stopIndex", "endSection", "startingSection", " startPosition", "initindex", "endRow", "startindex", " startOffset", " startindex", "StartInfo", "endIndex", " startInfo", "startPosition", "StartIndex", "usePosition", "endCode", " startPoint", "StartPosition", " startRow", "endPosition", "stopRow", "startOffset", "useInfo", "initIndex", "endPoint", "startInfo", "StartOffset", "startingPoint", "startingPosition", "endindex", "Startindex"], "count": ["number", "length", "allow", "found", "child", "depth", "follow", "find", "counter", "time", "more", "other", "i", "weight", "ind", "limit", "list", "total", "len", "group", "add", "first", "part", "keep", "type", "call", "thread", "self", "force", "Count", "code", "name", "c", "order", "old", "all", "close", "size", "sum", "start", "max", "current", "loop", "cache", "pool", "key", "test", "index", "coll", "col", "id"], "currentMovie": ["thisMovie", "currentlyMovie", "CurrentTheme", "parentFilm", "parentmovie", "reportedImage", "currentlyPicture", "currentFilm", "CurrentFilm", "reportedMusic", "reportedMovie", "defaultImage", "reportedmovie", " currentFilm", "currentlyMusic", "currentTheme", "defaultFilm", "defaultMovie", "CurrentMovie", "Currentmovie", " currentMusic", "parentPicture", "currentMusic", "validTheme", "thisFilm", "parentMovie", "currentmovie", " currentImage", "validFilm", " currentPicture", "reportedPicture", "validmovie", "currentPicture", "thisPicture", "reportedTheme", "currentImage", "defaultMusic", "reportedFilm", "validMovie", "thismovie", " currentmovie"], "movieName": ["camname", "moviename", "MovieFamily", "filmNumber", "MovieNumber", "movieId", "MovieId", "voicename", "movieFamily", "moneyFamily", "camFamily", "filmname", "movieInfo", "voiceId", "moneyName", "moneyNumber", "camName", "MovieName", "MovieInfo", "filmName", "voiceInfo", " movieFamily", " moviename", "filmFamily", "movieNumber", "voiceName", " movieId", "Moviename", " movieInfo"], "customer": ["Customeri", "Customers", "ustomer", "Customer", " customers", " customER", " customeri", "mixER", "customor", "customER", "mixers", "mixer", "customers", "mixor", "ustomers", "Customor", "ustomER", "CustomER", "customeri", "ustomor", "ustomeri"], "rating": ["number", "rr", "data", "rated", "ruby", "alpha", "string", "resource", "RC", "rolling", "http", "including", "writer", "value", "reading", "rates", "rate", "rage", "url", "error", "ring", "score", "reader", "missing", "type", "comment", "ing", "range", "radius", "packing", "rc", "feature", "rank", "Rating", "setting", "r", "rice", "padding", "attribute", "ranking", "info", "writing", "id"], "outBuf1": ["outKbuffOne", "outKuf3", "outDuffn", "outCufOne", "outDuff1", "outBbuffOne", "outDuff11", "outBafOne", "outFaf1", "outFafOne", "outBaf3", "outFufCloud", "outBbuf11", "outBbuf1", "outBaft1", "outBufOne", "outBummerCloud", "outBalth2", "outBbuff8", "outCuf1", "outBbuf3", "outBuf8", "outBalth1", "outDuf1", "outKuf8", "outBufn", "outBummerOne", "outBbuff3", "outBaft11", "outFbuf91", "outKuf1", "outCuff0", "outBumOne", "outFuf91", "outKbuf3", "outBaf1", "outBaftn", "outBum01", "outBbuff0", "outBuf01", "outDuf3", "outBuffOne", "outBaf8", "outKbuff8", "outDuff3", "outBiff1", "outBaft3", "outBuff11", "outKuf2", "outBuf3", "outKbuff1", "outBuff1", "outBafCloud", "outBuff8", "outBiff01", "outBuf11", "outBuff3", "outKbuf1", "outCuff1", "outBbufn", "outBummer1", "outCuffOne", "outFbuf01", "outKufOne", "outBiff91", "outBbuf2", "outDufn", "outBbuf91", "outBum91", "outKbuf2", "outFbuf1", "outBum1", "outKbuff3", "outFafCloud", "outBuff2", "outBuffn", "outFufOne", "outBaf0", "outDuf11", "outBalth3", "outFuf1", "outBbuf01", "outBuf0", "outCuf0", "outBuf91", "outBuffCloud", "outBufCloud", "outFuf01", "outFbufOne", "outBbuff1", "outBuff0", "outBiffOne", "outBbufOne"], "outBuf2": ["outBuber20", "outBbuf1", "outBbuff200", "outFbuff2", "outBbufTwo", "outFuf8", "outBuf20", "outBbuff8", "outBuf8", "outWBufTwo", "outFuf82", "outWBuff2", "outFbuff4", "outWBbuff200", "outFufTwo", "outBoff200", "outBuf82", "outBbuffer12", "outWBbuff2", "outBbuffer4", "outFuf4", "outBum2", "outFbuf2", "outWBuff0", "outFuf12", "outBait4", "outBbuff0", "outFbuff1", "outBuffTwo", "outFbufB", "outWBuf8", "outBuff1", "outWBbuff8", "outBuff8", "outFuf2", "outBuff4", "outBbuffTwo", "outBuff12", "outWBuff4", "outBuffB", "outWBuff8", "outFbuff82", "outBbuff4", "outFbuf4", "outBuber82", "outFbuffTwo", "outFuf20", "outBum82", "outBbuf2", "outBoffTwo", "outBbuff20", "outWBuf2", "outFufB", "outBbuff2", "outBbuf12", "outBait200", "outBbuffer2", "outBum20", "outBuff2", "outBbufB", "outWBbuffTwo", "outBait2", "outFbuff8", "outBbufferB", "outBait8", "outBoff2", "outBufB", "outBaitTwo", "outFuf1", "outBuf0", "outFbuff20", "outBbuff82", "outBuber8", "outBufTwo", "outBuf200", "outWBuf0", "outWBuf200", "outBuf12", "outBbuf4", "outBuber2", "outFbuf12", "outBuf4", "outBbuff1", "outWBuf4", "outBum8", "outBoff8", "outBait0", "outBuff0"], "endOfIndexFile": ["endOfindexTime", "endOfIndexfile", "endofindexFolder", "endOfDatafile", "endOfindexfile", "endofLinkDir", "endofLinkFiles", "endOfLinkFiles", "endOfIndexFiles", "endOfDataFile", "endofIndexFolder", "endofLinkFile", "endOfClientTime", "endOfDataTime", "endOfImageFolder", "endOfImageFiles", "endfile", "endOfLinkfile", "ended\n", "endOfClientDir", "Endfile", " end\n", "endOfLinkFile", "endofIndexDir", "endOfIndexFolder", "endOfLinkDir", "endOfClientFile", "endOfindexDir", "endofindexFiles", "endOfClientFiles", "endOfImageFile", "endOfImageTime", " endfile", "endofindexTime", "endOfLinkTime", "endOfindexFiles", "endOfIndexTime", "endOfDataDir", "endOfIndexDir", "End\n", "endofIndexFiles", "end\n", "endofLinkTime", "endofIndexFile", "endofIndexTime", "endofindexFile", "endedfile", "endOfindexFolder", "endOfindexFile"]}}
{"id1": "3430784", "id2": "22536033", "code1": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"in": ["loader", "session", "gin", "f", "version", "serv", "it", "data", "content", "isin", "socket", "src", "request", "inn", "source", "i", "resource", "con", "read", "is", "input", "init", "inas", "load", "min", "din", "url", "conn", "file", "reader", "ins", "bin", "m", "into", "connection", "err", "inner", "get", "image", "buffer", "b", "inside", "as", "exec", "c", "win", "In", "pass", "cin", "inc", "ac", "IN", "work", "nin", "ini", "body", "ex", "r", "login", "config", "again", "id"], "contentTransferEncoding": ["contentTransferEnitting", "contentTransferencitting", "contentTransferEoder", "contentTransferencoder", "contentTransferAcasing", "contentPartEoder", "contentTransferEcoder", "contentTransferEryption", "contentTransferCoding", "contentTransferencoding", "contentRestEnoding", "contentTransferEcoding", "contentRestEncaming", "contentTransferEnoded", "contentTransferEncasing", "contentTransferEncryption", "contentRestEncoding", "contentPartEncasing", "contentTransferEndoder", "contentPartEoding", "contentRestEnording", "contentTransferCasing", "contentTransferEasing", "contentTransferEngoding", "contentTransferCearing", "contentRestEnoder", "contentPartEasing", "contentPartEncoding", "contentTransferEncosing", "contentTransferencording", "contentTransferEnryption", "contentTransferEcording", "contentTransferEngearing", "contentTransferEndasing", "contentTransferEncording", "contentTransferEnearing", "contentTransferCaming", "contentTransferEcaming", "contentTransferAcoding", "contentTransferEngasing", "contentTransferEncearing", "contentTransferEnoder", "contentTransferEnaming", "contentTransferEosing", "contentTransferEnording", "contentPartEryption", "contentTransferEnosing", "contentTransferEncoded", "contentRestEncording", "contentTransferCoded", "contentPartEncryption", "contentTransferAcosing", "contentTransferCryption", "contentTransferEnoding", "contentTransferEncitting", "contentTransferEoding", "contentTransferEncaming", "contentTransferCoder", "contentRestEncoder", "contentTransferEnasing", "contentTransferCording", "contentTransferEndoded", "contentTransferEndoding", "contentTransferAcoder", "contentRestEnaming", "contentTransferEncoder", "contentPartEncoder", "contentTransferEngoded", "contentTransferEcitting"], "tempBody": [" tempFile", "tempFile", " tempLife", "outputFile", " tempbody", "tempLife", "tempCore", "tmpLife", "TempCore", "outputBody", "outputLife", "tmpbody", "TempBody", "tempbody", "TempFile", "tmpBody", " tempCore", "tmpFile", "tmpCore", "Tempbody", "outputbody"], "out": ["ext", "sync", "OUT", "a", "data", "user", "socket", "source", "i", "resource", "app", "output", "path", "line", "off", "writer", "this", "init", "again", "parent", "Out", "base", "raw", "file", "page", "conn", "temp", "bin", "connection", "err", "io", "inner", "obj", "channel", "o", "client", "c", "outs", "exec", "cache", "pool", "body", "ex", "copy", "extra", "object", "null"]}}
{"id1": "23291583", "id2": "4750967", "code1": "    private ByteArrayInputStream fetchUrl(String urlString, Exception[] outException) {\n        URL url;\n        try {\n            url = new URL(urlString);\n            InputStream is = null;\n            int inc = 65536;\n            int curr = 0;\n            byte[] result = new byte[inc];\n            try {\n                is = url.openStream();\n                int n;\n                while ((n = is.read(result, curr, result.length - curr)) != -1) {\n                    curr += n;\n                    if (curr == result.length) {\n                        byte[] temp = new byte[curr + inc];\n                        System.arraycopy(result, 0, temp, 0, curr);\n                        result = temp;\n                    }\n                }\n                return new ByteArrayInputStream(result, 0, curr);\n            } finally {\n                if (is != null) {\n                    try {\n                        is.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            if (outException != null) {\n                outException[0] = e;\n            }\n        }\n        return null;\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 0, "substitutes": {"urlString": ["urlSource", "urlFile", "sourceSource", "ruleSource", "fileSource", "sourceStream", "httpstring", "urlUrl", "httpSource", "filestring", "urlStream", " urlstring", "fileString", "sourceUrl", "ruleString", "urlstring", " urlStream", "sourceString", "fileFile", "httpString", "httpFile", " urlFile", " urlUrl", "ruleUrl", " urlSource", "ruleStream"], "outException": ["outEvent", "againception", " outError", "OutError", " outEvent", "outception", " outception", "againException", "inEvent", "inception", "againEvent", "inException", "Outception", "OutException", "againError", "inError", "outError"], "url": ["f", "bel", "data", "jar", "uri", "ssl", "string", "source", "i", "resource", "web", "feed", "rule", "str", "server", "http", "ur", "sl", "el", "lib", "fb", "URL", "store", "base", "file", "page", "conn", "ls", "www", "image", "open", "job", "b", "lr", "build", "l", "ll", "Url", "log", "loc", "li", "api", "rl", "r", "fl", "il", "ul", "e", "ver"], "is": ["oss", "hi", "ir", "nis", "ris", "it", "ori", "src", "ie", "uri", "iss", "abs", "isl", "i", "es", "ais", "app", "web", "isf", "has", "ois", "ib", "http", "us", "iv", "its", "init", "internet", "isa", "os", "in", "ai", "iso", "be", "ms", "err", "ar", "get", "ip", "bis", "IS", "ws", "ri", "as", "was", "or", "close", "Is", "isc", "are", "stream", "js", "isi", "si", "api", "ob", "out", "info", "il", "eni", "fs", "id"], "inc": ["ir", "inf", "length", "circ", "occ", "inn", "lc", "Inc", "INC", "ci", "con", "sec", "const", "dec", "ind", "ign", "limit", "iter", "init", "nc", "rec", "lock", "min", "spl", "conn", "in", "sc", "num", "ins", "keep", "exp", "err", "level", "inner", "ii", "ec", "inse", "incre", "c", "pri", "acc", "rc", "ac", "loc", "uc", "enc", "index", "col"], "curr": ["perrs", "perru", "Currc", "verrs", "carrc", "perrd", "charrr", "curpr", "curre", "CurR", "urrd", "terril", " currc", "terrd", "perro", "verpr", "grrs", "Curru", "urr", " currb", "perrn", "Currs", "ferry", "surR", "ferro", "urrn", "surrc", "surru", "ferr", "urrr", "Curr", " curbr", "terrs", "verr", "curro", "carrs", "currr", "curR", "grr", "curru", "curbr", "urro", "Curpr", "currs", "carru", "carril", "carrd", " curre", " currd", "perbr", "charrn", "urrb", "surrs", "currc", "urrc", " currs", "ferrs", "grry", "perrc", "Curbr", "curril", "curry", "terr", " curry", "charr", "currd", "currb", "carR", " curro", "charro", "perr", "perrb", "carr", "currn", "surr", " curpr", "perrr", "surre", " curril", " curru", "grro", "verrc", "perre"], "result": ["cover", "length", "found", "data", "content", "uri", "request", "source", "resource", "success", "output", "diff", "response", "fr", "iter", "list", "search", "text", "parent", "json", "function", "root", "event", "array", "error", "page", "res", "product", "err", "comment", "results", "buffer", "range", "arr", "done", "Result", "info", "order", "rc", "sum", "memory", "current", "cache", "test", "ver", "ret", "report", "r", "complete", "continue", "default", "status", "master", "date", "grade", "match", "message"], "n": ["number", "an", "nu", "un", "x", "nb", "ni", "no", "i", "ln", "cn", "nl", "t", "z", "init", "nc", "len", "rec", "ng", "nt", "p", "min", "conn", "ns", "num", "u", "k", "m", "err", "net", "rn", "nor", "s", "na", "nn", "o", "c", "N", "j", "en", "l", "size", "nd", "ne", "nr", "dn", "pn", "fn", "r", "enc", "e", "sn"], "temp": ["unsigned", "extra", "data", "content", "emp", "cut", "source", "empty", "lc", "output", "diff", "str", "tr", "tmp", "iter", "zip", "input", "init", "wait", "fake", "dest", "stable", "base", "txt", "raw", "v", "full", "part", "tc", "now", "shared", "err", "buffer", "py", "pre", "old", "cache", "current", "test", "cur", "key", "loc", "clean", "copy", "Temp", "null"]}}
{"id1": "14758866", "id2": "20886320", "code1": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"name": ["named", "address", "filename", "prefix", "version", "data", "content", "uri", "time", "string", "source", "domain", "resource", "remote", "path", "str", "username", "parent", "base", "file", "full", "part", "type", "location", "connection", "NAME", "action", "image", "hash", "title", "Name", "ame", "size", "memory", "cache", "key", "config", "word", "object", "info", "names", "id"], "inputStream": ["inputstream", "inputStreamer", "outputFile", "inputChannel", "cacheSteam", "Inputstream", "execStream", "InputFile", "outputSteam", "outputstream", "inputSteam", " inputStreamer", "cacheStream", "execSteam", " inputChannel", "InputStream", "InputStreamer", "execChannel", " inputstream", "outputStream", "outputChannel", " inputSteam", "inputFile", "InputSteam", "cachestream", "execStreamer", "InputChannel"], "in": ["re", "data", "socket", "src", "source", "con", "path", "input", "Out", "din", "reader", "ins", "bin", "m", "err", "inner", "image", "buffer", "c", "exec", "In", "log", "inc", "IN", "r"], "out": ["bar", "debug", "dump", "prefix", "OUT", "data", "msg", "flush", "ref", "point", "user", "output", "line", "buf", "cli", "list", "writer", "group", "window", "Out", "lock", "parent", "query", "raw", "error", "conn", "params", "file", "part", "page", "v", "bin", "gen", "err", "inter", "state", "io", "println", "buffer", "up", "client", "obj", "pre", "print", "outs", "proc", "outer", "ger", "log", "pool", "key", "r", "ex", "sys", "object"], "url": ["address", "f", "data", "rel", "socket", "uri", "user", "service", "ssl", "string", "source", "resource", "web", "remote", "path", "feed", "server", "http", "ur", "org", "sl", "URL", "base", "event", "file", "page", "full", "impl", "method", "gl", "location", "connection", "image", "buffer", "open", "update", "coll", "client", "route", "b", "browser", "l", "download", "stream", "Url", "cache", "log", "loc", "api", "ob", "config", "object", "pull"], "remoteName": ["fullName", "RemoteUrl", "RemoteName", "remoteKey", " remoteUrl", "remotename", "localUrl", "remoteUrl", " remotePath", "localKey", "fullKey", " remotename", "fullname", "remotePath", " remoteKey", "RemoteKey", "RemotePath", "fullPath", "localPath", "Remotename"], "localName": ["Localname", "cachename", "localString", "globalString", "externalLocation", "cacheName", "remoteLocation", "remoteKey", "LocalFile", "locString", "remotename", "globalName", "externalName", " localPath", "locPath", "cacheString", "globalKey", "localKey", "remoteFile", "LocalPath", "cachePath", "localFile", " localKey", " localname", "locName", "remotePath", "locname", " localString", "localLocation", "localname", "LocalKey", "externalFile", "LocalName", "globalname", "externalname", " localFile", "globalPath", "LocalLocation", "localPath", "globalFile", "remoteString"], "host": ["target", "address", "prefix", "format", "uri", "src", "home", "domain", "string", "path", "server", "Host", "http", "arch", "username", "database", "head", "conn", "method", "type", "hard", "ip", "header", "dir", "component", "addr", "loc", "driver", "localhost", "config", "h", "proxy", "auth"], "prot": ["platform", "prefix", "serv", " protocols", "cert", "rel", "ref", "uri", "rot", "password", "afi", "pro", "cont", "p", "txt", " plat", "conn", "part", "prop", "stat", "att", "ios", "conv", "channel", "pos", " proto", "pattern", "pri", "ht", "proc", "nat", "pass", "addr", "test", "pt", " protocol", "def", "api", "Prot", "config", "col", "ocol"], "port": ["number", "target", "address", "f", "length", "version", "allow", "patch", "point", "socket", "time", "string", "service", "resource", "path", "Port", "slice", "server", "http", "password", "limit", "hour", "duration", "project", "PORT", "pr", "priority", "username", "value", "pi", "month", "p", "file", "hop", "select", "method", "timeout", "type", "connection", "future", "ip", "client", "channel", "pid", "width", "size", "pass", "ports", "phone", "position", "localhost", "config", "direction", "ort", "proxy", "id"], "cacheFile": [" cacheDir", "proxyDir", "acheUnit", " cacheUnit", "acheFiles", "CachePath", "achePlace", "storageFiles", "cacheUnit", "cacheFolder", "cacheUrl", "achePath", "cacheFiles", " cachePlace", " cacheDirectory", "acheFile", "storagefile", "proxyHelper", "lockHelper", "CachePlace", " cacheFolder", "remoteFile", "remoteMessage", "CacheFile", "proxyUrl", " cachefile", "cachePath", "CacheFiles", "achefile", "localFile", "remoteFolder", "lockFile", "baseFile", "CacheDirectory", "cacheDirectory", "storageFile", "basefile", "cacheHelper", "cacheMessage", "baseFiles", " cacheUrl", " cachePath", "localDir", "proxyFile", "cachefile", "cacheDir", "acheDir", "cachePlace", "localUnit", "localfile", " cacheMessage", "proxyFolder", "baseDir", "lockUrl", "storageDirectory", "lockDir", " cacheHelper", " cacheFiles", "proxyMessage", "Cachefile", "CacheDir"], "urlConnection": ["sslconnection", "downloadConnection", "urlconnection", "URLFlow", "uriFlow", "downloadconnection", "URLClient", "URLConnection", "uriconnection", "sslConnector", "webPool", "httpConnector", "httpconnection", "lStream", "sslApplication", "httpFlow", "webConn", "fileApplication", "URLConnect", "webConnection", "webQuery", "sslConnect", "webConnect", "httpConnect", "filePool", "URLQuery", "urlConn", "urlPool", "urlClient", "downloadConnector", " urlQuery", "sslCode", "urlStream", "lConnect", "urlApplication", "lConn", "urlCode", " urlClient", " urlStream", "fileConnection", "urlFlow", "URLconnection", "uriConnection", "urlConnector", "urlQuery", "lConnection", "httpApplication", "httpConn", "webApplication", "httpStream", "urlConnect", "webClient", "fileConn", "sslConnection", " urlApplication", " urlConnect", "httpConnection", "downloadConnect", "httpPool", " urlConn", "URLCode", " urlCode", "uriConnect", "URLApplication"], "httpURLConnection": ["safeURClient", "httpMRconnection", "httpURLLine", "HttpUrlApplication", "httpGETCon", "httpHTTPClient", "HttpUrlClient", "httpCLconnection", "thisDBConnect", " httpSLLine", "httpLLConnect", "safeLLConnection", "safeURConnector", "httpUrlLine", "buildDBContext", "httpTRConnector", "httpURConnect", "httpDBContext", "buildDBTransaction", "httpSLLine", "httpFLTransaction", "buildURLConnection", "httpUNConnector", "httpURIConnect", "httpDBConnection", "httpIOconnection", "httpUrlconnection", "httpURLApplication", "thisDBConnection", " httpSLConnect", "thisURLConnect", "safeURLConnect", "httpUNConnect", "httpDBTransaction", "safeURLClient", "httpUrlApplication", "buildDBConnect", " httpURLConnector", "HttpURLconnection", "httpUrlConnection", "httpURLConnector", " httpSLSession", "httpLLClient", "httpIOCon", "safeURConnect", "httpSLConnection", "HttpUrlconnection", "HttpURLClient", "httpURLSession", "httpURConnection", "buildDBConnection", "httpURClient", " httpURLClient", "buildURLConnect", "httpURLCon", "buildURLTransaction", " httpUrlConnect", "httpSLSession", "httpRLApplication", "httpRLconnection", " httpURLConnect", "httpFLConnection", "httpURLClient", "httpFLContext", "regularMRConnection", "safeLLConnect", "httpCLApplication", "httpHTTPConnection", " httpURLLine", "httpURLConnect", "safeURLConnection", "thisURLConnection", "thisURLClient", "httpLLConnection", "httpSLClient", "httpDBClient", "httpSLConnect", "httpURConnector", "httpUNClient", "httpURTransaction", "httpURIConnection", " httpUrlConnection", "httpCLConnect", " httpUrlConnector", "httpURContext", "httpHTTPConnector", "regularURLconnection", "httpFLConnect", "httpUrlSession", "HttpURLApplication", "safeLLClient", "httpUrlConnect", "httpURLTransaction", " httpUrlClient", "httpCLClient", "httpGETConnection", "httpURLContext", "httpUNConnection", "httpTRConnect", "httpHTTPConnect", "httpMRCon", "HttpUrlConnection", " httpURLSession", "httpRLConnection", "httpRLClient", "httpUrlClient", "thisDBClient", "httpURIClient", "regularMRconnection", "safeURLConnector", "httpMRConnection", "regularURLConnection", "buildURLContext", "httpTRConnection", "httpUrlConnector", " httpSLConnection", "httpDBConnect", "httpGETconnection", "httpCLConnection", "regularURLCon", "HttpURLConnection", "safeURConnection", "httpURLconnection", "regularMRCon", "httpTRClient", "httpIOConnection"], "responseCode": ["replyStatus", "replyState", "respMessage", "replyType", "respState", "ResponseType", "ResponseCode", "responseState", "respType", "ResponseMessage", "responseStatus", "ResponseState", "respStatus", " responseMessage", "respCode", "responseType", "replyCode", "responseMessage", "ResponseStatus", " responseType"], "lastModified": ["lastMinified", "nextMOD\n", " lastModification", "lastMODification", "lastmodification", "nextMod\n", " lastMODification", "lastModIFIED", "lastModsified", "lastmodIFIED", "lastMODized", "lastMod\n", "lastModsized", "lastModized", "lastMODIFIED", "lastModsification", "lastMinized", " lastModized", " lastModIFIED", " lastMODized", " lastMODIFIED", "lastMinification", "lastMOD\n", "lastModification", "lastMin\n", " lastMODified", "lastMODified", "lastModsIFIED", "lastmodified", "lastMinIFIED"]}}
{"id1": "1798720", "id2": "15645004", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"packageName": ["applicationName", "pkgName", "PackageNames", "sourceName", "packagename", "PackagePath", "pluginNames", "packageNames", "sourcePath", "modulename", "applicationNames", "pluginName", "pluginPath", "directoryDir", " packagePath", " packageNames", "pkgNames", "applicationname", "directoryname", "PackageName", "sourcename", "pkgname", " packagename", "directoryPath", "sourceDir", "moduleName", "pluginname", "Packagename", "pkgPath", "packagePath", "directoryName", "applicationPath", "modulePath", "moduleDir"], "fileContents": ["fileContent", "fileParts", "FileContents", "singleNames", "singleContent", " fileParts", "FileNames", "FileContent", "doParts", "FileTextures", "doNames", "fileSources", "FileSources", " fileTextures", " fileSources", "doContent", "resourceSources", " fileContent", "fileTextures", "resourceTextures", "FileParts", "singleParts", "resourceNames", "doContents", "singleContents", "resourceContents"], "fileNames": [" fileValues", "modelNames", "letternames", "resourceTypes", "Filenames", "FileValues", "multipleName", " fileNumbers", "modelnames", "FileContents", "fTypes", "fNames", "FileTypes", "FileName", "fContents", "FileNames", " filenames", "placeValues", "fileTypes", "FileNumbers", "fileValues", "fileName", " fileName", "fileNumbers", "multipleTypes", " fileTypes", "placeNames", "placeNumbers", "filenames", "resourceName", "letterNames", "letterContents", "modelContents", "fName", "resourcenames", "resourceNames", "multipleNames", "multiplenames"], "dirBase": ["fileBased", "packageRoot", "folderBased", "Dirbase", "moduleBased", "directoryBase", "dirRoot", "fileDir", "DirPath", "folderbase", "directoryDir", " dirRoot", "moduleBase", "DIRbase", " dirPath", "DirRoot", "DirBase", "directorybase", "dirbase", "fileBase", "folderPart", "filePart", "directoryBased", "dirPath", "packagePath", "dirDir", "folderBase", "moduleDir", "dirBased", "DIRBased", "packagebase", "DIRBase", " dirbase", "packageBase", "dirPart", "DIRPart", "modulebase", "filebase"], "packageDir": ["PackageDir", "packageFolder", "directoryDirectory", "PackagePath", "PackageDirectory", "folderPath", "directoryFile", "directoryFolder", "packageBar", "directoryDir", " packagePath", "moduleBase", " packageFolder", "packageFile", "packageDirectory", "moduleBar", "parentDir", "directoryPath", "PackageFile", " packageDirectory", "parentName", "packagePath", "directoryName", "folderBar", "folderBase", "parentFile", " packageFile", "parentFolder", "modulePath", "packageBase", " packageBar", "moduleDir", "folderDir", " packageBase"], "created": ["needed", "edited", "existent", "updated", "found", "controlled", "claimed", "founded", "confirmed", "successful", "made", "path", " existed", "raised", "activated", "creation", "added", "formed", "authorized", "icated", "failed", "creator", "sc", "true", "owned", "established", "worked", "were", "used", "ed", "Created", "aaaa", "paid", "generated", "loaded", "result", "required", "produced", "called", "null", "create", " Created"], "currentPath": [" currentPoint", "reportedRoot", " currentFolder", " currentRoot", "CurrentPath", "publicPath", "currentDirectory", "currentpath", "publicpath", "CurrentPoint", "reportedpath", "publicPoint", "CurrentDirectory", "Currentpath", "CurrentRoot", "publicDirectory", "currentPoint", "reportedPath", "currentRoot", " currentDirectory", " currentpath", "CurrentFolder", "currentFolder", "reportedFolder"], "i": ["hi", "phi", "f", "x", "d", "it", "ui", "ori", "ti", "ie", "uri", "g", "bi", "gi", "ci", "qi", "slice", "di", "h", "z", "init", "pi", "q", "zi", "p", "v", "ix", "ai", "part", "u", "type", "m", "iu", "yi", "io", "inner", "ip", "ii", "y", "name", "info", "b", "ri", "I", "c", "fi", "multi", "j", "start", "me", "n", "si", "isi", "key", "li", "ini", "oi", "ji", "mi", "index", "xi", "eni", "e", "id"], "file": ["f", "filename", "child", "it", "data", "source", "resource", "per", "path", "rule", "feed", "http", "pe", "File", "folder", "base", "function", "fp", "full", "files", "place", "io", "letter", "s", "unit", "name", "up", "dir", "b", "le", "or", "ile", "l", "work", "log", "fe", "use", "out", "il", "e"], "fos": ["Fos", "foes", "Fops", "Foos", " foS", "FoS", " foes", "infoos", "faos", " fo", "Fis", "pios", "foos", "infops", "phoS", "phos", "voes", " fios", "fios", " faos", "vos", "vo", "fops", "fis", "phops", "foS", "fo", "Fios", " foos", "pos", "pops", "infos", "Fo", "Foes", "po", " fis", "infis", "phaos", " fops", "Faos", "vops"], "fileSrc": ["fileDource", "FileSRC", "fileNRC", "fileAsrc", "FileDRC", "filescc", " fileSRC", " fileDrs", "fileNrc", "filesrc", "fileSRC", "FileDoy", "FileSource", "fileSoy", "fileAsoy", " fileDrc", "FileSrc", " fileScc", "FileDource", "fileSrs", "fileDrs", "fileAsRC", " fileDRC", " fileDcc", "fileNrs", "filesRC", "fileDoy", "fileDcc", "fileAsource", "FileSoy", " fileSrs", "FileDrc", "fileScc", "fileDRC", "fileSource", "fileDrc", "filesrs", "fileNcc"], "fileDst": ["FileSsh", "fileShSt", "fileSst", "FileDsc", "fileShst", "contentShSt", "fileFrc", "fileDST", "fileStst", "fileFsh", "contentShst", "fileDsc", "fileDSt", "contentDrc", "fileSST", "contentDST", "FileSrc", "contentShrc", "fileStST", "fileSSt", "FileDsh", "fileFst", "contentShST", "fileFsc", "FileDst", "fileStrc", "contentDSt", "fileStSt", "FileSsc", "fileDsh", "fileSsh", "fileShST", "contentDst", "fileSsc", "FileDrc", "FileSst", "fileDrc", "fileShrc"], "reader": ["loader", "author", "ry", "rr", "data", "row", "more", "ler", "builder", "per", "feed", "director", "handler", "layer", "server", "read", "editor", "holder", "entry", "iter", "e", "book", "reading", "url", "in", "rer", "er", "worker", "io", "inner", "rar", "buffer", "image", "right", "keeper", "rc", "stream", "parser", "audio", "driver", "report", "r", "ner", "Reader", "oder"], "writer": ["wrapper", "master", "walker", "author", "data", "words", "rw", "usher", "socket", "source", "former", "xml", "builder", "ler", "document", "per", "director", "handler", "layer", "wire", "server", "riter", "war", "editor", "with", "entry", "iter", "maker", "rator", "sheet", "book", "value", "office", "wr", "Writer", "w", "er", "worker", "writers", "widget", "style", "inner", "buffer", "header", "ee", "later", "ws", "written", "player", "write", "outer", "work", "parser", "driver", "key", "r", "writ", "ner", "word", "out", "writing", "e", "message"], "line": ["number", "column", "f", "sync", "row", "lines", "point", "string", "lc", "source", "end", "no", "feed", "LINE", "str", "id", "layer", "model", "entry", "message", "character", "cr", "lf", "text", "base", "day", "block", "jo", "url", "page", "lin", "inline", "part", "stroke", "ge", "connection", "comment", "letter", "style", "header", "char", "unit", "Line", "name", "code", "cle", "job", "look", "c", "write", "l", "link", "pass", "key", "r", "word", "col", "cell"]}}
{"id1": "22235113", "id2": "21368981", "code1": "    protected Object unmarshallXml(final Unmarshaller unmarshaller, final String accessUrl, final String nameSpace, final String replace, final String with) throws Exception {\n        final URL url = new URL(accessUrl);\n        final BufferedReader inputStream = new BufferedReader(new InputStreamReader(url.openStream()));\n        String xmlContent = readWithStringBuffer(inputStream);\n        if (replace != null) {\n            xmlContent = xmlContent.replace(replace, with);\n        }\n        LOGGER.info(\"Calls \" + accessUrl);\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"\\nXml:\" + accessUrl + \"\\n\" + xmlContent);\n        }\n        if (LOGGER.isDebugEnabled()) {\n            final BufferedWriter out = new BufferedWriter(new FileWriter(\"target/XmlAgentLog\" + xmlRequestNumber++ + \".txt\"));\n            out.write(xmlContent);\n            out.close();\n        }\n        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xmlContent.getBytes());\n        Source source;\n        if (nameSpace != null) {\n            source = setNameSpaceOnXmlStream(byteArrayInputStream, nameSpace);\n        } else {\n            source = new StreamSource(byteArrayInputStream);\n        }\n        return unmarshaller.unmarshal(source);\n    }\n", "code2": "    public APIResponse create(Application application) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/application/create\").openConnection();\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n        connection.setUseCaches(false);\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\")));\n        connection.getOutputStream().flush();\n        connection.getOutputStream().close();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\")).readLine()));\n            response.setDone(true);\n            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));\n            connection.getInputStream().close();\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Create Application Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "label": 0, "substitutes": {"unmarshaller": ["unmarsholdor", "unmarshalinging", "unmockallingester", "unmarsholders", "unmarshaler", "unmarshalor", "unmarmoldor", "unmarshalleder", "unmarmaller", "unmarshalingester", "unmockalling", "unmarmallor", "unmockallinger", "unmarshalinger", "unmarmalled", "unmockallator", "unmarshalleded", "unmockallester", "unmarshalingator", "unmarshallinging", "unmarmallers", "unmarmolded", "unmarshallingester", "unmarshallator", "unmockallingator", "unmarshallor", "unmockaller", "unmarsholder", "unmarshalledator", "unmarshallester", "unmarshalledor", "unmarshalleding", "unmarshalled", "unmarshalers", "unmarshalledester", "unmarshalleders", "unmarshalling", "unmarshallers", "unmarmolders", "unmarsholded", "unmarshallinger", "unmarshallingator", "unmarshaled", "unmockallinging", "unmarmolder"], "accessUrl": ["escapeURL", " accessPage", "accessibleFile", "accessiblePath", "requestUrl", "accessibleURL", "accessUr", "AccessPage", "accessLocation", " accessFile", "accessEl", "AccessEl", "AccessLocation", "AccessFile", "requestFile", "requestPage", " accessPath", "accessibleUrl", "escapeUr", "requestLocation", "accessPath", "accessFile", "AccessURL", "requestURL", "escapeFile", "AccessUrl", "requestUr", "accessPage", "requestPath", " accessURL", "AccessPath", " accessUr", "requestEl", " accessLocation", "accessURL", " accessEl", "escapeUrl"], "nameSpace": ["NameName", "namesSp", "namesName", "Namespace", " nameText", " namePoint", "NameSp", "resourceSp", "namesspace", "namePath", "nameSp", "NamePart", " nameSp", "NamePath", "connectionPoint", "connectionPart", "NameSpace", " namespace", "namespace", "nameText", " namePart", "connectionText", "connectionSpace", "namePoint", "resourcePart", "NamePoint", "namesSpace", "resourcePath", " namePath", "resourceSpace", " nameName", "NameText", "namePart", "nameName"], "replace": ["cover", "join", "operation", "address", "save", "prefix", "re", "patch", "format", "find", "parse", "string", "strip", "alias", "flash", "sub", "apply", "see", "where", "align", "repl", "insert", "group", "search", "tag", "store", "repeat", "share", "array", "add", "escape", "reply", "protect", "fill", "place", "comment", "get", "remove", "pair", "change", "force", "br", "name", "update", "space", "write", "placed", "places", "quote", "over", "same", "split", "append", "r", "complete", "like", "use", "fix", "be", "match", "message"], "with": ["join", " WITH", "prefix", "x", "plugin", "format", "from", "other", "around", "resource", "flash", "xml", "host", "and", "id", "some", "without", "then", "apply", "by", "context", "search", "tag", " With", "add", "claim", "properties", "params", "place", "spec", "style", "get", "partial", "name", "before", "settings", "work", "at", "include", "With", "layout", " without", "none", "message"], "url": ["address", "socket", "uri", "user", "service", "ssl", "string", "xml", "resource", "path", "feed", "host", "server", "http", "zip", "sl", "URL", "window", "base", "file", "conn", "page", "connection", "buffer", "image", "client", "channel", "browser", "l", "ll", "stream", "Url", "log", "rl", "fl"], "inputStream": ["inputstream", "outputReader", "Inputstream", "outputSteam", "InputReader", "outputstream", "inputSteam", "InputBuffer", "InputStream", " inputReader", "inputReader", " inputstream", " inputBuffer", "outputBuffer", "inputBuffer", "outputStream", " inputSteam", "InputSteam"], "xmlContent": ["mlMessage", " xmlStream", "phpFile", "mlStream", "phpContent", "phpContext", "xmlReader", "complexContent", "xmlStream", "exampleStream", "phpReader", "docComment", " xmlContext", "phpDocument", " xmlString", "docContent", "txtContent", "xmlCode", " xmlAddress", "txtFile", "phpMessage", "xmlDocument", "complexcontent", " xmlCode", "complexContext", "xmlComment", " xmlDocument", "docMessage", "phpAddress", "xmlAddress", "mlReader", "xmlContext", "exampleMessage", " xmlReader", "exampleContent", " xmlComment", "phpString", "txtAddress", "mlCode", "mlContent", "exampleContext", "mlContext", "txtMessage", " xmlMessage", "complexDocument", "phpCode", "docString", "xmlcontent", " xmlFile", "mlString", "xmlMessage", "xmlString", " xmlcontent", "phpcontent", "mlComment", "xmlFile"], "out": ["ext", "extra", "sync", "OUT", "prefix", "data", "flush", "user", "string", "flow", "builder", "output", "path", "line", "response", "password", "project", "writer", "init", "group", "again", "window", "Out", "array", "file", "page", "in", "full", "plain", "w", "temp", "exp", "gen", "err", "io", "inner", "name", "up", "write", "outs", "result", "doc", "outer", "stream", "log", "key", "report", "ex", "copy", "word", "object"], "xmlRequestNumber": ["httpResponseCounter", "xmlPageNum", "xmlResponseNumber", "httpRequestNo", "xmlRequestNo", "xmlVersionCounter", "httpResponseNum", "xmlPageCounter", "xmlResponseNum", "xmlRequestCounter", "httpRequestNum", "httpRequestCounter", "xmlResponseNo", "xmlResponseCounter", "httpRequestNumber", "httpResponseNumber", "xmlVersionNumber", "xmlPageNumber", "xmlPageNo", "httpResponseNo", "xmlVersionNo", "xmlVersionNum", "xmlRequestNum"], "byteArrayInputStream": ["byteArrayReadStream", "byteArrayByteSteam", "byteArrayReadSteam", "byteArrayInputFile", "byteArrayOutputArray", "byteArrayOutputSteam", "byteStreamInputStream", "byteStringInputStream", "byteStringInputSteam", "byteStringInputstream", "byteArrayInputView", "byteArrayByteFile", "byteStreamOutputstream", "byteArrayReadFile", "byteStreamInputArray", "byteArrayInstream", "byteArrayOutputstream", "byteStringOutputStream", "byteStringOutputstream", "byteStreamOutputSteam", "byteStreamInputSteam", "byteArrayInView", "byteArrayFilestream", "byteStringInputView", "byteArrayOutputView", "byteStreamInputstream", "byteStreamInputFile", "byteArrayInputstream", "byteArrayInputSteam", "byteArrayReadArray", "byteStringOutputView", "byteStreamOutputStream", "byteArrayByteView", "byteArrayInputArray", "byteArrayFileStream", "byteArrayOutputStream", "byteArrayFileArray", "byteStreamOutputFile", "byteArrayFileFile", "byteStreamOutputArray", "byteArrayReadstream", "byteArrayOutputFile", "byteStringOutputSteam", "byteArrayBytestream", "byteArrayInStream", "byteArrayInSteam", "byteArrayByteStream"], "source": ["session", "target", "wrapper", "data", "content", "core", "src", "uri", "service", "resource", "rule", "SOURCE", "str", "slice", "plus", "model", "iter", "zip", "speed", "sl", "input", "class", "ce", "text", "secure", "kin", "rate", "reader", "sp", "method", "type", "scope", "object", "connection", "slave", "spec", "style", "get", "unit", "comp", "seed", "inner", "info", "result", "component", "size", "stream", "view", "position", "Source", "node", "ource", "config", "copy", "scene", "proxy", "null", "use", "id"]}}
{"id1": "8490710", "id2": "14191679", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 0, "substitutes": {"conn": ["session", "Connection", "oss", "ca", "ctx", "comm", "cm", "cs", "cat", "dh", "pg", "oci", "connect", "ci", "con", "cn", "dc", "db", "cr", "conf", "cli", "nc", "cp", "jc", "mm", "nt", "p", "ou", "ens", "ct", "cb", "connection", "state", "pub", "sql", "client", "c", "reg", "cc", "util", "en", "rc", "Conn", "n", "ann", "Connect", "ok", "loc", "ch", "mc", "ob", "enc", "config", "h", "coll", "col", "sn"], "ms": ["gm", "sem", "ans", "cs", "Ms", "MS", "hm", "pm", "es", "em", "ems", "DS", "ds", "mos", "is", "mn", "mm", "bs", "ys", "mes", "os", "bm", "vs", "ns", "ma", "ens", "gs", "mt", "res", "ins", "ls", "ims", "m", "qs", "pse", "s", "mb", "sql", "cms", "ums", "cus", "mis", "ws", "mx", "ops", "details", "md", "ml", "mod", "tm", "mas", "oms", "rs", "ps", "ts", "me", "js", "models", "keys", "mp", "mc", "mi", "mo", "fs", "ks"], "fechaSystem": ["fechassystem", "fechaSTEM", "fechlaSys", "febaService", "fichaSystem", "fekaSystem", "fechasSTEM", "fetchaSystem", "fechoSTEM", "febasSystem", "febasSys", "fechmaServer", "fichlaSys", "fichaSys", "fechlasystem", "fechoSystem", "fetchmaSystem", "fekasSTEM", "fechetaService", "fechasServer", "fetchmaSTEM", "fechetaSystem", "fechasSystem", "fechmaSys", "febaSystem", "fetchmasystem", "fechasSys", "fechtaSys", "fichasystem", "fetchaSTEM", "febaSys", "febaServer", "fechmaSystem", "fechaSys", "fichlasystem", "fekaSTEM", "fechosystem", "fetchasystem", "fekaSys", "fechasService", "fechasystem", "fechmaService", "fechtaSystem", "fechaService", "fichlaSystem", "fekasSys", "febasServer", "febasService", "fechetaServer", "fechlaSTEM", "fechetaSys", "fekasSystem", "fechaServer", "fechmaSTEM", "fechtasystem", "fechmasystem", "fechlaSystem"], "aaaammdd": ["aaaamtz", "aaaaammdd", "aaammdd", "aaaasmd", "aaaamsd", "aaammd", "aaaaamds", "aaammds", "aaaamd", "aaaammds", "aaaaammtz", "aaaymmd", "aaaasmds", "aaaymmsd", "aaaasmdd", "aaaymmdd", "aaammtz", "aaaamdd", "aaaymmds", "aaaamds", "aaaaamsd", "aaaaammds", "aaaammtz", "aaammsd", "aaaaammsd", "aaaaamdd", "aaaammsd", "aaaaamtz", "aaaasmtz", "aaaaamd", "aaaammd", "aaaaammd"], "fzafsis": ["fzAFtics", "fzhafs", "fzAFsi", "fzhaftics", "fzAFs", "fzaftics", "fzaphs", "fzafs", "fzaphsi", "fzahtics", "fzahs", "fzahsi", "fzhahsi", "fzaphtics", "fzhahtics", "fzhafsi", "fzAFsis", "fzaphsis", "fzhafsis", "fzhahsis", "fzafsi", "fzhahs"], "hhmmss": ["hhMMess", "HHmms", "hhmlms", "hhms", "hhmmmss", "hhMMss", "hhhmms", "hhmmess", "hhhmmess", "hhmds", "hhmlds", "hhMMds", "hhmdds", "hhhmmms", "hhhmmmss", "HHmmds", "hhmlss", "hhhmmmess", "hhmdss", "HHMMds", "hhhmmds", "HHMMms", "hhMMms", "hhmms", "hhhmmmds", "hhmdess", "hhhmmss", "hhMMs", "HHmmss", "hhmmds", "hhmmms", "hhmss", "HHmmms", "hhmmmess", "HHMMss", "HHMMs", "hhmls", "hhmmmds"], "sss": ["\u00dfss", "ussp", "rssp", "ssss", " ssss", "rsss", "rssls", "hesss", "rssss", " ssses", "ussses", "ssls", "ussss", "ssp", "hessns", "\u00dfns", "\u00dfs", "rssns", "rssses", " ssp", "usss", "\u00dfls", "ssses", "hessss", "ssns", "hessls"], "ss": ["oss", "styles", "hess", "ssh", "tz", "account", "cs", "st", "pg", "ses", "iss", "ssl", "string", "sf", "ross", "WS", "str", "ds", "sl", "ess", "pps", "\u00df", "uss", "ng", "bs", "vs", "ns", "rss", "hh", "ls", "css", "s", "nn", "SS", "ws", "struct", "su", "settings", "sq", "rs", "ps", "less", "ts", "sv", "js", "pass", "si", "xx", "eps", "ass", "fs"], "fzahsis": ["fzajsi", "fzeafsis", "fzavtics", "fzafses", "fzaftics", "fzeajses", "fzahtics", "fzavsi", "fzavsis", "fzahsi", "fzeaftics", "fzahses", "fzeafses", "fzeajtics", "fzeajsis", "fzeafsi", "fzajtics", "fzavses", "fzajsis", "fzajses", "fzafsi", "fzeajsi"], "afectados": ["afemptado", "afemptatos", "afectionantes", "rafctados", "AFectados", "rafectados", "rafectado", "afectanos", "rafectadas", "afecanos", "afctados", "AFectantes", "afectionanos", "afecantes", "afescantes", "rafctadas", "rafctatos", "afescadas", "afescados", "AFecadas", "afectionado", "afectatos", "afectado", "afctatos", "afectantes", "afemptadas", "AFectadas", "AFectanos", "afecados", "afectionatos", "afectionadas", "AFecados", "afctadas", "afctado", "afectionados", "rafectatos", "afemptados", "rafctado", "AFecanos", "afectadas", "afecadas", "AFecantes", "afescanos"]}}
{"id1": "10674824", "id2": "5682569", "code1": "    @Before\n    public void setUp() throws Exception {\n        final URL url = getClass().getClassLoader().getResource(\"insecureSSL.keystore\");\n        final KeyStore keystore = KeyStore.getInstance(\"jks\");\n        final char[] pwd = \"nopassword\".toCharArray();\n        keystore.load(url.openStream(), pwd);\n        final TrustManagerFactory trustManagerFactory = createTrustManagerFactory();\n        trustManagerFactory.init(keystore);\n        final TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();\n        final KeyManagerFactory keyManagerFactory = createKeyManagerFactory();\n        keyManagerFactory.init(keystore, pwd);\n        final KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();\n        final SSLContext serverSSLContext = SSLContext.getInstance(\"TLS\");\n        serverSSLContext.init(keyManagers, trustManagers, null);\n        localServer_ = new LocalTestServer(serverSSLContext);\n        localServer_.registerDefaultHandlers();\n        localServer_.start();\n    }\n", "code2": "    public void metodo1() {\n        int temp;\n        boolean flagDesordenado = true;\n        while (flagDesordenado) {\n            flagDesordenado = false;\n            for (int i = 0; i < this.tamanoTabla - 1; i++) {\n                if (tabla[i] > tabla[i + 1]) {\n                    flagDesordenado = true;\n                    temp = tabla[i];\n                    tabla[i] = tabla[i + 1];\n                    tabla[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["loader", "system", "address", "f", "cert", " URL", "uri", "src", "service", "ssl", "string", "source", "user", "resource", "path", "feed", "host", "server", "http", "entry", "sl", "URL", "class", "context", "base", "file", "page", "ls", "gl", "manager", "connection", "buffer", "image", "name", "client", "channel", "browser", "l", "Url", "key", "api", "config"], "keystore": ["rowstorage", "trusttool", "trustcache", "keyStore", "rowstore", "certserver", " keytool", "Keyserver", " keycache", "keystorage", "rowserver", "certstore", "rowtool", "Keycache", " keymanager", "truststorage", " keyStore", "keymanager", " keybase", "keybase", "airstore", " keyserver", "airStore", "keyserver", "truststore", "KeyStore", "keycache", "trustserver", "Keystore", "certStore", "trustStore", "airstorage", "Keybase", " keystorage", "trustmanager", "trustbase", "airmanager", "certbase", "keytool"], "pwd": ["fpass", " pw", " pword", "Pword", "prepass", "pword", "pWD", "pw", "cwd", "fword", "prew", "cWD", "Pw", " ppass", "ppass", "preword", "cpass", "prewd", "PWD", " pWD", "Pwd", "fwd", "fw", "cword", "cw", "Ppass"], "trustManagerFactory": ["keyManagerBuilder", "TrustLayerService", "trustManagementStore", "trustDirectorBuilder", "trustManBuilder", "trustmanagerFactory", "TrustManagerFactory", "TrustLayerFactory", "trustDirectorFactory", " trustDirectorStore", "trustManagerService", "keyManagerInterface", "trustLayerFactory", " trustDirectorService", "trustDirectoryInterface", "trustmanagerInterface", " trustManagerBuilder", "TrustLayerHelper", "keymanagerFactory", "trustmanagerStore", " trustManagerStore", "trustManagerBuilder", " trustDirectorFactory", "trustDirectoryService", " trustManagerService", "TrustManagerHelper", "trustDirectorService", "trustManagerInterface", "trustManagementService", "TrustManagerService", "trustmanagerBuilder", "keymanagerBuilder", "trustDirectorHelper", "trustManagementBuilder", "trustDirectoryBuilder", "trustManInterface", "trustLayerHelper", "trustLayerService", "keymanagerInterface", "trustManService", "trustManagementFactory", " trustDirectorBuilder", "trustDirectorStore", "trustManagerHelper", "trustManagerStore", "trustmanagerService", "trustDirectoryFactory", "keymanagerService", "trustManFactory", "trustmanagerHelper", "keyManagerService"], "trustManagers": ["trustManagerurers", "trustManager", "trustMatagers", "keyManurers", " trustManager", "trustMagers", " trustmanages", " trustmanagers", "trustMages", "trustmanagers", " trustmanurers", "keymanurers", "trustMurers", "keymanages", "trustManageragers", "keyManager", "keymanager", "trustmanurers", "trustManagerages", "trustmanages", "trustMager", "trustMaturers", "keymanagers", "trustMatages", "trustManages", " trustmanager", "keyManages", "trustMatager", "trustmanager", " trustManurers", "trustManurers", " trustManages", "trustManagerager"], "keyManagerFactory": ["keymanagerHelper", "keyManagerF", "keyLayerProvider", "keyManagerHelper", "trustmanagerFactory", "trustManagerF", "trustManagerService", "keyManagerInterface", "trustManagerProvider", "sslManagementInterface", "keymanagerFactory", "sslManagementHelper", "sslManagementService", "keyManagementF", "keyManagementFactory", "keymanagerF", "sslManagerService", "keyManagementService", "trustmanagerF", "keyManagementHelper", "sslManagerHelper", "keyDirectorInterface", "keyLayerService", "keyLayerFactory", "keyManagerProvider", "keymanagerInterface", "sslManagementFactory", "sslManagerFactory", "keymanagerProvider", "trustmanagerService", "keyDirectorService", "keyManagementInterface", "keymanagerService", "sslManagerInterface", "keyDirectorFactory", "keyDirectorHelper", "keyManagerService", "trustmanagerProvider"], "keyManagers": ["keyMANapters", "keyMutagers", "trustManainers", "keyMANagers", "keyMANages", "KeyManapters", "keyManurers", "keyMANurers", "keyManainers", "keyMANainers", "trustmanagers", "keymanapters", "keymanurers", "keyManapters", "KeyManages", "keymanages", "keymanisters", "keymanainers", "KeyMANagers", "KeyManurers", "keyMutainers", "trustmanainers", "KeyMANurers", "trustmanurers", "keyMuturers", "KeyManagers", "KeyMANages", "trustmanisters", "keymanagers", "keyManages", "trustManisters", "KeyMANapters", "keyMutisters", "trustManurers", "keyManisters", "keyMANisters"], "serverSSLContext": ["masterSSLChannel", "serverHttpFactory", "serverServerSession", "serverSLSession", " serverSecureConn", "serverSSLFactory", "serverSecureContext", " serverSLSession", "serverHTTPContext", "serverSSLSupport", "serverSLContext", " serverSLSupport", "masterSecurityChannel", "serverServerFactory", "serverHTTPService", "serverLSFactory", "masterSSLContext", " serverSecureClient", " serverSSLConn", "serverSecurityChannel", "serverHttpSupport", "masterSecurityContext", " serverSSLSession", "serverSLConn", "serverHTTPChannel", "serverSSLConn", " serverSSLFactory", "serverSSLChannel", "serverSecureClient", "masterSecurityService", "serverSLClient", " serverSSLSupport", "serverLSClient", "serverSSLClient", "masterSSLService", " serverSSLClient", " serverSecureContext", "serverSecurityService", "serverSecurityContext", "serverSLSupport", "serverSecureConn", "serverServerContext", " serverSecureFactory", "serverLSConn", "serverSecureFactory", "serverHttpSession", "serverHttpContext", "serverServerSupport", "serverSLFactory", " serverSLFactory", "serverLSContext", "serverSSLSession", "serverSSLService", " serverSLContext"], "localServer_": ["localPort_", "localserver_", "localClientWork", " localConnector_", "serverClientPool", "serverClientWork", " localServerRes", "globalSocketPool", "localConnectorlib", "localServerWork", "serverServer_", "localClientPool", "serverServerWork", "serverServerPool", "localPortWork", "localManagerRes", "localPortPool", "localSocket_", "localServicelib", "serverClient_", "globalSocket_", " localConnectorRes", " localServerlib", "localService_", "localSocketPool", "localServiceRes", "localserverPool", "localServerRes", "localManagerlib", "globalServerPool", "localserverWork", "localServerlib", "localManager_", "localServerPool", "localConnectorRes", " localConnectorlib", "globalServer_", "localConnector_", "localClient_"]}}
{"id1": "16466743", "id2": "14590676", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    public static void download(String address, String localFileName) {\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            URL url = new URL(address);\n            out = new BufferedOutputStream(new FileOutputStream(localFileName));\n            conn = url.openConnection();\n            in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n            System.out.println(localFileName + \"\\t\" + numWritten);\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        } finally {\n            try {\n                if (in != null) in.close();\n                if (out != null) out.close();\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"password": ["number", "account", "sword", "encrypted", "address", "f", "prefix", "data", "words", "wd", "string", "token", "path", " Password", "input", " passwords", "text", "username", "p", "array", "phrase", "secret", "buffer", "hash", "name", "email", "pattern", "Password", "pass", "PASS", "key", "crypt", "padding", "enc", "word", "attribute", "config", "login", "auth", "message"], "md": ["material", "cm", "nm", "pd", "um", "d", "sm", "ad", "pm", "hm", "amd", "dc", "db", "sha", "mu", "meta", "mm", "am", "p", "Cmd", "bf", "MD", "dd", "od", "bm", "mand", "ma", "mt", "cb", "m", "ms", " MD", "bd", "rm", "dig", "mb", "hash", "mg", "dm", "cd", "cmd", "mod", "ph", "mac", "mag", "mp", "mc", "mem", "mo", "metadata"], "b": ["bar", "ba", "f", "a", "nb", "rb", "d", "emb", "gb", "bb", "eb", "sb", "bi", "reb", "wb", "db", "ib", "fb", "buf", "buff", "binary", "bs", "base", "p", "orb", "lb", "u", "cb", "ab", "bd", "buffer", "mb", "br", "y", "B", "batch", "bytes", "l", "r", "ob", "be", "e"], "i": ["hi", "phi", "f", "x", "a", "d", "it", "data", "ui", "ti", "uri", "ni", "bi", "end", "ci", "qi", "gi", "slice", "mu", "di", "t", "z", "abi", "pi", "xi", "base", "p", "block", "zi", "v", "ai", "u", "io", "s", "ii", "o", "c", "I", "multi", "ri", "j", "l", "index", "start", "n", "si", "vi", "li", "r", "oi", "ji", "h", "info", "eni", "e", "id"], "pwHash": ["PwStr", " pwdSecret", "pwaSecret", " pwaHash", "pwrSalt", "pWSum", "pwrHash", " pwahash", "pwsSecret", "pWhash", "pwhhash", "pwSalt", " pwSalt", "pwaSalt", "pwaStr", "pwrSum", "PWStr", "pWSalt", "pwsSalt", "pwKey", "pwhSum", "pwStr", " pwdSalt", "pwsHash", "pwdSalt", " pwaKey", "pWHash", "PWSalt", "pwahash", "PwSum", "pwhHash", "pwhKey", " pwhash", "PWSum", "pWStr", "pwSum", "pwdSum", "PwSalt", " pwdHash", " pwKey", "PWHash", " pwSum", "pwaKey", " pwaSum", "pwaSum", "pwdHash", " pwdSum", "pwhash", "pWKey", "PwHash", " pwSecret", "pwaHash", "pwSecret", "pwrStr", "pwdSecret", "pwsSum"]}}
{"id1": "160739", "id2": "884867", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"inFile": ["outStream", "infile", "outFiles", "incStream", "sourceStream", "insfile", "inputfile", "incFile", "insFiles", "inputStream", "insStream", "inputFiles", "sourceFiles", "outfile", "incfile", "incFiles", "inFiles", "insFile", "inStream", "inputFile", "sourceFile", "sourcefile"], "outFile": ["outStream", "infile", "inputTime", "workingfile", "inDir", "inputfile", "workDir", "targetStream", "targetfile", "workingStream", "outfile", "outTime", " outStream", "targetFile", "inputDir", "outDir", "inTime", " outDirectory", "workTime", "inputFile", "targetDirectory", " outfile", "workingFile", "workfile", "workingDirectory", "workFile", "outDirectory"], "k_blockSize": ["k_BlockLength", "k_blockLength", "k_lineCount", "k_byteLength", "k_bitSize", "k_byteSize", "k_lockLen", "k_byteCode", "k_byteLen", "k_lineSize", "k_BlockSize", "k_blockInfo", "k_bitInfo", "k_blocksLen", "k_BlockCode", "k_lockCode", "k_blocksSize", "k_byteInfo", "k_bitCount", "k_blocksLength", "k_lineInfo", "k_blockCount", "k_lockSize", "k_byteCount", "k_BlockCount", "k_lockCount", "k_blockCode", "k_lockLength", "k_blocksCount", "k_blockLen"], "byteCount": ["flushSize", "characterLength", " byteSum", "flushLength", "bytecount", "byteSize", "characterSize", "ByteLength", "flushcount", "blockSum", "byteLen", "ByteLen", " byteLength", "blockLength", "flushCount", " byteSize", "ByteCount", "byteLength", "characterLen", "characterCount", " byteLen", "Bytecount", " bytecount", "ByteSize", "blockCount", "byteSum", "blockSize", "ByteSum"], "buf": ["queue", "border", "ctx", "bh", "rb", "data", "feat", "flush", "src", "brace", "feed", "alloc", "font", "tmp", "buff", "fb", "ucc", "cv", "seq", "len", "cas", "base", "bf", "vec", "fd", "img", "cb", "Buff", "exc", "buffer", "Buffer", "batch", "cmd", "bytes", "b", "result", "background", "rc", "uf", "loc", "cap", "append", "config", "bag", "la"], "ofp": ["fort", "ofc", "OFl", "forp", "Oftp", "OFt", "OFc", "afnp", "OFp", "afc", "Ofl", "oft", "Oft", "forc", "OFtp", "Ofnp", "Ofc", "ofl", "afp", "afl", "oftp", "OFnp", "fortp", "ofnp", "Ofp"], "zos": ["zig", "bos", "cfg", "core", "inos", "los", "abi", "zon", "zx", "enos", "nox", "bitcoin", "outs", "iframe", "modules", "oda", "hz", "zn", "ZI", "ozo", "zik", "zers", "zb", "zar", "ossus", "zona", "zy", "zi", "zyk", "bs", "obb", "fits", "owicz", "css", "gz", "iffs", "bes", "lol", "uz", "js", "packs", "zes", "ogl", "nz", "budget", "za", "liquid", "rons", "cos", "zag", "zip", "z", "os", "zo", "zin", "ls", "ws", "rez", "ros", "osi", "oS", "zer", "obs", "tz", "ses", "lins", "zen", "dylib", "robe", "ZA", "forge", "zl", "utils", "webkit", "jas", "soon", "ops", "oses", "kos", "zh"], "osw": ["eswd", " osww", "bwo", "esd", "osws", "issw", "esww", " osfw", "ossfw", "bsws", "isd", "bswo", "ossww", "osow", "ossow", "osshell", "ossw", "isw", "bx", "esow", "osfw", "ossd", "osswd", "esw", "essw", "osnow", "osssw", " osow", "iswd", "osx", "lswo", "oshell", "lsw", "bsx", "isy", "esnow", "lsx", "oswo", "ishell", "osd", "esfw", "bsw", "ossy", "osy", "osww", "eshell", "oswd", "ossnow", "bws", "esy", "lsws", "isnow"], "bw": ["Bew", "bbw", " bws", "lbr", "abW", "ebW", "bbew", "lbw", "lbsw", "bwh", "bwd", "abwd", "Bws", "fwh", "baw", "abwe", " bwa", "Bw", "fx", "fr", "bx", "bz", "bwu", "lbwa", "fbw", "bbws", "bbz", "ow", "bbwu", "fsw", "owu", "bW", "bbwh", "lw", "abw", "fbW", "lwa", "lx", " bwh", "oaw", "lbwh", "lbws", "lbz", "ebwe", "bbwa", "lsw", " bew", "fbwe", "owa", " baw", "ebwd", "fwa", "bsw", "bew", "ebw", "bbaw", "Bwa", "bwa", "fw", "bwe", "lbx", "bws", "fbwd", " bwu", " bz"], "zot": ["zori", "Zot", "zerita", "Ziot", " zor", "Zit", "jos", "Zor", "ziot", " zori", "zor", "aziot", "jit", "zeros", "zott", "azit", "jori", "azita", "azott", "Zott", "zerott", "zita", " ziot", "zerot", "zerori", "azor", "azot", "Zita", "zerit", "jot"], "ifp": ["ifi", "Iff", "iff", "ipc", "ifc", "IFl", "IFf", "IFb", "ipb", "Ifc", " iff", "ipp", "IFi", " ifc", " ifb", "IFp", "Ifi", " ifl", "IFc", "ifl", " ifi", "Ifp", "ipl", "ifb"], "zis": ["zeits", "zenIS", "jis", " zisi", "zeiss", "zIS", " zIS", "zits", "ziss", "zipip", "xits", "zib", "zipiss", "zenis", "zeip", "xis", "Zits", "zip", "Zis", "xais", " zais", " zib", "xisi", "jit", "jits", "zenib", " zits", "xib", "zisi", "xIS", "zenais", "zipis", "zeis", "Zip", "zais", "Ziss", "jisi", "zipits", "xit"], "isr": ["ispr", "isrb", "iscr", "ISr", "isrs", "ISrs", "issrs", "ISrc", "rispr", "ISrb", "risrb", "ISsr", " iscr", "irpr", " issr", "ISpr", "irr", "isrc", " isrs", "isssr", "irrc", "risrc", "risr", "isscr", "IScr", "issr", "irrb"], "br": [" BR", "bar", "ibl", "kr", "bl", "bh", "rb", "gr", "hr", "BR", "mr", "bro", "HR", "div", "sr", "bc", "str", "fr", "tr", "obl", "bsp", "bp", "sp", "img", "yr", " dr", "rib", " Br", "err", "Br", "arr", "shr", "b", "lr", "cro", "rs", "browser", "ctr", "ber", "ch", "body", "r", "ocr", "ob", " fr", "obi", "ibr"], "zit": [" zi", "zeits", "jip", "zipita", "zipith", "jIT", "zits", "xic", "jite", "zipip", "zenitter", "zipite", "zic", "jith", "zeith", " zite", "zeita", "zitter", "zipit", "zip", "zipIT", " zith", "jit", "xit", "zi", "jits", "zeIT", " zip", "zite", "zith", "zeit", "zeitter", " zits", "xith", " zic", "zita", "zenits", "zipitter", "zIT", "zenith", "jic", "jita", "zenit", "ji", "zipits", "xi"]}}
{"id1": "400275", "id2": "22879400", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "label": 0, "substitutes": {"url": ["loader", "address", "f", "filename", "bel", "ref", "uri", "service", "ssl", "string", "source", "resource", "xml", "path", "feed", "host", "server", "http", "fr", "ur", "sl", "el", "URL", "html", "base", "file", "www", "location", "connection", "io", "href", "buffer", "image", "name", "lr", "l", "link", "ll", "Url", "loc", "rl", "ob", "config", "null", "id"], "in": ["gin", "f", "a", "serv", "data", "isin", "socket", "inn", "ssl", "source", "i", "xml", "resource", "con", "token", "is", "input", "init", "this", "min", "din", "file", "conn", "reader", "part", "rin", "ins", "impl", "bin", "m", "err", "io", "inner", "image", "cms", "c", "inside", "as", "or", "In", "n", "inc", "IN", "nin", "ini", "r", "ex", "val", "config", "login", "out", "again", "pin", "id"]}}
{"id1": "20929570", "id2": "19810820", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"str": ["f", "kr", "st", "dr", "data", "msg", "string", "source", "sr", "cr", "fr", "tr", "input", "text", "txt", "url", "conn", "sp", "temp", "exp", "err", "char", "s", "buffer", "arr", "br", "name", "STR", "obj", "bytes", "b", "result", "Str", "pass", "r", "enc", "sec", "out", "stri", "e"], "messageDigest": ["messageDigester", " messageDer", "messageDen", "messageDester", "messageGester", "messageGher", "messageDher", "messageDigeter", "messageGested", "messagediger", "messageMarkest", "objectDigen", "MessageMarkpace", " messageDigester", " messageDher", "messageMarkEST", "objectdigester", "messagedigpace", "messageDeter", "messagePedest", "messagedigen", "messageSigner", "MessageDigester", "messageMailester", "messageDigit", "messageDighest", "messageDigpace", "MessageMarkEST", "messagedigeter", "objectDigest", "messageDpace", " messageDester", "MessageDigEST", "MessageDigest", "messagedigest", "messageDit", "messageMaileter", "messagePedhest", "Messagedighest", "messagedigester", "Messagedigest", "messageDefest", "messageSignester", "messageMailen", "messageSignest", "messageGest", "messageDefester", "messageDiger", "objectDigester", "messagePedEST", "Messagedigester", " messageDest", "MessageMarkester", "messageDer", "messageDigher", "objectDigeter", "messageDigested", "messageSignit", "messageDest", "messageDEST", " messageDigher", "objectdigest", "messageDigen", "messagedighest", "messageDested", "messageMarkester", "messageDefher", " messageDiger", "MessagedigEST", "messagePedester", "MessageDigpace", "objectdigen", " messageDit", " messageDigit", "MessageDighest", "messageMailest", "objectdigeter", "MessageMarkest", "messageDefested", " messageDigested", "messageDigEST", "messagedigit", "messageMarkpace", " messageDested", "messagedigEST"], "byteArray": ["byteBuffer", "charLength", "charOrder", " byteBuffer", "byteOrder", "characterArray", "bitLength", "letterObject", "fileBuffer", "ByteStream", "letterLength", "byteAmount", "ByteAmount", "byteAr", " byteAr", " byteOrder", "charStream", "byteObject", "ByteObject", "byteIndex", "wordString", "byteString", " byteAmount", "ByteLength", "byteStream", "charObject", "bitArray", "wordAr", " byteLength", "fileArray", "fileString", "charArray", "letterArray", "wordBuffer", "charAmount", "charIndex", "ByteArray", "bitOrder", "wordArray", "fileAr", "characterOrder", "byteLength", "bitAmount", "characterBuffer", " byteIndex", "ByteIndex", " byteString", "charBuffer", "characterAmount", "letterStream"], "md5StrBuff": ["md5strPref", "md5BrBuffer", "md5StringPref", "md5StBuff", "md5SlBuff", "md5StComp", "md2StrBuff", "md6strBuilder", "md6strText", "md2StringBuff", "md2StringBuffer", "md5StText", "md5StPref", "md5Slbuff", "md2StrProp", "md6StrBuff", "md5StringBuffer", "md5BrBuff", "md5SlProp", "md5StringBuff", "md5StrBuffer", "md5StApp", "md5Stringbuff", "md2StrApp", "md2StringProp", "md5LineBuffer", "md2StringPref", "md6strBuffer", "md2StrComp", "md5Trbuff", "md6StrText", "md5StrText", "md5strComp", "md5TrBuff", "md5StringComp", "md5SlBuffer", "md5LineText", "md5BrText", "md5StringApp", "md5StrComp", "md2StringApp", "md2StrBuffer", "md5StringBuilder", "md6strBuff", "md2StringComp", "md6StrBuffer", "md5strBuilder", "md2StringText", "md5BrApp", "md5strBuffer", "md5StrPref", "md5TrProp", "md5StringProp", "md5Strbuff", "md2StrText", "md2Strbuff", "md5StringText", "md5StBuffer", "md5strText", "md6StrBuilder", "md5LineBuff", "md5StrProp", "md5TrBuffer", "md5StrApp", "md5LineBuilder", "md2StrPref", "md5StrBuilder", "md5strBuff", "md2Stringbuff"], "i": ["phi", "f", "length", "x", "d", "it", "ui", "ti", "uri", "ie", "bi", "ci", "gi", "qi", "slice", "mu", "di", "abi", "pi", "chi", "p", "v", "in", "ai", "ix", "part", "u", "k", "iu", "io", "inner", "ip", "ii", "y", "name", "info", "o", "c", "ri", "I", "b", "fi", "multi", "j", "l", "n", "si", "key", "li", "oi", "ji", "field", "index", "xi", "e", "id"]}}
{"id1": "13563706", "id2": "20619879", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"request": ["application", "queue", "data", "user", "string", "resource", "remote", "document", "xml", "server", "input", "Response", "p", "query", "req", "event", "url", "method", "type", "connection", "buffer", "image", "QUEST", "info", "client", "result", "instance", "current", "view", "frame", "report", "complete", "attribute", "config", "object", "model", "create", "Request", "e", "message"], "response": ["application", "re", "service", "site", "resource", "document", "output", "status", "subject", "wa", "feed", "reason", "server", "http", "writer", " Response", "onse", "Response", "json", "respond", "query", "reply", "error", "res", "location", "connection", "results", "image", "header", "collection", "client", "result", "description", "resp", "view", "pool", "body", "report", "api", "index", "object", "model", "message"], "selectedPage": ["namedpage", "selectionpage", "selectedLine", " selectedSite", "electedButton", "selectionPage", "lectedFile", " selectedAction", "electedPage", "selectedpage", "lectedSite", "electedLine", "namedPage", "selectedAction", " selectedItem", "selectedFile", "namedLine", " selectedButton", "lectedPage", "selectionFile", "electedpage", "namedFile", " selectedLine", "selectionHour", "namedSite", "selectedSite", "lectedAction", "selectedButton", "lectedButton", " selectedpage", " selectedFile", " selectedHour", "lectedHour", "selectionButton", "selectedHour", "lectedpage", "selectionLine", "lectedItem", "selectionItem", "selectedItem", "lectedLine", "selectionAction"], "page": ["number", "peer", "per", "server", "pe", "project", "menu", "html", "block", "url", "sp", "type", "ge", "unit", "change", "view", "pool", "model", "e", "queue", "account", "address", "f", "plugin", "pg", " Page", "profile", "pp", "photo", "connection", "display", "po", "instance", "Page", "item", "me", "position", "fe", "record", "layout", "article", "je", "resource", "document", "rule", "handler", "office", "module", "language", "client", "cache", "node", "proxy", "message", "child", "row", "port", "user", "point", "site", "section", "parent", "p", "pl", "location", "image", "ip", "channel", "route", "result", "ice", "age", "phone"], "portalRequest": [" portalQuery", "portugalEvent", "PortortalRequest", "portelRequest", "portailResponse", "portbalRequest", "portortalUser", "portallRequest", "portugalResponse", "PortortalEvent", "PortortalAccess", "PortortalServer", "portalQuery", "portallingPage", "PortortalCommand", "portallingCommand", "portelQuery", "portortalRequest", "PortalResponse", "portALRequest", "portpalAccess", "portugalUser", "portailRequest", "portialRequest", " portalPage", "portalEvent", "portpalRequest", "PortalUser", "portugalOrder", "portugalServer", "portialResponse", "portortalServer", "portallingAccess", "portalServer", "portortalEvent", "portortalCommand", "portailUser", "portelPage", "portalUser", "PortortalResponse", " portalResponse", "portailOrder", " portialResponse", "portalResponse", "portelCommand", "PortalOrder", "PortalRequest", "portallingRequest", "portbalQuery", " portialRequest", "portallingResponse", "portortalAccess", "portpalPage", "portalOrder", "portialQuery", "PortalServer", "PortalAccess", "portALResponse", "PortortalPage", "PortalPage", "portalCommand", "portALUser", "portbalPage", "portortalPage", "portugalRequest", "PortortalOrder", "portbalResponse", "portortalResponse", "portortalOrder", "portialPage", "PortalCommand", "portallServer", " portialQuery", "portallUser", "PortalEvent", "PortortalUser", "portALEvent", "portpalResponse", "portallResponse", "portelResponse", "portalAccess", " portialPage", "portalPage"], "pageProp": ["pagePro", "projectprop", "projectProp", "resourceProp", "PagePro", "ageProp", "ageprop", " pageProperty", "PageProp", "ageProperty", "resourceProperty", " pageObj", "PageStr", "projectProperty", " pageStr", "parentPro", "pluginProp", "parentObj", "resourcePro", "pluginprop", "parentProperty", "peerProperty", "pageObj", "pluginPro", "pageprop", "pluginProperty", "Pageprop", "projectPro", "peerProp", "resourceprop", "parentProp", "peerPro", "agePro", "peerStr", " pagePro", "pageStr", "PageProperty", "PageObj", "pageProperty"], "possiblePage": ["puredGroup", "patchedOrder", "PossibilityLine", "patchingPage", "PossiblePages", "patchingpage", "pablepage", "PossibilityPages", "possibleGroup", "puredItem", "possiblyLine", "PossiblePage", "PossibleGroup", "patchedPage", "Possibilitypage", "PossiblyItem", "possiblepage", "possibleOrder", "PossiblyGroup", "permanentLine", "possibilitypage", "possibilityLine", "puredpage", "possiblyGroup", "permanentOrder", "PossiblyPage", "possiblePages", "possiblyPages", "PossibleItem", "patchingGroup", "patchingItem", "possiblyPage", "pableLine", "possiblyItem", "PossibilityPage", "pablePages", "PossibleLine", "pablePage", "Possiblypage", "possibleItem", "possibilityPage", "permanentPage", "possiblypage", "Possiblepage", "possibilityPages", "permanentpage", "possibleLine", "PossiblyLine", "patchedpage", "puredPage", "PossibleOrder", "possiblyOrder", "PossiblyOrder", "patchedLine"], "property": ["number", "maximum", "expression", "address", "f", "prefix", "data", "integer", "string", "section", "resource", "profile", "layer", "label", "uration", "character", "t", "perties", "project", "duration", "class", "binary", "Property", "value", "entity", "function", "p", " Property", "binding", "properties", "variable", "prop", "type", "future", "table", "header", "language", "name", "set", "result", "term", "notation", "feature", "key", "attribute", "config", "object", "operator"], "referer": ["defrer", "redrer", "defender", "afferer", "diffender", "Refender", "rederer", "differer", " refre", "reere", "refrer", " refber", "reiner", "Refere", "affrer", " refrer", "afferen", " referen", "refiner", "refere", "Referer", "affere", "Refeline", "ferer", "Refre", "refre", "rere", "deferer", "defere", "referers", " refere", "ferers", "Referers", "Referen", " refender", "diffiner", "Refrer", " refiner", "fere", "Refber", "reerer", "diffrer", " referers", "rerer", "defber", "redeline", "referen", "refender", "redber", "frer", "refber", "refeline", "Refiner", " refeline"]}}
{"id1": "530882", "id2": "88047", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"inFile": ["InPlace", "inPlace", "infile", "outFilename", " infile", "outPath", "outFiles", "oldfile", " inPath", "oldFiles", "outPlace", "oldFilename", "inputfile", "incFile", "oldFile", "inputFiles", "InPath", "incPlace", "outfile", "Infile", "incfile", "incFiles", "inFiles", "inFilename", "InFile", "inputFile", "inputFilename", " inFiles", "inPath", "InFiles"], "outFile": ["zipFilename", "Outfile", "outFilename", "outputFile", " outTable", "outputFolder", " outFolder", "OutFile", "outPlace", " outPlace", "OutDir", "OutPlace", "outputTable", " outString", "newFile", "inputFolder", "inputTable", "newDir", " outDir", "inputPlace", "outFolder", "zipString", "outfile", "outputString", "zipFILE", "outputFilename", "outDir", "zipFile", " outFilename", "inputFile", " outfile", "outputFILE", "outputPlace", "outFILE", "newPlace", "outString", " outFILE", "newfile", "outTable"], "iis": ["ioIs", "iniIs", "iIs", "iniais", "iisc", "iniisc", " iIS", "ciid", "iniiss", "iiIS", "Iiss", "iils", " iid", "iais", "iid", "ioisc", "iIS", "iniils", "Iis", "iniIS", "iniis", "ioiss", "ciis", " iais", "IIs", "ciiss", " iIs", "iiss", "ciais", "iniid", "iiIs", " iiss", "Iisc", "iois", "iiils", "iiis", " iils"], "dcmParser": ["dmcPar", " dcmLoader", "dcpReader", "DcmJar", "pdymReader", "pdymJar", "dmmarser", "dcrJar", "dcmStreamer", "DcmParser", "ddcParser", "dtermStreamer", " dpmPar", "dymReader", "dcrWriter", "dcpParser", "dmmReader", "dcmPar", "dcyJar", " dpmBuilder", "ddcLoader", "dcmarser", " dcmPlugin", "dpmparser", " dcmBuilder", "ddcPlugin", " dpmarser", "dmoduleParser", "dsemStreamer", "dpmStreamer", "dymParser", "dtermPlugin", "pdymParser", " dcmarser", "dtermParser", "ddcReader", "Dcmarser", "dymJar", " dcmPar", "dcrparser", "dsemParser", "Dcmparser", "dcmWriter", "dmmParser", " dpmJar", "dcmBuilder", " dpmStreamer", "dsemReader", " dpmPlugin", " dcmStreamer", "dcmparser", "dcmLoader", "dcmPlugin", "dmoduleReader", "dmcJar", "dcpJar", " dpmReader", "dpmLoader", "dcyParser", "dcyarser", "dcyReader", "dcrReader", "dpmJar", "pdcmReader", "dcrParser", "dpmBuilder", "dpmPar", "dymparser", "pdymparser", " dpmLoader", "DcmReader", " dpmParser", "pdcmParser", "dcpparser", " dcmReader", "dtermReader", "dmcParser", "dcmReader", "dcmJar", "dpmarser", "pdcmparser", "dcrarser", " dcmJar", "DcmWriter", "dmmWriter", "dpmParser", "dpmReader", "dcrPar", "dmodulePlugin", "pdcmJar", "dmoduleBuilder", "dsemPlugin", "dmcarser", "dpmPlugin"], "ds": ["session", "cs", "pd", "d", "docs", "uds", "data", "dt", "dr", "sync", "src", "iss", "gd", "Ts", "tes", "asi", "da", "dc", "ays", "db", "ipes", "DS", "parts", "di", "ads", "points", "is", "dds", "bs", "amps", "nas", "utils", "ys", "os", "des", "dd", "vs", "ns", "ils", "fd", "gs", "ins", "ls", "conn", "cdn", "Ds", "s", "Os", "tx", "services", "ws", "xs", "client", "details", "rs", "ss", "ps", "ros", "Db", "df", "js", "ts", "drivers", "plugins", "ld", "sys", "eps", "dat", "ks"], "pdReader": ["pidReader", "dsReader", "pidScan", "pidLoader", "xdreader", "hdRead", "pdParser", "dsLoader", "hdWriter", "pbLoader", "pdRead", "pcRead", "wdLoader", "xdReader", "pidParser", "xdRead", "pdLoader", "pcLoader", "pbParser", "pdreader", "pbReader", "wdWriter", "dsRead", "dsWriter", "hdreader", "wdRead", "pcScan", "wdReader", "hdReader", "pbScan", "pcParser", "pdScan", "dsreader", "pcWriter", "pcReader", "xdWriter"], "out": ["d", "flush", "ssl", "class", "store", "url", "full", "w", "code", "outs", "as", "external", "at", "inc", "pool", "auto", "sys", "model", "oder", "ext", "sync", "data", "with", "lib", "group", "base", "conn", "file", "in", "down", "img", "exp", "connection", "net", "io", "device", "write", "exec", "pass", "log", "key", "word", "again", "dot", "OUT", "builder", "output", "line", "db", "list", "writer", "Out", "array", "temp", "manager", "to", "s", "later", "up", "client", "order", "doc", "outer", "sum", "cache", "ex", "copy", "default", "object", "session", "child", "point", "user", "flow", "password", "cli", "parent", "lock", "page", "co", "gen", "err", "now", "call", "inner", "image", "name", "obj", "o", "result", "term", "over", "login", "null"], "dcmEncParam": ["dcmElParameter", "dcmAccSm", "dcmEngVar", "dpmDecParam", "dcmDecSm", "dcmElType", "dcmDecPar", "dcmEncSm", "dcmencParameter", "dcmEncVar", "dcmEncType", "dcmEncPar", "dcmEncParameter", "dcmencSm", "dcmAccParam", "dpmEncSm", "dcmEnVar", "dcmEngParam", "dcmElParam", "dcmEngType", "dcmEngParameter", "dcmElVar", "dcmEnType", "dpmDecParameter", "dcmEnParam", "dpmEncParam", "dpmDecSm", "dcmEnParameter", "dcmDecParameter", "dcmDecParam", "dcmencParam", "dcmAccParameter", "dcmEnPar", "dpmEncParameter"], "pdWriter": ["ddWrite", "dsWrite", "ddWriter", "tdOutput", "hdOutput", "hdWR", "hdWriter", "tdContent", "pdWR", "PDContent", "tdReader", "dsWR", "dsOutput", "ddOutput", "pxOutput", "ddWR", "PDOutput", "hdWrite", "pdContent", "PDReader", "dsWriter", "tdWriter", "pdOutput", "pxContent", "PDWriter", "pdWrite", "pxReader", "pxWriter"]}}
{"id1": "5683576", "id2": "812803", "code1": "    public String shorten(String url) {\n        List<NameValuePair> qparams = new ArrayList<NameValuePair>();\n        qparams.add(new BasicNameValuePair(\"version\", \"2.0.1\"));\n        qparams.add(new BasicNameValuePair(\"longUrl\", url));\n        if (login != null) {\n            qparams.add(new BasicNameValuePair(\"login\", login));\n            qparams.add(new BasicNameValuePair(\"apiKey\", apiKey));\n            qparams.add(new BasicNameValuePair(\"history\", \"1\"));\n        }\n        try {\n            BasicHttpParams params = new BasicHttpParams();\n            DefaultHttpClient httpclient = new DefaultHttpClient(params);\n            URI uri = URIUtils.createURI(\"http\", \"api.j.mp\", -1, \"/shorten\", URLEncodedUtils.format(qparams, \"UTF-8\"), null);\n            HttpGet httpget = new HttpGet(uri);\n            if (logger.isDebugEnabled()) logger.debug(\"HttpGet.uri={}\", httpget.getURI());\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                InputStream instream = entity.getContent();\n                JsonFactory f = new JsonFactory();\n                JsonParser jp = f.createJsonParser(instream);\n                JmpShortenResponse responseObj = new JmpShortenResponse();\n                for (; ; ) {\n                    JsonToken token = jp.nextToken();\n                    String fieldname = jp.getCurrentName();\n                    if (logger.isDebugEnabled()) logger.debug(\"Token={}, currentName={}\", token, fieldname);\n                    if (token == JsonToken.START_OBJECT) {\n                        continue;\n                    }\n                    if (token == JsonToken.END_OBJECT) {\n                        break;\n                    }\n                    if (\"errorCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorCode(jp.getIntValue());\n                    } else if (\"errorMessage\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorMessage(jp.getText());\n                    } else if (\"statusCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setStatusCode(jp.getText());\n                    } else if (\"results\".equals(fieldname)) {\n                        Map<String, ShortenedUrl> results = parseResults(jp);\n                        responseObj.setResults(results);\n                    } else {\n                        throw new IllegalStateException(\"Unrecognized field '\" + fieldname + \"'!\");\n                    }\n                }\n                Map<String, ShortenedUrl> results = responseObj.getResults();\n                if (results == null) {\n                    return null;\n                }\n                ShortenedUrl shortened = results.get(url);\n                if (shortened == null) {\n                    return null;\n                }\n                if (logger.isDebugEnabled()) logger.debug(\"JmpShortenResponse: {}\", responseObj);\n                if (\"OK\".equals(responseObj.getStatusCode())) {\n                    return shortened.getShortUrl();\n                }\n                if (logger.isWarnEnabled()) logger.warn(\"JmpShortenResponse: {}\", responseObj);\n            }\n        } catch (IOException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        } catch (URISyntaxException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        }\n        return null;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"url": ["account", " resource", "address", "version", "data", "service", "request", "string", "source", "i", "resource", "path", "host", "str", "server", "http", "sl", "URL", "text", "username", "json", "base", "page", "file", "method", "ls", "www", "location", "secret", " webpage", "language", "name", "route", "email", "term", "l", "Url", "key", "api", "config", "login", "id"], "qparams": [" qproperties", "Qparams", "quparams", "qudetails", "quresources", "qvals", "quchanges", " qapters", "sqoptions", "reqparams", "sqparts", "reqParameters", " qParameters", "reqquery", "quapi", "Qvals", " qnames", "Qproperties", "Qserver", "qproperties", "qmarks", "kmarks", "sqplugins", "qParameters", "qams", " qchanges", " qquery", "quvals", "Qnames", " qlines", "qdetails", "qquery", "sqchanges", "reqproperties", "Qresources", "qlines", "quplugins", " qplugins", "kams", "qunames", "kparams", "Qapi", "qresources", "qtproperties", "Qapters", "quparts", "kbody", " qvals", "qapters", "qchanges", " qapi", "qparts", "quapters", "qtparams", " qserver", "qbody", " qams", " qdetails", "quoptions", "qplugins", " qbody", "qulines", "qtParameters", "qnames", "sqlines", "qapi", " qparts", "qtquery", "sqparams", " qmarks", " qresources", "quserver", "qoptions", "qserver", "Qdetails", "quproperties", " qoptions", "Qchanges"], "params": ["ctx", "lp", " parameters", "ssl", "parse", "i", "per", "Parameters", "server", "http", "password", "param", "afi", "pro", "pi", "json", "license", "p", "mm", "properties", "ras", "ams", "phrase", "secret", "apter", "qs", "s", "radius", "services", "py", "details", "settings", "instance", "ps", "cmp", "plugins", "api", "config", "options", "posts", "rules"], "httpclient": [" httpClient", "HttpClient", "httpcall", " httpcall", "httpsclient", "webcon", "Httpclient", "webcall", "webresource", "webclient", "httpconnection", "httpClient", "httpsresource", "webconnect", "httpscon", " httpcon", "Httpcall", "webconnection", "webClient", "httpsconnection", " httpconnection", "httpcon", "Httpconnect", "httpresource", " httpresource", "httpconnect", " httpconnect"], "uri": ["address", "plugin", "ui", " ur", "service", "request", "i", "resource", "gi", "qi", "document", "path", "http", "server", "ur", "cli", "URI", "URL", "universal", "pi", "base", "database", " URI", "u", "environment", "directory", "location", "connection", "io", "href", "range", "archive", "doi", "client", "route", "ilo", "ri", "iri", "uni", "api", "mi", "direction", "proxy"], "httpget": ["httpfind", "httpGet", "httpGET", "phpget", "urlfind", "HttpGet", "ttpGet", "urlGet", "htmlfind", "phpGet", "httpsend", "HttpGET", "phfind", "Httpget", "phGet", "phpsend", " httpGet", "phpGET", "htmlGet", " httpGET", "phgot", "httpgot", "phget", " httpgot", " httpfind", "Httpsend", "ttpget", " httpsend", "htmlgot", "urlquery", "ttpfind", "ttpquery", " httpquery", "htmlget", "httpquery", "urlget"], "response": ["application", "data", "received", "service", "request", "resource", "document", "successful", "success", "output", "feed", "server", "http", "entry", "generation", "onse", "Response", "json", "respond", "value", "reply", "page", "full", "seeking", "environment", "connection", "collection", "channel", "relation", "result", "resp", "body", "api", "object", "status", "message"], "entity": ["issue", "data", "content", "company", "xml", "resource", "document", "em", "output", "ent", "person", "server", "entry", "el", "json", "value", "p", "event", "file", "page", "iso", "translation", "environment", "get", "element", "image", "collection", "obj", "email", "result", "component", "article", "Entity", "resp", "body", "api", "node", "metadata", "object", "info", "eni", "e", "message"], "instream": ["outStream", "infile", " infile", "inputstream", "instruct", "aspath", " instruct", "inputfile", "idpath", " inpath", "inpool", "inputStream", " inpool", " inStream", "inputstruct", "inpath", "aspool", "outfile", "idview", "inview", "asstream", "outstruct", "idstream", "inStream", " inview", "idpool", "outstream", "asview"], "f": ["d", "i", "sf", "fing", "feed", "fr", "conf", "t", "fb", "e", "fc", "F", "json", "tf", "p", "bf", "fp", "v", "full", "fd", "w", "fen", "m", "fac", "rf", "obj", "c", "j", "aff", "l", "flat", "df", "api", "fe", "framework", "h", "info", "fs", "fm", "fab"], "jp": ["peg", "hp", "pa", "ctx", "pb", "je", "dt", "gp", "jar", "lp", "git", "prot", "jj", "ja", "bj", "zip", "pp", "adj", "pr", "json", "jc", "pkg", "aja", "p", "txt", "jo", "fp", "qt", "bp", "jen", "java", "bot", "vp", "py", "keeper", "obj", "jing", "np", "dj", "j", "ppo", "kj", "jl", "js", "JP", "mp", "pai", "api", "rup", "ji", "ijk", "tp", "uj", "fm"], "responseObj": ["responseInfo", " responseObject", "respondObject", "reportObject", "ResponseObj", "responseOb", "Responseobj", "responseobj", "reportObj", "respondObj", "ResponseObject", "reportobj", "ResponseOb", "respExt", " responseInfo", " responseExt", "respondExt", "responseObject", " responseobj", "respObj", "respInfo", " responseOb", "responseExt", "reportOb", "respondInfo", "respObject"], "token": ["lex", "session", "next", "column", "sync", "data", "format", "pull", "tree", "oken", "string", "notice", "document", "rule", "str", "sign", "valid", "option", "Token", "character", "iter", "generation", "writer", "init", "note", "tag", "json", "random", "atom", "event", "variable", "qt", "in", "active", "type", "bot", "header", "element", "seed", "open", "right", "KEN", "name", "language", "channel", "skip", "pattern", "tick", "not", "cho", "po", "start", "current", "item", "wt", "parser", "ok", "key", "cookie", "node", "api", "ji", "complete", "field", "object", "info", "date", "operator"], "fieldname": [" fieldalias", "cellcode", "columnalias", "propertyna", "blockvalue", "fieldcode", " fieldna", "cellName", "labelName", "blockalias", "fieldvalue", " fieldcode", " fieldni", "columnname", "blockName", "fieldna", "labelni", " fieldvalue", "fieldName", "labelname", "propertycode", "columnvalue", "blockname", "fieldni", "cellname", "fieldalias", "propertyName", " fieldName", "Fieldname", "propertyname", "cellna", "FieldName", "Fieldni", "columnName"]}}
{"id1": "14691829", "id2": "15351863", "code1": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"in": ["inf", "a", "data", "string", "source", "i", "plus", "str", "input", "this", "text", "base", "p", "file", "conn", "reader", "ins", "bin", "m", "gen", "connection", "s", "buffer", "image", "c", "as", "In", "n", "inc", "cache", "IN", "val", "login", "config", "out", "info", "id"], "result": ["join", "data", "format", "string", "output", "diff", "db", "str", "response", "valid", "fr", "tr", "tmp", "fb", "this", "array", "v", "url", "page", "res", "err", "table", "results", "buffer", "hash", "br", "default", "Result", "up", "rf", "memory", "df", "cache", "work", "ger", "ret", "trace", "report", "r", "null", "out", "info", "match", "message"], "md5": ["dig6", "md7", " md4", "digql", "dig5", "mand5", "mand2", "mdql", "MD2", " md52", "dig85", "mand52", "amd4", "amd6", "amd85", " md6", " md2", "dig4", "md85", "MD4", "MD7", "dig2", "md52", "MD52", "mand4", "dig7", "md2", "md4", "MDql", "md6", " md85", " md7", "amd5", "MD5", " mdql"], "f": ["inf", "d", "format", "fun", "cf", "fast", "form", "sf", "feed", "output", "fx", "fr", "t", "fb", "fc", "F", "fa", "tf", "function", "p", "bf", "fp", "v", "fd", "of", "fo", "fac", "rf", "c", "l", "df", "af", "fw", "fn", "fe", "h", "info", "fs", "fm"], "b": ["ba", "xb", "d", "a", "rb", "g", "bb", " a", "string", "sb", "i", " B", "db", "ib", "fb", "binary", "text", "bs", "lb", "p", "block", "bf", "v", "bin", "boot", "k", "cb", "ab", "bd", "s", "B", "name", "bytes", "c", "l", "n", "body", "r", "ob", "back", "be", "e", "bit"]}}
{"id1": "17583193", "id2": "3514286", "code1": "    public boolean populateRecord(int[] attrIDs) throws IOException {\n        if (device == null) {\n            throw new RuntimeException(\"This is local device service record\");\n        }\n        if (attrIDs == null) {\n            throw new NullPointerException(\"attrIDs is null\");\n        }\n        if (attrIDs.length == 0) {\n            throw new IllegalArgumentException();\n        }\n        for (int i = 0; i < attrIDs.length; i++) {\n            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {\n                throw new IllegalArgumentException();\n            }\n        }\n        int[] sortIDs = new int[attrIDs.length];\n        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);\n        for (int i = 0; i < sortIDs.length; i++) {\n            for (int j = 0; j < sortIDs.length - i - 1; j++) {\n                if (sortIDs[j] > sortIDs[j + 1]) {\n                    int temp = sortIDs[j];\n                    sortIDs[j] = sortIDs[j + 1];\n                    sortIDs[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < sortIDs.length - 1; i++) {\n            if (sortIDs[i] == sortIDs[i + 1]) {\n                throw new IllegalArgumentException();\n            }\n            DebugLog.debug0x(\"query for \", sortIDs[i]);\n        }\n        DebugLog.debug0x(\"query for \", sortIDs[sortIDs.length - 1]);\n        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"attrIDs": ["attributeids", "attIDES", "attIDS", "attIDs", "sortIDS", "attributeID", "sortID", "tagIDS", "allIDs", "tagID", "allids", "sortIDES", "addrENTS", "sortids", "attID", "attENTS", "addrIDs", "allID", "attributeIDS", "attrENTS", "tagIDES", "attrids", "attributeIDES", "attids", "tagIDs", "attributeIDs", "attributeENTS", "attrIDS", "attrID", "addrID", "addrIDS", "allIDS", "attrIDES"], "i": ["phi", "length", "d", "ori", "ti", "uri", "ki", "pi", "k", "y", "fi", "n", "index", "xi", "e", "f", "x", "ui", "left", "g", "ni", "qi", "slice", "v", "ix", "in", "u", "iu", "yi", "io", "key", "li", "ji", "h", "info", "id", "a", "ij", "gi", "ind", "di", "z", "init", "my", "ai", "m", "ii", "c", "ri", "start", "api", "eni", "it", "ami", "ie", "bi", "ci", "is", "cli", "ik", "p", "inner", "ip", "o", "b", "multi", "I", "l", "si", "ini", "oi", "mi"], "sortIDs": ["ortIDES", " sortIDES", "sortIDS", "sortADS", "SortID", "SortIDs", "searchids", "orderIDs", "searchID", "sortID", " sortADS", "updateIDS", "allIDs", "allIDES", "searchIDS", "sortUID", "sortIDES", "ortIDs", "sortFiles", " sortUID", "filterID", "sortids", "SortUID", "filterIDs", "updateID", "allID", "syncIDES", "altIDES", " sortID", "orderIDES", "useIDs", "attrUID", "orderADS", "filterIDS", "syncID", "syncIDS", " sortids", "ortIDS", "useIDES", "altIDS", "syncIDs", "updateIDES", "useID", "altIDs", " sortFiles", "attrFiles", "ortID", "attrIDS", "useIDS", "orderIDS", "searchIDES", "SortIDES", "attrID", "updateIDs", " sortIDS", "SortIDS", "searchIDs", "orderFiles", "orderID", "ortUID", "filterUID", "ortids", "attrADS", "allIDS", "updateFiles", "altID", "orderids"], "j": ["f", "next", "d", "x", "je", "aj", "ui", "left", "ie", "last", "section", "ja", "jj", "ij", "qi", "fr", "bj", "di", "adj", "z", "pr", "jc", "J", "q", "p", "jo", "v", "ix", "part", "w", "u", "k", "jet", "ii", "y", "br", "job", "obj", "o", "b", "dj", "l", "jp", "oj", "jl", "js", "n", "key", "li", "ji", "h", "uj", "xi", "e"], "temp": ["tem", "needed", "wrap", "emp", "orig", "empty", " unused", "tr", "holder", " test", "tmp", "iter", "fake", " dummy", " result", "stable", " Temp", "modified", " orig", " temporary", "tc", "used", "get", "ed", "alt", " fake", "partial", " modified", "pack", "ash", " tmp", "max", "flat", "non", "test", " original", "key", "ex", "Temp", "porary"]}}
{"id1": "397240", "id2": "10385815", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"inFile": ["InPlace", "inPlace", "infile", "outFilename", " infile", "outPath", "outFiles", "oldfile", " inPath", "oldFiles", "outPlace", "oldFilename", "inputfile", "incFile", "oldFile", "inputFiles", "InPath", "incPlace", "outfile", "Infile", "incfile", "incFiles", "inFiles", "inFilename", "InFile", "inputFile", "inputFilename", " inFiles", "inPath", "InFiles"], "outFile": ["zipFilename", "Outfile", "outFilename", "outputFile", " outTable", "outputFolder", " outFolder", "OutFile", "outPlace", " outPlace", "OutDir", "OutPlace", "outputTable", " outString", "newFile", "inputFolder", "inputTable", "newDir", " outDir", "inputPlace", "outFolder", "zipString", "outfile", "outputString", "zipFILE", "outputFilename", "outDir", "zipFile", " outFilename", "inputFile", " outfile", "outputFILE", "outputPlace", "outFILE", "newPlace", "outString", " outFILE", "newfile", "outTable"], "iis": ["ioIs", "iniIs", "iIs", "iniais", "iisc", "iniisc", " iIS", "ciid", "iniiss", "iiIS", "Iiss", "iils", " iid", "iais", "iid", "ioisc", "iIS", "iniils", "Iis", "iniIS", "iniis", "ioiss", "ciis", " iais", "IIs", "ciiss", " iIs", "iiss", "ciais", "iniid", "iiIs", " iiss", "Iisc", "iois", "iiils", "iiis", " iils"], "dcmParser": ["dmcPar", " dcmLoader", "dcpReader", "DcmJar", "pdymReader", "pdymJar", "dmmarser", "dcrJar", "dcmStreamer", "DcmParser", "ddcParser", "dtermStreamer", " dpmPar", "dymReader", "dcrWriter", "dcpParser", "dmmReader", "dcmPar", "dcyJar", " dpmBuilder", "ddcLoader", "dcmarser", " dcmPlugin", "dpmparser", " dcmBuilder", "ddcPlugin", " dpmarser", "dmoduleParser", "dsemStreamer", "dpmStreamer", "dymParser", "dtermPlugin", "pdymParser", " dcmarser", "dtermParser", "ddcReader", "Dcmarser", "dymJar", " dcmPar", "dcrparser", "dsemParser", "Dcmparser", "dcmWriter", "dmmParser", " dpmJar", "dcmBuilder", " dpmStreamer", "dsemReader", " dpmPlugin", " dcmStreamer", "dcmparser", "dcmLoader", "dcmPlugin", "dmoduleReader", "dmcJar", "dcpJar", " dpmReader", "dpmLoader", "dcyParser", "dcyarser", "dcyReader", "dcrReader", "dpmJar", "pdcmReader", "dcrParser", "dpmBuilder", "dpmPar", "dymparser", "pdymparser", " dpmLoader", "DcmReader", " dpmParser", "pdcmParser", "dcpparser", " dcmReader", "dtermReader", "dmcParser", "dcmReader", "dcmJar", "dpmarser", "pdcmparser", "dcrarser", " dcmJar", "DcmWriter", "dmmWriter", "dpmParser", "dpmReader", "dcrPar", "dmodulePlugin", "pdcmJar", "dmoduleBuilder", "dsemPlugin", "dmcarser", "dpmPlugin"], "ds": ["session", "cs", "pd", "d", "docs", "uds", "data", "dt", "dr", "sync", "src", "iss", "gd", "Ts", "tes", "asi", "da", "dc", "ays", "db", "ipes", "DS", "parts", "di", "ads", "points", "is", "dds", "bs", "amps", "nas", "utils", "ys", "os", "des", "dd", "vs", "ns", "ils", "fd", "gs", "ins", "ls", "conn", "cdn", "Ds", "s", "Os", "tx", "services", "ws", "xs", "client", "details", "rs", "ss", "ps", "ros", "Db", "df", "js", "ts", "drivers", "plugins", "ld", "sys", "eps", "dat", "ks"], "pdReader": ["pidReader", "dsReader", "pidScan", "pidLoader", "xdreader", "hdRead", "pdParser", "dsLoader", "hdWriter", "pbLoader", "pdRead", "pcRead", "wdLoader", "xdReader", "pidParser", "xdRead", "pdLoader", "pcLoader", "pbParser", "pdreader", "pbReader", "wdWriter", "dsRead", "dsWriter", "hdreader", "wdRead", "pcScan", "wdReader", "hdReader", "pbScan", "pcParser", "pdScan", "dsreader", "pcWriter", "pcReader", "xdWriter"], "out": ["d", "flush", "ssl", "class", "store", "url", "full", "w", "code", "outs", "as", "external", "at", "inc", "pool", "auto", "sys", "model", "oder", "ext", "sync", "data", "with", "lib", "group", "base", "conn", "file", "in", "down", "img", "exp", "connection", "net", "io", "device", "write", "exec", "pass", "log", "key", "word", "again", "dot", "OUT", "builder", "output", "line", "db", "list", "writer", "Out", "array", "temp", "manager", "to", "s", "later", "up", "client", "order", "doc", "outer", "sum", "cache", "ex", "copy", "default", "object", "session", "child", "point", "user", "flow", "password", "cli", "parent", "lock", "page", "co", "gen", "err", "now", "call", "inner", "image", "name", "obj", "o", "result", "term", "over", "login", "null"], "dcmEncParam": ["dcmElParameter", "dcmAccSm", "dcmEngVar", "dpmDecParam", "dcmDecSm", "dcmElType", "dcmDecPar", "dcmEncSm", "dcmencParameter", "dcmEncVar", "dcmEncType", "dcmEncPar", "dcmEncParameter", "dcmencSm", "dcmAccParam", "dpmEncSm", "dcmEnVar", "dcmEngParam", "dcmElParam", "dcmEngType", "dcmEngParameter", "dcmElVar", "dcmEnType", "dpmDecParameter", "dcmEnParam", "dpmEncParam", "dpmDecSm", "dcmEnParameter", "dcmDecParameter", "dcmDecParam", "dcmencParam", "dcmAccParameter", "dcmEnPar", "dpmEncParameter"], "pdWriter": ["ddWrite", "dsWrite", "ddWriter", "tdOutput", "hdOutput", "hdWR", "hdWriter", "tdContent", "pdWR", "PDContent", "tdReader", "dsWR", "dsOutput", "ddOutput", "pxOutput", "ddWR", "PDOutput", "hdWrite", "pdContent", "PDReader", "dsWriter", "tdWriter", "pdOutput", "pxContent", "PDWriter", "pdWrite", "pxReader", "pxWriter"]}}
{"id1": "7425022", "id2": "14785308", "code1": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"wsdlURL": ["wsslPath", "wllPath", "wssdPath", "wsdnFILE", "wsdlPath", "wllURL", "wsllURL", "wsdnPath", "wslUrl", "wsdnUrl", "wsslURI", "wssdUrl", "wsdalURI", "wllFILE", "wsllURI", "wdlUrl", "wdlFILE", "wsdlFILE", "wsdlURI", "wslURI", "wsdalURL", "wsdnURL", "wdlPath", "wslPath", "wsdalUrl", "wllUrl", "wdlURI", "wsllFILE", "wssdFILE", "wsslURL", "wsdlUrl", "wdlURL", "wsdalPath", "wssdURL", "wslURL", "wsllUrl", "wsslUrl", "wsllPath"], "userPassword": [" userName", "UserName", "authorName", "userHack", "authorPassword", "authorHack", "Userpassword", " userpassword", "usePassword", " userPass", " userData", "UserHack", "userData", "userName", "usepassword", "UserPass", "UserData", "userpassword", "authorpassword", " userHack", "usePass", "useAuth", "UserAuth", " userAuth", "userAuth", "useData", "UserPassword", "userPass"], "filePath": ["FileStr", "fileLocation", "outputPath", " fileLocation", "filepath", " fileStr", "Filepath", "outputLocation", "FilePath", "fileStr", "outputStr", "outputpath", "FileLocation", " filepath"], "endpoint": ["adpointer", "adpoint", " endpo", "endpo", " endPoint", "adpo", "endpointer", "Endpointer", " endpoints", "Endpo", "Endpoint", "adpoints", "endpoints", "adPoint", " endpointer", "endPoint", "EndPoint", "Endpoints"], "conn": ["oss", "Connection", "comm", "ca", "ctx", "cm", "sync", "dh", "pg", "g", "socket", "cf", "Con", "ssl", "connect", "ci", "con", "dc", "cn", "pc", "conf", "org", "adj", "cli", "init", "nc", "cp", "nt", "p", "url", "ns", "co", "part", "w", "impl", "act", "ct", "cb", "connection", "inner", "pub", "sql", "open", "ws", "ec", "client", "conv", "c", "reg", "exec", "en", "close", "Conn", "rc", "n", "oa", "Connect", "ann", "ac", "loc", "ch", "fn", "dn", "mc", "enc", "ob", "h", "coll", "col", "auth"], "is": ["src", "ais", "its", "ism", "sc", "rss", "ar", "as", "Is", "isp", "sec", "index", "out", "fs", "hi", "rest", "ir", "ris", "x", "serv", "iss", "ib", "iv", "in", "res", "io", "bis", "mis", "ios", "rs", "ps", "stream", "js", "r", "h", "info", "il", "any", "i", "es", "ipp", "os", "est", "iso", "ai", "ins", "s", "ws", "ri", "or", "isc", "isi", "rx", "oc", "inst", "lis", "it", "ie", "isl", "has", "sr", "ois", "us", "p", "mes", "act", "ip", " IS", "IS", "ops", "was", "irc", "ss", "si", "im"], "isr": ["isrb", "ISr", "issw", "ISl", "ISw", "isl", "isrs", " isp", "issrb", "ISrs", "asr", "issp", "isw", "issrs", "ISrb", "asp", " isw", "asrb", " isl", "ISp", "asrs", "isp", "issl", "issr"], "sw": ["hi", "sem", "iw", "x", "rew", "sm", "wrap", "rw", "pg", "sb", "xml", "sf", "wb", "nw", "wa", "SW", "sh", "WS", "response", "cr", "war", "sl", "ow", "aw", "wx", "wp", "hop", "sc", "wr", "Sw", "w", "rss", "ww", "hw", "ws", "tw", "su", "was", "stream", "sv", "wh", "wt", "rx", "wl", "eng", "so", "r", "ew", "im"], "buf": ["queue", "bh", "rb", "data", "bb", "brace", "wb", "feed", "pad", "shift", "bc", "str", "cr", "buff", "fb", "cv", "len", "seq", "text", "ff", "cas", "base", "block", "func", "raw", "vec", "prop", "bin", "cb", "err", "box", "char", "bd", "buffer", "br", "Buffer", "batch", "b", "bytes", "rc", "uf", "ha", "cur", "pool", "rx", "uc", "bag", "la"], "read": ["need", " write", "length", "sync", "index", "child", "data", "find", "g", "check", "parse", "i", "Read", "end", "send", "connect", "feed", "ignore", "iter", "input", "wait", "text", "reading", "load", "block", "add", "raw", "sleep", "in", "num", "se", "w", "play", "reader", "select", "boot", "k", "get", "READ", "ride", "buffer", "open", "old", "write", "skip", "en", "size", "reads", "work", "n", "pass", "run", "start", "ok", "max", "stream", "log", "count", "r", "copy", "use", "default"], "outputDir": ["OutputFile", "tmpFolder", "OutputPath", "outputFile", "outputFolder", "tmpPath", "OutputDirectory", "OutputDir", "inputFolder", "OutputFolder", "tmpDir", "outputDirectory", "outFolder", "tmpDirectory", "inputDir", "outDir", "outputPath", "inputFile", " outputFolder", " outputFile", "outFile", " outputPath", " outputDirectory", "inputDirectory", "outDirectory"], "file": ["f", "filename", "child", "save", "data", "content", "source", "resource", "path", "output", "handler", "line", "db", "feed", "pe", "writer", "File", "folder", "store", "parent", "base", "function", "fp", "url", "full", "play", "directory", "files", "letter", "unit", "buffer", "name", "up", "dir", "b", "build", "le", "ile", "FILE", "stream", "work", "log", "local", "out", "object", "info", "create", "message"], "fos": [" fols", "fols", "New", "fOS", "ftOS", "path", "response", "http", "ioops", "this", "Response", "fops", "ftops", "ftols", "ioOS", "ftos", "s", "iools", "_", "client", "write", "HTTP", "ioos", "Url", " fops", " fOS"]}}
{"id1": "18793482", "id2": "10212189", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 0, "substitutes": {"locale": ["localue", "locationame", "locality", "cale", "LOCales", "locationales", "localoding", "cales", "locationALE", "locame", "localale", "LocALE", "localALE", "localame", "locationale", "Locame", "langale", "locue", "localality", "cue", "Locales", "localales", "langALE", "LOCALE", "Locale", "Locoding", "locoding", "locALE", "langales", "Locue", "coding", "locales", "LOCale", "langality", "LOCality"], "messageName": ["MessageKey", "phraseName", "format", " messageType", "msgKey", "http", "this", " messageKey", "phraseValue", "text", "messageType", " messageNames", "MessageValue", "add", "plain", "url", "phraseKey", "get", "MessageNames", "s", "messageKey", "_", "messageNames", "language", "msgNames", "MessageType", "msgType", "MessageName", "msgName", "phraseType"], "messageValue": ["applicationName", " messageVal", "applicationType", " messageType", "msgVal", "MessageVal", "messageType", "MessageValue", "messageVal", "applicationVal", "MessageType", "applicationValue", "msgType", "MessageName", "msgValue", "msgName"], "properties": ["Pro", "pb", "data", "xml", "stats", "resources", "conf", "tmp", "perties", "Property", "json", "pro", "txt", "params", "prop", " Properties", "py", "ops", "obj", "ips", "settings", "property", "ps", "api", "config", " props", "options", "metadata"], "i18nPath": ["i18nsText", "i18nsUrl", "i18neUrl", "i11pnPath", "i18nsPath", "i18fPath", "i14nPath", "i18bPath", "i11nCorp", "i14nsPath", "i16nStr", "i11nPath", "i18nsStr", "i18nCorp", "i11pnpath", "i14npath", "i18onText", "i18bpath", "i16nFormat", "i18onUrl", "i18bStr", "i18naPath", "i14nsUrl", "i18bFormat", "i18nFormat", "i16nsFormat", "i14nUrl", "i16nsStr", "i18fpath", "i18fFormat", "i18onPath", "i18onpath", "i14nspath", "i11pnCorp", "i11nUrl", "i18nStr", "i18nText", "i18nsFormat", "i18nePath", "i16nspath", "i18neCorp", "i11npath", "i18nepath", "i14nsText", "i18nspath", "i18pnPath", "i16nPath", "i14nText", "i18naText", "i18nUrl", "i18npath", "i16npath", "i18pnCorp", "i11pnUrl", "i18pnpath", "i18naUrl", "i18napath", "i18pnUrl", "i18nsCorp", "i18fStr", "i16nsPath"], "englishFile": ["EnglishJar", "internetFile", "officialPath", "internetResource", "englishDir", "englishPlace", "ianaFile", "EnglishFile", "ianaJar", "EnglishFiles", "EnglishPlace", "ianaDir", "Englishfile", "examplePath", " englishDir", "officialPlace", "englishResource", "englishPath", " englishPath", " englishFiles", "exampleFile", "englishFiles", "englishJar", "officialfile", "officialFile", "examplePlace", " englishResource", " englishJar", "englishfile", "EnglishPath", "examplefile", "ianaFiles", "EnglishResource", "EnglishDir", "internetPath", "internetFiles"], "propertiesFilePath": ["propertiesfilepath", "propertiesFilesName", "propertiesFileUrl", "pertiesFilepath", "pertiesDirUrl", "propertiesfilePath", "propertiesFilesPath", "propertiesDirPath", "propertiesFilepath", "pertiesDirName", "propertiesFullUrl", "propertiesFullName", "pertiesFileLocation", "propertiesfileUrl", "propertiesfileName", "pertiesDirPath", "pertiesFileName", "propertiesDirpath", "propertiesDirLocation", "propertiesFilespath", "propertiesDirUrl", "pertiesDirpath", "propertiesfileLocation", "pertiesFilePath", "propertiesDirName", "pertiesfilePath", "propertiesFullpath", "propertiesFileName", "pertiesfileName", "pertiesFileUrl", "pertiesfilepath", "propertiesFilesLocation", "pertiesfileLocation", "propertiesFileLocation", "propertiesFullPath"], "file": ["path", "http", "pe", "class", "File", "url", "full", "future", "unit", "buffer", "FILE", "model", "e", "application", "f", "data", "socket", "source", "binary", "folder", "base", "reader", "connection", "io", "stream", "log", "fe", "field", "h", "word", "use", "content", "string", "resource", "handler", "zip", "text", "book", "entity", "function", "fp", "part", "play", "directory", "single", "letter", "module", "media", "language", "up", "le", "property", "or", "ile", "work", "object", "message", "filename", "child", "it", "format", "parent", "lock", "p", "page", "die", "php", "files", "one", "force", "name", "b", "l"], "in": ["gin", "d", "it", "isin", "inn", "i", "con", "ic", "sin", "input", "init", "kin", "p", "din", "lin", "reader", "rin", "ins", "bin", "er", "into", "err", "io", "inner", "s", "image", "b", "ri", "inside", "or", "l", "win", "In", "n", "inc", "cin", "IN", "nin", "ini", "r", "login", "again", "pin"], "out": ["ext", "f", "sync", "OUT", "socket", "string", "home", "i", "builder", "output", "and", "cli", "lib", "by", "Out", "p", "ou", "v", "error", "full", "part", "co", "w", "plain", "bin", "one", "exp", "err", "net", "io", "to", "s", "inner", "image", "up", "obj", "client", "o", "b", "outs", "exec", "outer", "work", "n", "inc", "r", "ex", "fn", "word", "again"], "c": ["cl", "f", "d", "x", "a", "cu", "cf", "lc", "i", "ci", "ic", "con", "dc", "cr", "dec", "character", "col", "ce", "p", "cy", "v", "esc", "sc", "w", "ct", "k", "arc", "char", "code", "ec", "abc", "o", "b", "cc", "ice", "rc", "size", "l", "n", "ac", "ch", "xc", "r", "uc", "enc", "h", "pointer", "C", "e"], "is": ["ir", "lis", "ris", "re", "serv", "it", "ui", "iss", "i", "es", "ais", "does", "path", "has", "str", "ib", "us", "iter", "isu", "its", "isa", "os", "iso", "ins", "res", "get", "s", "bis", "IS", "ios", "ri", "as", "was", "Is", "are", "stream", "si", "api", "info", "id"], "breader": [" breaders", "rowner", " birders", " Breader", " Breaders", "breworer", "breadner", "breadler", "rainer", "brewner", "breaders", "breadER", "brewER", "rainER", " birder", "rainner", "rainorer", "rownner", " birdler", "brewer", " Breadler", " breadler", "rownorer", " BreadER", " birdER", " breadER", "rownER", "breadorer"], "line": ["sync", "plugin", "data", "row", "lines", "strip", "string", "section", "parse", "no", "end", "profile", "feed", "rule", "LINE", "str", "response", "lined", "model", "entry", "character", "nl", "sl", "el", "cell", "lf", "liner", "text", "value", "license", "day", "block", "error", "url", "page", "lin", "part", "inline", "one", "phrase", "style", "letter", "comment", "header", "name", "Line", "code", "look", "write", "le", "l", "link", "pass", "item", "definition", "frame", "log", "key", "split", "body", "li", "lo", "word", "status", "band", "message"], "strBuilder": ["strbuilder", " strReader", "StrBlock", " strParser", "strBot", "styleReader", "bcBuilt", "execParser", "stringbuilder", "arrBuilding", "StrBuilding", "StrReader", "stringBlock", "stringHelper", "StrBu", " strBot", "stringBuilt", "strBuilt", "execBuilder", "stringReader", "stringBuffer", "arrBuild", "stringBuilder", "strReader", " strBu", "styleBot", " strBuild", "arrbuilder", "strBuffer", " strBuilt", "styleBuilding", " strbuilder", "arrBuilder", "bcBuild", "strBuild", " strBuffer", "stringParser", "StrBuffer", "strBlock", "execBuild", "stringBuild", "bcHelper", "stringBuilding", "StrBuilder", "stringBu", " strHelper", "execBuffer", " strBlock", "StrBuild", "strBuilding", "stringBot", "strBu", "bcBuilder", "styleBuilder", " strBuilding", "strParser", "strHelper"], "pieces": ["rings", "bones", "styles", "pins", "tools", "bits", "circle", "features", "words", "lists", "lines", "clips", "bands", "phones", "blocks", "str", "sections", "parts", "cuts", "boxes", "tips", "tops", "photos", "nets", "groups", "cards", "items", "apps", "files", "css", "steps", "marks", "services", "cells", "ops", "objects", "bytes", "letters", "places", "vals", "caps", "cats", "values", "keys", "seconds", "pots", "split", "strings", "stars", "piece", "packs", "names"], "found": ["defined", "sent", "existent", "readable", "exist", "find", "left", "confirmed", "empty", "matched", "successful", "path", "built", "valid", "broken", "fall", " Found", "where", "z", "Found", "available", "search", "F", "lost", "failed", "enabled", "supported", "only", "first", "expected", "full", "identified", "true", "temp", "missing", "installed", "printed", "normal", "got", "finding", "existing", "closed", "used", "err", "given", "still", "changed", "filled", "initialized", "loaded", "result", "old", "not", "pos", "all", "good", "published", "l", "successfully", "fixed", "count", "created", "fl", "default", "null"]}}
{"id1": "22057083", "id2": "9327525", "code1": "    private void Connect() throws NpsException {\n        try {\n            client = new FTPClient();\n            client.connect(host.hostname, host.remoteport);\n            int reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                client.disconnect();\n                client = null;\n                com.microfly.util.DefaultLog.error_noexception(\"FTP Server:\" + host.hostname + \"refused connection.\");\n                return;\n            }\n            client.login(host.uname, host.upasswd);\n            client.enterLocalPassiveMode();\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            client.changeWorkingDirectory(host.remotedir);\n        } catch (Exception e) {\n            com.microfly.util.DefaultLog.error(e);\n        }\n    }\n", "code2": "    @Test\n    public void test02_ok() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(chartURL);\n            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);\n            nameValuePairs.add(new BasicNameValuePair(\"ws\", \"getDomainEvolution\"));\n            nameValuePairs.add(new BasicNameValuePair(\"chartTitle\", \"test\"));\n            nameValuePairs.add(new BasicNameValuePair(\"type\", \"chart\"));\n            nameValuePairs.add(new BasicNameValuePair(\"firstDate\", \"20111124\"));\n            nameValuePairs.add(new BasicNameValuePair(\"lastDate\", \"20111125\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParams\", \"type,counting,protocol,unit,proxy,domain,timeScale,period\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParamsValues\", \"chart,volume,all,hits,all,google.com,day,360\"));\n            nameValuePairs.add(new BasicNameValuePair(\"serieTitle\", \"serie\"));\n            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            assertNotNull(entity);\n            InputStream instream = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream));\n            System.out.println(reader.readLine());\n            instream.close();\n            assertEquals(\"error :\" + response.getStatusLine(), 200, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"client": ["session", "cm", "cl", "child", "plugin", "core", "port", "socket", "user", "service", "request", "connect", "resource", "proxy", "app", "con", "per", "cn", "remote", "host", "handler", "grid", "server", "http", "ci", "pc", "cloud", "cli", "lib", "console", "ce", "project", "cp", "secure", "parent", "conn", "co", "manager", "friend", "connection", "call", "get", "force", "open", "Client", "code", "name", "channel", "c", "util", "cc", "close", "cache", "current", "pool", "local", "clean", "ace", "api", "config", "default", "cell"], "reply": ["address", "next", "sync", "prefix", " replies", "request", "fire", "send", "status", "ply", "replace", "reason", "response", "read", "answer", "dy", "repl", "respond", "query", "ping", "error", "part", "bot", "connection", "call", "state", "err", "comment", "buffer", "code", "info", "related", "result", "echo", "link", "Reply", "resp", "post", "ret", "continue", " response", "message"]}}
{"id1": "5977352", "id2": "8932510", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"src": ["loader", "inst", "filename", "rb", "data", "uri", "gb", "sb", "source", "resource", "path", "slice", "tmp", "buf", "sl", "input", "this", "dist", "fp", "file", "conn", "url", "sc", "ins", "img", "files", "s", "obj", "b", "sel", "rc", "proc", "stream", "view", "loc", "ource", "config", "proxy"], "dest": ["delete", "target", "rest", " Dest", "d", "st", "orig", "home", "source", "thin", "wb", "Dest", "dc", "path", "output", "tmp", "zip", "project", " destination", "this", "class", "dist", "desc", "store", "folder", "cont", "cp", "txt", "parent", "file", "die", "destroy", "part", "url", "temp", "opt", "de", "img", "cdn", "table", "done", "later", "name", "dir", "obj", "route", "dep", "trans", "cache", "config", "null", "master"], "bufSize": ["queueSize", "bufferSize", "buffer2", "queuesize", "bufLen", "bufsize", "ufLen", " bufsize", "buffersize", "ufsize", "ufSize", "bufferLen", "buf2", " buf2", " bufLen", "queueLen", "uf2"], "force": ["urse", "delete", "f", "sync", "push", "flush", "source", "no", "remote", "require", "replace", "dirty", "apply", "deep", "parent", "store", "base", "p", "load", "front", "only", "file", "hard", "ist", "place", "forced", "ride", "route", "forcing", "write", "forces", "rc", "auto", "Force", "count", "like", "use", "pull", "id"], "buffer": ["queue", "border", "address", "length", "uffer", "data", "flush", "reference", "request", "source", "feed", "zero", "slice", "limit", "iter", "buff", "buf", "fb", "binary", "value", "base", "load", "raw", "url", "transfer", "reader", "bin", "offset", "seed", "Buffer", "batch", "b", "bytes", "write", "result", "memory", "cache", "split", "append", "padding", "null"], "read": ["lex", " write", "next", "length", "sync", "d", "allow", "data", "find", "ad", "check", "parse", "i", "Read", "connect", "send", "end", "feed", "ind", "iter", "input", "wait", "len", "text", "reading", "load", "block", "add", "raw", "sleep", "reader", "select", "play", "se", "fill", "seek", "k", "level", "get", "io", "ed", "READ", "ip", "open", "ride", "b", "skip", "write", "exec", "build", "close", "index", "size", "start", "work", "n", "reads", "run", "view", "pass", "current", "count", "copy", "use", "create", "show", "id"], "in": ["gin", "f", "a", "serv", "isin", "socket", "inn", "source", "i", "thin", "con", "sin", "input", "lib", "init", "base", "kin", "min", "din", "url", "conn", "reader", "rin", "part", "ins", "bin", "m", "err", "connection", "inner", "image", "up", "b", "c", "as", "inside", "win", "In", "pass", "n", "cin", "inc", "ac", "IN", "nin", "ini", "r", "ex", "login", "again", "pin", "pull", "id"], "out": ["ext", "sync", "OUT", "socket", "user", "home", "no", "i", "source", "app", "output", "off", "line", "with", "lib", "writer", "this", "init", "by", "Out", "ou", "can", "conn", "url", "plain", "part", "co", "w", "bin", "one", "exp", "err", "call", "net", "io", "inner", "connection", "image", "name", "up", "client", "obj", "o", "b", "exec", "outs", "write", "outer", "max", "n", "at", "inc", "ac", "cache", "nin", "key", "ex", "again", "id"]}}
{"id1": "14047629", "id2": "9398454", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"source": ["session", "target", "loader", "data", "content", "src", "service", "parse", "request", "proxy", "resource", "document", "remote", "path", "ources", "SOURCE", "server", "project", "input", "class", "text", "cp", "parent", "load", "processor", "fp", "file", "transfer", "in", "reader", "connection", "inner", "image", "buffer", "comp", "info", "result", "exec", "proc", "stream", "Source", "ource", "config", "use", "out", "object", "status"], "process": ["session", "target", "system", "processing", "port", "script", "Process", "resource", "document", "app", "cess", "path", "progress", "output", "press", "plus", "command", "project", "console", "class", "parent", "p", "share", "processor", "task", "file", "method", "worker", "thread", "call", "image", "display", "open", "job", "machine", "pid", "exec", "result", "program", "pipe", "proc", "index", "python", "work", "run", "parser", "loop", "post", "node", "use", "object", "status", "master"], "processStdOut": ["processStdOUT", "processStdinOutput", "processSttOUT", "processSTdOUT", "processStDOut", "processSttOutput", "processStdOutput", "processStDObj", "processStDOutput", "processSTDObj", "processStdinOUT", "processSTDOUT", "processSTdOutput", "processStdinObj", "processSTdObj", "processStDOUT", "processSttObj", "processSTDOutput", "processSTDOut", "processStdinOut", "processSttOut", "processStdObj", "processSTdOut"], "processStdIn": ["processSTdIns", "processSttIndex", "processStadin", "processSTstdIndex", "processSTstdin", "processStbIn", "processSTdIn", "processStbIN", "processStadIN", "processStstdIndex", "processStdinIN", "processStstdIn", "processStbIndex", "processSTstdIn", "processSttIn", "processStdinIn", "processStdIns", "processStstdin", "processStstdIns", "processSttIns", "processStbin", "processSttin", "processStdinOut", "processSTdin", "processStbIns", "processSTdIndex", "processStbOut", "processStdIN", "processStadIn", "processStdin", "processStdIndex", "processStadOut", "processStdinin", "processSTstdIns"]}}
{"id1": "22268798", "id2": "9398454", "code1": "    @Override\n    public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException {\n        String uniqueName = path.getBaseName();\n        URL url = buildURL(uniqueName);\n        URLContent content = new URLContent(url, this.getName(), uniqueName);\n        content.setUniqueName(uniqueName);\n        content.setReadable(true);\n        content.setWritable(writable);\n        content.setExists(true);\n        try {\n            URLConnection connection = url.openConnection();\n            String mimeType = connection.getContentType();\n            content.setMimeType(mimeType);\n            content.setWritable(true);\n        } catch (IOException ex) {\n            throw new ContentException(\"unable to obtain mime type of \" + url, ex);\n        }\n        return content;\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"principal": ["Princunctipal", "princential", "Princunctential", "pruncteter", "Princincipal", "prunctential", "princeter", "prercificate", "princificate", "pricipeter", "pricipential", "Princincential", "Princincificate", "pricipificate", "prunctipal", "prerceter", "pricipipal", "prercential", "Princunctificate", "prunctificate", "prercipal", "Princuncteter", "Princinceter"], "path": ["loader", "ath", "PATH", "next", "prefix", "data", "format", "user", "uri", "request", "string", "source", "resource", "project", "class", "context", "text", "parent", "root", "file", "pointer", "part", "prop", "Path", "method", "location", "name", "client", "pattern", "property", "instance", "link", "node", "api", "object", "info"], "version": ["target", "format", "string", "resource", "str", "server", "vision", "project", "json", "parent", "value", "v", "level", "Version", "versions", "VERSION", "release", " versions", "ver", "current", "node", "val", "out", "object", "model", "date", "depth"], "properties": ["Pro", "address", "data", "features", "resources", "perties", "classes", "Property", "pro", "json", "items", "params", "prop", "state", "results", "objects", "details", "ips", "settings", "property", "types", "ps", "values", "plugins", "fields", "options", "metadata"], "uniqueName": ["blockPath", " uniquePath", "stringname", "blockKey", "filename", " uniqueType", "baseName", "UniqueTime", "blockType", " uniqueKey", "filePath", "UniqueType", "basePath", " uniqueTime", "basename", "uniquePath", "blockName", "Uniquename", "fileName", " uniquename", "UniqueKey", "baseKey", "UniqueName", "uniqueTime", "uniquename", "stringKey", "uniqueType", "UniquePath", "stringPath", "uniqueKey", "fileTime", "stringName"], "url": ["address", "f", "found", "user", "uri", "bb", "ssl", "string", "source", "proxy", "web", "resource", "feed", "host", "layer", "server", "http", "sl", "el", "URL", "this", "parent", "html", "base", "error", "file", "page", "conn", "ls", "www", "location", "image", "open", "name", "coll", "client", "channel", "build", "l", "ll", "link", "download", "Url", "log", "position", "loc", "ob", "object"], "content": ["common", "ext", "wrapper", "cover", "ca", "cm", "address", "child", "data", "core", "condition", "user", "cf", "section", "proxy", "resource", "remote", "container", "document", "output", "const", "host", "layer", "response", "server", "handler", "lc", "this", "ce", "parent", "cont", "creator", "load", "source", "file", "conn", "page", "full", "reader", "temp", "location", "comment", "image", "change", "default", "media", "code", "update", "coll", "client", "c", "result", "instance", "current", "cache", "ac", "key", "node", "complete", "config", "copy", "Content", "object", "model", "create", "message"], "connection": ["application", "session", "Connection", "number", "data", "uri", "string", "section", "connect", "resource", "proxy", "container", "con", "handler", "response", "http", "server", "character", "context", "communication", "creator", "database", "conn", "reader", "directory", "io", "image", "open", "connected", "coll", "client", "channel", "relation", "c", "control", "pool", "position", "loc", "config", "object"], "mimeType": ["mmiveInfo", "MimeName", "Mimetype", "miveInfo", "mimesPath", "mmimeInfo", "mimePath", "mmiveType", "MIMEtype", "mangPath", "metytype", "mangtype", "metyInfo", "mivetype", "mIMEName", "mmivetype", "mangName", "MIMEName", "mIMEtype", "MIMEType", "mimestype", "mimesType", "mimeName", "mangType", "MIMEPath", "mIMEPath", "mIMEType", "mmimeType", "mimeInfo", "metyType", "MimePath", "MimeType", "mimesName", "mmimetype", "mimetype", "mIMEInfo", "miveType"]}}
{"id1": "12197169", "id2": "16969205", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    private List<JarFile> webArchives(ServletContext servletContext) throws IOException {\n        List<JarFile> list = new ArrayList<JarFile>();\n        Set<Object> paths = servletContext.getResourcePaths(WEB_LIB_PREFIX);\n        for (Object pathObject : paths) {\n            String path = (String) pathObject;\n            if (!path.endsWith(\".jar\")) {\n                continue;\n            }\n            URL url = servletContext.getResource(path);\n            String jarURLString = \"jar:\" + url.toString() + \"!/\";\n            url = new URL(jarURLString);\n            JarFile jarFile = ((JarURLConnection) url.openConnection()).getJarFile();\n            JarEntry signal = jarFile.getJarEntry(FACES_CONFIG_IMPLICIT);\n            if (signal == null) {\n                if (log().isTraceEnabled()) {\n                    log().trace(\"Skip JAR file \" + path + \" because it has no META-INF/faces-config.xml resource\");\n                }\n                continue;\n            }\n            list.add(jarFile);\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"in": ["f", "a", "it", "data", "isin", "inn", "ssl", "source", "from", "con", "path", "token", "on", "server", "read", "fr", "is", "input", "by", "scan", "min", "din", "url", "file", "conn", "reader", "error", "lin", "ins", "bin", "er", "of", "err", "connection", "io", "inner", "s", "buffer", "ing", "image", "cms", "o", "c", "b", "l", "doc", "In", "stream", "at", "n", "inc", "log", "IN", "nin", "ini", "r", "ex", "login", "index", "out", "again", "info", "e", "id"], "line": ["f", "L", "data", "row", "lines", "parse", "string", "source", "lc", "end", "status", "rule", "LINE", "str", "id", "message", "entry", "ine", "el", "sl", "lf", "text", "value", "block", "url", "file", "lin", "page", "inline", "reader", "ge", "comment", "unit", "buffer", "Line", "code", "name", "b", "write", "le", "l", "link", "ne", "log", "frame", "key", "val", "record", "object", "col", "e", "cell"], "i": ["phi", "f", "x", "d", "ori", "ui", "ti", "ie", "ni", "bi", "ci", "gi", "qi", "slice", "di", "abi", "pi", "zi", "p", "ai", "ix", "u", "k", "io", "ip", "ii", "o", "b", "ri", "I", "fi", "j", "l", "n", "uni", "si", "li", "ini", "oi", "index", "xi", "eni", "e", "ski"], "logDatum": ["logFictionary", "Logdum", "logDumbo", "systemMetumbo", "systemMetictionary", "logMetictionary", "LogData", "LogDict", "logDsatum", "systemDatum", "logDsata", "logDsict", "logDatict", "Logdatum", "logDict", "LogDatum", "systemMetata", "systemDumbo", "logMetumbo", "logDictionary", "Logdata", "logDsum", "logdatum", "logdum", "logMetata", "systemMetatum", "Logdict", "logDum", "logDatata", "logData", "logFatum", "logDatatum", "systemDictionary", "LogDum", "logdata", "logdict", "logFumbo", "logMetatum", "systemData", "logFata"]}}
{"id1": "3558512", "id2": "17999474", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "label": 1, "substitutes": {"out": ["loader", "dump", "filename", "OUT", "a", "data", "content", "string", "source", "i", "output", "server", "writer", "parent", "Out", "raw", "file", "conn", "page", "temp", "w", "bin", "gen", "err", "io", "buffer", "image", "name", "up", "archive", "obj", "client", "o", "outs", "exec", "cache", "pool", "report", "ex", "copy", "png"], "parser": ["loader", "system", "wrapper", "pillar", "plugin", "lp", "Parser", "parse", "xml", "builder", "upload", "per", "handler", "server", "pe", "pp", "writer", "class", "cp", "pkg", "parent", "base", "p", "txt", "processor", "file", "reader", "php", "er", "arser", "worker", "manager", "seed", "rar", "up", "as", "instance", "ss", "cache", "test", "tt", "copy", "master"], "on_disk": ["onnetdemand", "onbootlock", "on_demand", "on_storage", "onjspace", "onjdrive", "onnetdrive", "onJdisk", "off_delete", "onnetfile", "onnetdisk", "off_demand", "onbookdelete", "onJlock", "off_space", "off_drive", "off_file", "onjdisk", "onbootdisk", "off_storage", "on_space", "onjfile", "on_file", "off_disk", "on_lock", "on_delete", "onbookdisk", "onbootstorage", "onJdrive", "on_drive", "onbookdrive", "off_lock", "onnetspace", "onbootdrive", "onJdemand"], "in": ["f", "data", "socket", "inn", "source", "i", "thin", "con", "ax", "input", "inas", "kin", "min", "din", "file", "conn", "lin", "reader", "rin", "ins", "bin", "connection", "inner", "o", "c", "as", "win", "In", "stream", "pass", "inc", "ac", "IN", "ini", "r", "copy", "login", "again", "info", "pin"]}}
{"id1": "17522011", "id2": "23677147", "code1": "    public static String read(ClassLoader classLoader, String name, boolean all) throws IOException {\n        if (all) {\n            StringMaker sm = new StringMaker();\n            Enumeration enu = classLoader.getResources(name);\n            while (enu.hasMoreElements()) {\n                URL url = (URL) enu.nextElement();\n                InputStream is = url.openStream();\n                String s = read(is);\n                if (s != null) {\n                    sm.append(s);\n                    sm.append(StringPool.NEW_LINE);\n                }\n                is.close();\n            }\n            return sm.toString().trim();\n        } else {\n            InputStream is = classLoader.getResourceAsStream(name);\n            String s = read(is);\n            is.close();\n            return s;\n        }\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 0, "substitutes": {"classLoader": [" classLoad", "fileDir", " classloader", "classPath", "filePath", "Classloader", "resourceReader", "classLoad", "resourceLoading", "classloader", "fileloader", "ClassLoad", "fileLoader", "classDir", " classPath", " classDir", "resourceLoader", "ClassPath", "ClassReader", " classLoading", "fileLoad", " classReader", "ClassLoading", "classReader", "resourceloader", "ClassDir", "classLoading", "ClassLoader"], "name": ["named", "address", "filename", "prefix", "x", "child", "data", "time", "string", "home", "no", "resource", "alias", "path", "str", "class", "search", "parent", "value", "base", "large", "root", "file", "part", "type", "connection", "NAME", "comment", "image", "Name", "code", "old", "ame", "size", "pass", "n", "key", "null", "word", "default", "active", "names", "none", "id"], "all": ["named", "any", "f", "sync", "allow", "left", "alpha", "app", "ALL", "and", "with", "apply", "each", "list", "total", "this", "alls", "am", "array", "al", "only", "full", "part", "one", "sort", "call", "partial", "process", "batch", "not", "l", "pass", "at", "ann", "auto", "local", "All", "attribute", "active", "both", "global", "none"], "sm": ["gm", "cm", "nm", "asm", "serv", "ama", "hm", "vm", "service", "sb", "source", "sf", "em", "sk", "sr", "sh", "sy", "im", "mo", "zip", "sl", "ym", "sa", "mm", "km", "bm", "sam", "sp", "m", "ms", "smith", "rm", "wm", "su", "sw", "om", "tm", "ss", "sum", "sv", "si", "sym", "imm", "spe", "api", "so", "Sm", "fm", "SM", "sim", "sn"], "enu": ["venou", " ennu", "munU", " enus", "ENou", "anu", "munus", "munun", "enun", "ENc", "enus", "Enus", "Ennu", "Enun", "anU", "ENus", "encu", "Enu", "venus", "enncu", "venu", "Enc", "venc", "EnU", "ennus", "Enou", "ENu", "anus", "enou", "Encu", "enU", "anun", "ennu", "ennnu", " encu", "enc", "munu"], "url": ["loader", "plug", "address", "f", "rel", "uri", "ssl", "string", "source", "i", "resource", "web", "path", "layer", "str", "server", "http", "ur", "sl", "zip", "URL", "base", "file", "in", "page", "impl", "ls", "connection", "image", "job", "browser", "l", "ll", "download", "Url", "loc", "li", "key", "r", "pull", "id"], "is": ["ir", "esi", "lis", "ris", "it", "serv", "ori", "iss", "uri", "ie", "isl", "abs", "iris", "i", "es", "ais", "app", "ic", "has", "ignore", "web", "ois", "im", "http", "us", "its", "init", "isa", "p", "os", "iso", "in", "vs", "ins", "ls", "act", "ar", "io", "inner", "ip", "ii", "image", "cms", "bis", "IS", "mis", "ios", "ops", "ri", "as", "was", "or", "close", "Is", "isc", "are", "js", "isi", "si", "api", "info", "il", "id"], "s": ["session", "ans", "S", "comments", "f", "cs", "d", "ments", "ses", "g", "lines", "ssl", "string", "sb", "abs", "es", "sf", "i", "ds", "ies", "sl", "ings", "its", "p", "sg", "os", "rows", "ns", "se", "sc", "gs", "ins", "ls", "w", "u", "als", "m", "ms", "spec", "les", "sets", "results", "storage", "services", "ches", "ws", "ions", "o", "details", "su", "c", "ips", "outs", "rs", "ss", "l", "ps", "ts", "n", "js", "sv", "si", "strings", "r", "ows", "h", "e", "ks"]}}
{"id1": "9647576", "id2": "8079516", "code1": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 0, "substitutes": {"stbookings": ["stbookalls", "ssbookINGS", "stbooksINGS", "stbookies", "stBookalls", "storderies", "stbooksies", "ssbookies", "storderalls", "stbookINGS", "stbooksalls", "ssbookings", "ssbooksies", "stBookings", "ssbookalls", "storderINGS", "storderings", "stBookies", "ssbooksINGS", "stBookINGS", "ssbooksalls", "ssbooksings", "stbooksings"], "stchartwl": ["STconfigml", "stplotwl", "stchartml", "stconfigowl", "STchartowl", "stconfigls", "STconfigls", "stplotml", "st_wl", "st_ml", "stconfigml", "stconfigwl", "stplotls", "STchartwl", "st_ls", "STconfigowl", "stchartls", "STchartls", "st_owl", "STchartml", "stplotowl", "stchartowl", "STconfigwl"], "sp": ["session", "prefix", "yp", "pace", "script", "iss", "service", "source", "spr", "xml", "profile", "span", "sk", "sf", "str", " esp", "pe", "osp", "sl", "pp", "pr", "text", "html", "p", "sg", "bsp", "op", "asp", "esp", "page", "sup", "sc", "se", "Sp", "type", "scope", "ig", "ip", "name", "ap", "space", "email", "ss", "ps", "isp", "amp", "jp", "si", "tp", "mp", "rap", "ep", "SP", "sil"], "bookingid": ["bookINGid", "booksingsinfo", "bookinginfo", "bookingsname", "bookINGname", "booksingid", "booksingurl", "bookillingurl", "bookillingid", "bookillingname", "booksingsid", "bookingsurl", "bookingsinfo", "bookingname", "bookINGinfo", "bookingsid", "booksingname", "bookINGurl", "booksingsurl", "bookingurl", "bookillinginfo", "booksingsname", "booksinginfo"], "currentcoach": ["currentwoaches", "currentloach", "currentloac", " currentcoatt", "currentgoach", "currentCOac", "currentloacher", " currentloach", "currentoach", "currentgoah", "reportedoACH", "currentcoACH", " currentcoac", "currentpoach", "reportedoaches", "currentwoach", "currentCoaches", " currentCOaches", "reportedcoaches", "currentgoACH", "currentpoACH", "currentboac", "currentoaches", "currentboacher", "reportedoach", "currentCoac", "currentboach", "currentgoaches", "currentcoatt", "reportedoah", "currentloatt", "currentoah", "currentCOach", " currentcoacher", "reportedcoah", "currentcoah", " currentCOach", "currentwoac", "currentoACH", "currentcoaches", " currentcoaches", "currentCoach", " currentCOac", "currentCOacher", "currentCOatt", "currentcoac", " currentloac", " currentloacher", "currentCOaches", " currentCOacher", "currentpoaches", "reportedcoach", "reportedcoACH", "currentCoacher", "currentpoah", "currentwoacher", "currentcoacher", "currentboatt", " currentloatt"], "currentseat": ["reportedcourse", "currentslave", " currentticket", "reportedstaff", "currentstaff", "reportedseat", "reportedslave", " currentstaff", "Currentstaff", "Currentslave", " currentslave", "Currentcourse", "currentticket", " currentcourse", "Currentticket", "Currentseat", "reportedticket", "currentcourse"], "agentbooksql": ["antpagessql", "agentwindowssql", "agentbookQL", "agentwindowsym", "userbookQL", "agentbooksQL", "userbooksQL", "userbookssql", "agentbooksq", " agentbooksiel", "agentpagesQL", " agentpagesql", " agentbooksQL", "agentwindowsQL", "agentpagesiel", "agentblocksql", "antpagessl", "agentpagesq", "agentbookql", "agentpagesql", "agentmailsiel", "agentmailsql", "agentbooksiel", "userbooksym", "userbookql", " agentpagesq", "antpagesql", "agentblocksQL", "agentbookiel", "agentmailsQL", "agentbookssl", "agentpagesym", "antpagesQL", " agentpagesiel", " agentbooksq", "antbookssl", "agentbooksym", " agentpagesQL", "agentpagessl", "agentbookym", "antbooksql", "antbooksQL", "agentpagessql", "agentmailsq", "agentbookssql", "userbookym", "agentbookq", "agentblockssql", "agentblockssl", "antbookssql", "agentwindowsql", "agentbooksl"], "userbooksql": ["agentbookslog", "usercapsil", "clientwordsiel", "userstylesql", "clientbooksizzle", "userbookslog", "agentbookQL", "userwordslog", "userpagesiel", "userstylessql", "userpageslog", "userlocksyl", "userbookQL", "clientbooksiel", "usercapsql", "agentbooksQL", "userbooksQL", " useravesyl", "clientwordsizzle", "userbookssql", "clientbooksql", "usercapsyl", "userlocksil", "userbooksli", "usercapsli", "useravesql", "clientwordssql", "agentbookql", "userbooklog", "useravesyl", "userbookql", "userlocksql", " useravesql", "userlocksli", "useravesli", "userpagesQL", " useravesli", "userwordsizzle", " userbooksyl", " userbooksli", "userpagesql", "userwordsQL", "userpagesizzle", " useravesil", "userwordsiel", "agentbooklog", "userstylesizzle", "userbooksil", "agentbookssql", "userbooksiel", "userstylesiel", "userbooksyl", "userwordsql", "userwordssql", "userpagessql", " userbooksil", "userbooksizzle", "clientwordsql", "clientbookssql", "useravesil"], "tickpos": ["trackPos", " tickPOS", "ickPOS", "tickpo", " tickos", "ickos", "kickpo", "trippos", "tickPOS", "ickpoint", "ickerpos", "tickos", "nickPos", "cyclepos", "tickpoint", "ickeros", "cycleposition", "tickPos", " tickpointer", "ickpos", "kickPos", "kickindex", "ickerPos", "trippo", "tripindex", "ickPos", "tickpointer", "nickpos", "ickpointer", " tickpoint", " tickposition", "ickerpointer", "nickposition", "nickPOS", "tickindex", "tickposition", "kickpos", "ickposition", " tickPos", "cyclePos", "trackpoint", "nickpo", "ickindex", "ickpo", "trackpos", "tripPos", "cyclepo"], "chartavailupdsql": ["chartavailupsrssql", "chartavailupsrsqs", "chartavailupsdsqs", "chartavailupdsQL", "chartavailupsdsQL", "chartavailupsdsql", "chartavailupssql", "chartavailupsQL", "chartavailuprsQL", "chartavailupdsqs", "chartavailupdssql", "chartavailupsdssql", "chartavailupsqs", "chartavailupsql", "chartavailuprsqs", "chartavailupdql", "chartavailupdQL", "chartavailupsrsql", "chartavailuprsql", "chartavailupsrsQL", "chartavailuprssql", "chartavailupdqs"]}}
{"id1": "8166767", "id2": "10158738", "code1": "    public Object invoke(MethodInvocation invocation, int retryTimes) throws Throwable {\n        retryTimes--;\n        try {\n            String url = getServiceUrl() + \"/\" + invocation.getMethod().getName();\n            HttpPost postMethod = new HttpPost(url);\n            if (invocation.getMethod().getParameterTypes().length > 0) postMethod.setEntity(new StringEntity(JsonUtils.toJson(invocation.getArguments())));\n            HttpResponse rsp = HttpClientUtils.getDefaultInstance().execute(postMethod);\n            StatusLine sl = rsp.getStatusLine();\n            if (sl.getStatusCode() >= 300) {\n                throw new RuntimeException(\"Did not receive successful HTTP response: status code = \" + sl.getStatusCode() + \", status message = [\" + sl.getReasonPhrase() + \"]\");\n            }\n            HttpEntity entity = rsp.getEntity();\n            StringBuilder sb = new StringBuilder();\n            InputStream is = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"utf-8\"));\n            String line;\n            while ((line = reader.readLine()) != null) sb.append(line).append(\"\\n\");\n            reader.close();\n            is.close();\n            String responseBody = null;\n            if (sb.length() > 0) {\n                sb.deleteCharAt(sb.length() - 1);\n                responseBody = sb.toString();\n            }\n            Type t = invocation.getMethod().getGenericReturnType();\n            if (t.equals(Void.class) || responseBody == null) return null;\n            return JsonUtils.fromJson(responseBody, t);\n        } catch (ConnectTimeoutException e) {\n            if (retryTimes < 0) throw e;\n            if (urlFromDiscovery) {\n                String serviceUrl = discoverServiceUrl(getServiceInterface().getName());\n                if (!serviceUrl.equals(getServiceUrl())) {\n                    setServiceUrl(serviceUrl);\n                    log.info(\"relocate service url:\" + serviceUrl);\n                }\n            }\n            return invoke(invocation, retryTimes);\n        }\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"invocation": ["Call", "request", "voked", "Get", "http", "convoked", "Invoice", "volocation", "Invociation", "convocation", "invocated", " Inviation", "Inviation", "voloice", "convoice", "Invocation", "encocation", "inviation", "requocation", " invoke", "Http", "inoker", " invoice", "promociation", "invoking", " Invoker", "HTTP", "encoke", "lnocation", "lnoice", "encoice", "lnocated", "voice", "Request", "requiation", "promocation", "response", "promiation", "lnoked", " invoking", "this", "encoker", "requoker", "inocation", "invoker", "s", "Error", "_", "invociation", "Invoker", "promoker", "Invoke", " invoker", "convocated", "Invoking", " Invociation", "Response", "invoke", "vocated", "inoking", "invoice", "vocation", "invoked", "requoice", "voloker", " Invocation", "voliation"], "retryTimes": ["retvalTime", "retrowDays", "retvalTimes", "rettryTS", "retriedtimes", "retryingTS", "retryHours", "retrowTimes", "RetryingTimes", "retvalTS", "retriTimes", "RetryingHours", "retryingtimes", "RetryHours", "retrainTime", "retryingHours", "retrainHours", "RetryingBlocks", "rettryTimes", "retryTime", "retryingBlocks", "Retrytimes", "RetryTS", "RetryingValues", "retvalBlocks", "retraintimes", "RetryValues", "RetryingDays", "retryingDays", "retryingTime", "retriedHours", "RetryingTS", "retrowValues", "retriDays", "retryDays", "retryingTimes", "rettryTime", "retryValues", "retrowTime", "retriTime", "rettryBlocks", "RetryTimes", "retryBlocks", "retrytimes", "retriedTimes", "retriedTime", "retryTS", "retrainTimes", "retryingValues", "RetryTime", "retriValues", "RetryingTime", "RetryDays", "RetryBlocks", "Retryingtimes"], "url": ["address", "data", "uri", "service", "ssl", "string", "source", "resource", "path", "host", "response", "http", "server", "URL", "json", "html", "base", "method", "ls", "location", "connection", "href", "image", "name", "channel", "route", "b", "email", "l", "ll", "Url", "loc", "rl", "r", "config", "object", "enabled", "id"], "postMethod": ["PostFunction", "PostMethod", "headFunction", "POSTMethod", "headPost", "patchPost", "patchOperation", "postMethods", "postFunction", " postOperation", "newOperation", "POSTOperation", "POSTMethods", "newMethod", " postFunction", "PostOperation", "postPost", "postMessage", "patchMethod", " postMessage", "newMessage", "PostMethods", "PostPost", "headMethod", "postOperation", " postMethods", "patchFunction", "headMethods", "POSTMessage", " postPost", "newMethods"], "rsp": ["rserv", " rserv", "rdsl", "hSp", "Rsp", "rssp", "Rserv", "Rsc", "rsc", "rssc", "hsc", "rrresp", "Rresp", " rpc", " rsl", "rrsp", "rpc", " rresp", "hsp", "Rsl", "Rpc", "rrserv", "rdsc", "rsSp", "hsl", "rsl", "rrsl", "rdsp", "rssl", " rsc", "rresp", "rdpc", " rSp", "rSp"], "sl": ["cl", "bl", "hl", " Sl", "sm", "isl", "ssl", "lc", "sf", "Sl", "sh", "fr", "dl", "el", "kl", "repl", "cli", "shell", "se", "sp", "ls", "pl", "SL", "SB", "ml", "su", "sw", "lr", "sel", "l", "ll", "sle", "log", "si", "rl", "cel", "fl", "sil", "status", "il", "la", "sn"], "entity": ["application", "et", "data", "content", "service", "string", "xml", "em", "resource", "document", "output", "status", "ent", "person", "response", "http", "model", "el", "oter", "meta", "json", "page", "translation", "environment", "type", "connection", "image", "collection", "email", "ilo", "result", "instance", "component", "article", "Entity", "body", "api", "metadata", "enc", "object", "info", "e", "message"], "sb": ["abb", "pb", "xb", "sync", "bh", "rb", "nb", "sm", "gb", "bb", "src", "ssl", "abs", "eb", "sf", "wb", "sr", "bc", "db", "ib", "bj", "fb", "buf", "sth", "buff", "binary", "sa", "rob", "bs", "lb", "bf", "sg", "bsp", "txt", "bm", "bp", "sp", "ls", "SB", "cb", "ab", "mb", "bt", "ws", "b", "su", "lr", " SB", "sq", "kb", "ss", "bg", "sv", "si", "split", "ob", "login", "info"], "is": ["ir", "lis", "ris", "serv", "it", "ui", "src", "uri", "iss", "iris", "isl", "ie", "i", "es", "ais", "has", "ib", "iter", "its", "os", "in", "ai", "iso", "vs", "ins", "res", "ar", "io", "get", "s", "ip", "bis", "IS", "info", "ios", "ri", "as", "was", "or", "rs", "Is", "iri", "isi", "rx", "si", "api", "r", "ser", "out", "im", "fs", "id"], "reader": ["loader", "ir", "f", "ry", "it", "rr", "rb", "row", "ro", "ruby", "i", "Reader", "ler", "per", "feed", "handler", "server", "read", "iter", "input", "writer", "reading", "in", "rer", "er", "io", "inner", "s", "buffer", "ip", "rar", "ri", "lr", "or", "l", "rc", "stream", "rx", "parser", "ini", "r", "ser", "ner", "e", "oder"], "line": ["cl", "sync", "data", "row", "lines", "string", "lc", "i", "source", "end", "no", "feed", "LINE", "str", "nl", "cr", "pe", "character", "el", "cell", "liner", "lf", "text", "block", "page", "lin", "inline", "part", "stroke", "ge", "char", "comment", "letter", "ip", "buffer", "Line", "code", "name", "cle", "b", "le", "sel", "l", "link", "non", "pass", "lo", "body", "key", "li", "e", "message"], "responseBody": ["ResponsePart", "requestContent", "responsePart", "resultBody", "responseLine", "replyBody", "reportData", "responsebody", "responseContent", "reportBody", "resultbody", "resultContent", "ResponseMessage", " responseLine", "replyMessage", " responseMessage", " responseData", "requestbody", "replyLine", "replyPart", "reportPart", "reportLine", "ResponseContent", " responsePart", "resultPart", "replyContent", "ResponseBody", "responseMessage", " responsebody", "requestBody", "replyData", "responseData", "Responsebody", " responseContent"], "t": ["et", "ext", "target", "f", "d", "it", "st", "template", "dt", "format", "g", "te", " T", "Type", "i", "ot", "z", "class", "tf", "p", "q", "v", "T", "u", "type", "ct", "m", "k", "tor", "s", "y", "att", "ant", "o", "c", "types", "en", "l", "ts", "n", "wt", " type", "r", "h", "e"], "serviceUrl": ["serverUr", " serviceName", "spaceurl", "serviceName", "ServiceUr", "serviceDir", "starturl", "ServiceUrl", "startUr", "serviceURL", "spaceURL", "serverURL", "spaceName", "serverName", " serviceurl", " serviceDir", "ServiceName", "serverDir", "spaceUrl", "Serviceurl", "startUrl", "serviceUr", " serviceUr", "serverUrl", "serviceurl", "ServiceDir", "ServiceURL", "startURL", " serviceURL", "serverurl"]}}
{"id1": "15510198", "id2": "8468859", "code1": "    protected static Parser buildParser(URL url) throws IOException, ParserException {\n        Parser parser;\n        URLConnection connection = openConnection(url);\n        if (!(connection instanceof HttpURLConnection) || ((HttpURLConnection) connection).getResponseCode() == 200) {\n            parser = new Parser(connection);\n        } else {\n            parser = null;\n        }\n        return parser;\n    }\n", "code2": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["loader", "address", "bug", "data", " URL", "uri", "service", "ssl", "source", "proxy", "resource", "path", "host", "str", "server", "http", "sl", "URL", "class", "this", "base", "file", "page", "www", "location", "io", "image", "open", "name", "obj", "channel", "c", "l", "link", "Url", "loc", "config", "object", "null"], "parser": ["loader", "pd", "x", "pard", "plugin", "data", "fruit", "angler", "Parser", "parse", "au", "xml", "ler", "builder", "handler", "server", "http", "pe", "pc", "writer", "class", "this", "parent", "jack", "p", "root", "processor", "fp", "reader", "php", "se", "library", "er", "arser", "type", "worker", "manager", "slave", "style", "seed", "result", "instance", "jp", "cache", "test", "pool", "api", "config", "object", "null", "master"], "connection": ["application", "session", "Connection", "condition", "reference", "socket", "uri", "service", "lc", "connect", "resource", "document", "section", "con", "proxy", " Connection", "handler", "bc", "db", "response", "http", "server", "character", "class", "this", "context", "communication", "function", "database", "event", "conn", "pointer", "reader", "directory", "io", "image", "open", "connected", "collection", "client", "channel", "relation", "c", "instance", "j", "link", "ion", "position", "loc", "config", "object", "message"]}}
{"id1": "22734545", "id2": "1985677", "code1": "    public void generate(String urlString, String target) throws Exception {\n        URL url = new URL(urlString);\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        BufferedInputStream inputStream = new BufferedInputStream(urlConnection.getInputStream());\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target));\n        byte[] buf = new byte[10 * 1024];\n        int len;\n        while ((len = inputStream.read(buf, 0, buf.length)) != -1) {\n            outputStream.write(buf, 0, len);\n        }\n        inputStream.close();\n        outputStream.close();\n        urlConnection.disconnect();\n    }\n", "code2": "    public SRWGuiClient(String initialURL) {\n        super(\"Simple Swing Browser\");\n        this.initialURL = initialURL;\n        addWindowListener(new ExitListener());\n        WindowUtilities.setNativeLookAndFeel();\n        JPanel topPanel = new JPanel();\n        topPanel.setBackground(Color.lightGray);\n        homeButton = new JIconButton(\"home.gif\");\n        homeButton.addActionListener(this);\n        JLabel urlLabel = new JLabel(\"URL:\");\n        urlField = new JTextField(30);\n        urlField.setText(initialURL);\n        urlField.addActionListener(this);\n        topPanel.add(homeButton);\n        topPanel.add(urlLabel);\n        topPanel.add(urlField);\n        getContentPane().add(topPanel, BorderLayout.NORTH);\n        try {\n            URL url = new URL(initialURL);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            boolean xml = true;\n            String inputLine;\n            StringBuffer content = new StringBuffer(), stylesheet = null;\n            Transformer transformer = null;\n            inputLine = in.readLine();\n            if (inputLine == null) {\n                System.out.println(\"No input read from URL: \" + initialURL);\n                return;\n            }\n            if (!inputLine.startsWith(\"<?xml \")) {\n                xml = false;\n                content.append(inputLine);\n            }\n            if (xml) {\n                inputLine = in.readLine();\n                if (inputLine.startsWith(\"<?xml-stylesheet \")) {\n                    int offset = inputLine.indexOf(\"href=\");\n                    String href = (inputLine.substring(inputLine.indexOf(\"href=\") + 6));\n                    href = href.substring(0, href.indexOf('\"'));\n                    System.out.println(\"href=\" + href);\n                    url = new URL(url, href);\n                    String stylesheetURL = url.toString();\n                    System.out.println(\"stylesheet URL=\" + url.toString());\n                    transformer = (Transformer) transformers.get(stylesheetURL);\n                    if (transformer == null) {\n                        BufferedReader sheetIn = new BufferedReader(new InputStreamReader(url.openStream()));\n                        sheetIn.readLine();\n                        stylesheet = new StringBuffer();\n                        while ((inputLine = sheetIn.readLine()) != null) stylesheet.append(inputLine).append('\\n');\n                        System.out.println(stylesheet.toString());\n                        TransformerFactory tFactory = TransformerFactory.newInstance();\n                        StreamSource xslSource = new StreamSource(new StringReader(stylesheet.toString()));\n                        transformer = tFactory.newTransformer(xslSource);\n                        transformers.put(stylesheetURL, transformer);\n                    }\n                }\n            }\n            while ((inputLine = in.readLine()) != null) content.append(inputLine).append('\\n');\n            htmlPane = new JEditorPane();\n            if (transformer != null) {\n                StringReader stringRecordReader = new StringReader(content.toString());\n                StringWriter xmlRecordWriter = new StringWriter();\n                StreamSource streamXMLRecord = new StreamSource(stringRecordReader);\n                transformer.transform(streamXMLRecord, new StreamResult(xmlRecordWriter));\n                String html = xmlRecordWriter.toString();\n                int i = html.indexOf('>');\n                html = \"<html>\" + html.substring(html.indexOf('>') + 1);\n                System.out.println(html);\n                htmlPane.setContentType(\"text/html\");\n                htmlPane.setText(\"<html><head><META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"><title>GSAFD Thesaurus</title></head><body><center><h2>GSAFD Thesaurus</h2></center><p>A thesaurus of genre terms to support the \\\"Guidelines on Subject Access to Individual Works of Fiction , Drama\\\" (GSAFD)</p><table cellspacing=\\\"5\\\" width=\\\"100%\\\"><tr><td><h3>Search</h3><p></p></td><td valign=\\\"top\\\"><h3>Browse</h3></td></tr></table></body></html>\");\n            } else htmlPane.setText(content.toString());\n            htmlPane.setEditable(false);\n            htmlPane.addHyperlinkListener(this);\n            JScrollPane scrollPane = new JScrollPane(htmlPane);\n            getContentPane().add(scrollPane, BorderLayout.CENTER);\n        } catch (IOException ioe) {\n            warnUser(\"Can't build HTML pane for \" + initialURL + \": \" + ioe);\n        } catch (TransformerException e) {\n        }\n        Dimension screenSize = getToolkit().getScreenSize();\n        int width = screenSize.width * 8 / 10;\n        int height = screenSize.height * 8 / 10;\n        setBounds(width / 8, height / 8, width, height);\n        setVisible(true);\n    }\n", "label": 0, "substitutes": {"urlString": ["addressUrl", "urlFile", "resourceString", "resourcestring", "addressString", "httpstring", "urlUrl", "addressStream", "filestring", "fileStream", "urlStream", "fileString", "urlstring", " urlStream", "resourceFile", "fileFile", "httpString", "fileStr", "httpFile", "resourceStr", "fileUrl", " urlFile", " urlUrl", "urlStr", "addressFile", "httpStr"], "target": ["address", "next", "filename", "format", "content", "src", "string", "source", "resource", "remote", "path", "output", "host", "project", "top", "context", "dest", "text", "parent", "base", "database", "file", "temp", "timeout", "location", "connection", "to", "buffer", "name", "result", "download", "arget", "external", "Target", "object", "match"], "url": ["plug", "f", "user", "bb", "uri", "ssl", "string", "source", "resource", "web", "feed", "host", "server", "http", "sl", "URL", "this", "blog", "base", "file", "conn", "page", "ls", "gl", "www", "connection", "buffer", "image", "open", "client", "c", "b", "build", "l", "ll", "stream", "Url", "download", "log", "r", "config", "ball"], "urlConnection": ["inputConnection", " urlPool", "urlconnection", "urlUnit", "URLConnection", "httpconnection", "fileUnit", "URLNetwork", "webConn", "webConnection", "fileconnection", "URLConnector", "webConnect", "URLConn", "httpConnect", "webUnit", "urlConn", "urlPool", "URLUnit", "inputPool", " urlConnector", "fileConnection", "URLconnection", "urlConnector", "httpConn", "inputConn", "webconnection", "urlConnect", "webNetwork", "fileNetwork", "inputConnector", "httpConnection", "inputConnect", " urlConn", "urlNetwork", "inputconnection", "URLPool"], "inputStream": ["outputConnection", "inputConnection", "inputChannel", " inputQueue", "InputView", "outputSteam", "inputSteam", " inputConnection", "outputView", " inputChannel", "InputStream", " inputView", "inConnection", "inSteam", "InputConnection", "inView", "inputView", "InputQueue", "outputChannel", " inputSteam", "InputSteam", "inStream", "outputQueue", "inputQueue", "InputChannel"], "outputStream": ["outputConnection", "inputConnection", "resourceStream", "inputstream", " outputstream", "OutputDirectory", "outputSteam", "OutputStream", "inputSteam", "outputstream", "putSteam", "putStream", "Outputstream", "outputView", "resourceSteam", "outputDirectory", " outputStreamer", "resourcestream", "inputView", "putStreamer", "OutputSteam", "OutputStreamer", "resourceConnection", "outputStreamer", " outputView", "putstream", "OutputView", " outputConnection", " outputDirectory", " outputSteam", "inputDirectory"], "buf": ["queue", "ba", "bh", "rb", "data", "cat", "bb", "gb", "wb", "output", "pad", "blocks", "bc", "dec", "off", "buff", "fb", "input", "cv", "seq", "cas", "ff", "bs", "block", "bf", "raw", "v", "vec", "func", "fd", "num", "bp", "bin", "cb", "Buff", "ab", "bd", "buffer", "br", "done", "Buffer", "batch", "job", "b", "bytes", "c", "pos", "rc", "uf", "pool", "loc", "cap", "count", "uc", "bag", "la"], "len": ["f", "length", "data", "ie", "no", "i", "end", "ln", "ler", "line", "off", "db", "read", "limit", "iter", "el", "lf", "base", "nt", "min", "lin", "in", "part", "bin", "err", "c", "b", "pos", "le", "pre", "fin", "en", "l", "size", "Len", "start", "n", "ann", "li", "val", "r", "count", "cap", "fl", "la"]}}
{"id1": "17296916", "id2": "2465747", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 0, "substitutes": {"wrap": ["cover", "wrapper", "f", "format", "core", "parse", "web", "word", "wb", "div", "flash", "wa", "handler", "wire", "war", "zip", "ow", "binary", "html", "lock", "p", "wx", "wp", "w", "handle", "worker", "now", "thread", "get", "box", "self", "image", "force", "process", "ws", "wra", " wrapper", "b", "sw", "util", "we", "build", "create", "or", "pipe", "stream", "work", "cache", "frame", "run", "rap", " wrapped", "api", "h", "default", "bag", "use", "message"], "buffer": ["loader", "wrapper", "bar", "queue", "cover", "pb", "template", "msg", "ref", "reference", "bb", "BU", "sb", "source", "wave", "flash", "document", "builder", "feed", "bc", "layer", "server", "iter", "buff", "buf", "fb", "pause", "this", "binary", "board", "abi", "writer", "base", "reply", "error", "transfer", "bm", "url", "shell", "reader", "bin", "manager", "cb", "surface", "table", "header", "image", "Buffer", "batch", "player", "b", "print", "result", "timer", "cache", "frame", "log", "bridge", "view", "loop", "report", "copy", "null", "message"], "encoding": ["ecoded", "Encryption", "ecoder", "encoder", "enoding", "signoding", "engoder", "coder", "encode", "engode", "encoded", "ecryption", "cryption", "enryption", "decoding", "signoder", "Encoding", "decode", "encryption", "decoder", "enoder", "ecoding", "Encoded", "enoded", "engoded", "signoded", "decoded", "engryption", "signode", "Encoder", "engoding", "coded", "coding"], "headers": ["ids", "wrapper", "bits", "data", "content", "features", "breaks", "lines", "blocks", "stats", "str", "http", "ers", "parts", "checks", "members", "classes", "ppers", "groups", "ints", "heads", "head", "properties", "params", "events", "files", "writers", "s", "header", "pages", "frames", "details", "objects", "caps", "ters", "vals", "types", "settings", "rs", "values", "keys", "plugins", "ports", "body", "strings", "fields", "h", "padding", "names", "options", "dict"], "is": ["oss", "obs", "isol", "nis", "lis", "cs", "ris", "bas", "ori", "ui", "it", "iss", "isl", "iris", "oris", "abs", "las", "i", "es", "ais", "has", "ois", "ib", "http", "us", "isu", "its", "bs", "ics", "isa", "os", "iso", "in", "ai", "ins", "ls", "ms", "s", "bis", "IS", "mis", "ws", "ios", "ops", "tis", "as", "was", "or", "Is", "ros", "are", "js", "isi", "api", "osi", "ob", "out", "info", "fs", "sis"], "bos": ["obo", "osa", "bones", "obs", "pins", "bas", "bits", "bh", "uds", "oops", "ses", "beans", "aos", "lins", "home", "bi", "proxy", "abs", " Bos", "ois", "bc", "cos", "mos", "los", "oks", "ubs", "abi", "zos", "bs", "os", "ubis", "fits", "zo", "obos", "bps", "shadow", "bot", "bis", "ko", "cms", "bes", "mis", "opus", "ios", "ops", "mobi", "tis", "oses", "bid", "outs", "bott", "kb", "ros", "bo", "osi", "so", "ob", "oos", "obi", "oes", "fs", " os"]}}
{"id1": "9802073", "id2": "4852691", "code1": "    public void testAutoCommit() throws Exception {\n        Connection con = getConnectionOverrideProperties(new Properties());\n        try {\n            Statement stmt = con.createStatement();\n            assertEquals(0, stmt.executeUpdate(\"create table #testAutoCommit (i int)\"));\n            con.setAutoCommit(false);\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (0)\"));\n            con.setAutoCommit(false);\n            con.rollback();\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (1)\"));\n            con.setAutoCommit(true);\n            con.setAutoCommit(false);\n            con.rollback();\n            con.setAutoCommit(true);\n            ResultSet rs = stmt.executeQuery(\"select i from #testAutoCommit\");\n            assertTrue(rs.next());\n            assertEquals(1, rs.getInt(1));\n            assertFalse(rs.next());\n            rs.close();\n            stmt.close();\n        } finally {\n            con.close();\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "label": 0, "substitutes": {"con": ["Connection", "ocon", "core", "Con", "connect", " CON", "conf", "syn", "non", "n", "ctrl", "pool", "config", "un", "sync", "x", "cn", "pr", "cas", "can", "conn", "ran", "connection", "po", "en", "close", "log", "col", "pin", "crit", "an", "ca", "ctx", "cl", "plan", "union", "cond", "db", "pc", "cp", "ct", "m", "CON", "ec", "client", "ain", "c", "util", "pre", "Conn", "cache", "ac", "mc", "coll", "common", "session", "custom", "cm", "platform", "row", "user", "cf", "container", "bc", "cr", "fc", "lock", "min", "co", "act", "com", "one", "gen", "conv", " conn", "cc", "rc", "win", "uc", "ver"], "stmt": ["Stnt", "Stau", " stur", "tmt", "Stor", " stb", "Stmb", "slmt", "strmt", "stur", "stct", "stmb", " stnt", "stMT", "thnm", "Stmr", "slur", "slct", " stor", "Stm", "Stmt", "stau", "tmp", "Stur", " stnm", "thock", " stock", "ctb", "strmb", "strnt", "thmt", "stmo", " stm", "ctmp", "stb", "stm", "ctmt", "STnm", "thmp", " stmo", "stnt", "STmt", "Stb", "stmr", "StMT", " stau", "stock", "ctmo", "Stmo", "stnm", " stMT", "ctor", "tm", " stmr", "STock", "tmr", "Stct", "ctm", "stmp", "slMT", "strau", " stmp", " stct", "Stmp", "STmp", "stor", " stmb"], "rs": ["rys", "cs", "ris", "rr", "row", "Rs", "hr", "src", " res", "rd", " rows", "acks", "RC", "sr", "eers", "cr", "ds", "hs", "repl", "ra", "pr", "rates", "RS", "errors", "rows", "sc", "reader", "rss", "ras", "ins", "res", "ls", "ges", "ms", "s", "results", "rt", "xs", "ries", "vers", "ri", "rc", "ros", "ps", "rx", "rl", "r", "ars", "ows", "mr", " RS", "ks"]}}
{"id1": "15241397", "id2": "3495460", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public boolean actEstadoEnBD(int idRonda) {\n        int intResult = 0;\n        String sql = \"UPDATE ronda \" + \" SET estado = 1\" + \" WHERE numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"request": ["application", "queue", "data", "user", "uri", "received", "resource", "document", "xml", "web", "subject", "server", "http", "initial", "input", "context", "query", "req", "event", "url", "reader", "method", "er", "type", "connection", "buffer", "image", "QUEST", "client", "result", "instance", "parser", "report", "complete", "object", "info", "Request", "message"], "response": ["application", "queue", "version", "data", "content", "site", "other", "wave", "resource", "document", "output", "host", "server", "model", "generation", "writer", "onse", "Response", "json", "respond", "function", "parent", "reply", "error", "page", "connection", "results", "image", "collection", "client", "result", "resp", "cache", "view", "pool", "body", "report", "out", "object", "status", "message"], "rewrittenQueryString": ["rewrittenQueryLine", "rewrittenUrlService", "rewrittenPageString", "rewwrittenRequestString", "rewrittenPageLine", "rewrittenQuestionText", "rewrittenRequestArray", "rewwrittenQueryLine", "rewrittenPageService", "rewrittenRequestString", "rewwrittenQueryText", "rewrittenQuestionLine", "rewrittenHeaderLine", "rewrittenRequestText", "rewrittenqueryString", "rewrittenqueryStr", "rewrittenQuestionStr", "rewrittenRequestStr", "rewwrittenQueryStr", "rewwrittenRequestService", "rewrittenqueryText", "rewwrittenRequestArray", "rewrittenUrlLine", "rewrittenQueryService", "rewwrittenRequestText", "rewrittenQueryStr", "rewrittenQueryArray", "rewwrittenQueryService", "rewrittenPageArray", "rewwrittenQueryArray", "rewwrittenRequestLine", "rewrittenRequestService", "rewrittenQueryText", "rewrittenHeaderService", "rewrittenRequestLine", "rewrittenQuestionString", "rewrittenqueryService", "rewwrittenRequestStr", "rewrittenUrlText", "rewwrittenQueryString", "rewrittenHeaderArray", "rewrittenUrlString", "rewrittenqueryLine", "rewrittenHeaderString"], "rewrittenUrl": ["rewatchedText", "rewwrittenUr", "rewrittenFile", "rerittenJar", "RewwrittenUrl", "RewrittenText", "rewwrittenUrl", "rewedUrl", "RewwrittenServer", "RewrittenFile", "RewwrittenUr", "RewrittenUrl", "rewardedHost", "rewrapedUrl", "rewoldedURL", "rewrawnUrl", "rerittenUrl", "rewatchedServer", "rewreatedurl", "rewanedURL", "rewoldedFile", "rewedURL", "rewoldedUrl", "rewriteUr", "rewriteFile", "rewroteUrl", "rewrapedUr", "rewrawnurl", "RewrittenLocation", "rewrawnText", "rewrittenServer", "rewrawnURL", "rewardedLocation", "rewatchedURL", "rewedHost", "RewrittenURL", "rewrittenLocation", "rewrittenUr", "rewrittenJar", "rewriteServer", "rewroteURL", "rewrittenurl", "rewreatedUrl", "rewardedUrl", "RewwrittenHost", "rewanedHost", "rewardedURL", "Rewrittenurl", "rewrittenHost", "rewanedUrl", "RewwrittenURL", "RewrittenServer", "RewwrittenFile", "RewwrittenLocation", "RewrittenUr", "rewwrittenServer", "rewrapedFile", "rerittenFile", "rewrapedURL", "rewanedLocation", "rewatchedUrl", "rewriteUrl", "rewriteText", "rewrittenURL", "RewwrittenText", "rewwrittenURL", "rewedJar", "rewreatedText", "rewrittenText", "rewwrittenFile", "rewroteurl", "rewwrittenHost", "rerittenHost", "rewwrittenurl", "RewrittenHost", "rewreatedURL", "rewedFile", "rewwrittenText", "rewoldedHost", "rerittenURL", "rewriteURL", "Rewwrittenurl", "rewedurl", "rewwrittenLocation", "rerittenurl", "rewwrittenJar", "rewroteJar"], "httpURLConnection": ["httpMRconnection", "httpURLConstruction", "httpLLconnection", "httpURLOperation", "httpUrlInterface", " httpURLNode", "httpURIContext", "httpLLConnect", " httpRLConstruction", "facebookPathConnection", "cacheURLConnection", "httpURConnect", "httpURChannel", "facebookPathconnection", "cacheUrlConnect", "httpHTTPInterface", "httpPathConnect", "httpPathChannel", "httpURIConnect", "httpDBConnection", "httpUrlconnection", "httpURLApplication", " httpRLConnection", "facebookPathChannel", "httpURConstruction", " httpRLConnect", "httpUrlApplication", "httpStreamConn", "facebookURLconnection", "httpUrlConnection", "httpHTTPApplication", "httpRLConn", "httpMRConnect", "httpHTTPConn", "facebookPathConnect", "httpGETInterface", "httpRLConnect", "facebookURLChannel", "httpURConnection", "cacheURLOperation", "cacheUrlConn", "cacheUrlOperation", " httpURconnection", "cacheUrlConnection", " httpRLContext", " httpURLconnection", "httpRLconnection", "httpUrlConn", " httpURLConnect", "httpLLConn", "httpUrlOperation", "httpStreamConnect", "httpGETConn", "facebookURLConnection", "httpHTTPConnection", "httpStringConnect", "httpURLConnect", "httpStreamOperation", "facebookURLConnect", "httpLLConnection", " httpURLInterface", "httpURNode", "httpGETApplication", "httpURIConnection", "httpURContext", " httpURLConn", " httpRLConn", "cacheURLConnect", "httpPathConnection", " httpURLConstruction", "httpLLOperation", "httpUrlConnect", "httpPathconnection", " httpHTTPInterface", "httpGETConnection", "httpDBNode", "httpURLConn", " httpHTTPConnection", "httpURLContext", "httpURLChannel", "httpStreamConnection", "httpRLConnection", "httpRLConstruction", "httpURLInterface", " httpRLconnection", " httpURLApplication", " httpURNode", " httpHTTPApplication", "cacheURLConn", " httpURLContext", " httpHTTPConn", " httpURConnect", "httpStringconnection", "httpMRConn", "httpMRConnection", "httpRLContext", "httpStringChannel", " httpURConnection", "httpDBConnect", "httpDBconnection", "httpURLNode", "httpURconnection", "httpStringConnection", "httpURLconnection", "httpUrlNode", "httpURIConstruction"], "header": ["cover", "filter", "column", "version", "next", "dr", "data", "core", "string", "section", "document", "token", "rule", "handler", "director", "line", "layer", "server", "second", "entry", "character", "iter", "list", "writer", "member", "group", "block", "head", "event", "error", "part", "er", "single", "comment", "buffer", "hash", "pair", "later", "channel", "player", "her", "Header", "component", "outer", "feature", "over", "definition", "bridge", "item", "key", "driver", "consumer", "after", "headers", "index", "default", "back", "info", "field", "date", "attribute", "match", "message"], "value": ["hello", "expression", "version", "child", "Value", "data", "content", "format", "string", "end", "server", "valid", "model", "entry", "option", "VALUE", "label", "password", "member", "text", "json", "parent", "function", "v", "variable", "type", "now", "comment", "letter", "get", "element", "media", "name", "archive", "job", "set", "property", "description", "index", "values", "item", "current", "key", "val", "field", "default", "object", "info", "attribute", "message"], "inputStream": [" inputWriter", "inputstream", "outputWriter", "Inputstream", "inputWriter", "outputSteam", "inputResource", "outputstream", "inputSteam", "InputResource", "InputStream", " inputstream", " inputSteam", "InputSteam", "InputWriter", " inputResource", "outputResource"], "outputStream": ["OutputFile", "inputstream", "inputStreamer", "referencestream", "outputFile", "referenceSteam", "OutputStream", "outputSteam", "responseSteam", "responseStream", "outputstream", "inputSteam", "OutputChannel", "Outputstream", "referenceStream", "responseChannel", "OutputSteam", "OutputStreamer", "referenceStreamer", "outputStreamer", "outputChannel", "responseFile", " outputFile", " outputChannel", " outputSteam"]}}
{"id1": "481364", "id2": "8667872", "code1": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 0, "substitutes": {"downloadFilesWorker": ["downloadPhotosPooller", "downloadFilesWler", "downloadPhotosPooler", "downloadPhotosWorkler", "downloadFilesWorkler", "downloadPhotosPoolers", "downloadPhotosWorkers", "downloadFilesLinkers", "downloadFilesLinkER", "downloadFilesWer", "downloadFilesPoolER", "downloadFilesWorkers", "downloadPhotosPoolER", "downloadFilesWorkER", "downloadFilesPooler", "downloadFilesPooller", "downloadPhotosWorker", "downloadFilesPoolers", "downloadFilesLinkler", "downloadFilesWER", "downloadFilesLinker", "downloadFilesWers", "downloadPhotosWorkER"], "startDownloadDate": ["startSpawnDate", " startUploadTime", "startInstallData", "StartReviewDate", "StartDownloadTime", "startUploadYear", "StartDownloadDate", "startMailStage", "startImportDate", "startReviewTime", " startDownloadData", "startImportDay", "startDownloadStatus", "StartDownloadYear", "StartReviewYear", "startUploadStage", " startDownloadDay", "startInstallDate", "startUploadDate", "StartDownloadStatus", "startSpawnStage", "startUploadTime", "startUploadDay", "startDownloadData", "startPullTime", "startPullYear", "startReviewDate", " startDownloadTime", "startUploadStatus", "startDownloadTime", " startUploadModel", " startUploadDate", " startDownloadModel", "startMailModel", " startUploadStage", "startPullDate", "startReviewYear", "startReviewStatus", "startInstallTime", "startSpawnTime", "startImportData", "startDownloadModel", " startUploadData", "startPullStatus", "startInstallDay", "startMailDate", " startDownloadStage", "startSpawnModel", "startImportTime", "startUploadData", "startDownloadDay", "StartReviewStatus", " startUploadDay", "startMailTime", "startDownloadYear", "StartReviewTime", "startDownloadStage", "startUploadModel"], "refreshSpeed": ["refendGrade", "refetchGrade", "refillStep", "refendStep", "refillGrade", " refillSpeed", "refreshStep", "refillStyle", " refillStyle", "refetchSpeed", "refreshGrade", "refillSpeed", "refendSpeed", "refetchStep", " refreshStyle", "refendStyle", " refreshStep", "refreshStyle", "refetchStyle", " refreshGrade", " refillGrade", " refillStep"], "lastDate": ["firstData", "firstDate", " lastTime", "firstDay", " lastData", "lastTime", "firstTime", " lastDay", "lastDay", "LastData", "LastTime", "lastData", "LastDate", "LastDay"], "totalSizeRead": ["TotalNumberWritten", "totalNumberWritten", " totalSizeREAD", "totalSizeReader", "totalNumberReader", "TotalNumberBuild", "totalSizeFound", "totalSizeREAD", "TotalNumberRead", "totalStringRead", "totalizeWritten", " totalNumberREAD", "totalMoneyREAD", "totalNumberFound", " totalSizeWritten", "TotalNumberFound", "totalTimeFound", "totalMoneyRead", "totalGenderRead", "totalMoneyReader", "totalStringBuild", "totalGenderREAD", "TotalSizeRead", "totalNumberBuild", "totalSizeWritten", "totalGenderReader", "totalizeRead", "totalTimeRead", "totalLengthWritten", "TotalSizeWritten", "totalMoneyWritten", "totalStringWritten", "totalLengthRead", "totalLengthBuild", "totalSizeBuild", "TotalSizeBuild", "totalNumberREAD", "totalGenderWritten", " totalNumberReader", "totalTimeWritten", "totalizeFound", " totalNumberWritten", "TotalSizeFound", " totalSizeReader"], "totalNumberRead": ["totalNumberWritten", "totalNumberFollow", "totalnumberWrite", "totalNumbersFollow", "totalStringRead", " totalNumberFollow", " totalnumberread", " totalSizeWritten", "totalMoneyAct", "totalMoneyread", "totalMoneyRead", "totalnumberread", "totalNumberread", " totalnumberAct", "totalnumberRead", " totalNumberWrite", "totalSizeFollow", "totalSizeWritten", "totalnumberWritten", " totalnumberRead", "totalLengthWrite", "totalLengthWritten", "totalNumbersRead", "totalStringWritten", "totalLengthRead", "totalNumbersWritten", " totalSizeWrite", "totalLengthFollow", "totalMoneyWrite", " totalSizeFollow", "totalSizeAct", " totalnumberWrite", "totalSizeWrite", " totalnumberWritten", "totalSizeread", " totalNumberread", "totalStringread", "totalnumberAct", " totalNumberAct", " totalNumberWritten", "totalNumbersWrite", "totalNumberAct", "totalNumberWrite"], "photo": ["number", "asso", "person", "entry", " photograph", "facebook", "project", "photos", "room", "large", " photos", "jp", "sharing", "data", "profile", "gallery", "slice", "phot", "favorite", "pic", "friend", "opus", "instance", "journal", "item", " photographer", "gal", "ji", "record", "opa", "info", "voice", "cover", "peg", "video", "ickr", "reference", "document", "layer", "vision", "Photo", "single", "media", "language", "collection", "job", "ilo", "camera", "trial", "album", "audio", "api", "copy", "la", "avi", "filename", "Photos", "jpg", " photography", "member", "username", "json", "pixel", "license", "page", "student", "widget", " Photo", "image", "obj", "result", "l", "picture", "phone", "lo", "login", "Flickr"], "url": ["system", "address", "data", "socket", "uri", "user", "ssl", "string", "source", "resource", "document", "web", "path", "contact", "host", "server", "http", "org", "sl", "URL", "conn", "file", "page", "www", "location", "image", "open", "name", "client", "channel", "l", "download", "link", "stream", "Url", "position", "loc", "api", "config", "out"], "connection": ["application", "session", "Connection", "which", "socket", "uri", "connect", "web", "document", "con", "director", "handler", "bc", "response", "http", "server", "URL", "context", "communication", "function", "database", "conn", "in", "uno", "reader", "directory", "io", "image", "connected", "client", "channel", "c", "or", "l", "stream", "control", "position", "loc", "body", "api", "out", "info"], "dis": ["re", "data", "ui", "det", "uri", "service", "no", "resource", "web", "con", "http", "fr", " Dis", "di", "dl", "lib", "DIS", "rec", "Dis", "mor", "dist", "conn", "file", "des", "reader", "se", "res", "normal", "de", "io", "to", "device", "ws", "dir", "channel", "pos", "pre", "or", "non", "loc", "api", "body", "out", "coll", "info"], "fos": ["Fos", "Fops", "dot", "fOS", "infOS", "bos", "paos", "fws", "faos", "bops", "Fis", "fot", "doses", "fops", "infaos", "dos", "Fot", "fis", "bot", "fo", "bis", "Fws", "dops", "info", "boses", "pos", "foses", "po", "Fo", "infos", " fws", "Foses", " fis", " fops", "pOS", "bws", "Faos", "FOS"], "b": ["bar", "ba", "pb", "f", "xb", "nb", "rb", "emb", "bl", "bb", "gb", "eb", "sb", "wb", "db", "ib", "buff", "binary", "bs", "base", "p", "lb", "bf", "v", "bin", "boot", "cb", "ab", "bd", "buffer", "mb", "br", "B", "job", "c", "bytes", "l", "n", "r", "ob", "be", "e", "bit"], "sizeRead": [" sizeFind", "izeWrite", "memberRequest", "sizeLength", "unitRead", "izeFind", " sizeRun", "izeLoad", "numberSize", "izeBuild", "izeSize", "SizeWrite", "SizeFind", "SizeLength", "numberReader", " sizeSize", "numberBuild", "numberRead", " sizeLength", "SizeLoad", "speedWrite", "memberRead", "unitLength", "izeRun", "SizeRun", "sizeSize", "sizeFind", " sizeReader", "izeReader", "speedReader", " sizeWrite", "numberWrite", "sizeRun", "izeRequest", " sizeRequest", "sizeLoad", "sizeBuild", "sizeReader", " sizeBuild", "memberReader", "sizeWrite", "unitWrite", "speedRead", "SizeReader", "speedSize", "sizeRequest", " sizeLoad", "izeRead", "unitReader", "SizeRead"], "totalDiffTime": ["totaldiffCount", "finalDiffTime", "finaldiffRate", "finaldiffLine", "TotalDiffRate", "totalDiffRate", "totaldiffLine", "totalDiffCount", "TotaldiffValue", "totaldiffValue", "totalDiffValue", "TotaldiffRate", "totalDeltaCount", "totalDistRate", "TotalDiffValue", "totalDistTime", "totalDiffSize", "totaldiffTime", "totalDiffLine", "TotaldiffSize", "totalDeltaRate", "totalDeltaValue", "finaldiffTime", "totalDeltaSize", "totalDistCount", "finalDiffLine", "TotalDiffSize", "totalDeltaLine", "totalDeltaTime", "finaldiffCount", "finalDiffRate", "TotaldiffTime", "totalDistLine", "TotalDiffTime", "totaldiffSize", "finalDiffCount", "totaldiffRate"], "totalSpeed": ["fullWeight", "fullSpeed", "fullHalf", " totalTime", "TotalWeight", "maxTime", "TotalRank", " totalRate", "TotalRate", "TotalHalf", "maxRank", "TotalTime", "totalWeight", "fullRate", "totalRate", " totalRank", "totalHalf", "basicWeight", "basicSpeed", "basicHalf", "maxRate", "TotalSpeed", "totalTime", "maxSpeed", "basicRate", "totalRank"], "list": ["queue", "cl", "live", "bl", "st", "LIST", "lists", "detail", "left", "low", "source", "lc", "status", "gallery", "slice", "see", "cli", "member", "parent", "cont", "p", "load", "array", "page", "full", "part", "ls", "type", "stack", "object", "ist", "table", "best", "collection", "code", "batch", "set", "result", "not", "all", "l", "view", "pool", "test", "li", "fl", "complete", "like", "record", "coll", "layout", "la"]}}
{"id1": "3558512", "id2": "20375440", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "label": 1, "substitutes": {"out": ["loader", "dump", "filename", "OUT", "a", "data", "content", "string", "source", "i", "output", "server", "writer", "parent", "Out", "raw", "file", "conn", "page", "temp", "w", "bin", "gen", "err", "io", "buffer", "image", "name", "up", "archive", "obj", "client", "o", "outs", "exec", "cache", "pool", "report", "ex", "copy", "png"], "parser": ["loader", "system", "wrapper", "pillar", "plugin", "lp", "Parser", "parse", "xml", "builder", "upload", "per", "handler", "server", "pe", "pp", "writer", "class", "cp", "pkg", "parent", "base", "p", "txt", "processor", "file", "reader", "php", "er", "arser", "worker", "manager", "seed", "rar", "up", "as", "instance", "ss", "cache", "test", "tt", "copy", "master"], "on_disk": ["onnetdemand", "onbootlock", "on_demand", "on_storage", "onjspace", "onjdrive", "onnetdrive", "onJdisk", "off_delete", "onnetfile", "onnetdisk", "off_demand", "onbookdelete", "onJlock", "off_space", "off_drive", "off_file", "onjdisk", "onbootdisk", "off_storage", "on_space", "onjfile", "on_file", "off_disk", "on_lock", "on_delete", "onbookdisk", "onbootstorage", "onJdrive", "on_drive", "onbookdrive", "off_lock", "onnetspace", "onbootdrive", "onJdemand"], "in": ["f", "data", "socket", "inn", "source", "i", "thin", "con", "ax", "input", "inas", "kin", "min", "din", "file", "conn", "lin", "reader", "rin", "ins", "bin", "connection", "inner", "o", "c", "as", "win", "In", "stream", "pass", "inc", "ac", "IN", "ini", "r", "copy", "login", "again", "info", "pin"]}}
{"id1": "17791385", "id2": "6988216", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "label": 1, "substitutes": {"src": ["inst", "inf", "filename", "st", "rb", "uri", "sb", "source", "resource", "upload", "sin", "http", "sl", "input", "dist", "dest", "txt", "sup", "file", "url", "sc", "ins", "img", "ls", "files", "s", "image", "obj", "b", "sit", "sel", "rc", "stream", "loc", "config", "ipl", "back"], "dst": ["dsts", "fdfd", "pdft", "pdst", "dfd", "Dsts", "ddfd", "ddsp", "stst", "stlt", "Dst", " dlt", "dft", "stdest", "fdst", "pdsp", "dlt", "fdsp", "Ddest", "fdft", "pdfd", "ddft", " ddest", "ddest", "ststs", "ddst", "dsp", " dsts", "Dlt"], "in": ["gin", "f", "data", "socket", "inn", "i", "ln", "con", "sin", "is", "input", "init", "kin", "din", "conn", "lin", "url", "rin", "reader", "file", "ins", "impl", "bin", "m", "err", "inner", "inside", "as", "win", "In", "n", "cin", "inc", "IN", "nin", "ini", "r", "login", "h", "again", "oin", "pin", "pull", "id"], "out": ["ext", "f", "sync", "x", "OUT", "other", "i", "output", "off", "line", "server", "writer", "parent", "Out", "raw", "conn", "file", "plain", "part", "w", "temp", "bin", "exp", "err", "net", "io", "s", "self", "up", "obj", "client", "o", "exec", "outs", "outer", "n", "at", "inc", "post", "cache", "ex", "copy", "again", "null"], "buf": ["queue", "ctx", "length", "bl", "cat", "rb", "data", "bh", "bb", "wb", "pad", "bc", "off", "buff", "fb", "seq", "ff", "base", "bf", "raw", "v", "vec", "fd", "lim", "bin", "cb", "bd", "buffer", "br", "batch", "cmd", "bytes", "b", "c", "rc", "uf", "cur", "loc", "cap", "val", "uc", "count", "fl", "bag"], "len": ["cl", "f", "length", "data", "no", "i", "lc", "end", "ln", "lt", "line", "ind", "sl", "el", "lf", "base", "nt", "lin", "fd", "part", "ix", "rev", "lim", "bin", "err", "name", "pos", "c", "le", "all", "en", "l", "size", "ll", "Len", "n", "fin", "split", "cap", "count", "val", "li", "fl"]}}
{"id1": "4468255", "id2": "20619879", "code1": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"from": ["d", "path", "http", "entry", "by", "ce", "html", "url", "missing", "er", "From", "self", "open", "code", "original", "old", "before", "link", "at", "auto", "so", "e", "un", "f", "data", "left", "source", "with", " form", "context", "base", "file", "normal", "of", "connection", "io", "stream", "log", "local", "id", "empty", "form", "resource", " file", "line", "without", "zip", "this", "os", "add", "ate", "part", "se", "temp", "client", "dir", "c", "or", "start", "back", "user", "feed", "parent", "one", "range", "name", "vol", "o"], "to": ["yet", "To", "son", "path", "token", "on", "http", "pe", "by", "root", "jo", "but", "sp", "de", "as", "not", "disk", "auto", "so", "target", "sync", "x", "template", "data", "socket", "source", "eto", "two", "top", "base", "file", "connection", "io", "comp", "storage", "process", "tom", "po", "me", "no", "resource", "output", "line", "plus", "db", "dis", "database", "front", "os", "load", "too", "office", "se", "temp", "stat", "dir", "client", "or", "cache", "copy", "TO", "system", "user", "site", "t", "termin", "flo", "parent", "p", "one", "location", "name", "about", "o", "toc", "all", "size", "tto", "null"], "result": ["ure", "real", "length", "allow", "found", "data", "follow", "mask", "ok", "source", "success", "diff", "replace", "plus", "valid", "sign", "accept", "fail", "member", "search", "function", "lock", "event", "error", "url", "die", "math", "card", "part", "effect", "true", "method", "res", "var", "ult", "mer", "err", "comment", "future", "results", "force", "br", "arr", "Result", "up", "info", "term", "cur", "rc", "sum", "compl", "current", "cache", "pass", "ret", "work", "test", "val", "r", "count", "report", "continue", "use", "default", "status", "date", "match", "ver"], "subFiles": ["smallContents", "ubContents", "ubDir", "smallfiles", "newsfiles", " subParents", "subDir", "SubWords", "partfiles", "SubParts", " subFs", "newsFiles", "smallFiles", "ubfiles", "ubFile", "subPages", "subFs", "partFs", "ubFiles", "partFiles", "newFile", " subDir", "subNotes", "subFile", " subfiles", "partParents", "ubNotes", "newPages", "singParents", "newParts", " subPages", " subNotes", "smallNotes", " subContents", "newfiles", "subWords", " subFile", " subWords", "subContents", "newFiles", "singfiles", " subParts", "SubFile", "SubPages", "singFiles", "subParents", "SubFiles", "Subfiles", "newsWords", "subParts", "newsParts", "singFs", "subfiles", "ubPages"], "i": ["hi", "phi", "f", "x", "d", "ori", "ui", "it", "a", "ti", "uri", "ie", "bi", "ci", "gi", "slice", "di", "is", "h", "iv", "z", "pi", "p", "v", "ai", "ix", "u", "k", "iu", "io", "inner", "s", "ip", "ii", "y", "name", "o", "b", "ri", "I", "multi", "c", "j", "l", "n", "si", "key", "li", "ini", "oi", "mi", "index", "xi", "e", "id"], "newDir": ["subConf", "subDir", "subDirectory", "nextDir", "nextFolder", "newD", "oldDir", " newFolder", "newFile", "subD", "oldFile", "subJar", "rawdir", "newConf", "NewFile", " newJar", "subFile", "rawJar", "newDirectory", "oldFolder", "newJar", "rawDir", "NewFolder", "subdir", "NewConf", " newdir", " newFile", "NewD", " newDirectory", " newConf", "newdir", "rawDirectory", "NewDir", "NewDirectory", "newFolder", "nextFile", "oldDirectory", "nextDirectory", " newD"], "in": ["gin", "f", "a", "serv", "it", "data", "pull", "isin", "socket", "ie", "inn", "source", "thin", "con", "diff", "on", "is", "input", "init", "this", "min", "din", "file", "lin", "conn", "reader", "url", "part", "ins", "bin", "m", "err", "inner", "io", "image", "up", "o", "b", "c", "l", "win", "In", "cin", "inc", "IN", "nin", "ini", "r", "ex", "login", "index", "again", "config", "pin", "e", "id"], "out": ["ext", "sync", "OUT", "serv", "cat", "socket", "con", "output", "on", "off", "line", "with", "lib", "writer", "Out", "base", "lock", "ou", "op", "cy", "conn", "file", "can", "co", "w", "img", "bin", "one", "exp", "err", "call", "net", "io", "inner", "name", "up", "client", "obj", "o", "c", "outs", "write", "exec", "all", "sum", "n", "at", "log", "post", "inc", "ex", "again"], "fileLength": ["pageSize", "fileSize", "baseLen", "baselength", "filelength", "FileLength", "baseLength", "fileLen", "Filelength", "pageName", "lineName", "pagelength", "fileName", " fileLen", "lineSize", " fileName", "FileSize", "FileLen", "linelength", "baseSize", "pageLength", " filelength", "lineLength", " fileSize"], "charBuff": ["pairMatrix", " charBuffer", "wordBuffer", "pairBuffer", "charBuffer", "pairBuff", "wordMatrix", " charMatrix", "charMatrix", "wordBuff"], "len": ["et", "lit", " split", "ni", "ln", "line", "iter", "lf", " lang", "nt", "part", "rev", "bin", " Len", "pos", "fin", "en", "l", "Len", "start", "cmp", " pos", "li", "val", "split", "fl", "id"], "oneChar": ["oneCor", "oneCh", "OneCh", "eightCharacter", "eightchar", " oneCor", "singleCor", "singleChar", "fourPixel", "eachChar", "singleCh", "eightPixel", "singleByte", "fourChar", "eachPixel", "eightChar", "fourCharacter", "OneByte", " oneCharacter", "eachCharacter", "oneByte", "OneChar", "eachchar", "oneCharacter", " onechar", "fourchar", "OneCor", "singlechar", "singleCharacter", " oneCh", "onePixel", "onechar", " oneByte"]}}
{"id1": "149935", "id2": "4716110", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"src": ["inst", "ctx", "filename", "st", "rb", "feat", "ref", "uri", "gb", "ssl", "sb", "source", "string", "resource", "upload", "prot", "Dest", "path", "sin", "RC", "slice", "tmp", "buf", "sth", "input", "sl", "supp", "dist", "username", "secure", "load", "req", "fp", "url", "file", "sc", "reader", "impl", "img", "cb", "gz", "spec", "href", "s", "cpp", "storage", "gn", "vr", "name", "code", "obj", "sit", "sel", "rc", "proc", "download", "stream", "component", "cmp", "dep", "Source", "loc", "fn", "rl", "SourceFile", "ource", "config", "sec", "back", "sn"], "dest": ["target", "orig", "home", "source", "wb", "Dest", "dc", "path", "di", "tmp", "lib", " destination", "class", "dist", "cont", "txt", "temp", "img", "bin", "std", "dir", "obj", "disk", "fn", " dst", "null", "dat"], "in": ["inf", "f", "d", "a", "data", "isin", "inn", "source", "i", "t", "is", "input", "inas", "din", "file", "reader", "ins", "bin", "err", "io", "up", "as", "doc", "win", "ps", "In", "stream", "n", "pass", "inc", "IN", "ini", "r", "ex", "val", "login", "pin"], "p": ["pa", "pb", "pd", "f", "d", "pg", "g", "lp", "pm", "i", "per", "pc", "pe", "t", "h", "pp", "pr", "cp", "pi", "op", "fp", "v", "wp", "bp", "part", "sp", "cop", "m", "s", "py", "o", "pre", "c", "np", "b", "po", "j", "l", "ps", "jp", "parser", "tp", "P", "e"], "ds": ["docs", "d", "uds", "dt", "lp", " db", "ays", "hs", "ads", " DS", "ded", "scripts", "des", "ils", "icks", "ants", "qs", "dm", "vals", "dates", "ld", "sys", "dat", "posts", "ks", "styles", "ans", "pd", "cs", "sync", "data", "words", "points", "dp", "bs", "dd", "gs", "cdn", "Ds", "ups", "rs", "ps", "js", " dd", "sts", "cons", "tools", "els", "lines", "db", "DS", "di", "dist", "amps", "os", "tests", "vs", "dos", "ins", "ls", " sd", "s", "ws", "xs", "ts", "plugins", " props", " ps", "eps", "obs", "gd", "da", "dc", "parts", "dds", "ys", "utils", "nas", "ns", "ss", "df", "models", "dl"], "format": ["filter", "f", "filename", "prefix", "template", "feat", "data", "Format", "plugin", "version", "string", "source", "form", "xml", "path", "handler", "host", "t", "layout", "atter", "class", "tag", "scale", "function", "sche", "fp", "file", "url", "fd", "part", "type", "act", "spec", "style", "letter", "unit", "table", "language", "name", "struct", "ant", "pattern", "nat", "at", "frame", "parser", "fn", "api", "config", "magic", "record", "object", "model", "match"], "hasPixelData": ["hasPictureData", "hasPicOps", "haspixelStyle", " hasPixeldata", "hasBytedata", "hasPicStyle", "hasPixelDATA", "hasPictureDATA", "haspixelData", " hasPixelOps", "hasPixeldata", "hasPixelStyle", "haspixelOps", "hasPicData", "hasByteData", " hasPixelSize", "haspixelSize", "hasPicturedata", "hasPixelSize", "haspixelDATA", "haspixeldata", "hasPixelOps", " hasPixelStyle", " hasPixelDATA", "hasByteSize"], "inflate": [" inflATE", "infloocate", "uninflocate", "infloase", "uninfloute", "uninfloate", "information", "informATE", "incollate", "infloATE", "inflation", "infolute", " information", "infolame", "incollame", "inFlase", "incollocate", "inFlate", "informate", "infloate", "influte", "inflase", "incollute", "uninfloame", "inFlation", "uninflute", "infolate", "informase", "inflame", "infolocate", "infloation", " informase", "uninfloocate", " informate", "infloame", "infloute", "inflocate", "uninflame", " inflation", "inFlATE", " inflase", "inflATE", " informATE", "uninflate"], "pxlen": ["nplin", "pyln", "pxlf", "fxlen", "pngden", "xyfin", "pyden", "pxden", "fxden", "rxfin", "xplength", "xplen", "fxval", "pglf", "xylen", "pyl", "xpval", "cpden", "fxlf", "pxlin", "pxLen", "rxlen", "pylen", "pngln", "pplen", "fxl", "cpln", "pngLen", "rxlin", "nplen", "npden", "xyden", "fxlength", "ppden", "pxval", "pxfin", "pxl", "ppln", "npfin", "rxden", "xyLen", "xylin", "fxln", "pxlength", "xplf", "pxln", "pglen", "cplen", "pnglen", "cpl", "xyln", "ppLen", "pglength", "pgval"], "out": ["session", "dump", "prefix", "OUT", "re", "user", "point", "output", "line", "server", "cli", "lib", "list", "group", "parent", "store", "lock", "Out", "base", "v", "conn", "error", "page", "gen", "err", "inter", "io", "code", "up", "obj", "step", "print", "outs", "work", "cache", "log", "post", "copy", "sys", "again"]}}
{"id1": "3252116", "id2": "5682569", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    public void metodo1() {\n        int temp;\n        boolean flagDesordenado = true;\n        while (flagDesordenado) {\n            flagDesordenado = false;\n            for (int i = 0; i < this.tamanoTabla - 1; i++) {\n                if (tabla[i] > tabla[i + 1]) {\n                    flagDesordenado = true;\n                    temp = tabla[i];\n                    tabla[i] = tabla[i + 1];\n                    tabla[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"source": ["target", "f", "data", "content", "src", "uri", "from", "service", "string", "resource", "document", "output", "SOURCE", "slice", "password", "sl", "input", "this", "text", "dest", "parent", "base", "fp", "file", "url", "sp", "security", "connection", "secret", "buffer", "code", "result", "stream", "Source", "body", "ource", "config", "object", "e"], "s": ["ends", "S", "f", "d", "ses", "g", "ssl", "string", "sb", "es", "ds", "t", "is", "sl", "its", "ings", "p", "sg", "os", "rows", "ns", "als", "gs", "ins", "ls", "m", "results", "sets", "bis", "services", "ws", "ops", "bytes", "b", "rs", "ss", "ps", "ts", "n", "js", "si", "sym", "series", "strings", "r", "h", "fs", "e"], "hexDigits": ["hexdigats", "hexFormists", "hexDigit", "hexFormits", "hexSignings", "hexdigitives", " hexDigases", "hexSignists", "hexdigites", "hexEdists", "hexFormats", "hexSignats", "tempSignits", "hexEdites", "tempDigals", "hexDigals", "tempDigits", " hexDigings", "hashDigits", "tempSignists", "hexDigists", "hexSignals", "hexDigats", "hashDigists", "hexdigists", "hexFormitives", "tempSignals", "hexDigings", " hexDigit", "hexdigases", "hexEdals", "tempSignites", "hashFormits", "hexdigings", "hexdigit", "hashDigats", "tempDigists", "hashFormists", "hexDigases", "hexEdits", "hexDigites", "hexSignites", "hexSignases", "hexSignit", "tempDigites", "hexdigits", "hashFormats", "hashDigitives", "hexdigals", "hexSignitives", "hexSignits", "hexDigitives", "hashFormitives"], "md": ["cm", "um", "f", "mail", "pd", "nm", "sm", "wd", "pm", "em", "amd", "mad", "dc", "rpm", "sha", "mu", "di", "meta", "mm", "am", "bf", "MD", "dd", "mand", "ma", "mt", "m", " MD", "bd", "dig", "rm", "mb", "mg", "vd", "dm", "cd", "cmd", "hd", "df", "mac", "mag", "mp", "mc", "mi", "metadata"], "tmp": ["rb", "data", "app", "pad", "stuff", "fb", "buf", "buff", "pp", "meta", "dest", " temp", "base", "p", "txt", "array", "sup", "v", "params", "wp", "bp", "temp", "sp", "img", "cb", "now", "buffer", "seed", "cpp", "storage", "bt", "obj", "pre", "np", "proc", "ppo", "cmp", "test", "mp", "api", "append", "area", "config", "extra", "pointer"], "str": ["cs", "st", "dr", "data", "hr", "string", "hex", "div", "sr", "cr", "dec", "tr", "fr", "iter", "sl", "pr", "text", "txt", "v", "part", "sp", "temp", " substr", " sp", "err", "exp", "spec", "char", "style", "unit", "inner", "arr", "br", "code", "STR", "obj", "pos", "exec", "j", "ss", "doc", "Str", "ctr", "cur", "r", "enc", "sec", "stri", "dict"], "k": ["kk", "kw", "f", "d", "x", "g", "ck", "sk", "ks", "ku", "ki", "kat", "ek", "ak", "q", "p", "kid", "v", "w", "u", "y", "ko", "unk", "K", "c", "b", "o", "dk", "j", "work", "n", "mk", "ok", "key", "kick", "ch", "e", "id"], "i": ["hi", "phi", "f", "x", "a", "d", "ui", "it", "ti", "uri", "bi", "gi", "ci", "qi", "shift", "mu", "di", "t", "z", "abi", "pi", "chi", "p", "v", "in", "ai", "u", "iu", "m", "io", "ip", "ii", "y", "info", "c", "b", "I", "ri", "multi", "j", "l", "n", "si", "li", "ini", "oi", "ji", "index", "xi", "e"], "byte0": ["number5", "word5", "number2", "byte2", "word1", "number0", "pixel2", "bytek", "number1", "byte6", "pixel00", " byte1", "letterk", "number6", "number00", "pixelk", "byte1", " byte2", "pixel5", " byte00", "letter2", "word2", "letter0", "numberk", " byte6", "pixel0", "word0", "letter00", "pixel6", " byte5", "byte00", "byte5"]}}
